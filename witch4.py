# crush plus inertia, 2 ogres, ogre uses crush against ogre w inertia, LINE 30978 is location of bug, need to return prematurely to apply_damage 'amount,type' while inertia_loop executes
'''
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/tkinter/__init__.py", line 1883, in __call__
    return self.func(*args)
  File "witch4.py", line 22173, in <lambda>
    app.animate_squares(sqrs)
  File "witch4.py", line 22197, in do_crush
    else:
  File "witch4.py", line 22218, in crush_loop
    d = damage(my_str, tar_end)
  File "witch4.py", line 1534, in lock
    app.death_count += 1
  File "witch4.py", line 1492, in apply_damage
    efcts = attacker.attack_effects[:] + app.loc_dict[tuple(attacker.loc)].atk_effects
  File "witch4.py", line 1498, in atk_loop
    efcts = defender.defense_effects[:] + app.loc_dict[tuple(defender.loc)].def_effects[:]
  File "witch4.py", line 1519, in defense_loop
    ef = effects_list[0]
TypeError: cannot unpack non-iterable NoneType object
'''

# dark ritual plus artificer bottle gnome, too good?

# ogre actions

# descr crush

# stats of summons in action descr

# descr effct descr inertia, cloudkill map effct descr

# meld- add all actions from one ent to another, interactions with evolutions, etc... that require Ent specific flags... Leap...
# for ent specific attrs, can add all unique attrs to 'melded' ent, for v in values, if k not in ent.__dict__.keys(), ent.key = value...
# this has problem... Ent specific flags are reset by checking class of object, 'melded' ent of dif class will not have all flags reset 
# at end round...

# quicker way to see summary of in-hand...

# make windows, linux exes...

# make other comp-controlled stuff behave like pyrrhic gnome move, hunting hawk, hypnotic spectre, barrow wight, deaths head moth, 

# change user-owner, computer-controlled stuff to allow for arb. added actions...
# their eot control should account for variable attack ranges (use/add Entity.attack_range?), added or removed actions, incr/decr moves/acts/moverange,

# some kind of mulligan protection... all/no-summon? what about non-summon decks? what about information protection/revealing for duel?
# could actually enforce some kind of pseudo random... arbitrary criteria: within some threshold of proportion of deck total... for example
#    a 60 card deck with 20 summons would redraw a starting hand where more than twice that proportion exists OR less than half that proportion exists... so hands with MORE THAN 2/3s summons OR LESS THAN 1/6 = auto redraw (do not need to necessarily make this process obvious or a matter of choice for player)
# auto-redraw depending on IF a threshold of summon to non-summon exists,
# for example, threshold is 10 percent (deck must consist of 90/10 ratio tombs/summons, either)
#     then-- auto-redraw rule is in effect for opening hand
#     - auto-redraw will enforce that opening hand is within some range of the ratio of tombs/summons
#       - start testing with range at half and twice as much as ratio, 90/10 becomes 95/5 - 80/20

# need gate-like spell for ents (Witch spell that targets ents)

# add info text for all ents that need it, ent.info_text default None

# debug mass grave, when placing 2 tombs, pressing the first button auto chooses the next?

# difficulty mode for campaign, just change map info 

# something to give caster +1 moves

# ways to destroy/disrupt tombs, like efface, counter? a spell
# instead of playing a tomb, set spell_entomb to used, discard 1, destroy tomb?
# increase the cost of an arcane dict entry, of a tomb imprint in play?
# any actions that alter spell metadata (costs/imprint-times) need to be applied like other effects (stack of effects) instead of 
#    directly altering the spell object

# the sun dispel timing with undo effects that need time to resolve...?

# cenobite into summon
# need cenobite gifs or images...

# for each less sanity than 10 (X), +X phys stats max 4 -2
# spend spirit?, discard hand? sacrifice some amount of ents/animals
# reduce library to some amount of specific cards (around 5?) ADD LOSS OF GAME ON NO DRAW?
# each player chooses and kills an ent of own (opnt?), reduce smn count? how to play around 'go first/second' mechanic

# mokujin- self gets def efct that redirects dmg to ent you own

# cant insert logging in to_hit, does not have context of what called it (the ent.ids)
# maybe in atk/def loop
# insert logging here, write to some buffer, use that to populate some canvas/image/popup

# rec nightmare, destroy a tomb with this imprint and a smn you own in smn list, smn a smn that exists in your discard

# more maps in duel, page maps

# screen/window to log text objects, make popup from menu?

# levels where you must encroach on groups of mostly stationary enemies, to progress through some terrain/walls/rooms

# desc in info for minotaur and dragon special rules (actions that cannot be removed from ent, ignore invis/psyshield, free move/charge/iceblast and conditions for)

# in center_focus()
# minimap captures r-click ONLY to 'jump' (move_map()) to translated pixel location
# center_map() func, equalize distance from cursor to both top and bottom of screen
# move cursor until target sqr is 'around' center of map...then move cursor to target sqr
# center of map depend on screen size?
# target sqr is edge of map? other edge cases?
# 'around' = 

# wraith, perm def efct reduce melee/ranged dmg to 1, perm psyshield

# make gorgon class / level

# smart bots, smart targeting, ie kobold shamans prefer targets with low psyche/wisdom

# finish Morgan

# level with 'waypoints' end/start turn on waypoint to move between areas..., multiple screen/background level...

# save game during level?

# show costs of actions, without disrupting the names for action_descr lookups...
# alt five is infi symbol

'''
Random names/ideas
boost, major familiar, healing salve, detox, dire poison, freeze, 
bolt, mental decay, clear mind, quicken, sunbeam, trance, shocking strike

Agnes Stuff
themes- 'Psionics', movement augmentation ; 'Disease' debilitating spells affected by proximity of ents ; 'Astrology|Astronomy' ... ; 'Demonic Pantheon' (Lesser Key of Soloman), Beleth patron

Mind Leech
redirect magick dmg to target

armor of thorns
sot/eot all adj take 1 piercing, add phys resist

trap in stone
replace ent w less than 40 max spirit w inert ent or 'block'

illusory eclipse
transform all umbrae wolves (friendly and enemy), tar shadow gains invis

lament of the void
bard gets way to dispel invis psyshield chance

guardian of the chthonic gate
summon cerberus, slashing and fire atk, lasts only this turn

plutos verdict
doom-like

Ali Stuff
themes- 'Sacrifice' spells have downside/upside, sometimes useful on either friendly or enemy ents ; 'Egyptian Pantheon', Osiris Patron, Fakir Techniques

Iron Maiden
tar takes piercing dmg to get efct that reduces/resists phys

Bed of Nails
get efct that incrs phys to gain resists to poison, magick, elemental

Riddle of the Sphinx
choose among resists that a tar has, tar loses that resist on psy save fail (-2)

Third Eye
all wi range rsn make psy save -2 or lose invis and psyshield

Hammer of the Abyss
crushing dmg to tar

Mirage
tar gains magick resist, exchange position with enemy ent

Zombify
tar (non pb/witch) gains wkns fire. -2 agl, resist phys, add action 'gangrenous bite' agl v agl, str vs end + 3dmg with -1 end and add wkns poison

Pierce the Veil
tar gets atk efct, remove all resist (1 turn) and psyshield if tar fails psy save -3

Morgan LeFay Stuff
themes- 'woodland' summons: spells that create computer-controlled, player-owned ents; Spells that create terrain effects supporting 'woodland' types ; Range attacks and movement ; 'Arthurian/Celtic Pantheon', Ceridwen patron, 

source material - changelings, leprechaun, puca, banshee, loughleagh (lake of healing), black lamb, T'yeer-Na-N-Oge, Hy-Brasail (isle of the blessed), dullahan, far darrig, merrow, sluagh (horde,undead), fomorian (giants), bean nighe, barghest, beast of bodmin moor, black annis/anny, redcap, nuckelavee
'''

import tkinter as tk
# from tkinter import ttk
from os import walk
from PIL import ImageTk,Image
from random import choice, randrange, shuffle
from functools import partial, reduce
from fractions import Fraction
# from pickle import dump, load
from copy import deepcopy
from math import ceil
from collections import namedtuple
# filehandler = open(filename, 'r') 
# object = pickle.load(filehandler)

def unique(listoflists):
    tx = [tuple(s) for s in listoflists]
    ts = list(set(tx))
    return [list(t) for t in ts]

def round_100(x):
    prefix = x // 100
    rm = int(str(x)[-2:])
    if rm >= 50:
        prefix += 1
    return prefix



# vorpal blade- adds vorpal strike- adj agl v agl, str v end slsh melee, autokill animal type
# descriptions of spells and actions, takes a string that has been stripped of underscores (as it exists in the move dict of ents)
def action_description(act):
    if act == 'Slash':
        return 'To-hit agility vs agility, strength vs endurance slashing melee damage, adjacent target as action.'
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == 'Crush':
        return 'Each adjacent non-flying unit, on to-hit agl vs agl, take str vs end crushing melee damage.'
    elif act == 'Cloudkill':
        return 'Leaves a map effect at each location without this effect at each location in range 2 from a location. At end of turn, any unit occupying one of these locations gets an effect causing end of turn 2 poison damage.'
    elif act == 'Inertia':
        return 'Spell target gets defense effect that redirects melee, ranged, or spell damage that is crushing type to all adjacent units and reduces the damage to the original unit to zero.'
    elif act == 'Yellow Priest':
        return 'Censer Grenade attacks the sanity of grouped units. Trials of Hatheg-Kla gives +1 actions, but -5 sanity and teleports the target among the furthest distant locations. Dagons Chosen gives many stat bonuses but reduces sanity to 3. Yellow Priest summons Nightgaunts that can move around hit targets with Grasp. Nightgaunts can be destroyed to summon Migo, with very high stats but only action leaves -1 mental stats on hit. Migo can be destroyed to summon Guardian of the Chthonic Gate, which is immobile but very dangerous to nearby units...'
    elif act == 'Diabolist':
        return 'Good physical stats and disruptive attacks against an opposing Witch (versus the campaign mode) that can remove the imprint from a Tomb or search and remove a card from the deck. Can teleport units with infiltrate and give invisibility. Can heal self and remove cards from Discard with Graverob.'
    elif act == 'Enchantress':
        return 'High spirit, good mental stats, and Wall of Blossoms to make blocking/surround situations make for a defensive summon. Enlightment and Regrowth can gain card draw and reuse of key cards. Aura Blast does magick damage based on owners in-hand size. Wildfire can damage a group of enemies near those with a weakness to fire. Forestwalk gives ethereal move type, psyshield, and invisibility until the end of turn.'
    elif act == 'Chronomancer':
        return 'Can give negative effects to initiative or move enemies to back of initiative queue. Vanish and Gate can relocate units. Time Warp is most powerful action, but has to be planned for, with adjacent friendly units with a higher initiative than the Chronomancer.'
    elif act == 'Inquisitor':
        return 'Above average all stats but only can deal damage with Cleanse with Fire. Otherwise, can attack magick of a group of enemies or remove actions with Abeyance. Nullify is one of few ways to remove effects. Prophecy and Anoint can give bonuses to either reason or wisdom.'
    elif act == 'Drake':
        return 'Good ranged poison attack and high physical stats, but low mental stats. Can give self either invisibility or psyshield, or place a map effect to give -3 move range, agility, and dodge to units with normal move type. Wing Buffet does explosive ranged damage and can relocate a unit.'
    elif act == 'Chirurgeon':
        return 'Summons Cadavers that start out with no actions or moves, but are fairly resilient. Cadavers can be given either an acid ranged attack or slashing melee attack, in addition to Move action and stat bonuses by a Chirurgeon. Is one of few units to start with 2 actions, but can quickly use up all of its magick every turn and needs replenishment from Tombs or something.'
    elif act == 'Wurdulak':
        return 'Has ranged actions Entrance and Entrall to attack the ranged stats or sanity of targets. Vampiric Bite gives a +3 bonus to psyche if it hits with piercing damage. Chill Touch does cold melee damage and leaves -1 wisdom effect. Can change to Bat Form for flying and movement bonues or Wolf Form for physical stat increase, both lasting until the end of the turn. High physical and good mental stats, inhibited by move range or stat decrease from Form changes.'
    elif act == 'Fiend':
        return 'Chain Lightning can hit many nearby units with ranged electrical damage. Pounce hits adjacent enemies with slashing melee damage and moves the Fiend over obstacles. Hidden Haymaker will auto-hit if user is invisible. Overload will add another action, if they strength and psyche of the Fiend can somehow be increased to more than 2 their base value. Roar will damage the sanity of a group of nearby enemies. High physical stats and low mental stats.'
    elif act == 'Beastmaster':
        return 'Summons a group of animal units with Wyld Hunt. Can use Unsummon on any animal type to destroy it and have the owner draw a card. Can give weaknesses and resistances to animal types with Sigil. Can place adjacent animal types at the front of the initiative queue with Orions Call, even if they have already used a round this turn. Swarm and Heel can either enhance or detract from the movement of nearby animal types. Spiritual Hammer does crushing spell damage to an adjacent target. Moderate stats with not much offense besides Hammer. Has to support animals from Wyld Hunt or elsewhere, or use them for drawing cards. Although, crushing attacks are rare and useful against Tombs.'
    elif act == 'Goblin Shaman':
        return 'Can use Lightning Rod or Jokulhaups to do a lot of damage to all nearby enemies, with Lightning Rod hitting automatically but target are chosen randomly and Jokulhaups doing two separate to-hit rolls for fire and explosive spell damage to non-flying. Can summon Plague Vermin that leave end-of-turn poison damage. Fervor increases the physical stats of nearby animals at the expense of sanity. Teleport Field can move a group of units at once. Call Mount will give the Goblin Shaman either a Boar or flying Eyegaunt mount. The Boar can use charge to damage all adjacent enemies with slashing damage and increases the casters physical stats. The Eyegaunt gives flying move type, ranged stat bonuses, and a ranged attack againts non-flying units that does explosive damage.'
    elif act == 'Artificer':
        return 'Place Tombs from discard with Lost Artifact, if they are unique among Tombs in play. Globe of Invulnerability can trap or protect units, reducing damage they deal and receive, and inhibiting their move range. Globe Roll will damage impacted units based on the contained unit strength. Two types of Gnome summons either damage when they explode or heal friendly spirit and magick. Low physical stats and medium mental stats. Needs to protect self with Globe or stay away from attacks and play a support role.'
    elif act == 'Thaumaturge':
        return 'Among best healers with Aura and Moonlight. Hass one of few ways to dispel effects or map effects with Esuna and Tranquility. Can give stat bonuses with Devils Mark and Unholy Chant. Can make piercing or spell ranged attacks with Arrow of Diana or Zephyr Lance. High agility, dodge, medium wisdom and psyche,  and slashing resistance gives decent defense.'
    elif act == 'Murrain Wolf':
        return 'Slow moving and resilient, can poison adjacent enemies. Can give Scarab death trigger that summons Scarab that can then transform with Scarab Swarm. Can give -1 acts and -3 moves on a Paralyze hit. A lot of spirit and most stats above average give good defense, but limited by move range and range of actions.'
    elif act == 'Fell Evolver':
        return 'Can choose one of its Evolutions to use each round. Each tier of evolutions requires one of the previous tier. Each tier is mutually exclusive. Can either choose a combination of melee (slashing,crushing,poison) OR ranged (fire,acid,poison) attack, and either bonuses or resistances affecting either melee combat (agility, endurance) OR spell casting (reason). Can gain flying type move (and the ranged fire attack) with Chimeric Mutation OR +1 acts with Unstable Mutation. All stats start at the high end of average (6), but get bonuses based on which evolutions are chosen.'
    elif act == 'Pixie':
        return 'Can switch psyche and strength of target with Biotranspose, reduce reason with Glammering, grant psyshield with Pixie Dust, Dispel effects that have end-of-turn effects with Detox, and caused either crushing or piercing ranged spell damage. High mental stats and low physical stats. Flying move type.'
    elif act == 'Hexmage':
        return 'Uses one of a few unique Hexes (proximity effects on self) that can decrease enemy strength or psyche, or give physical combat resists, boost wisdom, or reduce move range. Otherwise, has melee slashing attacks that either decrease strength or reason.'
    elif act == 'Umbrae Wolf':
        return '2 forms, use Phase Shift to switch between. Wolf form has higher physical stats and does ranged cold damage. Can also dispel, heal, or grant invisibility among Darkblast and Dark Shroud. Gaze decreases move range. Stalk increases physical damage received by the affected unit. Mist form has low physical and high mental stats (wisdom, reason, psyche). Can do magick damage and heal self with drain life. Haste that increases initiative and moves.'
    elif act == 'Illusionist':
        return 'Low physical stats, teleport move type. Can teleport other units with Gate. Provide physical combat bonuses with Simulacrum and Doubling Cube. Smoke Bomb creates a map effect providing invisibility. Ranged attacks that either do explosive damage or decrease Dodge and reveal invisibility with Pyrotechnics, Mortar, and Tracer Grenade.'
    elif act == 'Berserker':
        return 'Quick, evasive movement with Leap (free action to move over obstacles) and Charge type move preventing many move status effects. Slashing melee damage with Whirlwind to damage all adjacent, at a reduced accuracy. Can turn own melee attacks to fire or poison with Molten or Bane Claws. Howl From Beyond affects sanity and reason of enemies. Can reveal invisible units with Track or attempt to Dispel effects on self with Rage. Low defense against spells (wisdom and psyche), high physical stats.'
    elif act == 'The World':
        return 'Each player draws a card for each Tomb they own.'
    elif act == 'Burning Hands':
        return 'Adds Flame Fan action to caster. Spell target adjacent unit on to-hit wis vs wis, takes psy vs psy fire spell damage. Flame Fan costs 1 magick and 1 action.'
    elif act == 'Flame Fan':
        return 'Spell target adjacent unit on to-hit wis vs wis, takes psy vs psy fire spell damage. Flame Fan costs 1 magick and 1 action.'
    elif act == 'Acid Arrow':
        return 'Adds Acid Bolt. Spell target in range reason on to-hit wis vs wis, takes psy vs psy acid spell damage. Acid Bolt costs 1 magick and 1 action to use.'
    elif act == 'Acid Bolt':
        return 'Spell target in range reason on to-hit wis vs wis, takes psy vs psy acid spell damage. Acid Bolt costs 1 magick and 1 action to use.'
    elif act == 'Iron Skins':
        return 'Adds Defense effect to caster. On receiving melee, ranged, or spell damage that is not crushing, reduce the damage to 1 and  subtract 1 from duration. Must destroy a tomb with this imprint on cast.'
    elif act == 'Judgment':
        return 'If opponent Witch has more Tombs than you, destroy a spell target Tomb on to-hit wis vs wis.'
    elif act == "Witch's Blood":
        return 'Caster does 4 magick spell damage to self and adds 4 magick to self and each adjacent friendly unit.'
    elif act == 'Stupor':
        return 'Spell target Witch, on to-hit wis vs wis, discards a card at random from in-hand.'
    elif act == 'Vorpal Blade':
        return 'Adds Vorpal Strike to caster. Adj agl v agl, str v end slsh melee, autokill animal type on hit. Costs 1 action to use.'
    elif act == 'Vorpal Strike':
        return 'Adj agl v agl, str v end slsh melee, autokill animal type on hit. Costs 1 action to use.'
    elif act == 'Black Blade of Disaster':
        return 'Adds Black Blade Strike to caster. On agl vs agl to-hit, apply -X to random effect of target. Where X is what str vs end damage would be. Costs 1 action to use.'
    elif act == 'Black Blade Strike':
        return 'On agl vs agl to-hit, apply -X to random effect of target. Where X is what str vs end damage would be.'
    elif act == 'The Devil':
        return 'Caster discards hand. Spell target unit gets +3 str, agl, end, dodge, psyche, wis, rsn.'
    elif act == 'The Star':
        return 'Cast a spell from a tomb in caster discard if that tomb also exists in caster in-hand. Canceling that spell will not return the cost of The Star.'
    elif act == 'Quicksilver':
        return 'Spell target gets +3 initiative effect.'
    elif act == 'Abbysal Maw':
        return 'Action target range bls, mm vs dodge to-hit, msl vs end fire spell damage.'
    elif act == 'The Wheel':
        return 'Shuffle discard and exile into library, draw a card.'
    elif act == 'The Fool':
        return 'Spell target friendly unit gets wisdom reduced to 1 and defense effect that causes melee, ranged, and spell damage to reduce to maximum of current wisdom and places a +1 wisdom effect at duration of this caster reason and level wisdom.'
    elif act == 'The Moon':
        return 'Spell target list-summon is copied at a random location among closest locations. Copy has base stats equal to current stats of target, except acts and moves.'
    elif act == 'The Tower':
        return 'Caster gets -1 physical and mental (str,end,agl,dodge,psyche,wis,rsn,san) stats. On removal of effect and passing psyche save, draw 2 cards.'
    elif act == 'The Sun':
        return 'All undead units in range 2 have all effects attempted to dispel at +6 modifier.'
    elif act == 'Death':
        return 'Caster gets undead type and +1 endurance, if it does not already have this effect.'
    elif act == 'Strength':
        return 'Spell target gets defense effect, on wisdom save check recalculate received damage using defender strength and endurance.'
    elif act == 'The Hierophant':
        return 'Proximity effect on caster, all friendly units in range 1 get +2 strength, endurance, agility, dodge, and initiative.'
    elif act == 'The Empress':
        return 'For each friendly unit in range 2 (list-summon or Witch) with wisdom greater than strength, draw 1 card.'
    elif act == 'The High Priestess':
        return 'Each friendly, non-Tomb, unit in range 1-3 with wisdom greater than strength is healed 3 times its number of effects.'
    elif act == 'The Emperor':
        return 'Each friendly unit within range 1-2 with strength greater that wisdom get +1 acts effect lasting 1 turn.'
    elif act == 'The Chariot':
        return 'Caster gets +1 move range and ethereal move type.'
    elif act == 'The Lovers':
        return 'Spell target gets attack and defense effect reduce dealt and recieved melee, ranged, and spell damage to maximum 2.'
    elif act == 'The Hermit':
        return 'Spell target in range reason gets -2 strength, agility, endurance, and dodge; also psyshield and invisibility.'
    elif act == 'Justice':
        return 'Deals magick spell damage equal to 3 times opponent summon count minus caster summon count to each enemy list-summon.'
    elif act == 'The Hanged Man':
        return 'Spell target in range reason gets move range reduced to maximum 2 and +2 wisdom.'
    elif act == 'Temperance':
        return 'If the opponent Witch (duel mode only) has at least 2 more tombs than caster, place tomb from either hand or discard in play'
    elif act == 'Voodoo Doll':
        return 'Summon inert voodoo doll at location. Has no end of turn action. Has permanent defense effect that does magick redirect damage to each list-summon in play if the attack is melee, ranged, or spell.'
    elif act == 'Call Plague Vermin':
        return 'Summon Plague Vermin at location. Costs 2 magick.'
    elif act == 'Sigil':
        return 'An adjacent animal type without this effect gets weakness or resistance of any type at duration reason and level wisdom. Costs 3 magick.'
    elif act == 'Unsummon':
        return 'Destroy an adjacent spell target animal type. Its owner draws a card. Costs 1 magick.'
    elif act == 'Calm':
        return 'An adjacent spell target unit gets +3 sanity at duration reason and level wisdom.'
    elif act == 'Offering':
        return 'Destroy a spell target animal type you own to give another spell target unit +1 to psy, wis, rsn, san at duration reason and level wisdom.'
    elif act == 'Plague Vermin':
        return 'Summon a plague vermin at any location in rng reason, it leaves an end-of-turn effect doing 2 poison damage.'
    elif act == 'Voodoo Doll':
        return 'Summon an inert unit with a permanent defense effect that redirects all damage to each non-list summon, of type magick and redirect.'
    elif act == 'The Magician':
        return 'The caster, on passing a wisdom save check, teleports to any location in range reason.'
    elif act == 'The Hierophant':
        return 'Caster gets proximity effect that gives all friendly units up to range 1 +2 str, end, agl, dodge, init.'
    elif act == 'Foresight':
        return 'Search your library for up to three cards and exile them.'
    elif act == 'Aftershock':
        return 'A spell target Tomb in range rsn, and each Tomb connected adjacently, on to-hit wis vs wis, take 4 crushing spell damage.'
    elif act == 'Pillage':
        return 'Destroy a Tomb you own in range rsn to add 3 magick to caster.'
    elif act == 'Scour':
        return 'Set the imprint of a Tomb you own in range rsn to empty. Tomb must have a non-empty imprint. Draw 2 cards.'
    elif act == 'Hallowed Ground':
        return 'All Tombs without this effect in range 2 of a location in range rsn, gain psyshield and invisibility at duration reason and level wisdom.'
    elif act == 'Magick Missle':
        return 'Deal magick spell damage equal to the number of Tombs you own to a spell target unit in range rsn. When putting this tomb in play, put it into caster exile instead of discard.'
    elif act == 'Profane Pshent':
        return 'Add Devour Intellect action to caster. On to-hit agl vs agl to an adjacent action target unit with psyche greater than 1, target gets -1 psyche effect and caster gets +1 psyche effect at duration reason and level wisdom. Devour Intellect cost 1 action to use.'
    elif act == 'Devour Intellect':
        return 'On to-hit agl vs agl to an adjacent action target unit with psyche greater than 1, target gets -1 psyche effect and caster gets +1 psyche effect at duration reason and level wisdom. Devour Intellect cost 1 action to use.'
    elif act == 'Spiritual Hammer':
        return 'On to-hit wisdom vs wisdom, an adjacent spell target unit takes psyche vs psyche crushing spell damage. If the unit has animal type, remove it from initiative queue. Costs 1 magick.'
    elif act == "Orion's Call":
        return 'All animal type units in range 2, on caster wisdom save check, are moved to front of initiative queue (or replaced there). Costs 4 magick.'
    elif act == 'Wyld Hunt':
        return 'Summon Eagle, Boar, and Wolf, as long as none of these still exist from the same caster. Costs 6 magick.'
    elif act == 'Dive':
        return 'On to-hit agl vs agl, str vs end piercing ranged damage.'
    elif act == 'Survival_of_the_Fittest':
        return 'Discard a summon card to search for any summon in library and add to hand.'
    elif act == 'Call Mount':
        return 'Call either Eyegaunt or Boar mount for caster. Eyegaunt gives caster flying, +2 move range, bonuses to ranged attack stats, and bombard, a ranged attack. Boar gives +3 physical stats, +3 move range, charge type move, and charge attack, moving forward up to full move range and damaging all adjacent enemies at the end of move range in some direction. Costs 4 magick.'
    elif act == 'Jokulhaups':
        return 'All non-flying units in range 2 of caster, on 2 separate wisdom vs wisdom to-hit checks, take psyche vs psyche fire, then psyche vs psyche explosive spell damage. Costs 6 magick.'
    elif act == 'Lightning Rod':
        return 'Between 1 and 3, randomly chosen, units among the units within range 3 of caster are automatically hit for psyche vs psyche electric spell damage. Costs 4 magick.'
    elif act == 'Swarm':
        return 'All animal types between range 1 and 2 of caster, that do not have this effect, get +1 moves and move range at duration reason and level wisdom. Costs 3 magick.'
    elif act == 'Fervor':
        return 'All animal types between range 1 and 2 of caster, that do not have this effect, get +2 str, agl, end, dodge, init, and -3 sanity at duration reason and level wisdom. Costs 3 magick.'
    elif act == 'Bombard':
        return 'All units within range 1 of a location within range bls, on to-hit mm vs dodge, take msl vs end explosvie ranged damage.'
    elif act == 'Charge':
        return 'Choose an empty adjacent location. Travel in that direction up to move range until encountering a unit or blocked location. Then, on to-hit agl vs agl, each adjacent unit takes str vs end slashing melee damage.'
    elif act == 'Teleport Field':
        return 'All units within range 3 of a location, that do not have the type nonsentient, in range rsn, are teleported randomly among the empty locations closest to another location in range rsn. Costs 4 magick.'
    elif act == 'Pull from the Aether':
        return 'Put a card from your exiled cards into your hand.'
    elif act == 'Carrion Wyrm':
        return 'Remove any number of unique cards from your discard (put in exile) to create a Wyrm user-controlled unit with base stats equal to 1 plus the number removed.'
    elif act == 'Spectral Pillory':
        return 'On to-hit wisdom vs wisdom, target gets effect: -2 move range (max 0), end-of-turn 2 magick damage.'
    elif act == 'Upheaval':
        return 'Destroy all summon list summons and tombs. Each player draws a card for each and summon count is decreased.'
    elif act == 'Fork':
        return 'Cast the spell imprinted on spell target tomb in range reason with an imprint not set to empty. If spell is cancelled, either by the player or because it cannot be cast, magick for the spell is returned, but not the 3 magick spent on fork itself.'
    elif act == 'Vanish':
        return 'All friendly units in range reason are teleported randomly around the map. Costs 7 magick.'
    elif act == 'Censer Grenade':
        return 'All non-Witch, non-Yellow Priest units within range 2 of a location within range ballistics, on to-hit marksmanship vs dodge, get a -3 sanity effect at duration reason and level wisdom.'
    elif act == 'Dessicate':
        return 'All units in range 1 of a location within range reason, on to-hit wisdom vs wisdom, get fire weakness effect at duration reason and level wisdom.'
    elif act == 'Fists of Stone':
        return 'An adjacent spell target gets an attack effect changing melee to crushing damage.'
    elif act == 'Call Migo':
        return 'Destroy a nightgaunt you own to summon a Migo, a flying, user-controlled unit that gives -1 psyche, wisdom, reason, sanity on hit. Costs 6 magick.'
    elif act == 'Call Nightgaunt':
        return 'Summon a user controlled flying nightgaunt, whose grasp attack does not damage but moves the unit to a location within move range. Self is randomly moved among the closest empty locations. Costs 4 magick.'
    elif act == 'Guardian of the Chthonic Gate':
        return 'Destroy a Migo you own to summon Guardian. Has no moves, always fails sanity checks, 2 acts, high stats, proximity effect causing -4 sanity (all range 3), and end-of-turn: all in range 2 on to-hit wisdom vs wisdom, -2 psyche, wisdom, reason, sanity. Costs 9 magick.'
    elif act == 'Trials of Hatheg Kla':
        return 'A spell target enemy unit, on to-hit wisdom vs wisdom, is teleported among the furthest empty sqrs. It gets -5 sanity, +1 acts.'
    elif act == "Dagon's Chosen":
        return 'A spell target friendly unit gets sanity reduced to 3, +1 acts and moves, +2 move range, strength, agility, endurance, dodge, initiative.'
    elif act == 'Grasp':
        return 'On to-hit agility vs agility, relocate target to location within move range. Self is relocated among the empty locations nearest.'
    elif act == 'Proboscis':
        return 'On to-hit agility vs agility, target gets effect -1 psyche, wisdom, reason, sanity.'
    elif act == 'Warpfire Cloud':
        return 'All in range 3, on to-hit wisdom vs wisdom, get -2 psyche, wisdom, reason, sanity.'
    elif act == 'Lost Artifact':
        return 'If a tomb is in your discard that is unique among tombs in play, return it to play with 1 spirit remaining.'
    elif act == 'Globe of Invulnerability':
        return 'Create a map effect at a location. Gives -5 move range, attack and defense effects that reduce melee, ranged, and spell damage to maximum of 2. Cannot be cast on same location as Witch. Costs 6 magick.'
    elif act == 'Globe Hover':
        return 'Relocate Globe of Invulnerability created by caster and any contained unit to a location within range reason. Costs 2 magick.'
    elif act == 'Globe Roll':
        return 'Choose a direction from Globe that caster created. Globe moves up to caster psyche unless obstructed by a blocked location (the map itself, not any units). All units along that path make a dodge save check (modifier -4) or suffer an attack from the unit contained in globe. Except the damage is crushing melee using the contained unit strength vs struck unit endurance. The struck units are then relocated randomly among empty locations within range 2 of themselves. Costs 4 magick.'
    elif act == 'Pyrrhic Gnomes':
        return 'Create an inert gnome summon that seeks to occupy empty adjacent locations to enemies, but otherwise does not act. It has a death trigger that deals explosive ranged damage to all adjacent units equal to 3 times its tick value. Tick value starts at 1 and increases by 1 during every end-of-turn phase. After moving, there is a chance of exploding equal to 20 times the number of enemy adjacent units. Limit 2 per artificer. Costs 3 magick.'
    elif act == 'Bottle Gnomes':
        return 'Create an inert gnome summon that seeks to occupy empty adjacent locations to friendly units, but otherwise does not act. It has a death trigger that adds spirit and magick to each adjacent friendly unit equal to its psyche. Limit 4 per artificer. Costs 1 magick.'
    elif act == 'Hunting Hawk':
        return 'Summon an inert (acts at end-of-turn) flying hawk with move range 6 and attack range 4. It attacks at agility vs agility to-hit, strength vs endurance slashing melee damage.'
    elif act == "Siren's Call":
        return 'All non-inert, non-Witch enemy units that fail a psyche save check (mod = -3) make a move among their legal moves towards a chosen location within range reason.'
    elif act == 'Recall Globe':
        return 'Recall globe from this caster from any location to caster location.'
    elif act == "Death's Head Moth":
        return 'Summon an inert (not player controlled, attacks during end-of-turn) flying moth that moves at range 6, attacks at range 4, agility vs agility to-hit, psyche vs psyche magick melee damage, leaving an end-of-turn 2 poison damage effect at duration reason and level wisdom. Destroys a tomb you control with this imprint on cast.'
    elif act == 'Efface':
        return 'Choose a tomb you own and a tomb you do not own with imprints not set to empty. Set each of those tombs imprint to empty (removing the ability to cast that spell).'
    elif act == 'Graverob':
        return 'Remove a card from opponent Witch discard to heal caster 6 spirit and magick.'
    elif act == 'Lobotomy':
        return 'Any adjacent unit (regardless of invisibility or psyshield) is attacked at agility vs agility to-hit, strength vs endurance piercing melee damage. If target is a Witch, search library for a card and exile it.'
    elif act == 'Poison Weapon':
        return 'Any adjacent unit is given an attack effect that adds end-of-turn 3 poison damage to melee or ranged attacks and changes type to poison. Duration reason at level strength.'
    elif act == 'Infiltrate':
        return 'Caster and adjacent friendly unit are relocated randomly among the closest empty locations to any location within move range. Caster and target each gain invisibility for 1 turn at level wisdom.'
    elif act == 'Retreating Strike':
        return 'Any adjacent unit (regardless of invisibility or psyshield) is attacked at agility vs agility to-hit, strength vs endurance slashing melee damage. Then, relocate caster to location within move range and caster gains invisibility for 1 turn at level wisdom.'
    elif act == 'Hypnotic Spectre':
        return 'Summon an inert (not player controlled, attacks during end-of-turn) flying spectre that moves at range 5, attacks at range 4, agility vs agility to-hit, psyche vs psyche magick melee damage. If target is a Witch, discard a card at random from hand. '
    elif act == 'Styxian Guide':
        return 'Instead of placing a tomb this turn, search your library for any card and put it in your hand. Sets tomb-used to true (may be reset by further effects).'
    elif act == 'Giant Growth':
        return 'A spell target in range reason gets +X to strength, endurance, and agility, and heals X spirit. X is equal to the number of cards discarded to cast this spell. Duration is reason at level wisdom.'
    elif act == 'Living Death':
        return 'Summon X Cadavers among the closest empty to a location. X is equal to your summon_cap minus summon_count.'
    elif act == 'Wrath of Samael':
        return 'Pay X magick in addition to casting. Deals X elec ranged and X fire spell to each summon that is not inert.'
    elif act == 'Mass Grave':
        return 'Put a number of tombs into play up to your summon_cap minus summon_count. They are distributed randomly around a location within range reason.'
    elif act == 'Myopic Neuroticism':
        return 'Discard any number of cards to add that much magick.'
    elif act == 'Quest of the Hermit Druid':
        return 'Reveal cards from the top of your library until you reveal a summon or library is empty. Put the summon into your hand, if exists, and the other revealed cards into your discard.'
    elif act == 'Coercion':
        return 'Discard a card to look at opponent Witch in-hand and choose and discard. Cannot target psyshield.'
    elif act == 'Foretell':
        return 'Look at the top 2 cards of opponent Witch library. Put each either on bottom of library or in discard. Cannot target psyshield.'
    elif act == 'Compromised Immunity':
        return 'On to-hit wisdom vs wisdom, spell target gains weakness to poison.'
    elif act == 'Defile':
        return 'On to-hit wisdom vs wisdom, do 4 slashing damage to a spell target tomb.'
    elif act == 'Scrye':
        return 'Draw 1 card.'
    elif act == 'Dark Ritual':
        return 'Gain 1 magick plus 1 for each adjacent friendly summon that is not a Tomb, then caster does 3 magick spell damage to each of those summons.'
    elif act == 'Grave Twin':
        return 'If caster has at least 2 empty adjacent locations, may place 2 tombs of the same name instead of the normal 1.'
    elif act == 'Rite of Spring':
        return 'Draw a card for each less than the summon cap your current summon total.'
    elif act == 'Frantic Search':
        return 'Draw 2 cards and discard 3 cards.'
    elif act == 'Forestwalk':
        return 'Caster gains invisibility and psyshield, and move type becomes ethereal until the end of this turn.'
    elif act == 'Aura Blast':
        return 'Spell target in range reason, on to-hit wisdom vs wisom, takes magick spell damage equal to the in_hand total of owner Witch. Costs 4 magick.'
    elif act == 'Regrowth':
        return 'Return a Tomb from your discard to hand. Costs 3 magick.'
    elif act == 'Enlightenment':
        return 'Draw a card for each wisdom effect on caster. Costs 4 magick.'
    elif act == 'Wall of Blossoms':
        return 'All empty locations surrounding a spell target withing range reason become populated with inert Wall of Blossoms summons. Costs 2 magick.'
    elif act == 'Wildfire':
        return 'A spell target in range reason that has weakness to fire, and each connected summon with weakness to fire are consumed with wildfire. Those summons, and each adjacent summon, all take caster psyche vs endurance fire spell damage. Costs 4 magick.'
    elif act == 'Animate Tomb':
        return 'A tomb is able to move and act, gains move and tomb bash, a melee crushing attack.'
    elif act == 'Tomb Bash':
        return 'To-hit agility vs agility, strength vs endurance crushing melee damage.'
    elif act == 'Summon Lesser Demon':
        return 'Transform a Foul Familiar you own into a Lesser Demon.'
    elif act == 'Summon Cenobite':
        return 'Summon a Cenobite at an empty location.'
    elif act == 'Barrow Wight':
        return 'Summon a Barrow Wight under caster control at a target location. The Barrow Wight has no actions or moves, but does so during end of turn phase. It will seek out and attack ONLY enemy tombs.'
    elif act == 'Haunted Cairn':
        return 'Place a summoned Cairn at empty location. At end-of-turn, Cairn generates Ghast unit under control of Cairn controller at an empty adjacent location, if one exists.'
    elif act == 'Pixie Dust':
        return 'Spell target in range reason gains psyshield effect at duration reason and level wisdom.'
    elif act == 'Screech':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, gets -3 sanity and -1 move range at level and duration strength.'
    elif act == 'Fangs of Apophis':
        return 'Spell target in range reason gets +1 str, agl and melee damage changed to poison.'
    elif act == 'Wreathed in Flame':
        return 'Spell target in range reason gets fire resistance and loses fire weakness. Attackers doing melee damage to effect holder take 6 fire damage.'
    elif act == 'Reaping of Saturnus':
        return 'Destroy a spell target summon you own, anywhere on the map, to decrease your summon count by 1. Draw a card.'
    elif act == 'Snuffle':
        return 'Target loses psyshield.'
    elif act == 'Flying Move':
        return 'Move without being impeded by obstacles.'
    elif act == 'Flying Move':
        return 'Move without being impeded by obstacles.'
    elif act == 'Pox':
        return 'Adjacent units get end-of-turn effect: 3 poison dmg. Duration is reason. Level is wisdom.'
    elif act == 'Summon':
        return 'Place a Summon at an adjacent location, once per turn. Does not use actions.'
    elif act == 'Move':
        return 'Move according to move type and move range'
    elif act == 'Spell':
        return 'Cast cantrip or arcane spell'
    elif act == 'Gravity':
        return 'A unit within range equal to caster rsn gets move range reduced by 2, also -2 agility and dodge. Duration equal to caster rsn. Level equal to caster wis. Target as spell.'
    elif act == 'Curse of Oriax':
        return 'A non-witch unit within range of caster rsn gets -1 to each (psy,wis,rsn,san,init) and takes 2 magick dmg at end of turn. Duration equal to caster rsn. Level equal to caster wis. Target as spell.'
    elif act == 'Pestilence':
        return 'Range rsn, psy vs psy poison spell dmg, psy vs psy (minus distance from primary target times 2) to all within range 3 on hit. Primary target gets effect: eot 3 poison dmg and a death trigger that passes new eot effect to all adjacent (dur and level based on current caster abilities). Duration = rsn times 2, level = wis. Does not target unit. Targets location (can cast on units with psyshield).'
    elif act == 'Plague':
        return 'Target in range rsn and each unit connected by occupied adjacent sqrs (counting units without pestilence effect) gets -4 to a random ability among str, agl, end, mm, psy, wis, rsn, san, init. Duration = rsn, level = wis. Target as spell.'
    elif act == "Beleth's Command":
        return 'Costs 1 act AND 1 mv to use. A non-adjacent unit is struck by lightning, taking psyche vs psyche elec dmg. On to-hit (psyche vs strength) the unit gets -1 moves, lasting rsn at level wis. Then, all adjacent units to the caster take psy vs psy fire dmg. The caster gains +1 psyche +1 endurance effect if not already possessed, lasting rsn at level wis. Target only lightning target as spell.'
    elif act == "Minerva's Gift":
        return 'Spell target gets +1 agl, init, heal 1 spirit. Duration 2 turns at level wis.'
    elif act == 'Psionic Push':
        return 'A unit is pushed at/towards any location (including its current) within range 2 as long as the path is unobstructed. After push, if there are any adjacent units then each plus original target make agility save(+1). A failed save means the unit takes a crushing attack from the pushed unit using half strength(of pushed unit, rounded up) vs endurance(of unit receiving attack) (the pushed unit attacks itself upon a failed save after ending a push adjacent to other units, ending the push on a location with no adjacent units results in no attacks to any unit). Spell target.'
    elif act == 'Energize':
        return 'Target gets effect +1 mvs. Lasts 2 turns at level wisdom. Spell target.'
    elif act == 'Psi Blades':
        return 'Adjacent target gains a melee attack action. Aglity vs aglity to hit, psyche vs psyche electric melee damage. Duration is reason, level wisdom. Spell target, added psi slash is action target'
    elif act == 'Psi Slash':
        return 'This is the action added from Psi Blades. Attack adjacent, aglity vs aglity to hit, psyche vs psyche electric melee damage.'
    elif act == 'Pyrotechnics':
        return 'Range is ballistics. Marksmanship vs Dodge to hit. Missle vs Endurance fire ranged damage. Action target (ents without invis).'
    elif act == 'Molecular Subversion':
        return 'The very structure of a creature begins to dissolve... Target gains an effect that removes resistances to acid and explosive (resistances may be gained through effects cast after this spell). Also gives an effect that adds weakness to acid and explosive dmg. Duration is reason at level of caster wisdom. Spell target.'
    elif act == 'Plutonian Cloak':
        return 'Target gets a defense effect. When taking damage, if the type is slashing, piercing, or crushing melee damage, this summon gains invisibility (untargetable with non-spell actions) until the end of this turn; OR, if the damage source is a spell, the summon gains psyshield (untargetable with spells) until the end of this turn. Invisibility or psyshield are not added if the summon already has them as types added by this spell. Duration of caster reason at level wisdom. (each instance of either invisibility or psyshield last 1 turn). Spell target.'
    elif act == 'Hidden From the Stars':
        return 'A non-witch adjacent target gains +1 agility, dodge, and wisdom. Duration is reason at level of wisdom. Spell target.'
    elif act == 'Cosmic Sight':
        return 'All enemies within range 3 of caster make wisdom check (-2) or get an effect which strips all preexisting instances of psyshield (effects applied later may grant psyshield while this is still in effect). May grant effect to unit already with this effect (for the purposes of stripping later added instances of psyshield). Duration is reason at level of wisdom. No targeting.'
    elif act == 'Bewitch':
        return 'Any non-witch target, friendly or enemy, within range of reason, gains an effect granting psyshield until the end of this turn. Level is wisdom. Spell target.'
    elif act == 'Read the Stars':
        return 'Spell target summon gains attack effect that increases elec and cold type damage by 2 when the source is melee, ranged, or spell. Duration is reason at level of wisdom.'
    elif act == 'Demonic Sight':
        return 'Any target in range of reason, on to hit psyche vs psyche, gets an effect that strips invisibility. Duration is reason. Level is wisdom. (must be targetable by spells).'
    elif act == 'Mist Move':
        return 'Move without being obstructed by obstacles.'
    elif act == 'Drain Life':
        return 'range of reason, to hit wis vs wis, magick damage psyche vs psyche. Caster is healed equal to half the amount of dmg successfully dealt (rounded up). Target as spell. Costs 3 magick.'
    elif act == 'Muddle':
        return 'If to-hit wisdom vs wisdom, spell target gets an end of turn effect causing it to attack itself. It attempts a hit with its own agility (always 50%, unless affected by its own attack or defense effects). A successful hit causes strength vs endurance (its own) crushing dmg. Lasts 3 turns at level of wisdom. Costs 2 magick.'
    elif act == 'Tendrils of Chaos':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, gets -2 to a random ability among all abilities besides acts, moves, move range, ballistics, and missle, and can be given multiple times to the same unit. Duration equal to caster reason  at level of wisdom. Target as spell.'
    elif act == 'Warpfire':
        return 'A location which does not already have a warpfire effect has a warpfire placed on it. At the start of the turn, each unit within range 3 of the warpfire is teleported to a random square among the squares CLOSEST to the warpfire. At end-of-turn, if a unit occupies the location, it gets -4 sanity effect at reason duration and wisdom level (of original caster).'
    elif act == 'Phase Shift':
        return 'Switch between the Umbrae Wolf and Umbrae Mist forms. Counts as action.'
    elif act == 'Dark Shroud':
        return 'Spell target unit in range reason without this effect, and all friendly within range 1, heal 2 spirit and receive +1 dodge if they do not already have the effect. The primary target gains invisibility. Duration is reason, level is wisdom. Costs one magick, does not target.'
    elif act == 'Umbrae Strike':
        return 'Action target. Range ballistic. Marksmanship versus dodge to-hit. Missle versus endurance cold ranged damage.'
    elif act == 'Stalk':
        return 'To-hit marksmanship vs dodge, unit gets an effect which causes either slashing, crushing, or piercing damage dealt to it to be increased by 2, if the type if melee or ranged. Duration is missle, level is ballistic. Targets as action.'
    elif act == 'Darkblast':
        return 'If used on a friendly unit, attempt to dispel(level = missle) any 1 effect and then heal it 3 spirit. If used on an enemy unit, a successful to-hit (marksmanship vs dodge) does piercing ranged damage: missle vs endurance. After the attack, attempts to dispel(level = missle) any 1 effect on the target. Targets as an action. Costs 2 magick.'
    elif act == 'Leap':
        return 'Move over obstacles to any square within move range. Movement effects do not affect the range of Leap unless specifically noted. Does not count as either an action or a move. Can only be used once per turn.'
    elif act == 'Rage':
        return 'Dispel(level = strength) attempt all current effects on self. Gain +3 str, end, +4 psy. Take 3 magick damage when effect expires, dispelled, or otherwise removed. Remove all current actions besides Move, Leap, Rage, and Whirlwind. Duration is reason. Level is strength.'
    elif act == 'Hurl':
        return 'Move an adjacent friendly unit to a location up to distance strength from Berserker. Target as action.'
    elif act == 'Whirlwind':
        return 'Attack each adjacent unit (does not target). To-hit: agl-3(min 1) vs agl, slashing damage: str vs end'
    elif act == 'Simulacrum':
        return 'Target, as spell, within range reason gets +3 agility and dodge. Duration is reason at level of wisdom. Costs 2 magick.'
    elif act == 'Gate':
        return 'Target, as spell, within range reason. Relocate unit to any location within range reason. Costs 2 magick.'
    elif act == 'Mortar':
        return 'A unit within range (ballistics<=ballistics+2), and all units within range 2 of that location, upon failing to-hit marksmanship vs dodge, take a random amount of explosive ranged damage (between missle-minus-d3 and missle). Does not target.'
    elif act == 'Tracer Grenade':
        return 'A unit within range (ballistics<=ballistics+2), and all units within range 2 of that location, upon failing to-hit marksmanship vs dodge, get -4 dodge and effect that strips instances of previously held invisibility (later effects may grant invisibility while this effect still persists). Duration is missle. Level is ballistics.'
    elif act == 'Doubling Cube':
        return 'Spell target in range reason gets double effect if they do not already have it. Effect causes any slashing, crushing, or piercing damage (from melee and ranged sources) made against unit to force attacker to make a to-hit roll (psyche vs psyche) against defender. On fail, the attackers dmg is reduced to 1. Duration is reason, level is wisdom. Costs 3 magick.'
    elif act == 'Unholy Chant':
        return 'All other friendly units within range 2 of caster get +1 to all stats (str, agl, end, mm, msl, bls, dod, psy, wis, rsn, san, init, moverange) for the remainder of the turn at level wisdom. Costs 1 magick.'
    elif act == 'Arrow of Diana':
        return 'Target within range of ballistics, on fail of to-hit marksmanship vs dodge, takes missle vs endurance piercing damage. Action target'
    elif act == 'Esuna':
        return 'Target within range reason has each effect attempted to dispel(wisdom). Targets as spell. Costs 2 magick.'
    elif act == 'Moonlight':
        return 'Target within range reason is healed equal to caster psyche up to its max spirit. Target as spell. Costs 2 magick.'
    elif act == 'Aura':
        return 'All friendly units within range 3 heal a random amount between 1 and caster psyche. Costs 4 magick.'
    elif act == 'Tranquility':
        return 'Dispel(wisdom) attempt all effects on a location.'
    elif act == 'Paralyze':
        return 'An adjacent spell target, upon failing wisdom vs wisdom to-hit, gets an effect which reduces move range by 3,and reduces its number of actions by 1. Duration is reason. Level is wisdom. Costs 5 magick.'
    elif act == 'Scarab Gestation':
        return 'Spell target, range reason (non-scarab/scarab swarm). On caster psyche save check, gives a death trigger that summons a scarab under your control. Costs 3 magick. Duration is 13 turns. Level is psyche.'
    elif act == 'Bite':
        return 'Scarab bites an adjacent unit. To-hit: agl vs agl, damage: str vs end, acid melee.'
    elif act == 'Scarab Swarm':
        return 'Transform a scarab into a flying scarab swarm.'
    elif act == 'Spore Cloud':
        return 'Target location in range 2 gets effect: +4 dodge, -2 damage if type is slashing, piercing, or fire and melee or ranged or spell. Duration is reason. Level is wisdom.'
    elif act == 'Claw Rake':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg. If unit does not have effect, gets Ghoul Venom -1 str, end and end-of-turn 2 poison dmg at duration of reason and level of wisdom (of ghoul).'
    elif act == 'Bone Strike':
        return 'adjacent action target, agl vs agl, str vs end crushing dmg.'
    elif act == 'Firebolt':
        return 'spell target range reason, wis vs wis, psy vs psy fire dmg. Costs 1.'
    elif act == 'Scratch':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg.'
    elif act == 'Chop':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg.'
    elif act == 'Bless':
        return 'Heal a friendly spell target within range reason equal to caster psyche.'
    elif act == 'Boiling Blood':
        return 'Adjacent spell target that you own gets +4 str, -4 end, end-of-turn 2 fire damage. Duration is reason. Level is wisdom.'
    elif act == 'Dark Sun':
        return 'Adjacent spell target gets +1 actions until the end of this turn if it passes a wisdom save check. Level is wisdom.'
    elif act == 'Meditate':
        return 'Caster gets +1 psyche and +2 move range until the end of this turn. Level is wisdom.'
    elif act == 'Horrid Wilting':
        return 'Target location, and all units within range 2, on to-hit wis vs wis, take psyche vs endurance acid damage. Does not target.'
    elif act == 'Mummify':
        return 'Spell target within range reason gets +4 endurance and move range reduced to 1. If unit is a Berserker, its leap is set to used for the turn on casting and during start-of-turn effects. Duration is reason. Level is wisdom.'
    elif act == 'Command of Osiris':
        return 'All friendly units within half range reason (rounded down, min 1) get +1 str and end. They are also healed for 1 spirit. All enemies in the same range get -1 str and end. Duration is reason. Level is wisdom. Does not target.'
    elif act == 'Immolate':
        return 'Spell target within half of reason range (rounded down, minimum 1) takes (psyche vs psyche) fire spell damage.'
    elif act == 'Disintegrate':
        return 'Spell target within range reason gets -1 to random ability among str, agl, end, rsn, san. It also gets end-of-turn effect that gives -1 among the same abilities and causes 1 acid damage. Duration is reason. Level is wisdom.'
    elif act == 'Darkness':
        return 'A location within range reason, and all within range 1 of that, get location effect causing units with normal or flying move type (which are not immovable) moving from them -2 move range. Costs 3 magick. Lasts 2 turns at level wisdom.'
    elif act == 'Foul Familiar':
        return 'Summon familiar under your control. Caster takes 5 magick damage on familiar death.'
    elif act == 'Poison Sting':
        return 'Range ballistics, marksmanship vs dodge to-hit, missle vs endurance poison damage. Hit also causes effect, -1 strength and 1 poison damage end-of-turn, stackable. Duration is missle. Level is ballistics.'
    elif act == 'Dire Charm':
        return 'All units within range reason, upon to-hit wisdom vs wisdom, damage themselves using their own strength vs endurance, crushing melee. Costs 6 magick. Does not target.'
    elif act == 'Baleful Stare':
        return 'Spell target within range reason, upon to-hit wisdom vs wisdom, that does not have this effect gets -2 endurance and end-of-turn 2 acid damage. Duration is reason. Level is wisdom.'
    elif act == 'Mind Rot':
        return 'Spell target in range reason gets -2 wisdom, -1 reason, -3 sanity. Duration is reason. Level is wisdom.'
    elif act == 'Legerdemain':
        return 'If caster passes a save check (mod -3), exchange position of two, non-Witch spell target units.'
    elif act == 'Grasp of the Old Ones':
        return 'Any unit within range reason, upon to-hit psyche vs psyche, gets an effect that strips invisibility and psyshield. Duration is reason. Level is wisdom. Does not target.'
    elif act == 'Dust Devil':
        return 'A spell target within range reason, upon to-hit wisdom vs wisdom, takes psyche vs psyche explosive damage and is relocated to any of the locations (chosen randomly) furthest away from the caster among the locations within distance from the target equal to caster psyche.'
    elif act == 'Dispel':
        return 'An action target within range reason, upon failing to-hit wisdom vs wisdom, has all effects attempted to dispel using caster wisdom. Upon another to-hit using wisdom vs wisdom, the unit gets an effect that strips psyshield. Duration is reason. Level is wisdom.'
    elif act == 'Brambles':
        return 'Spell target within range reason, and all enemy units within distance 2, get -1 move range if they have normal type movement and, on to-hit wisdom vs wisdom, take psyche vs psyche slashing spell damage. Costs 3.'
    elif act == 'Flesh Hooks':
        return 'An adjacent friendly action target, without this ability, is granted Hook Attack action. This action targets a unit within range reason that, on to-hit wisdom vs dodge, does psyche vs endurance piercing ranged damage. Action is granted for duration reason at level wisdom. Costs 4 magick.'
    elif act == 'Hellfire':
        return 'Spell target within range reason, on to-hit wis vs wis, does psyche vs psyche fire spell damage. If that unit fails an endurance save(-5), it gets burn effect which causes slashing, crushing, piercing, fire, and explosive damage to be increased by 2. Duration is reason. Level is wisdom. Costs 3 magick.'
    elif act == 'Stregth Through Wounding':
        return 'All units within range 3 take 2 piercing ranged damage. Friendly units get +1 psyche and endurance. Duration is reason. Level is wisdom.'
    elif act == 'Analyze':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, gets an effect that removes resistances to slashing, piercing, crushing, and explosive damage. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Smoke Bomb':
        return 'A location within range ballistics, which does not have this effect, gets effect that grants invisibility to the occupant. Duration is missle. Level is marksmanship.'
    elif act == 'Pierce Shield':
        return 'Any unit within range reason, on to-hit wisdom vs wisdom, gets effect that removes psyshield and gives -1 to psyche and wisdom. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Rend Space':
        return 'Deal explosive spell damage to a unit equal to 3 times the number of map effects at that location. Costs 2.'
    elif act == 'Haste':
        return 'A spell target within range, without this effect, reason gets +4 initiative, +1 agility, dodge, and moves. Duration is reason. Level is wisdom. Costs 5 magick.'
    elif act == 'Encumber':
        return 'A spell target within range reason, without this effect, on to-hit wisdom vs wisdom, gets -4 initiative and -2 agility, marksmanship, dodge, move range, and -1 moves. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Gaze':
        return 'Action target within range ballistics, which does not already have this effect, on to-hit marksmanship vs dodge, gets -3 move range to a minimum of 1, if its move range is above zero. Duration is missle. Level is marksmanship.'
    elif act == 'Howl From Beyond':
        return 'All non-Witch, enemy units within range reason without this effect, on to-hit strength vs strength, get -2 sanity and -3 reason. Duration is endurance. Level is strength.'
    elif act == 'Track':
        return 'All enemy units within range reason, on to-hit agility vs agility, get an effect that removes invisibility. Duration is endurance. Level is strength.'
    elif act == 'Toxic Miasma':
        return 'All enemy units, which are not Murrain Wolves, within range reason, on to-hit wisdom vs wisdom, get an effect that removes invisibility. Another to-hit wisdom vs wisdom gives -1 sanity and reason. Duration is reason. Level is wisdom.'
    elif act == 'Leprous Bite':
        return 'An adjacent action target unit, on to-hit agility vs agility, gets -1 str, end, agl, mm, psy, wis, rsn, init, -3 sanity, and takes strength vs endurance slashing melee damage.'
    elif act == 'Concerted Volley':
        return 'Each friendly unit within range 2 of caster gets +X marksmanship where X is equal to the number of friendly units within range 2 of caster without this effect, max +4 bonus to each unit. Duration is wisdom. Level is wisdom. Costs 1.'
    elif act == 'Vengeance':
        return 'Spell target gets defense effect, on receiving melee or ranged damage, adds a +1 effect to str,agl,end,psy,wis,rsn. +1 Effect may be added up to 4 times. Both +1 boosts and this effect have duration equal to caster reason and level equal to caster wisdom.'
    elif act == 'Pounce':
        return "'Jump'(move unimpeded by obstacles) to a location within move range that is adjacent to at least 1 enemy unit. After relocating, attack each adjacent enemy, to-hit agility vs agility, damage strength vs endurance, slashing melee. Does not target."
    elif act == 'Suplex':
        return "An adjacent, action target unit, that does not have the type 'immovable', on to-hit agility vs agility, is relocated to any adjacent location from the caster. Any unit occupying the location is relocated to one of the closest locations to its current location. The original target, and the other potential unit, both take damage equal to the caster strength vs their endurance, crushing melee."
    elif act == 'Anoint':
        return 'Any spell target within range reason, that does not have this effect, gets +1 wisdom. Duration is reason. Level is wisdom. Costs 1 magick.'
    elif act == 'Abeyance':
        return 'An adjacent non-Witch, spell target unit, on to-hit wisdom vs wisdom, has an action of your choice removed for duration reason at level wisdom. Costs 3 magick.'
    elif act == 'Reveal':
        return 'An adjacent unit, on to-hit wisdom vs wisdom, gets an effect that strips psyshield if it has psyshield, otherwise gets an effect that strips invisibility. Duration is reason. Level is wisdom.'
    elif act == 'Nullify':
        return 'All units within range reason, that do not have either psyshield or invisibility, have each of their effects attempted to dispel using the caster wisdom. Costs 3 magick.'
    elif act == 'Roar':
        return 'All enemy units within range reason that do not have this effect, on strength vs strength to-hit get -3 sanity. Duration is endurance. Level is srength.'
    elif act == "Devil's Mark":
        return 'A non-Witch spell target unit gets +1 to any chosen ability. Costs 2 magick. Duration is reason. Level is wisdom.'
    elif act == 'Mesmerize':
        return 'Spell target within range rsn, on to hit wisdom vs wisdom, gets an effect causing a start-of-turn psyche save check(mod 0). On failure, the unit loses one action, if it has any, and is dealt crushing melee damage equal to its own strength vs endurance. Duration is reason. Level is wisdom.'
    elif act == 'Torment':
        return 'A spell target within range reason gets an effect that gives -2 psyche, if it does not already have this effect. It then takes psyche vs endurance magick spell damage.'
    elif act == 'Entrance':
        return 'A spell target in range reason, on to-hit psyche vs psyche, gets -4 sanity at duration reason and level wisdom. Costs 4 magick.'
    elif act == 'Enthrall':
        return 'A spell target within range reason without this effect, on to-hit psyche vs psyche, gets -3 marksmanship and missle at duration reason and level wisdom. Costs 4 magick.'
    elif act == 'Chill Touch':
        return 'An adjacent action target, on to-hit agility vs agility, gets -1 wisdom at duration reason and level wisdom, then takes strength vs endurance cold melee damage.'
    elif act == 'Enervating Grasp':
        return 'An adjacent action target, on to-hit agility vs agility, has magick drained and given to the caster equal to psyche vs psyche damage. The caster cannot go above their base magick in this manner.'
    elif act == 'Vampiric Bite':
        return 'An adjacent action target, on to-hit agility vs agility, takes strength vs endurance piercing melee damage. Caster gets +3 psyche, if it does not have this effect, at duration reason and level wisdom.'
    elif act == 'Bat Form':
        return 'Once per round, Wurdulak may shift form into either bat or wolf form, an Effect lasting 1 turn at level wisdom. Bat form gives +3 to move range, +4 to dodge, and changes move type to flying, and -3 to strength, agility, endurance.'
    elif act == 'Wolf Form':
        return 'Once per round, Wurdulak may shift form into either bat or wolf form, an Effect lasting 1 turn at level wisdom. Wolf form gives +4 agility, +3 move range, and -3 to psyche, wisdom.'
    elif act == 'Hook Attack':
        return 'To-hit wisdom vs dodge. Damage psyche vs endurance, piercing ranged.'
    elif act == 'Stitch Cadaver':
        return 'Summon a Cadaver under your control within range reason. Cadaver performs a round during the end-of-turn phase. If it can  move adjacent to an enemy by moving its move range, it will, and then perform an attack (agility vs agility to-hit, strength vs endurance crushing melee damage). Otherwise it moves randomly within its move range. Cadaver gets a normal round during the turn, but has no actions to use unless granted by the Chirurgeon (or other source).'
    elif act == 'Bone Pincers':
        return 'Action target cadaver you own. It gains an effect granting an action, which targets as action an adjacent unit and on to-hit agility vs agility does strength vs endurance slashing melee damage. This effect has duration reason and level wisdom.'
    elif act == 'Willful Perambulation':
        return 'Action target cadaver you own. It gains an effect granting an action, which allows it to move using its moves. This effect has duration reason and level wisdom.'
    elif act == 'Corrosive Glands':
        return 'Action target cadaver you own. It gains an effect granting an action, which targets as action a unit within range ballistics and on to-hit marksmanship vs dodge does missle vs endurance acid ranged damage. This effect has duration reason and level wisdom.'
    elif act == 'Bone Pincer Attack':
        return 'Action target adjacent unit. On to-hit agility vs agility, does strength vs endurance slashing melee damage.'
    elif act == 'Corrosive Attack':
        return 'Action target unit within range ballistics. On to-hit marksmanship vs dodge, does missle vs endurance acid ranged damage.'
    elif act == 'Alacrity':
        return 'Action target cadaver you own within range reason gets +5 agility, +4 move range  and strength. Costs 4 magick. Duration is reason. Level is wisdom.'
    elif act == 'Farsight':
        return 'Action target cadaver you own within range reason gets +6 marksmanship, +2 ballistics, and +4 missle. Costs 4 magick. Duration is reason. Level is wisdom.'
    elif act == 'Fuse Trap':
        return 'Add local effect to a location within reason. On undo, do 3 explosive undo damage to each unit within range 3 of the effect (damage source is caster of fuse trap). Duration is 1. Level is wisdom.'
    elif act == 'Entomb':
        return 'Place Tomb or Summon at empty adjacent location (one of each per turn). Tombs imprint one arcana spell. Spells may be cast once per turn for each imprint, as long as you have the necessary magick to spend. Summons are controlled by you and limited by the summon cap (destroyed summons do not decrease the summon cap). Tomb is inert. At end of turn, each tomb you own heals each friendly adjacent unit (spirit and magick) equal to tomb strength. Witch gains magick at the beginning of the start-of-turn phase for each tomb controlled plus its magick regen rate. Entomb does not use actions.'
    elif act == 'Arcana':
        return 'Cast an arcane spell. Spells may be cast once for each time they are imprinted on Tombs you created, and as long as you have the magick to spend. Using an arcane spell does not use up actions.'
    elif act == 'Pain':
        return 'Destroy a summon you own within range reason. All adjacent units take psyche (of caster) vs endurance explosive ranged damage.'
    elif act == 'Hatred':
        return 'A spell target unit without this effect gets an attack effect. Whenever dealing melee damage, this unit gets a +2 strength effect at the duration and level of caster reason and wisdom. Bonus is applied after damage amount calculated and can be applied up to 5 times. This effect has duration reason and level wisdom.'
    elif act == 'Terror':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage.'
    elif act == 'Fear':
        return 'Action target in range reason, and all other enemy units adjacent, on to-hit wisdom vs wisdom take psyche vs psyche cold spell damage. Then, if they do not have this effect, get -1 move range and psyche.'
    elif act == 'Slow':
        return 'Spell target in range reason, and all other enemy units adjacent, if they do not have this effect, get -2 move range and an attack effect that reduces their ranged and melee damage by half (rounded down) to a minimum of 1.'
    elif act == 'Willowisp':
        return 'Spell target in range reason takes psyche vs endurance fire spell damage and gets a burn defense effect, if it does not already possess one. Burn causes melee, ranged, and spell damage received to be increased by 2 if the type is slashing, crushing, piercing, fire, or explosive. The target is then moved to a random location within distance 4, as long as an open path exists.'
    elif act == 'Wail':
        return 'All enemy units within range reason of caster are moved to a location among those furthest from caster from the moves the unit could normally make and lose psyshield and invisibility.'
    elif act == 'Iron Spirit':
        return 'An adjacent spell target summon gets +1 strength, endurance, and wisdom. Duration is reason. Level is wisdom.'
    elif act == 'Strength of the Void':
        return 'An adjacent spell target summon gets +1 strength, endurance, and psyche. Duration is reason. Level is wisdom.'
    elif act == 'Gift of Mars':
        return 'An adjacent spell target summon gets +1 missle, marksmanship, and psyche. Duration is reason. Level is wisdom.'
    elif act == "Mercury's Blessing":
        return 'An adjacent spell target summon gets +1 agility, dodge, and move range. Duration is reason. Level is wisdom.'
    elif act == 'Duress':
        return 'Spell target within range reason that has psyche equal to or greater than its strength, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage; then, gets an effect -4 reason and -7 sanity at duration reason and level wisdom.'
    elif act == 'Summon Undead':
        return 'Summon two skeletons and one ghoul.'
    elif act == "Tourach's Hymn":
        return 'Spell target within range reason that has strength equal to or greater than its psyche, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage; then, gets an effect -4 strength and agility at duration reason and level wisdom.'
    elif act == 'Staff of Vecna':
        return 'A unit within range reason gets an effect that removes psyshield.'
    elif act == 'Stomp':
        return 'All units, that are not flying, ethereal, or immovable, take between 1 and 6 minus their distance from caster, electric ranged damage. They are then moved up to 2 squares closer towards the caster, if an unobstructed path exists.'
    elif act == 'Pound':
        return 'All adjacent enemy units, on to-hit agility vs agility, takes strength vs endurance crushing melee damage.'
    elif act == 'Charge':
        return 'An enemy unit on a straight path from caster, whose location is equal to or greater than the caster move range   but less than or equal to 2 times the caster move range, is Charged. The caster is relocated adjacent, and on to-hit agility vs agility, the unit takes strength vs endurance crushing melee damage.'
    elif act == 'Rake':
        return 'An adjacent unit, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Iceblast':
        return 'A unit within range reason, and all other units within range 1, on to-hit wisdom vs wisdom, take psyche vs psyche cold spell damage.'
    elif act == 'Vivify':
        return 'Restore spirit and magick equal to caster psyche. Costs 1 magick.'
    elif act == 'Lift':
        return 'Spell target gets a move type effect that changes its move type to flying.'
    elif act == 'Fireblast':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche fire spell damage. The unit then gets a Burn effect, if it does not already have one, causing slashing, crushing, piercing, fire, or explosive damage to be increased by 2 if it is of type melee, ranged, or spell.'
    elif act == 'Teleport':
        return 'Moves a friendly unit within range reason closer to enemy units, moving within the same reason range.'
    elif act == 'Charged Bolt':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche electric spell damage.'
    elif act == 'Lacerate':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Lunge':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance piercing melee damage.'
    elif act == 'Frenzy':
        return 'All adjacent units, on to-hit agility vs agility, take strength vs endurance slashing melee damage.'
    elif act == 'Shout':
        return 'All units within range reason, on to-hit strength vs psyche, get -2 sanity.'
    elif act == 'Gale':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance electric ranged damage.'
    elif act == 'Static Storm':
        return 'All units within range reason, besides caster, have all effects attempted to dispel by caster using wisdom.'
    elif act == 'Cyclonic Rift':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche electric spell damage. Then, teleport it to a random location no further from itself than the caster psyche.'
    elif act == 'Breath of Life':
        return 'All Air Elementals are healed 10 spirit. Then, all of their effects are attempted to dispel using caster wisdom.'
    elif act == 'Summon Air Elementals':
        return 'Summon 3 Air Elementals, once, close to the caster.'
    elif act == 'Summon Earth Elementals':
        return 'Summon 3 Earth Elementals, once, close to the caster.'
    elif act == 'Earthquake':
        return 'All units within range reason that are not flying, ethereal, or immovable, take psyche vs agility crushing spell damage; And, are moved up to 4 squares among those squares that are furthest from the caster.'
    elif act == 'Summon Fire Elementals':
        return 'Summon 3 Fire Elementals, once, close to the caster.'
    elif act == 'Firewall':
        return 'All units, that are not Fire Elementals, and in lateral lines from the caster, up to range reason; take psyche vs psyche fire spell damage.'
    elif act == 'Surge':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance piercing ranged damage.'
    elif act == 'Dehydrate':
        return 'Spell target in range reason, and all enemy units range 2 from target, on to-hit wisdom vs wisdom, take psyche vs psyche acid spell damage, AND get an effect giving weakness to Fire damage.'
    elif act == 'Fog':
        return 'Spell target in range reason, and all enemy units range 2 from target, on to-hit wisdom vs wisdom, take 3 cold spell damage; AND, get an effect giving -3 to move range, if they do not already possess this effect.'
    elif act == 'Purify':
        return 'Any unit within range reason with at least 2 effects, that are not Dehydrate or Fog, has all effects attempted to dispel (besides Dehydrate or Fog) using the caster wisdom.'
    elif act == 'Summon Water Elementals':
        return 'Summon 3 Water Elementals, close to the caster. Water Elementals can only travel in one of the four cardinal directions, depending on their direction on summon. They must move forward and are destroyed on colliding with an obstacle.'
    elif act == 'Flare':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance fire ranged damage.'
    elif act == 'Rock Punch':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance crushing melee damage.'
    elif act == 'Zephyr Lance':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche slashing spell damage. Costs 2 magick.'
    elif act == 'Lift':
        return 'Spell target gets effect that changes move type to flying. Duration is reason. Level is wisdom.'
    elif act == 'Mass Hysteria':
        return 'The next five units remaining to act in initiative queue, on to-hit wisdom vs wisdom, get -5 sanity effect. Duration is reason. Level is wisdom.'
    elif act == 'Riposte':
        return 'An adjacent action target, on to-hit agility vs agility, gets an attack effect that causes its melee damage dealt to be reduced to 1 on failing an agility vs agility to-hit check vs defender. Duration is reason. Level is wisdom.'
    elif act == 'Cloister':
        return 'A spell target in range reason has all of its effects levels raised by 6.'
    elif act == 'Genjutsushi':
        return 'Spell target in range reason gets an attack effect. When dealing melee or ranged damage, this unit gets an effect granting invisibility lasting 1 turn at level of its own agility. The effect is added immediately on resolution of the attack effect (before any later attack/defense effects or damage being dealt). The spell itself has duration reason and level wisdom.'
    elif act == 'Molten Claws':
        return 'Adds attack effect to self. Changes damage type to fire and adds 2 damage if type is melee. Duration is reason. Level is wisdom.'
    elif act == 'Bane Claws':
        return 'Adds attack effect to self. Changes damage type to poison, adds end-of-turn 2 poison damage effect to hit melee targets. Duration is reason. Level is wisdom.'
    elif act == 'Aura of Agony':
        return 'Spell target within range reason gets an effect that gives all enemy units (of caster) within range 2, -3 sanity. Duration is reason. Level is wisdom.'
    elif act == 'Dampening Emanation':
        return 'Spell target within range reason gets an effect that gives all units within range 2, -3 move range. Duration is reason. Level is wisdom.'
    elif act == 'Blind':
        return 'Spell target in range reason gets -3 ballistics and reason. Duration is reason. Level is wisdom.'
    elif act == 'Assail':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Wooden Skin':
        return 'Evolution that changes melee damage to crushing type and leaves splinter effect on targets, causing 2 piercing end-of-turn damage with duration reason and level wisdom, if they do not already have this effect (melee damage only). +3 strength. Add resist and remove weakness to piercing.'
    elif act == 'Calcify':
        return 'Evolution that gives +3 wisdom and psyche. Melee damage changed to piercing. Adds resistance and removes weakness to magick. Cannot be used with wooden skin.'
    elif act == 'Unstable Fervor':
        return 'Evolution that gives +1 acts, +3 endurance, removes weakness and adds resist to electric. Cannot be used with chimeric mutation. Must have wooden skin or calcify.'
    elif act == 'Chimeric Mutation':
        return 'Evolution that changes move type to flying, gives +2 move range, removes weakness and adds resist to fire. +3 mm. Adds Scorch action that targets as action any within range ballistics, and all within range 1 of that target, on mm vs dodge to-hit, does msl vs end fire ranged damage. Cannot be used with unstable fervor. Must have either wooden skin or calcify.'
    elif act == 'Moldering Effluvium':
        return 'Evolution that granting end of turn effect that gives -4 endurance to all adjacent enemies at duration reason and level wisdom. Adds resistance and removes weakness to acid. Changes melee, ranged, and spell damage to acid. +3 dodge. Cannot be used with squamous carapace. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation.'
    elif act == 'Squamous Carapace':
        return 'Evolution that gives +3 dodge and agility. End of turn heal 4 to caster. Adds resist and removes weakness to crushing. Cannot be used with moldering effluvium. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation.'
    elif act == 'Winnowing Verdure':
        return 'Evolution that adds proximity effect giving all enemy within range 2 of caster -4 agility and initiative. Adds resist and removes weakness to slashing. Cannot be used with noxious respiration. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation, and moldering effluvium or squamous carapace.'
    elif act == 'Noxious Respiration':
        return 'Evolution that adds attack effect causing damage to add -3 reason and move range effect at duration reason and level wisdom, if defender does not already have this effect. Attack type becomes poison. +3 psyche. Adds resist and removes weakness to poison. Cannot be used with winnowing verdure. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation, and moldering effluvium or squamous carapace.'
    elif act == 'Nimbus of Oppression':
        return 'Proximity effect on caster giving all units in range 3 -4 psyche. Costs 2 magick. Duration is reason. Level is wisdom.'
    elif act == 'Halo of Encumberance':
        return 'Proximity effect on caster giving all units in range 3 -4 strength. Costs 2 magick. Duration is reason. Level is wisdom.'
    elif act == 'Feedback':
        return 'Deal electric melee damage to an adjacent action target unit equal to the number of effects it has.'
    elif act == 'Trenchant Lunula':
        return 'An adjacent action target unit, on to-hit agility vs agility, takes strength vs endurance slashing melee damage and gets an effect giving -2 reason at duration reason and level wisdom.'
    elif act == 'Scorch':
        return 'Action target, and each adjacent, on to-hit wisdom vs wisdom, take psyche vs psyche fire ranged damage.'
    elif act == 'Psychic Suffocation':
        return 'Proximity effect giving all enemy within range 1 of caster -1 acts (remember that acts are determined for each unit at the begin of its round).'
    elif act == 'Mirror Armor':
        return 'Spell target in range reason gets effect: on taking spell type damage, if attacker misses wisdom vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. Duration reason. Level wisdom.'
    elif act == 'Forcefield':
        return 'Spell target in range reason gets effect: on taking ranged type damage, if attacker misses marksmanship vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. Duration reason. Level wisdom.'
    elif act == 'Pierce the Heart':
        return 'An adjacent action target unit, on to-hit agility vs agility, takes strength vs endurance piercing melee damage and gets an effect giving -2 strength at duration reason and level wisdom.'
    elif act == 'Nix':
        return 'Any of the caster hex effects currently active are attempted to be dispelled using wisdom+10, to allow changing hexes.'
    elif act == 'Torpor Field':
        return 'All enemy in range 3 get -4 move range.'
    elif act == 'Enmeshing Coils':
        return 'Spell target in range reason, and each adjacent enemy without this effect, get -3 agility.'
    elif act == 'Cleanse with Fire':
        return 'All nonsentient type, enemy units within range 3 of caster, on to-hit wisdom vs wisdom, take psyche vs psyche fire spell damage. Costs 2 magick.'
    elif act == 'Persecute':
        return 'All enemy units within range 3 of caster, on to-hit wisdom vs wisdom, lose magick equal to caster psyche. Costs 3 magick.'
    elif act == 'Prophecy':
        return 'Spell target within range reason gets +3 reason effect at duraton reason and level wisdom. Costs 4 magick.'
    elif act == 'Chain Lightning':
        return 'Action target within range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance electric ranged damage. If target is hit, chain lightning attempts to hit a random unit that has not yet been hit within range 3 and is not the caster. Chain lightning continues to pass as long as it successfully hits and there is a target in range. Costs 3 magick.'
    elif act == 'Overload':
        return 'If caster strength and psyche are both at least 2 greater than their base values, caster gets effect granting +1 acts (acts are granted at begin of round) at duration reason and level wisdom. Costs 4 magick.'
    elif act == 'Hidden Haymaker':
        return 'If caster is invisible, auto-hit an adjacent action target for strength vs endurance crushing melee damage.'
    elif act == 'Spit Venom':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs dodge poison ranged damage and gets an effect causing 2 end-of-turn poison damage.'
    elif act == 'Hindering Mucilage':
        return 'A location within range ballistics gets a map effect causing units with normal move type to get -3 agility, dodge, and move range when occupying the location.'
    elif act == 'Wing Buffet':
        return 'An action target in range ballistics, on to-hit marksmanship vs dodge, is relocated to a random location among those furthest from the caster and within range caster strength from target and takes missle vs endurance explosive ranged damage.'
    elif act == 'Chameleon Camouflage':
        return 'Caster gains invisibility effect. Cannot be used if caster already has this effect or Shimmering Scales.'
    elif act == 'Shimmering Scales':
        return 'Caster gains psyshield effect. Cannot be used if caster already has this effect or Chameleon Camouflage.'
    elif act == 'Elemental Langour':
        return 'Spell target in range reason, on wisdom vs wisdom to-hit, gets an effect that removes resistance and adds weakness to fire, cold, and electric damage. Cannot be used on target with this effect or Asthenia. Costs 3 magick.'
    elif act == 'Asthenia':
        return 'Spell target in range reason, on wisdom vs wisdom to-hit, gets an effect that removes resistance and adds weakness to slashing, piercing, and crushing damage. Cannot be used on target with this effect or Elemental Langour. Costs 3 magick.'
    elif act == 'Detox':
        return 'Spell target in range reason has each of its effects with an end-of-turn effect attempted to dispel using the caster wisdom. Costs 2 magick.'
    elif act == 'Geomantic Clutch':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche crushing spell damage and an effect that reduces its move range by 3, if it does not have this reduction already. If the unit is flying move type, then add 3 to the damage and it gets an effect that changes its move type to normal. Costs 4 magick.'
    elif act == 'Biotranspose':
        return 'A spell target in range reason without this effect, on to-hit wisdom vs wisdom, gets an effect that switches its strength and psyche.'
    elif act == 'Agony':
        return 'Spell target in range reason, on to-hit marksmanship vs dodge, takes psyche vs psyche magick spell damage. Costs 1 magick.'
    elif act == 'Glammering':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, gets -2 reason and move range at level wisdom and duration reason. Costs 2 magick.'
    elif act == 'Cloak of Minerva':
        return 'Effect on caster causing all friendly units in range 3 of caster to get +4 wisdom. Costs 2 magick. Duration is reason and level is wisdom.'
    elif act == 'Enervating Blow':
        return 'Action target range 1, on to-hit agility vs agility, takes strength vs endurance crushing melee damage and is moved to the back of the initiative queue.'
    elif act == 'Slow Motion':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, is moved to the back of the initiative queue if still in and gets -5 initiative at duration reason and level wisdom. Costs 2 magick.'
    elif act == 'Time Warp':
        return 'Each non-Witch, adjacent, friendly unit, on successful caster wisdom check, is either moved or placed at the front of the initiative queue depending on whether it currently is in the queue. Costs 4 magick.'
    elif act == 'Rebuking Shield':
        return 'Effect on caster causing all friendly units in range 3 of caster to gain resistance to slashing, piercing, and crushing. Costs 3 magick. Duration is reason and level is wisdom.'
    elif act == 'Stasis':
        return 'The next 5 non-witch units in the initiative queue, on to-hit wisdom vs wisdom, get -1 actions if they do not already have this effect, at duration reason and level wisdom. Costs 4 magick.'
    elif act == 'Astrological Guidance':
        return 'Move a spell target within its legal moves and decrease its moves for this turn by 1.'
    elif act == 'Recall':
        return 'Up to two friendly units are relocated among the closest locations to the caster. Costs 2 magick.'
    elif act == '':
        return ''
    elif act == '':
        return ''
    else:
        return 'Some description'

def loc_effect_description(ef):
    if ef.name == 'Spore_Cloud':
        return '+4 dodge, reduces piercing, slashing, fire damage by 2 (min 1) if it is melee or ranged or spell.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Warpfire':
        return 'Start-of-turn relocate all within range 3 among random locations closest to warpfire.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Darkness':
        return '-2 move range from this location for normal and flying move type.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Smoke_Bomb':
        return 'Grants invisibility.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fuse_Trap':
        return 'On undo, do 3 explosive undo damage to each unit within range 3.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hindering_Mucilage':
        return '-3 agility, dodge, and move range for units with normal move type.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Globe_of_Invulnerability':
        return '-5 move range, reduce melee, ranged, and spell damage (attack and defense) to max 2.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Cloudkill':
        return 'During end of turn phase, occupying unit gets effect causing end of turn 2 poison damage. Duration is reason and level is wisdom of caster.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return ''+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    else:
        return 'Some description'

# takes an Effect instance, returns a string descr, used in populate_context=>get_info/get_more_info
def effect_description(ef):
    if ef.name == 'Curse_of_Oriax':
        return '-1 psy,wis,rsn,san,init, 2 magick dmg eot, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Cloudpoison':
        return 'End of turn 2 poison damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Spectral_Pillory':
        return '-2 move range, end-of-turn 2 magick damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Iron_Skin':
        return 'When receving melee, ranged, or spell damage that is not crushing, reduce the damage to 1 and subtract 1 from duration. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Forestwalk':
        return 'Invisibility, psyshield and ethereal move type, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chthonic_Anguish':
        return '-4 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Dagon's_Chosen":
        return 'Sanity reduced to 1, +1 acts, mvs, +2 move range, str, agl, end, dodge, init. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Trials_of_Hatheg_Kla':
        return '-5 sanity, +1 acts. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Proboscis':
        return '-1 psyche, wisdom, reason, sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chthonic_Spiral':
        return '-2 psyche, wisdom, reason, sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Censer_Grenade':
        return '-3 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pixie_Dust':
        return 'psyshield, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Stasis':
        return '-1 acts, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Splinters':
        return 'End of turn 2 piercing damage, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Screech':
        return '-3 sanity, -1 move range, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pox':
        return 'Eot 3 poison dmg, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wail':
        return 'Lose psyshield and invisibility, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fangs_of_Apophis':
        return '+1 str, agl, poison melee damage, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wreathed_in_Flame':
        return 'Fire resistance and 6 fire damage to melee attackers on hit, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pestilence':
        return '3 poison dmg eot, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plague':
        return '-4 random effect, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gravity':
        return '-2 agility, dodge, and move range, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hidden_From_the_Stars':
        return '+1 agility, dodge, wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Cloak':
        return 'Adds defense effect. If receiving slashing, piercing, or crushing damage, add invisibility to self for the remainder of turn. If receiving magick damage, add psyshield to self for remainder of turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Invisibility':
        return 'Adds Invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Psyshield':
        return 'Adds Psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Cosmic_Sight':
        return 'Removes Psyshield. Targets as action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Demonic_Sight':
        return 'Removes Invisibility. Targets as spell. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Beleth_Stun':
        return '-1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Beleth's_Command":
        return '+1 psyche, endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Paralyze':
        return '-3 move range (min 1) and -1 actions. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Scarab_Gestation':
        return 'Gives death trigger that summons Scarab. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dark_Shroud':
        return '+1 Dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dark_Shroud_Invis':
        return 'Invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Muddle':
        return 'End-of-turn, unit attacks self, agl vs agl, str vs end (own abilities) crushing damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Stalk':
        return 'Increases received slashing, piercing, and crushing damage by 2, if the type is melee of ranged. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Tendrils_Drain':
        return '-2 random ability. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Rage':
        return '+3 strength, endurance, +4 psyche. 3 magick damage on end. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Doubling_Cube':
        return 'When receiving slashing, piercing, or crushing damage (melee or ranged), attacker must hit (psyche vs psyche) or the damage is reduced to 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Tracer_Grenade':
        return '-4 dodge, lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Simulacrum':
        return '+3 agility and dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Molecular_Subversion':
        return 'Removes resistances to acid and explosive. Add weaknesses acid and explosive. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Minerva's_Gift":
        return '+1 agility and initiative. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bewitch':
        return 'Adds psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Read_the_Stars':
        return '+2 when dealing cold or electric damage, if the type is melee, ranged, or spell. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Psi_Blades':
        return 'Adds Psi Slash action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Energize':
        return '+1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Ghoul_Venom':
        return '-1 str, end. End-of-turn 2 poison damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Boiling_Blood':
        return '+4 str, -4 end. End-of-turn 2 fire damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dark_Sun':
        return '+1 actions. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Meditate':
        return '+1 psyche, +2 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mummify':
        return '+4 endurance. Move range reduced to 1. Berserker leap set to used (use may be regained through later spells/effects). dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Osiris_Blessing':
        return '+1 strength and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Osiris_Curse':
        return '-1 strength and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Disintegrate':
        return '-1 to random ability among str, agl, end, rsn, san and also additional -1 randomly among same at end-of-turn. 1 acid damage end-of-turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Warp_Insane':
        return '-4 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hex':
        return '-1 str,agl,end,mm,dod,psy,wis,rsn,san,init. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Poison_Sting':
        return '-1 strength. 1 poison damage end-of-turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Unholy_Chant':
        return '+1 all abilities (not actions, moves). dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Baleful_Stare':
        return '-1 psyche, end-of-turn 2 acid damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Brambles':
        return '-1 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mind_Rot':
        return '-3 wisdom, reason, sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Grasp_of_the_Old_Ones':
        return 'Lose psyshield and invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dispel':
        return 'Lose psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Burn':
        return 'Slashing, crushing, piercing, fire, and explosive damage increased by 2. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Flesh_Hooks':
        return 'Grants Hook Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Strength_Through_Wounding':
        return '+1 psyche and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Analyze':
        return 'Removes resistances to slashing, piercing, crushing, and explosive damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pierce_Shield':
        return 'Remove psyshield. -1 psyche and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Haste':
        return '+4 initiative. +1 agility, dodge, and moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Encumber':
        return '-4 initiative. -2 agility, marksmanship, dodge, and move range. -1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gaze':
        return '-3 move range, min 1 (will not raise above 0). dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Howl_From_Beyond':
        return '-2 sanity, -3 reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Track':
        return 'Lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Miasma_Drain':
        return '-1 sanity and reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Miasma_Invis':
        return 'Lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Leprous Bite':
        return '-1 str, end, agl, mm, psy, wis, rsn, san, init. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Concerted_Volley':
        return '+X marksmanship. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Abeyance':
        return 'Action removed. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vengeance':
        return 'adds +1 to str,agl,end,psy,wis,rsn on non-sot/eot dmg. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vengeance_Boost':
        return '+1 str,agl,end,psy,wis,rsn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Reveal_Psyshield':
        return 'Remove psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Reveal_Invisibility':
        return 'Remove invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Abeyance':
        return 'Remove chosen action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Roar_Friendly':
        return '+2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Roar_Enemy':
        return '-3 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Anoint':
        return '+1 wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Devil's_Mark":
        return '+2 to chosen ability. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hook_Attack':
        return 'Wisdom vs dodge to-hit, psyche vs endurance piercing, ranged damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Contagion':
        return '-3 strength, agility, endurance, dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mesmerize':
        return 'At start-of-turn, on psyche save check fail (mod 0), unit takes crushing melee damage equal to its own strength vs endurance AND loses one action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Entrance':
        return '-4 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Enthrall':
        return '-3 marksmanship and missle. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chill_Touch':
        return '-1 wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vampiric_Bite':
        return '+3 psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bat_Form':
        return '+3 move range, +4 to dodge, flying move type, -3 strength, agility, endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wolf_Form':
        return '+4 agility, +3 move range, -3 psyche and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hatred':
        return 'Whenever dealing melee damage, this unit gets +2 strength at duration reason and level wisdom of caster of this effect. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hatred_Strength':
        return '+2 strength. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bone_Pincer_Attack':
        return 'Grants Bone Pincer Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Willful_Move':
        return 'Grants Move. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Corrosive_Attack':
        return 'Grants Corrosive Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Alacrity':
        return '+5 agility, +4 move range and strength. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Farsight':
        return '+6 marksmanship, +2 ballistics, +4 missle. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fear':
        return '-1 move range and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Slow':
        return '-2 move range. Melee and ranged damage dealt is reduced by half (rounded down) minimum 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Iron_Spirit':
        return '+1 strength, endurance, and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Strength_of_the_Void':
        return '+1 strength, endurance, and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gift_of_Mars':
        return '+1 missle, marksmanship, and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Mercury's_Blessing":
        return '+1 agility, dodge, and move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Duress':
        return '-4 reason and -7 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Tourach's_Hymn":
        return '-4 strength and agility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Staff_of_Vecna':
        return 'Removes psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Torment':
        return '-2 psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Shout':
        return '-2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Riposte':
        return 'Melee damage dealt reduced to 1 on failing to-hit agility vs agility check against defender. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Lift':
        return 'Changes move type to flying. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fog':
        return '-3 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dehydrate':
        return 'Adds fire weakness. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mass_Hysteria':
        return '-5 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Genjutsushi':
        return 'When dealing melee or ranged damage, this unit gets invisibility effect. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Genju_Invisibility':
        return 'Invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Molten_Claws':
        return 'Change melee damage to fire type, add 2 damage to melee. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bane_Claws':
        return 'Change melee damage to poison, add end-of-turn 2 poison damage bane poison to hit melee targets. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bane_Poison':
        return 'End of turn 2 poison damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Blind':
        return '-3 ballistics and reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Nimbus_of_Oppression':
        return '-4 psyche, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Halo_of_Encumberance':
        return '-4 strength, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Torpor_Field':
        return '-3 move range, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Psychic_Suffocation':
        return '-1 acts, range 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Cloak_of_Minerva':
        return '+4 wisdom, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Rebuking_Shield':
        return 'Resistance to slashing, piercing, crushing, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Trenchant_Lunula':
        return '-2 reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dampening_Emanation':
        return '-3 move range, range 3. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wooden_Skin':
        return 'Crushing attack type that leaves splinter effect causing 2 piercing end-of-turn damage at duration reason and level wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Calcify':
        return '+3 wisdom and psyche. Melee damage is piercing. Adds resist and removes weakness to magick. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Unstable_Fervor':
        return '+1 acts, +3 endurance. Remove weakness and adds resist to electric. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chimeric_Mutation':
        return 'Changes move type to flying, gives +2 move range and +3 mm. Removes weakness and adds resist to fire. Adds scorch action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Moldering_Effluvium':
        return 'End-of-turn -4 endurance to adjacent enemies. Add resist and removes weakness to acid. Changes melee, ranged, and spell damage to acid. +3 dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Squamous_Carapace':
        return '+3 dodge and agility. End-of-turn heal 4 spirit. Adds resist and removes weakness to crushing. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Winnowing_Verdure':
        return 'All enemy range 3 get -4 agility and initiative. Removes weakness and adds resist to slashing. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Noxious_Respiration':
        return 'Damage causes -3 reason and move range. +3 psyche. Attack type becomes poison. Removes weakness and adds resist to poison. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Aura_of_Agony':
        return 'All enemy in range 2 get -3 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mirror_Armor':
        return 'On taking spell type damage, if attacker misses wisdom vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Forcefield':
        return 'On taking ranged type damage, if attacker misses marksmanship vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Elemental_Langour':
        return 'Removes resistance and adds weakness to fire, cold, electric. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Asthenia':
        return 'Removes resistance and adds weakness to slashing, piercing, crushing. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Biotranspose':
        return 'Strength and psyche are switched. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Slow_Motion':
        return '-5 initiative. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Astrological_Guidance':
        return '-1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    else:
        return 'Some description'

def death_trigger_description(name):
    if name == 'Familiar_Death':
        return 'Owner takes 4 magick damage.'
    elif name == 'Contagion':
        return 'Each adjacent unit without this effect gets -3 strength, agility, endurance, and dodge. Duration is reason. Level is wisdom.'
    elif name == 'Pestilence':
        return 'Each adjacent unit without this effect gets end-of-turn 3 poison damage effect and this death trigger.'
    elif name == 'Scarab_Gestation':
        return 'Create a Scarab under same control as effect owner.'
    else:
        return 'Some Description'

def miss(loc):
    app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Miss!', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
    app.canvas.create_text(loc[0]*100-app.moved_right+51, loc[1]*100-app.moved_down+76, text = 'Miss!', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
    app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Miss!', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')

# takes start and end coord ([x,y]), returns True if no interceding 'block' sqrs, else False
def los(start, end):
    blocked = [c for c in app.coords if app.grid[c[0]][c[1]] == 'block']
    x = start[0]*100+50-app.moved_right
    y = start[1]*100+50-app.moved_down
    endx = end[0]*100+50-app.moved_right
    endy = end[1]*100+50-app.moved_down
    if x == endx:
        xstep = 0
        ystep = 10
    elif y == endy:
        xstep = 10
        ystep = 0
    else:
        slope = Fraction(abs(x - endx), abs(y - endy))
        xstep = slope.numerator
        ystep = slope.denominator
        while xstep + ystep < 10:
            xstep *= 2
            ystep *= 2
    def los_loop(sx, sy, ex, ey, xstep, ystep):
        if abs(sx - ex) < 15 and abs(sy - ey) < 15:# close enough to goal sqr
            return True
        if sx > ex:
            sx -= xstep
        elif sx < ex:
            sx += xstep
        if sy > ey:
            sy -= ystep
        elif sy < ey:
            sy += ystep
        cx = round_100(sx)
        cy = round_100(sy)
        if [cx,cy] in blocked:
            return False
        else:
            return los_loop(sx, sy, ex, ey, xstep, ystep)
    return los_loop(x, y, endx, endy, xstep, ystep)

# convenience funcs
def dist(loc1, loc2):
    return abs(loc1[0] - loc2[0]) + abs(loc1[1] - loc2[1])

# start is coord like [2,3], goal is list of coords like [[2,4],[4,5]...], grid is list of lists where each list is a 'row'
# 'row' holds strings ('', 'EntityID', or 'block')
# returns path from start to goal (list of coords)
def bfs(start, goal, grid):
    path = []
    q = [[start]]
    visited = [start]
    while q:
        path = q[0]
        q = q[1:]
        last = path[-1]
        if last in goal:
            return path
        else:
            adj = [c for c in app.coords if dist(c, last) == 1 and grid[c[0]][c[1]] == '']
            shuffle(adj)
            for s in adj:
                if s not in visited:
                    q.append(path + [s])
                    visited.append(s)
    return None
    
    
# get all cs in each lateral direction, filter by range, blocked means stopped by obstruction, blocked False get all sqrs
# dir = all or north south east west
# blocked is ents or blocks or False (blocked by nothing)
def lateral_sqrs(loc, range, blocked = False, dir = 'all'):
    mvs = []
    cs = app.coords
    if dir == 'all' or dir == 'north':
        def north(dst):
            if blocked=='ents' and [loc[0],loc[1]-dst] in cs and app.grid[loc[0]][loc[1]-dst] == '':
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
            elif blocked=='blocks' and [loc[0],loc[1]-dst] in cs and app.grid[loc[0]][loc[1]-dst] != 'block':
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
            elif blocked==False and [loc[0],loc[1]-dst] in cs:
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
        north(1)
    if dir == 'all' or dir == 'south':
        def south(dst):
            if blocked=='ents' and [loc[0],loc[1]+dst] in cs and app.grid[loc[0]][loc[1]+dst] == '':
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
            elif blocked=='blocks' and [loc[0],loc[1]+dst] in cs and app.grid[loc[0]][loc[1]+dst] != 'block':
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
            elif blocked==False and [loc[0],loc[1]+dst] in cs:
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
        south(1)
    if dir == 'all' or dir == 'west':
        def west(dst):
            if blocked=='ents' and [loc[0]-dst,loc[1]] in cs and app.grid[loc[0]-dst][loc[1]] == '':
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
            elif blocked=='blocks' and [loc[0]-dst,loc[1]] in cs and app.grid[loc[0]-dst][loc[1]] != 'block':
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
            elif blocked==False and [loc[0]-dst,loc[1]] in cs:
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
        west(1)
    if dir == 'all' or dir == 'east':
        def east(dst):
            if blocked=='ents' and [loc[0]+dst,loc[1]] in cs and app.grid[loc[0]+dst][loc[1]] == '':
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
            elif blocked=='blocks' and [loc[0]+dst,loc[1]] in cs and app.grid[loc[0]+dst][loc[1]] != 'block':
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
            elif blocked==False and [loc[0]+dst,loc[1]] in cs:
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
        east(1)
    mvs = list(filter(lambda x : dist(x, loc) <= range, mvs))
    return mvs

def to_hit(a1, a2):
    base = 50
    dif = a1 - a2
    base += (dif*5)
    rand = randrange(1, 100)
    if rand < base:
        return True
    else:
        return False
        
# add random element?
def damage(a1, a2):
    base = 6
    dif = a1 - a2
    if base + dif < 1: return 1 
    else: return base + dif
    
# takes 2 ent objects, a negative int amount, a string type 'melee', 'ranged', 'poison', or 'magick', and a lockname string to set
# following effects MAY change amount applied (amount is always the only value returned, whether changed or not), OR do different non-damage things
def apply_damage(attacker, defender, amount, type, sourcename, sourcetype, lockname):
    efcts = attacker.attack_effects[:] + app.loc_dict[tuple(attacker.loc)].atk_effects
    efcts = efcts[::-1]
    atk_loop(efcts, attacker, defender, amount, type, sourcename, sourcetype, lockname)
    
def atk_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname):
    if effects_list == []:
        efcts = defender.defense_effects[:] + app.loc_dict[tuple(defender.loc)].def_effects[:]
        efcts = efcts[::-1]
        defense_loop(efcts, attacker, defender, amount, type, sourcename, sourcetype, lockname)
    else:
        ef = effects_list[0]
        effects_list = effects_list[1:]
        amount, type = lock(ef, attacker, defender, amount, type, sourcename, sourcetype)
        if attacker.id not in app.all_ents():
            root.after(333, lambda de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : finish_apply_damage(de, am, ty, sn, st, ln))
        elif attacker.id not in app.all_ents() and defender.id not in app.all_ents():
            root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            atk_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)
#         atk_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)

        
def defense_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname):
    if effects_list == []:
        # delay to wait for lockvar to be created
        root.after(333, lambda de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : finish_apply_damage(de, am, ty, sn, st, ln))
    else:
        ef = effects_list[0]
        effects_list = effects_list[1:]
        amount, type = lock(ef, attacker, defender, amount, type, sourcename, sourcetype)
        if attacker.id not in app.all_ents():
            root.after(333, lambda de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : finish_apply_damage(de, am, ty, sn, st, ln))
        elif attacker.id not in app.all_ents() and defender.id not in app.all_ents():
            root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            defense_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)
#         defense_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)


# func that is called with 'lock' must accept lockname which it changes after executing to signal completion
def lock(func, *args, **kwargs):
    name = 'dethlok'+str(app.death_count)
    app.death_count += 1
    app.dethloks[name] = tk.IntVar(0)
    return_args = func(*args, **kwargs, lockname = name)
    app.wait_variable(app.dethloks[name])
    return return_args

#
def finish_apply_damage(defender, amount, type, sourcename, sourcetype, lockname = None):
    app.get_focus(defender.id)
    amount = abs(amount) # get amount as pos value to apply resist/wknss
    resist = defender.get_resist()
    if type in resist:
        amount = max(1,amount//2)
    weak = defender.get_weak()
    if type in weak:
        amount = int(amount*1.5)
    pre = defender.spirit
    defender.spirit -= amount
    if defender.spirit > defender.base_spirit:
        defender.spirit = defender.base_spirit
    post = defender.spirit
    d = pre - post
    app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+64-app.moved_down, text = sourcename+' '+str(d)+' spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
    app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+65-app.moved_down, text = sourcename+' '+str(d)+' spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
    if defender.spirit <= 0:
        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+90-app.moved_down, text = defender.name.replace('_',' ') + ' Killed...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+91-app.moved_down, text = defender.name.replace('_',' ') + ' Killed...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        name = 'Dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda id = defender.id, name = name : app.kill(id, name))
        app.wait_variable(app.dethloks[name])
        app.dethloks[lockname].set(1)
    else:
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
        
# takes 2 ent objects, positive int amount
def apply_heal(healer, target, amount):
    target.spirit += amount
    if target.spirit > target.base_spirit:
        target.spirit = target.base_spirit
        
# takes two lists of lists (lists of coords, [[x,y],[x2,y2],...])
# returns a list of their intrsct or []
def intersect(lx,ly):
    tx = [tuple(s) for s in lx]
    ty = [tuple(s) for s in ly]
    nl = list(set(tx) & set(ty))
    return [list(t) for t in nl]

# GLOBALS
curs_pos = [0, 0]
selected = []
selected_vis = []
map_pos = [0, 0]
grid_pos = [0,0]


# change to only import what is neededmm
# import pygame
from pygame import mixer
freq = 44100     # audio CD quality
bitsize = -16    # unsigned 16 bit
channels = 1     # 1 is mono, 2 is stereo
buffer = 1024    # number of samples (experiment to get right sound)
# use this just for intro screen, ideally make it loop smoothly (no lull in sound)
mixer.init(freq, bitsize, channels, buffer)
background_music = mixer.Channel(0) # argument must be int
sound_effects = mixer.Channel(1)
# background_music.music.set_volume(0.7) # optional volume 0 to 1.0
# background_music.music.load('Ove Melaa - Dead, Buried and Cold.ogg')
# background_music.music.play(-1, 0)

class Dummy():
    def __init__(self):
        pass

Spell = namedtuple('Spell',['name','func','cost','times_imprint','times_cast'])

class Death_Trigger():
    def __init__(self, name = None, level = None, undo_func = None, dt = None):
        self.name = name
        self.level = level
        self.undo_func = undo_func # called if dispelled
        self.dt = dt # death trigger func, called in kill()
        self.ts = app.count # timestamp, if order needed
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            return 'Dispelled'
        else:
            return 'Not Dispelled'


class Proximity_Effect():
    def __init__(self, name = None, ent = None, range = None, abls = None, abl_func = None, eot_func = None, sot_func = None, weak_func = None, resist_func = None, atk_func = None, def_func = None):
        self.name = name
        self.ent = ent
        self.range = range
        if abls != None:
            self.abls = abls
        else:
            self.abls = []
        self.abl_func = abl_func
        self.eot_func = eot_func
        self.sot_func = sot_func
        self.weak_func = weak_func
        self.resist_func = resist_func
        self.atk_func = atk_func
        self.def_func = def_func
        self.ts = app.count
        app.count += 1
        
        self.img = ImageTk.PhotoImage(Image.open('animations/' + name + '/0.png'))
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/' + name + '/' + anim))
            self.anim_dict[i] = a
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]
        
    def get_locs(self):
        return [c for c in app.coords if self.range[0] <= dist(c,self.ent.loc) <= self.range[1]]
        
    
    
class Effect():
    def __init__(self, name = None, duration = None, level = None, undo_func = None, eot_func = None, sot_func = None, vis = None):
        self.name = name
        self.sot_func = sot_func
        self.eot_func = eot_func
        self.undo_func = undo_func
        self.duration = duration
        self.level = level
        self.ts = app.count
        if vis != None:
            self.vis = Vis(name = vis, loc = None)
        else:
            self.vis = None
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            return 'Dispelled'
        else:
            return 'Not Dispelled'

# instances of these exist in the effects_dict of Loc instances (one Loc instance for each x,y coord on map)
# app.loc_dict[(x,y)] = inst
class Local_Effect():
    def __init__(self, name = None, duration = None, level = None, undo_func = None, eot_func = None, sot_func = None, atk_func = None, def_func = None, loc = None, avoid = None):
        self.name = name
        self.sot_func = sot_func
        self.eot_func = eot_func
        self.undo_func = undo_func
        # atk/def funcs, not used like this yet, applied directly to the locs efct stack
        self.atk_func = atk_func
        self.def_func = def_func
        self.duration = duration
        self.level = level
        self.loc = loc
        self.avoid = avoid
        self.ts = app.count
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            
            return 'Dispelled'
        else:
            return 'Not Dispelled'

class Vis():
    def __init__(self, name, loc):
        tags = name+str(app.count)
        app.count += 1
        self.tags = tags
        if name == 'Aura':
            self.name = name
            self.img = app.aura_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.aura_anims.items():
                self.anim_dict[k] = v
        elif name == 'Mortar':
            self.name = name
            self.img = app.mortar_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.mortar_anims.items():
                self.anim_dict[k] = v
        elif name == 'Pestilence':
            self.name = name
            self.img = app.pestilence_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.pestilence_anims.items():
                self.anim_dict[k] = v
        elif name == 'Plague':
            self.name = name
            self.img = app.plague_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.plague_anims.items():
                self.anim_dict[k] = v
        elif name == 'Toxic_Miasma':
            self.name = name
            self.img = app.toxic_miasma_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.toxic_miasma_anims.items():
                self.anim_dict[k] = v
        elif name == 'Cleanse_with_Fire':
            self.name = name
            self.img = app.cleanse_with_fire_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.cleanse_with_fire_anims.items():
                self.anim_dict[k] = v
        else:
            self.name = name
            self.img = ImageTk.PhotoImage(Image.open('animations/' + name + '/0.png'))
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            anims = [a for r,d,a in walk('animations/' + self.name + '/')][0]
            anims = [a for a in anims[:] if a[0] != '.']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/' + name + '/' + anim))
                self.anim_dict[i] = a
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]


class Loc():
    def __init__(self, loc):
        self.loc = loc
        self.move_range_effects = []
        self.atk_effects = []
        self.def_effects = []
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.msl_effects = []
        self.mm_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.type_effects = []
        self.weak_effects = []
        self.resist_effects = []
        self.move_range_effects = []
        self.action_effects = []
#         self.cantrips_effects = []
        self.smns_effects = []
        self.effects_dict = {}

class Sqr():
    def __init__(self, img, loc):
        self.img = img
        self.loc = loc
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in app.sqr_anims.items():
            self.anim_dict[k] = v
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]


class Entity():
    def __init__(self, name, id, img, loc, owner, type = 'normal', info_text = None):
        self.info_text = info_text
        self.inert = False
        self.name = name
        self.id = id
        self.img = img
        self.loc = loc
        self.owner = owner
        self.immovable = False
        self.type = type # just used for 'large' ents
        if self.type == 'large':
            self.tags = ('large', self.id)
        else:
            self.tags = id
        self.base_spirit = self.spirit
        self.base_magick = self.magick
        self.base_mvs = self.mvs
        self.base_acts = self.acts
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.attack_effects = []
        self.defense_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.move_range_effects = []
        self.death_triggers = [] # hold Death_Trigger instances
        self.resist_effects = [] # obj.resist and obj.weak are in subclass instances
        self.weak_effects = [] # resist/weak resolved in apply_damage()
        self.types = [] # holds invis, psyshield...
        self.type_effects = []
        self.effects_dict = {}
        self.anim_dict = {}
        self.init_normal_anims()
        self.anim_counter = randrange(0, len(self.anim_dict.keys()))
        self.action_effects = []
        self.move_type_effects = []
        self.inert_effects = []
        
    # just a testing func
    def get_stat_total(self):
        total = 0
        for abl in ['str','end','agl','dodge','wis','psyche','rsn']:
            total += self.get_abl(abl)
        print(total)
        
    def get_inert(self):
        inert = self.inert
        for ef in self.inert_effects:
            inert = ef(inert)
        return inert
        
        
    def ranged_attack(self, loc, visid, lockname):
        global selected_vis
        app.focus_square(loc)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/'+visid+'.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict[visid] = Vis(name = visid, loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict[visid].img, tags = visid)
        selected_vis.append(visid)
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete(visid)
                app.canvas.create_image(startx, starty, image = app.vis_dict[visid].img, tags = visid)
                app.canvas.tag_raise(visid)
            elif starty < endy:
                starty += ystep
                app.canvas.delete(visid)
                app.canvas.create_image(startx, starty, image = app.vis_dict[visid].img, tags = visid)
                app.canvas.tag_raise(visid)
            if startx > endx:
                startx -= xstep
                app.canvas.delete(visid)
                app.canvas.create_image(startx, starty, image = app.vis_dict[visid].img, tags = visid)
                app.canvas.tag_raise(visid)
            elif startx < endx:
                startx += xstep
                app.canvas.delete(visid)
                app.canvas.create_image(startx, starty, image = app.vis_dict[visid].img, tags = visid)
                app.canvas.tag_raise(visid)
                # debug here, if within certain range...
            app.vis_dict[visid].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                app.canvas.delete(visid)
                del app.vis_dict[visid]
                selected_vis.remove(visid)
                app.dethloks[lockname].set(1)
            else:
                root.after(20, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
        
    def get_move_type(self):
        type = self.move_type
        for ef in self.move_type_effects:
            type = ef(type)
        return type
        
    def legal_moves(self):
        mt = self.get_move_type()
        if mt == 'normal':
            return self.normal_moves()
        elif mt == 'ethereal' or mt == 'flying' or mt == 'teleport':
            return self.flying_moves()
        elif mt == 'charge':
            return self.charge_moves()
        else:
            print('unknown move type legal moves')
            
    def charge_moves(self):
        loc = self.loc
        # get all cs in each lateral direction, filter by move range
        mvs = []
        cs = app.coords
        def north(dst):
            if [loc[0],loc[1]-dst] in cs and app.grid[loc[0]][loc[1]-dst] == '':
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
        north(1)
        def south(dst):
            if [loc[0],loc[1]+dst] in cs and app.grid[loc[0]][loc[1]+dst] == '':
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
        south(1)
        def west(dst):
            if [loc[0]-dst,loc[1]] in cs and app.grid[loc[0]-dst][loc[1]] == '':
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
        west(1)
        def east(dst):
            if [loc[0]+dst,loc[1]] in cs and app.grid[loc[0]+dst][loc[1]] == '':
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
        east(1)
        mvs = list(filter(lambda x : dist(x, self.loc) <= self.get_abl('move_range'), mvs))
        return mvs
        
    def flying_moves(self):
        loc = self.loc[:]
        mvlist = []
        for c in app.coords:
            if dist(loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '':
                mvlist.append(c)
        return mvlist
        
    def normal_moves(self):
        loc = self.loc[:]
        mvlist = []
        sqr_cost_map = {}
        def findall(loc, start, distance):
            if start > distance:
                return
            adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
            for s in adj:
                if tuple(s) in sqr_cost_map:
                    if sqr_cost_map[tuple(s)] < start:
                        continue
                sqr_cost_map[tuple(s)] = start
                if s not in mvlist:
                    mvlist.append(s)
                findall(s, start+1, distance)
        findall(loc, 1, self.get_abl('move_range'))
        return mvlist
        
    def sanity_check(self):
        val = randrange(0,101)
        san = self.get_abl('san')
        san *= 10
        if val > san:
            return 'Fail'
        else:
            return 'Pass'
        
    # types holds 'large', 'invisibility', 'psyshield'...
    def get_types(self):
        ts = self.types[:]
        for ef in self.type_effects + app.loc_dict[tuple(self.loc)].type_effects:
            ts = ef(ts)
        return ts
        
    # called in atk/def loops during apply_damage
    def get_resist(self):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get prox efcts with resist funcs
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.resist_func != None and self.loc in ef.get_locs():
                prox_efcts.append(ef.resist_func)
        rs = self.resist[:]
        for ef in self.resist_effects + prox_efcts + app.loc_dict[tuple(self.loc)].resist_effects:
            rs = ef(rs)
        return rs
        
    # called in atk/def loops during apply_damage
    def get_weak(self):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get prox efcts with weak funcs
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.weak_func != None and self.loc in ef.get_locs():
                prox_efcts.append(ef.weak_func)
        ws = self.weak[:]
        for ef in self.weak_effects + prox_efcts + app.loc_dict[tuple(self.loc)].weak_effects:
            ws = ef(ws)
        return ws
        
    # actions are acts/spells that are granted to objects temporarily
    def get_actions(self):
        actions = dict(self.actions)
        for ef in self.action_effects + app.loc_dict[tuple(self.loc)].action_effects:
            actions = ef(actions)
        return actions
            
    # called in animation loop for all objects (ent, vis)
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]
            
    # should be called only by ents that HAVE attack animations
    def init_attack_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./attack_animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('attack_animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
    # called for protaganists that have cast anims (witch/agnes)
    def init_cast_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./casting_animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('casting_animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
    # sets an objects animations to those in the same file as its name
    def init_normal_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
            
    def get_abl(self, abl):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get all prox efcts of same abl
        prox_efcts = []
        prox_names = []
        # filter prox efcs by name, only resolve 1 of each
        for k,ef in app.proximity_effects_dict.items():
            if abl in ef.abls and self.loc in ef.get_locs():
                if ef.name not in prox_names:
                    prox_names.append(ef.name)
                    prox_efcts.append(ef.abl_func)
        if abl == 'str':
            q = self.str_effects + prox_efcts + app.loc_dict[tuple(self.loc)].str_effects
            base = self.str
        elif abl == 'agl':
            q = self.agl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].agl_effects
            base = self.agl
        elif abl == 'end':
            q = self.end_effects + prox_efcts + app.loc_dict[tuple(self.loc)].end_effects
            base = self.end
        elif abl == 'mm':
            q = self.mm_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mm_effects
            base = self.mm
        elif abl == 'msl':
            q = self.msl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].msl_effects
            base = self.msl
        elif abl == 'bls':
            q = self.bls_effects + prox_efcts + app.loc_dict[tuple(self.loc)].bls_effects
            base = self.bls
        elif abl == 'dodge':
            q = self.dodge_effects + prox_efcts + app.loc_dict[tuple(self.loc)].dodge_effects
            base = self.dodge
        elif abl == 'psyche':
            q = self.psyche_effects + prox_efcts + app.loc_dict[tuple(self.loc)].psyche_effects
            base = self.psyche
        elif abl == 'wis':
            q = self.wis_effects + prox_efcts + app.loc_dict[tuple(self.loc)].wis_effects
            base = self.wis
        elif abl == 'rsn':
            q = self.rsn_effects + prox_efcts + app.loc_dict[tuple(self.loc)].rsn_effects
            base = self.rsn
        elif abl == 'init':
            q = self.init_effects + prox_efcts + app.loc_dict[tuple(self.loc)].init_effects
            base = self.init
        elif abl == 'san':
            q = self.san_effects + prox_efcts + app.loc_dict[tuple(self.loc)].san_effects
            base = self.san
        elif abl == 'acts':
            q = self.acts_effects + prox_efcts + app.loc_dict[tuple(self.loc)].acts_effects
            base = self.base_acts
        elif abl == 'mvs':
            q = self.mvs_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mvs_effects
            base = self.base_mvs
        elif abl == 'smns':
            q = self.smns_effects + prox_efcts + app.loc_dict[tuple(self.loc)].smns_effects
            base = self.base_smns
        elif abl == 'move_range':
            q = self.move_range_effects + prox_efcts + app.loc_dict[tuple(self.loc)].move_range_effects
            base = self.move_range
        for func in q:
            base = func(base)
        return base
        
    # the ent performs a save check against one of its abilities with a modifier
    def save_check(self, abl, mod = 0):
        a = self.get_abl(abl)
        a += mod
        a *= 10
        rand = randrange(0, 102)
        if rand < a:
            return 'Pass'
        else:
            return 'Fail'
            
            
    # for use with Legerdemain cantrip
    def leger_move(self, end):
        oldloc = self.loc[:]
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        un ='Teleport'+str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Legerdemain', loc = oldloc[:])
        vis = app.vis_dict[un]
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = un)
        root.after(999, lambda end = end, un = un : self.leger_move_finish(end, un))
        
    def leger_move_finish(self, endloc, un):
#         app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
#         app.grid[endloc[0]][endloc[1]] = self.id
        app.canvas.delete(un)
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        del app.vis_dict[un]
        app.vis_dict[un] = Vis(name = 'Legerdemain', loc = endloc[:])
        vis = app.vis_dict[un]
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = un)
        root.after(999, lambda endloc = endloc, un = un : self.cleanup_leger_move(endloc, un))
        
    def cleanup_leger_move(self, endloc, un):
        try: 
            del app.vis_dict[un]
            app.canvas.delete(un)
        except: pass
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
            
            
    # for use with Berserker throw
    def throw_move(self, sqr, lockname = None):
        global selected
        selected.append(self.id)
        ln = lockname
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.throw_move_finish(end_sqr, start_sqr, ln)
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
    def throw_move_finish(self, end, start, ln):
        sound_effects.stop()
        global selected
        selected.remove(self.id)
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
#         if app.num_players == 2 or self.owner == 'p1':
#         app.unbind_all()
#         app.rebind_all()
        app.dethloks[ln].set(1)
            
            
# For computer controlled entities
class Bot(Entity):
    def __init__(self, name = None, img = None, loc = None, owner = None, type = 'normal'):
        if type == 'large':
            id = self.id
        else:
            id = 'b'+str(app.count)
            app.count += 1
        super().__init__(name, id, img, loc, owner, type = type)
        
    def do_move(self, loc, lockname = None):
        ln = lockname
        mt = self.get_move_type()
        if mt == 'normal' or mt == 'charge':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda e = self, loc = loc, ln = ln : Bot.ai_normal_move(e, loc, ln))
        elif mt == 'flying' or mt == 'ethereal':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda e = self, loc = loc, ln = ln : Bot.ai_flying_move(e, loc, ln))
        elif mt == 'teleport':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda e = self, loc = loc, ln = ln : Bot.ai_teleport_move(e, loc, ln))
        
    # debug add other move sounds...
    def ai_normal_move(self, endloc, lockname = None):
        global selected
        if isinstance(self, Skeleton):
            effect1 = mixer.Sound('Sound_Effects/undead_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, -1)
        elif isinstance(self, Undead_Knight):
            effect1 = mixer.Sound('Sound_Effects/undead_knight_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, -1)
        else:
            effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, -1)
        selected.append(self.id)
        id = self.id
        start_sqr = self.loc[:]
        path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
                Bot.ai_finish_move(self, endloc, start_sqr, lockname)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
    
    # used by flying and ethereal ents (any ai ents that move unobstructed)
    def ai_flying_move(self, sqr, lockname = None):
        global selected
        selected.append(self.id)
        app.focus_square(sqr)
        if isinstance(self, Revenant):
            effect1 = mixer.Sound('Sound_Effects/revenant_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 60 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                Bot.ai_finish_move(self, end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
        
    # uses generic teleport animation (yellow circles)
    def ai_teleport_move(self, endloc, lockname = None):
        global selected
        oldloc = self.loc[:]
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        n = 'tport'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Teleport', loc = oldloc[:])
        vis = app.vis_dict[n]
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = n)
        root.after(1666, lambda  ent = self, el = endloc, visname = n, ln = lockname : Bot.ai_continue_teleport(ent, el, visname, ln))
        
    def ai_continue_teleport(self, endloc, visname, lockname):
        app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
        app.grid[endloc[0]][endloc[1]] = self.id
        try: 
            del app.vis_dict[visname]
            app.canvas.delete(visname)
        except: pass
        n = 'tport'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Teleport', loc = endloc[:])
        vis = app.vis_dict[n]
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = n)
        root.after(1666, lambda ent = self, el = endloc, visname = n, ln = lockname : Bot.ai_cleanup_teleport(ent, el, visname, ln))
        
    def ai_cleanup_teleport(self, endloc, visname, lockname):
        del app.vis_dict[visname]
        app.canvas.delete(visname)
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
        if lockname != None:
            root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
        
    # to be used by ai_normal_move, ai_flying_move
    def ai_finish_move(self, end_sqr, start_sqr, lockname):
        global selected
        sound_effects.stop()
        selected.remove(self.id)
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        if lockname != None:
            root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
        
        
# for user controlled/summoned ents
# wrappers around Entity.do_move(self, endloc, lockname) to handle hotkeys/buttons
class Summon(Entity):
    def __init__(self, name, id, img, loc, owner, type = 'normal'):
        super().__init__(name, id, img, loc, owner, type = type)
        
    # called from the user-interface, dispatches to below functions depending on move_type etc...
    def move(self, event = None):
        if self.mvs < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_move)
        sqrs = self.legal_moves()
        app.animate_squares(sqrs)
        b = tk.Button(app.context_menu, text = 'Confirm Move Square', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.call_do_move(e, sqr, sqrs))
        b.pack(side = 'top', pady = 3)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 20), fg = 'tan3', highlightbackground = 'tan3', command = self.cleanup_move)
        b2.pack(side = 'top', pady = 3)
        app.context_buttons.append(b2)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.call_do_move(e, sqr, sqrs))
        
    def call_do_move(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.mvs -= 1
        lock(self.do_move, sqr[:])
        
    def cleanup_move(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def do_move(self, loc, lockname = None):
        ln = lockname
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        mt = self.get_move_type()
        if mt == 'normal' or mt == 'charge':
            self.normal_move(loc, ln)
        elif mt == 'flying' or mt == 'ethereal':
            self.unobstructed_move(loc, ln)
        elif mt == 'teleport':
            self.teleport_move(loc, ln)
            
    def normal_move(self, loc, lockname = None):
        ln = lockname
        global selected
        effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        # start ANIM here
        id = self.id
        start_sqr = self.loc[:]
        end_sqr = loc[:]
        selected.append(id)
        # get path and move_loop over each sqr until path consumed
        path = bfs(start_sqr, [end_sqr], app.grid) # end_sqr must be in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            if x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            if y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.normal_move_finish(end_sqr, start_sqr, ln)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path)
            
    def normal_move_finish(self, end, start, ln):
        sound_effects.stop()
        global selected
        selected.remove(self.id)
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.rebind_all()
        app.dethloks[ln].set(1)
            
    # for flying, ethereal, ents unobstructed by 'block' or other ents
    def unobstructed_move(self, sqr, lockname = None):
        global selected
        selected.append(self.id)
        ln = lockname
        if isinstance(self, Familiar_Imp):
            effect1 = mixer.Sound('Sound_Effects/familiar_imp_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, -1)
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.normal_move_finish(end_sqr, start_sqr, ln)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
    def teleport_move(self, end, ln):
#         global selected
        oldloc = self.loc[:]
        if isinstance(self, Umbrae_Wolf):
            effect1 = mixer.Sound('Sound_Effects/shadow_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
            app.vis_dict['Mist_Move'] = Vis(name = 'Mist_Move', loc = oldloc[:])
            vis = app.vis_dict['Mist_Move']
        else:
            effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
            app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = oldloc[:])
            vis = app.vis_dict['Teleport']
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda end = end, ln = ln : self.teleport_move_finish(end, ln))
        
    def teleport_move_finish(self, endloc, ln):
        app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
        app.grid[endloc[0]][endloc[1]] = self.id
        app.canvas.delete('Teleport')
        if isinstance(self, Umbrae_Wolf):
            del app.vis_dict['Mist_Move']
            app.vis_dict['Mist_Move'] = Vis(name = 'Mist_Move', loc = endloc[:])
            vis = app.vis_dict['Mist_Move']
        else:
            effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
            del app.vis_dict['Teleport']
            app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = endloc[:])
            vis = app.vis_dict['Teleport']
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda endloc = endloc, ln = ln : self.cleanup_teleport(endloc, ln))
        
    def cleanup_teleport(self, endloc, ln):
        try: 
            del app.vis_dict['Teleport']
            app.canvas.delete('Teleport')
        except: pass
        try: 
            del app.vis_dict['Mist_Move']
            app.canvas.delete('Mist_Move')
        except: pass
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.rebind_all()
        app.dethloks[ln].set(1)
        
        
        
class Tomb(Summon):
    def __init__(self, name, id, img, loc, owner, level, imprint):
        self.imprint = imprint
        if level == 1:
            self.actions = {}
            self.str = 1
            self.agl = 4
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 30
            self.init = 4
            self.spirit = 13
            self.magick = 15
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
            self.level = level
        elif level == 2:
            self.actions = {}
            self.str = 1
            self.agl = 4
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 30
            self.init = 4
            self.spirit = 13
            self.magick = 15
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
            self.level = level
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['fire', 'poison', 'cold', 'magick', 'elec', 'acid']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['nonsentient']
        
    def vivify(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_vivify)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_vivify(event = e, s = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Vivify', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_vivify(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vivify(self, event, s, sqrs):
        id = app.grid[s[0]][s[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, (Witch, Tomb)):
            return
        if s not in sqrs:
            return
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/vivify.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         self.init_cast_anims()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Vivify', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Vivify', font = ('chalkduster', 16), fill = 'azure', tags = 'text')
        amt = self.get_abl('psyche')
        apply_heal(self, ent, amt)
        ent.magick += amt
        if ent.magick > ent.base_magick:
            ent.magick = ent.base_magick
        app.vis_dict['Vivify'] = Vis(name = 'Vivify', loc = ent.loc[:])
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+89-app.moved_down, text = '+'+str(amt)+' spirit, magick', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+90-app.moved_down, text = '+'+str(amt)+' spirit, magick', font = ('chalkduster', 13), fill = 'azure', tags = 'text')
        root.after(2111, self.cleanup_vivify)


        
    def cleanup_vivify(self, event = None):
#         self.init_normal_anims()
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Vivify']
            app.canvas.delete('Vivify')
        except: pass
        try: app.canvas.delete('text')
        except: pass
        

'''
enervating blow- agl v agl to hit crsh melee, move to back of initq
time warp- each frndly in rng1, on caster psy check for each, is moved/placed in front of initq
slow motion- spell tar rng rsn, on wis vs wis tohit is moved to back of initq and gets -5 init
stasis- next 5 ents in initq, on tohit wis vs wis, get -1 acts efct if they do not have this efct
energy transfer- two spell tar ents in initq exchange places in initq
'''
class Chronomancer(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Enervating Blow':self.enervating_blow, 'Gate':self.gate, 'Time Warp':self.time_warp, 'Slow Motion':self.slow_motion, 'Stasis':self.stasis, 'Vanish':self.vanish}
            self.str = 3
            self.agl = 7
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 6
            self.rsn = 5
            self.san = 14
            self.init = 8
            self.spirit = 19
            self.magick = 31
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Enervating Blow':self.enervating_blow, 'Gate':self.gate, 'Time Warp':self.time_warp, 'Slow Motion':self.slow_motion, 'Stasis':self.stasis, 'Recall':self.recall, 'Vanish':self.vanish}
            self.str = 4
            self.agl = 8
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 8
            self.psyche = 6
            self.wis = 7
            self.rsn = 5
            self.san = 15
            self.init = 9
            self.spirit = 27
            self.magick = 39
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['explosive', 'piercing']
        super().__init__(name, id, img, loc, owner)

    def gate(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_gate)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_gate_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_gate_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def choose_gate_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if app.ent_dict[id].immovable == True:
            return
        if self.magick < 2:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_gate)
        distance = self.get_abl('rsn')
        app.cleanup_squares()
        sqrs = [c for c in app.coords if dist(self.loc,c)<=distance and app.grid[c[0]][c[1]]=='']
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_gate)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id = id, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
    
    def do_gate(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        self.magick -= 2
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_gate(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        n = 'gate'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Gate', loc = ent.loc[:])
        root.after(1666, lambda n = n : cleanup_gate(n))
        n = 'gate'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Gate', loc = sqr[:])
        root.after(1999, lambda n = n : cleanup_gate(n))
        lock(Bot.ai_teleport_move, ent, sqr)
        self.cleanup_gate()
    
    def cleanup_gate(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)


    def vanish(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_vanish)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_vanish(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Vanish', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_vanish(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vanish(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 7:
            return
        self.magick -= 7
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Vanish', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Vanish', justify = 'center', fill = 'lavender', font = ('chalkduster', 16), tags = 'text')
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v.immovable==False and v.owner==self.owner]
        sqrs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        for e in ents:
            s = choice(sqrs)
            Bot.ai_teleport_move(e, s)
            sqrs.remove(s)
        root.after(2666, self.finish_vanish)
        
    def finish_vanish(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
    
    
    # choose up to 2 friendly units anywhere, relocate them among the closest empty sqrs closest to caster
    def recall(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_recall)
        sqrs = [v.loc for k,v in app.all_ents().items() if v != self and v.owner == self.owner]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose First Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if self.magick < 2:
            return
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.immovable == True:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        app.cleanup_squares()
        root.bind('<q>', self.cleanup_recall)
        sqrs = [v.loc for k,v in app.all_ents().items() if v != self and v.owner == self.owner and k != id]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs, id1 = id: self.cont_recall(e, sqr = sqr, sqrs = sqrs, id1 = id1))
        b = tk.Button(app.context_menu, text = 'Choose Second Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs, id1 = id : self.cont_recall(event = e, sqr = sqr, sqrs = sqrs, id1 = id1))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b3 = tk.Button(app.context_menu, text = 'None', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda id1 = id, nt = True : self.cont_recall(id1 = id1, no_target = nt))
        b3.pack(side = 'top')
        app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
            
            
    def cont_recall(self, event = None, sqr = None, sqrs = None, id1 = None, no_target = False):
        ids = [id1]
        if no_target == False:
            if sqr not in sqrs:
                return
            id = app.grid[sqr[0]][sqr[1]]
            if id not in app.all_ents().keys():
                return
            if id1 == id:
                return
            ent = app.ent_dict[id]
            if ent.immovable == True:
                return
            ids.append(id)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= 2
        self.acts -= 1
        self.do_recall(ids = ids)
    
    def do_recall(self, event = None, ids = None):
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        closest_sqrs = sorted([c for c in app.coords if app.grid[c[0]][c[1]] == ''], key = lambda x : dist(x,self.loc))
        for id in ids:
            oldloc = app.ent_dict[id].loc[:]
            newloc = closest_sqrs[0]
            closest_sqrs = closest_sqrs[1:]
            app.focus_square(newloc)
            lock(Bot.ai_teleport_move, app.ent_dict[id], newloc)
        self.cleanup_recall()
            
    
    def cleanup_recall(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)


    def stasis(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_stasis)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_stasis(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Stasis', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_stasis(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stasis(self, event = None, sqrs = None):
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Stasis', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Stasis', justify = 'center', fill = 'lavender', font = ('chalkduster', 16), tags = 'text')
        ids = [id for id in app.init_q if isinstance(app.ent_dict[id],Witch) != True]
        ids = ids[:5]
        if ids == []:
            root.after(1666, self.finish_stasis)
        else:
            self.stasis_loop(ids)
    
    def stasis_loop(self, ids):
        if ids == []:
            self.finish_stasis()
        else:
            id = ids[0]
            app.get_focus(id)
            ids = ids[1:]
            ent = app.ent_dict[id]
            un = 'Stasis'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Stasis', loc = ent.loc[:])
            def cleanup_stasis_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            if to_hit(self.get_abl('wis'),ent.get_abl('wis')) == True and 'Stasis' not in [v.name for k,v in ent.effects_dict.items()]:
                def stasis_acts(acts):
                    return max(0,acts-1)
                p = partial(stasis_acts)
                ent.acts_effects.append(p)
                ent.acts -= 1
                def undo(ent, p, lockname = None):
                    ent.acts_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Stasis' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Stasis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = '-1 actions', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = '-1 actions', justify = 'center', fill = 'lavender', font = ('chalkduster', 13), tags = 'text')
                root.after(1555, lambda un = un : cleanup_stasis_vis(un))
                root.after(1666, lambda ids = ids : self.stasis_loop(ids))
            else:
                miss(ent.loc)
                root.after(1555, lambda un = un : cleanup_stasis_vis(un))
                root.after(1666, lambda ids = ids : self.stasis_loop(ids))
        
    def finish_stasis(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)


    def slow_motion(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_slow_motion)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_slow_motion(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Slow Motion', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_slow_motion(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_slow_motion(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 2:
            return
        self.magick -= 2
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Slow_Motion'] = Vis(name = 'Slow_Motion', loc = ent.loc[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Slow Motion', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Slow Motion', justify ='center', font = ('chalkduster', 13), fill = 'lavender', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            if ent.id in app.init_q:
                app.init_q.remove(ent.id)
                app.init_q.append(ent.id)
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '-5 init', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '-5 init', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            def slow_effect(stat):
                return max(1,stat-5)
            p = partial(slow_effect)
            ent.init_effects.append(p)
            def undo(ent, func, lockname = None):
                ent.init_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Slow_Motion'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Slow_Motion', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(ent.loc)
        root.after(1999, lambda e = None : self.finish_slow_motion(event = e))
        
    def finish_slow_motion(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Slow_Motion']
            app.canvas.delete('Slow_Motion')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)

    def time_warp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_time_warp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_time_warp(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Time Warp', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_time_warp(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_time_warp(self, event = None, sqrs = None):
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Time Warp', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Time Warp', justify = 'center', fill = 'lavender', font = ('chalkduster', 16), tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1 and v.owner == self.owner and isinstance(v,Witch)==False]
        if ids == []:
            root.after(1666, self.finish_time_warp)
        else:
            self.time_warp_loop(ids)
    
    def time_warp_loop(self, ids):
        if ids == []:
            self.finish_time_warp()
        else:
            id = ids[0]
            ids = ids[1:]
            ent = app.ent_dict[id]
            un = 'Time_Warp'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Time_Warp', loc = ent.loc[:])
            def cleanup_warp_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            if self.save_check('wis') == 'Pass':
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Time Warp', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Time Warp', justify = 'center', fill = 'lavender', font = ('chalkduster', 16), tags = 'text')
                if ent.id in app.init_q:
                    app.init_q.remove(ent.id)
                app.init_q = [ent.id]+app.init_q
                root.after(1666, lambda un = un : cleanup_warp_vis(un))
                root.after(1777, lambda ids = ids : self.time_warp_loop(ids))
            else:
                miss(ent.loc)
                root.after(1555, lambda un = un : cleanup_warp_vis(un))
                root.after(1666, lambda ids = ids : self.time_warp_loop(ids))
        
    def finish_time_warp(self, event = None):
        self.init_normal_anims()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)


    def enervating_blow(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_enervating_blow)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_enervating_blow(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Enervating Blow', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_enervating_blow(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enervating_blow(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Enervating_Blow'] = Vis(name = 'Enervating_Blow', loc = sqr[:])
        if to_hit(self.get_abl('agl'),ent.get_abl('agl')) == True:
            #move to back of initq if in
            if ent.id in app.init_q:
                app.init_q.remove(ent.id)
                app.init_q.append(ent.id)
            d = damage(self.get_abl('str'),ent.get_abl('end'))
            root.after(1666, lambda e = None : self.cleanup_enervating_blow(event = e))
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Enervating Blow', 'melee')
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cleanup_enervating_blow(event = e))
        
    def cleanup_enervating_blow(self, event = None):
        try: 
            del app.vis_dict['Enervating_Blow']
            app.canvas.delete('Enervating_Blow')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)


class Enchantress(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Enlightenment':self.enlightenment, 'Wall of Blossoms':self.wall_of_blossoms, 'Regrowth':self.regrowth, 'Aura Blast':self.aura_blast, 'Forestwalk':self.forestwalk, 'Wildfire':self.wildfire}
            self.str = 2
            self.agl = 4
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 6
            self.wis = 7
            self.rsn = 3
            self.san = 14
            self.init = 5
            self.spirit = 29
            self.magick = 26
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Enlightenment':self.enlightenment, 'Wall of Blossoms':self.wall_of_blossoms, 'Regrowth':self.regrowth, 'Aura Blast':self.aura_blast, 'Forestwalk':self.forestwalk, 'Wildfire':self.wildfire}
            self.str = 3
            self.agl = 5
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 7
            self.wis = 8
            self.rsn = 4
            self.san = 15
            self.init = 6
            self.spirit = 39
            self.magick = 33
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison', 'acid']
        super().__init__(name, id, img, loc, owner)
        
    # spell target, has each empty adj sqr occupied by 'Wall of Blossoms' ent (inert)
    def wall_of_blossoms(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_wall_of_blossoms)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_wall_of_blossoms(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Target for Wall of Blossoms", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_wall_of_blossoms(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wall_of_blossoms(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id],Witch):
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Blossoms'] = Vis(name = 'Blossoms', loc = sqr[:])
        def cleanup_wall():
            app.canvas.delete('Blossoms')
            del app.vis_dict['Blossoms']
        root.after(2666, cleanup_wall)
        root.after(2333, lambda s = sqr[:] : self.continue_wall_of_blossoms(s))
        
    def continue_wall_of_blossoms(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Wall_of_Blossoms.png'))
        sqrs = [c for c in app.coords if dist(sqr,c) == 1 and app.grid[c[0]][c[1]] == '']
        for s in sqrs:
            if self.owner == 'p1':
                id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
                app.ent_dict[app.p1_witch].summon_ids += 1
            else:
                id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
                app.ent_dict[app.p2_witch].summon_ids += 1
            app.ent_dict[id] =  Wall_of_Blossoms(name = 'Wall_of_Blossoms', id = id, img = img, loc = s[:], owner = self.owner, level = self.level)
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
            app.grid[s[0]][s[1]] = id
        self.finish_wall_of_blossoms()
        
    def finish_wall_of_blossoms(self, event = None):
        app.generic_cancel()
    
    # return discarded arcana, not smn from discard pile to hand
    def regrowth(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_regrowth)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_regrowth(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Regrowth', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_regrowth(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_regrowth(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Regrowth'] = Vis(name = 'Regrowth', loc = self.loc[:])
        def cleanup_regrowth():
            del app.vis_dict['Regrowth']
            app.canvas.delete('Regrowth')
        root.after(1999, cleanup_regrowth)
        app.depop_context(event = None)
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(14, 14, text= 'Choose Arcana...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
        bg.create_text(15, 15, text= 'Choose Arcana...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        if self.owner == 'p1':
            discard = app.ent_dict[app.p1_witch].discard[:]
        else:
            discard = app.ent_dict[app.p2_witch].discard[:]
        discard = [c for c in discard if c not in app.summons_list]
        if discard == []:
            root.after(1666, lambda e = None : self.finish_regrowth(event = e))
        else:# MAKE BUTTONS becomes page effects like page actions
            self.page_regrowth(discard_list = discard)
                    
                    
    def page_regrowth(self, event = None, discard_list = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, card in enumerate(discard_list[index:index+5]):
            i += 1
            p = partial(self.regrowth_return, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            # below should become effect_description_popup, (there is no equivalent to more info popup, effect desc shown in more info
#             b1.bind('<Button-2>', lambda ef = ef : app.effect_description(ef))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda dl = discard_list, i = index-5 : self.page_regrowth(discard_list = dl, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, dl = discard_list, i = index-5 : self.page_regrowth(discard_list = dl, index = i))
            app.context_buttons.append(b4)
        if len(discard_list) > len(discard_list[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda dl = discard_list, i = index+5 : self.page_regrowth(discard_list = dl, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, dl = discard_list, i = index+5 : self.page_regrowth(discard_list = dl, index = i))
                    
                    
            
    def regrowth_return(self, event = None, card = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        # put card in hand, rmv from discard
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        witch.in_hand.append(card)
        witch.discard.remove(card)
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Return '+str(card).replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Return '+str(card).replace('_',' '), justify = 'center', fill = 'olivedrab', font = ('chalkduster', 16), tags = 'text')
        root.after(1999, self.finish_regrowth)
            
            
    def finish_regrowth(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # target w wkns fire, 'spreads' to all adj w wkns to fire, target+spread and all adj to that group, each take dmg caster psyche vs end, fire spell
    def wildfire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_wildfire)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_wildfire(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Wildfire Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_wildfire(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wildfire(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'fire' not in ent.get_weak():
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        def cleanup_wildfire(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
            
        # takes ents
        def find_spread(checked, q, all):
            while q:
                last = q[-1]
                all.append(last)
                checked.append(last)
                q = q[:-1]
                adj = [v for k,v in app.all_ents().items() if v not in checked and dist(v.loc,last.loc)==1 and 'fire' in v.get_weak()]
                if adj == []:
                    pass
                else:
                    for v in adj:
                        if v not in q and v not in checked:
                            q.append(v)
            return all
        spread = find_spread([],[ent],[])
        #now get all adj to spread
        adj = [v for k,v in app.all_ents().items() for e in spread if v not in spread and dist(v.loc,e.loc)==1]
        all = list(set(spread+adj))
        for e in all:
            n = 'Wildfire'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Wildfire', loc = e.loc[:])
            root.after(1666, lambda n = n : cleanup_wildfire(n))
        def wildfire_loop(ents):
            if ents == []:
                self.finish_wildfire()
            else:
                ent = ents[0]
                ents = ents[1:]
                d = damage(self.get_abl('psyche'),ent.get_abl('end'))
                lock(apply_damage, self, ent, -d, 'fire', 'Wildfire', 'spell')
                root.after(111, lambda es = ents : wildfire_loop(es))
        wildfire_loop(all)
                    
    def finish_wildfire(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def aura_blast(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_aura_blast)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_aura_blast(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Aura Blast Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_aura_blast(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aura_blast(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 4:
            return
        self.magick -= 4
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        lock(Entity.ranged_attack, self, ent.loc[:], 'Aura_Blast')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            if self.owner == 'p1':
                witch = app.ent_dict[app.p1_witch]
            else:
                witch = app.ent_dict[app.p2_witch]
            d = len(witch.in_hand)
            lock(apply_damage, self, ent, -d, 'magick', 'Aura Blast', 'spell')
            root.after(111, self.finish_aura_blast)
        else:
            miss(ent.loc)
            root.after(1999, self.finish_aura_blast)
        
    def finish_aura_blast(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
    def forestwalk(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_forestwalk)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_forestwalk(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Forestwalk', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_forestwalk(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_forestwalk(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Forestwalk' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/discord.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+24, text = 'Forestwalk', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+25, text = 'Forestwalk', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Forestwalk'] = Vis(name = 'Forestwalk', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Invisible, Psyshield, Ethereal move type', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Invisible, Psyshield, Ethereal move type', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def forestwalk_effect(types):
            return types + ['invisibility', 'psyshield']
        p = partial(forestwalk_effect)
        self.type_effects.append(p)
        def forest_move(type):
            return 'ethereal'
        p2 = partial(forest_move)
        self.move_type_effects.append(p2)
        def undo(ent, p, p2, lockname = None):
            ent.type_effects.remove(p)
            ent.move_type_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2)
        self.effects_dict['Forestwalk'] = Effect(name = 'Forestwalk', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(2666, self.finish_forestwalk)
        
    def finish_forestwalk(self, event = None):
        try: 
            del app.vis_dict['Forestwalk']
            app.canvas.delete('Forestwalk')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    
    def enlightenment(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enlightenment)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enlightenment(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Enlightenment', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enlightenment(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enlightenment(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Enlightenment', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Enlightenment', justify = 'center', fill = 'antiquewhite', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Enlightenment'] = Vis(name = 'Enlightenment', loc = sqr[:])
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        amt = len(self.wis_effects)
        witch.in_hand += witch.library[:amt]
        witch.library = witch.library[amt:]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+34, text = 'Draw '+str(amt), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+35, text = 'Draw '+str(amt), justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        root.after(2666, self.finish_enlightenment)
        
    def finish_enlightenment(self, event = None):
        try: 
            del app.vis_dict['Enlightenment']
            app.canvas.delete('Enlightenment')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()


class Yellow_Priest(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Censer Grenade':self.censer_grenade, 'Offering to Dagon':self.offering_to_dagon, 'Trials of Hatheg Kla':self.trials_of_hatheg_kla, "Dagon's Chosen":self.dagons_chosen, 'Call Nightgaunt':self.call_nightgaunt, 'Call Migo':self.call_migo, 'Guardian of the Chthonic Gate':self.guardian}
            self.str = 4
            self.agl = 7
            self.end = 7
            self.mm = 8
            self.msl = 7
            self.bls = 4
            self.dodge = 11
            self.psyche = 9
            self.wis = 10
            self.rsn = 7
            self.san = 13
            self.init = 7
            self.spirit = 17
            self.magick = 26
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.actions = {'Move':self.move, 'Censer Grenade':self.censer_grenade, 'Offering to Dagon':self.offering_to_dagon,   'Trials of Hatheg Kla':self.trials_of_hatheg_kla, "Dagon's Chosen":self.dagons_chosen, 'Call Nightgaunt':self.call_nightgaunt, 'Call Migo':self.call_migo, 'Guardian of the Chthonic Gate':self.guardian}
            self.str = 4
            self.agl = 7
            self.end = 7
            self.mm = 8
            self.msl = 7
            self.bls = 4
            self.dodge = 11
            self.psyche = 9
            self.wis = 10
            self.rsn = 7
            self.san = 13
            self.init = 7
            self.spirit = 17
            self.magick = 26
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['fire', 'explosive','poison','acid','slashing','piercing']
        super().__init__(name, id, img, loc, owner)
        
        
    # spell target you do own, san reduced to 3, +1 acts,mvs +2 mv rng,str,agl,end,dodge,init
    def dagons_chosen(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_dagons_chosen)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_dagons_chosen(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Target for Dagon's Chosen", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_dagons_chosen(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_dagons_chosen(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if isinstance(ent,Witch):
            return
        if ent.immovable == True:
            return
        if self.magick < 6:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 6
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict["Dagon's_Chosen"] = Vis(name = "Dagon's_Chosen", loc = ent.loc[:])
        # san red 3, +1 acts,mvs, +2 mv rng,str,agl,end,dodge,init
        def dagon_san(stat):
            return min(stat,3)
        p = partial(dagon_san)
        ent.san_effects.append(p)
        def dagon_acts(stat):
            return stat+1
        p2 = partial(dagon_acts)
        ent.acts_effects.append(p2)
        ent.mvs_effects.append(p2)
        def dagon_efct(stat):
            return stat+2
        p3 = partial(dagon_efct)
        ent.str_effects.append(p3)
        ent.agl_effects.append(p3)
        ent.end_effects.append(p3)
        ent.dodge_effects.append(p3)
        ent.init_effects.append(p3)
        ent.move_range_effects.append(p3)
        def undo(ent, p, p2, p3, lockname = None):
            ent.san_effects.remove(p)
            ent.acts_effects.remove(p2)
            ent.mvs_effects.remove(p2)
            ent.str_effects.remove(p3)
            ent.agl_effects.remove(p3)
            ent.end_effects.remove(p3)
            ent.dodge_effects.remove(p3)
            ent.init_effects.remove(p3)
            ent.move_range_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p, p2, p3)
        un = 'dagon'+str(app.count)
        app.count += 1
        ent.effects_dict[un] = Effect(name = "Dagon's_Chosen", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Sanity max 3, +1 acts,mvs, +2 phys stats', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Sanity max 3, +1 acts,mvs, +2 phys stats', justify = 'center', fill = 'indianred', font = ('chalkduster', 13), tags = 'text')
        root.after(1777, lambda t = 'text': app.canvas.delete(t))
        root.after(1888, self.cleanup_dagons_chosen)
    
    def cleanup_dagons_chosen(self, event = None):
        try:
            del app.vis_dict["Dagon's_Chosen"]
            app.canvas.delete("Dagon's_Chosen")
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    #  tport spell tar you do not own rndmly among furthest empty locs, -5 san, +1 acts)
    # should be on to-hit or save check...
    def trials_of_hatheg_kla(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_hatheg)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_hatheg(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target for Trials of Hatheg Kla', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_hatheg(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def choose_hatheg(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if ent.owner == self.owner:
            return
        if ent.immovable == True:
            return
        if self.magick < 6:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 6
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict['Hatheg'] = Vis(name = 'Hatheg', loc = ent.loc[:])
        def cleanup_hath():
            del app.vis_dict['Hatheg']
            app.canvas.delete('Hatheg')
        root.after(1666, cleanup_hath)
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            sqrs = [c for c in app.coords if app.grid[c[0]][c[1]]=='']
            sqr = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, sqrs)
            # tport move ent to sqr, then add efcts
            lock(Bot.ai_teleport_move, ent, sqr)
            # -5 san, +1 acts
            def hath_efct(stat):
                return max(1,stat-5)
            p = partial(hath_efct)
            ent.san_effects.append(p)
            def hath_acts(stat):
                return stat+1
            p2 = partial(hath_acts)
            ent.acts_effects.append(p2)
            def undo(ent, p, p2, lockname = None):
                ent.san_effects.remove(p)
                ent.acts_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            un = 'hath'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Hatheg_Kla_Trials', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            self.cleanup_hatheg()
        else:
            miss(ent.loc)
            root.after(1777, lambda t = 'text': app.canvas.delete(t))
            root.after(1888, self.cleanup_hatheg)
    
    def cleanup_hatheg(self, event = None):
        try:
            del app.vis_dict['Hatheg']
            app.canvas.delete('Hatheg')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    # destroy an ent you own, add 6 spirit, 3 magick to all adj to that ent
    def offering_to_dagon(self, event = None):
    # choose an ent you own, destroy it, then create on that loc
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_offering_to_dagon)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_offering_to_dagon(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Target for Offering to Dagon", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_offering_to_dagon(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_offering_to_dagon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if ent.owner != self.owner:
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr[:])
        def cleanup_wall():
            app.canvas.delete('Curse_of_Oriax')
            del app.vis_dict['Curse_of_Oriax']
        root.after(1666, cleanup_wall)
        lock(app.kill, ent.id)
        # get adj ents and heal spirit and magick for each, only friendly
        ents = [v for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc,sqr)==1]
        def dagon_loop(ents):
            if ents == []:
                self.finish_offering_to_dagon()
            else:
                ent = ents[0]
                ents = ents[1:]
                ent.magick += 3
                if isinstance(ent,Witch)==False:
                    if ent.magick>ent.base_magick:
                        ent.magick = ent.base_magick
                apply_heal(self, ent, 3)
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '+3 spirit, magick', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '+3 spirit, magick', justify = 'center', fill = 'indianred', font = ('chalkduster', 13), tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ents = ents : dagon_loop(ents))
        dagon_loop(ents)
                    
        
    def finish_offering_to_dagon(self, event = None):
        app.generic_cancel()
        
    
    
    # smn, -1 san,wis,psy, destroy an ent you own 
    def call_migo(self, event = None):
    # choose an ent you own, destroy it, then create on that loc
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_call_migo)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_call_migo(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Target for Call Migo", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_call_migo(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_call_migo(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Nightgaunt)==False:
            return
        if ent.owner != self.owner:
            return
        if self.magick < 6:
            return
        self.magick -= 6
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr[:])
        def cleanup_wall():
            app.canvas.delete('Curse_of_Oriax')
            del app.vis_dict['Curse_of_Oriax']
        root.after(1666, cleanup_wall)
        lock(app.kill, ent.id)
        root.after(1555, lambda s = sqr[:] : self.cont_call_migo(s))
    
    def cont_call_migo(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Migo.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Migo(name = 'Migo', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_call_migo()
        
    def finish_call_migo(self, event = None):
        app.generic_cancel()
        
        
    # like cadaver (not inert,has mvs,acts) on hit -1 san, 'carries' ent (flying move) to any loc in wi move range, if one exists, deposit self empty nrst
    def call_nightgaunt(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_call_nightgaunt)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1 and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_call_nightgaunt(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Nightgaunt", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_call_nightgaunt(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_call_nightgaunt(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr[:])
        def cleanup_summon():
            app.canvas.delete('Curse_of_Oriax')
            del app.vis_dict['Curse_of_Oriax']
        root.after(2333, cleanup_summon)
        root.after(2333, lambda s = sqr[:] : self.continue_call_nightgaunt(s))
        
    def continue_call_nightgaunt(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Nightgaunt.png'))
        if self.owner == 'p1':
            id = self.id+'nightgaunt'+ str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = self.id+'nightgaunt'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Nightgaunt(name = 'Nightgaunt', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_call_nightgaunt()
        
    def finish_call_nightgaunt(self, event = None):
        app.generic_cancel()
        
    # must destroy migo you own
    # smn inert ent with prox efct (-4 san, rng 3), no moves/move range, atks adj for slsh melee, then does aoe cold ranged to all wi rng 3 
    def guardian(self, event = None):
    # choose an ent you own, destroy it, then create on that loc
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_guardian)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_guardian(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Target for Guardian", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_guardian(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_guardian(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        # limit one per caster, id of guardian is caster id plus guardian(example: a1guardian or b3guardian)
        if self.id+'guardian' in app.all_ents().keys():
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Migo)==False:
            return
        if ent.owner != self.owner:
            return
        if self.magick < 9:
            return
        self.magick -= 9
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Warpfire'] = Vis(name = 'Warpfire', loc = sqr[:])
        def cleanup_wall():
            app.canvas.delete('Warpfire')
            del app.vis_dict['Warpfire']
        root.after(1666, cleanup_wall)
        lock(app.kill, ent.id)
        root.after(1555, lambda s = sqr[:] : self.cont_guardian(s))
    
    def cont_guardian(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Guardian_of_the_Chthonic_Gate.png'))
        if self.owner == 'p1':
            id = self.id+'guardian'
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = self.id+'guardian'
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Guardian_of_the_Chthonic_Gate(name = 'Guardian_of_the_Chthonic_Gate', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_guardian()
        
    def finish_guardian(self, event = None):
        app.generic_cancel()
        
        
    # tracer grenade like, does sanity -3 effect
    def censer_grenade(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_censer_grenade)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_censer_grenade(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Grenade', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_censer_grenade(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_censer_grenade(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/pestilence.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Censer_Grenade'] = Vis(name = 'Censer_Grenade', loc = self.loc)
        selected_vis.append('Censer_Grenade')
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def mortar_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                app.vis_dict['Censer_Grenade'].rotate_image()
                app.canvas.delete('Censer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Censer_Grenade'].img, tags = 'Censer_Grenade')
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete('Censer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Censer_Grenade'].img, tags = 'Censer_Grenade')
                app.canvas.tag_raise('Censer_Grenade')
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete('Censer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Censer_Grenade'].img, tags = 'Censer_Grenade')
                app.canvas.tag_raise('Censer_Grenade')
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete('Censer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Censer_Grenade'].img, tags = 'Censer_Grenade')
                app.canvas.tag_raise('Censer_Grenade')
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete('Censer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Censer_Grenade'].img, tags = 'Censer_Grenade')
                app.canvas.tag_raise('Censer_Grenade')
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.continue_censer_grenade(end_sqr)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : mortar_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        mortar_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
        
    def continue_censer_grenade(self, sqr):
        global selected_vis
        app.canvas.delete('text')
        selected_vis.remove('Censer_Grenade')
        del app.vis_dict['Censer_Grenade']
        app.canvas.delete('Censer_Grenade')
        effect1 = mixer.Sound('Sound_Effects/pox.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict['Censer_Exploded'] = Vis(name = 'Censer_Exploded', loc = sqr)
        def cleanup_explode():
            del app.vis_dict['Censer_Exploded']
            app.canvas.delete('Censer_Exploded')
        root.after(999, cleanup_explode)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 2 and isinstance(v,(Witch,Yellow_Priest))==False]
        # mortar loop
        def mortar_loop(ents):
            if ents == []:
                self.cleanup_censer_grenade()
            else:
                effect1 = mixer.Sound('Sound_Effects/pox.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                n = 'Traced' + str(app.count)
                app.count += 1
                loc = ent.loc[:]
                app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Pox', loc = loc)
                def cleanup_vis(name):
                    app.canvas.delete('text')
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                if to_hit(self.get_abl('mm'),ent.get_abl('dodge')):
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '-3 sanity', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '-3 sanity', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    def censer_effect(stat):
                        return max(1,stat-3)
                    p = partial(censer_effect)
                    ent.san_effects.append(p)
                    def undo(id, p, lockname = None):
                        app.ent_dict[id].san_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p)
                    un = 'censer'+str(app.count)
                    app.count += 1
                    ent.effects_dict[un] = Effect(name = 'Censer_Grenade', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('bls'))
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
                else:
                    miss(ent.loc[:])
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
        mortar_loop(ents)
        
    def cleanup_censer_grenade(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
#         app.unbind_all()
        app.rebind_all()
    

class Goblin_Shaman(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Call Plague Vermin':self.call_plague_vermin, 'Fervor':self.fervor, 'Teleport Field':self.teleport_field, 'Lightning Rod':self.lightning_rod, 'Jokulhaups':self.jokulhaups, 'Call Mount':self.call_mount}
            self.str = 4
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 6
            self.wis = 6
            self.rsn = 7
            self.san = 13
            self.init = 8
            self.spirit = 29
            self.magick = 36
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        elif level == 2:
            self.actions = {'Move':self.move, 'Call Plague Vermin':self.call_plague_vermin, 'Fervor':self.fervor, 'Teleport Field':self.teleport_field, 'Lightning Rod':self.lightning_rod, 'Jokulhaups':self.jokulhaups, 'Call Mount':self.call_mount}
            self.str = 4
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 6
            self.wis = 6
            self.rsn = 7
            self.san = 13
            self.init = 8
            self.spirit = 29
            self.magick = 36
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['fire', 'explosive']
        super().__init__(name, id, img, loc, owner)
        self.eyegaunt_anims = {}
        for k,v in app.eyegaunt_anims.items():
            self.eyegaunt_anims[k] = v
        self.boar_anims = {}
        for k,v in app.boar_anims.items():
            self.boar_anims[k] = v
        super().__init__(name, id, img, loc, owner)
        
    def init_eyegaunt_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.eyegaunt_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
    def init_boar_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.boar_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
        
    def call_plague_vermin(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_call_plague_vermin)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_call_plague_vermin(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Plague Vermin", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_call_plague_vermin(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_call_plague_vermin(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id != '':
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        vis = app.vis_dict['Summon']
        def cleanup_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1777, cleanup_summon)
        root.after(1888, lambda s = sqr[:] : self.continue_call_plague_vermin(s))
        
    def continue_call_plague_vermin(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Plague_Vermin.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Plague_Vermin(name = 'Plague_Vermin', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_call_plague_vermin()
        
    def finish_call_plague_vermin(self, event = None):
        app.generic_cancel()
        
        
    # all animals rng 2, +2 phys stats, -3 san
    def fervor(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_fervor)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fervor(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Fervor', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fervor(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fervor(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/brambles.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Fervor', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Fervor', justify ='center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2 and 'animal' in v.get_types() and 'Fervor' not in [j.name for i,j in v.effects_dict.items()]]
        def cleanup_fervor(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        def fervor_loop(ents):
            if ents == []:
                self.finish_fervor()
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                s = ent.loc[:]
                u = 'fervor' + str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Fervor', loc = s)
                app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = '+2 str, agl, end, dod, init, -3 sanity', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = '+2 str, agl, end, dod, init, -3 sanity', justify ='center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
                def fervor_stat(stat):
                    return stat+2
                p = partial(fervor_stat)
                ent.str_effects.append(p)
                ent.agl_effects.append(p)
                ent.end_effects.append(p)
                ent.dodge_effects.append(p)
                ent.init_effects.append(p)
                def fervor_san(stat):
                    return max(1, stat-3)
                p2 = partial(fervor_san)
                ent.san_effects.append(p2)
                def un(ent, p, p2, lockname = None):
                    ent.str_effects.remove(p)
                    ent.agl_effects.remove(p)
                    ent.end_effects.remove(p)
                    ent.dodge_effects.remove(p)
                    ent.init_effects.remove(p)
                    ent.san_effects.remove(p2)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                uf = partial(un, ent, p, p2)
                n = 'fervor' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Fervor', undo_func = uf, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1555, lambda name = u : cleanup_fervor(name))
                root.after(1666, lambda ents = ents : fervor_loop(ents))
        fervor_loop(ents)
            
            
    def finish_fervor(self, event = None):
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.exists_check(app.active_ent)
        
    # btwn 1-3 rndmly chsn amt, in rng 3 auto hit elec psy vs psy spell
    def lightning_rod(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_lightning_rod)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_lightning_rod(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Lightning Rod', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_lightning_rod(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_lightning_rod(self, event = None, sqrs = None):
        if self.magick < 4:
            return
        self.magick -= 4
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Lightning Rod', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Lightning Rod', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        amt = randrange(1,4)
        ents1 = [v for k,v in app.all_ents().items() if v.loc in sqrs]
        ents = []
        for j in range(amt):
            if ents1 == []:
                break
            else:
                e = choice(ents1)
                ents.append(e)
                ents1.remove(e)
        def cleanup_light(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for e in ents:
            n = 'light' + str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Lightning_Rod', loc = e.loc[:])
            root.after(1999, lambda n = n : cleanup_light(n))
        def light_loop(ents):
            if ents == []:
                self.finish_lightning_rod()
            else:
#                 effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
#                 effect1.set_volume(app.effects_volume.get())
#                 sound_effects.play(effect1, 0)
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                lock(apply_damage, self, ent, -d, 'elec', 'Lightning Rod', 'spell')
                light_loop(ents)
        light_loop(ents)
        
    def finish_lightning_rod(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.exists_check(app.active_ent)
        
    # all non-flying in rng rsn, 2 separate wis v wis to-hit, fire then explosive spell dmg
    def jokulhaups(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_jokulhaups)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_jokulhaups(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Jokulhaups', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_jokulhaups(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_jokulhaups(self, event = None, sqrs = None):
        if self.magick < 6:
            return
        self.magick -= 6
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Jokulhaups', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Jokulhaups', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        ents = [v for k,v in app.all_ents().items() if v.loc in sqrs and 'flying' != v.get_move_type()]
        def cleanup_jokul(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for e in ents:
            n = 'jokul' + str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Jokulhaups', loc = e.loc[:])
            root.after(1999, lambda n = n : cleanup_jokul(n))
        def jokul_loop(ents):
            if ents == []:
                self.finish_jokulhaups()
            else:
                effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                misscount = 0
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, ent, -d, 'fire', 'Jokulhaups Fire', 'spell')
                else:
                    misscount += 1
                if ent.id in app.all_ents().keys():
                    if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                        d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                        lock(apply_damage, self, ent, -d, 'explosive', 'Jokulhaups Explosion', 'spell')
                    else:
                        misscount += 1
                    if misscount == 2:
                        miss(ent.loc)
                        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                        root.after(1666, lambda ents = ents : jokul_loop(ents))
                    else:
                        jokul_loop(ents)
                else:
                    jokul_loop(ents)
        jokul_loop(ents)
        
    def finish_jokulhaups(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.exists_check(app.active_ent)
        
        
    # teleport all non-list smns in rng2 of loc, distributed at the nrst empty locs to any loc in rng rsn
    def teleport_field(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_teleport_field)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.choose_teleport_field(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.choose_teleport_field(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_teleport_field(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 4:
            return
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('rsn')]
        app.animate_squares(sqrs)
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,sqr)<=2 and 'nonsentient' not in v.get_types()]
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs, ents = ents : self.do_teleport_field(event = e, sqr = s, sqrs = sqrs, ents = ents)) 
        b = tk.Button(app.context_menu, text = 'Choose Teleport Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs, ents = ents : self.do_teleport_field(event = e, sqr = s, sqrs = sqrs, ents = ents))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_teleport_field(self, event = None, sqr = None, sqrs = None, ents = None):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        self.magick -= 4
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Teleport Field', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Teleport Field', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        sqrs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        for e in ents:
            s = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b, sqrs)
            Bot.ai_teleport_move(e, s)
            sqrs.remove(s)
        root.after(2666, self.finish_teleport_field)
        
    def finish_teleport_field(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
        
        
    def call_mount(self, event = None):
        if self.acts < 1:
            return
        if self.magick < 4:
            return
        efs = [v.name for k,v in self.effects_dict.items()]
        if 'Eyegaunt_Mount' in efs or 'Boar_Mount' in efs:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_call_mount)
        app.depop_context(event = None)
        label = tk.Label(root, text = 'Choose Mount', fg = 'tan3', bg = 'black', font = ('chalkduster', 20))
        label.pack()
        app.context_buttons.append(label)
        sqrs = [self.loc[:]]
        root.bind(1, lambda e, sqr = grid_pos, sqrs = sqrs : self.call_eyegaunt(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Eyegaunt', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.call_eyegaunt(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        root.bind(2, lambda e, sqr = grid_pos, sqrs = sqrs : self.call_boar(event = e, sqr = sqr, sqrs = sqrs)) 
        b2 = tk.Button(app.context_menu, text = 'Boar', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.call_boar(event = e, sqr = sqr, sqrs = sqrs))
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        b3 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b3.pack(side = 'top')
        app.context_buttons.append(b3)
        
    def call_boar(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= 4
        self.acts -= 1
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = self.loc[:])
        def cleanup_smn():
            del app.vis_dict['Summon']
            app.canvas.delete('Summon')
        root.after(1999, cleanup_smn)
        self.init_boar_anims()
        # EFFECTS, moves until encounters an ent, then attacks it
        def charge_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = lateral_sqrs(obj.loc[:], 1)
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : do_charge(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Choose Direction', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : do_charge(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def do_charge(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                if obj.loc[0] < sqr[0]:
                    dir = 'east'
                elif obj.loc[1] < sqr[1]:
                    dir = 'south'
                elif obj.loc[0] > sqr[0]:
                    dir = 'west'
                elif obj.loc[1] > sqr[1]:
                    dir = 'north'
                path = lateral_sqrs(obj.loc, obj.get_abl('move_range'), blocked='ents', dir=dir)
                if path == []:
                    return
                else:
                    last = path[-1]
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                lock(Bot.ai_normal_move, obj, last)
                ents = [v for k,v in app.all_ents().items() if dist(v.loc,obj.loc)==1]
                def charge_loop(obj, ents):
                    if ents == []:
                        cancel_attack()
                    else:
                        ent = ents[0]
                        ents = ents[1:]
                        app.vis_dict['Goblin_Shaman_Charge'] = Vis(name = 'Goblin_Shaman_Charge', loc = ent.loc[:])
                        my_agl = obj.get_abl('agl')
                        tar_dod = ent.get_abl('dodge')
                        if to_hit(my_agl, tar_dod) == True:
                            my_str = obj.get_abl('str')
                            tar_end = ent.get_abl('end')
                            d = damage(my_str, tar_end)
                            lock(apply_damage, obj, ent, -d, 'slashing', 'Charge', 'melee')
                            charge_loop(obj, ents)
                        else:
                            miss(ent.loc)
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda obj = obj, ents = ents : charge_loop(obj, ents))
                charge_loop(obj, ents)
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Goblin_Shaman_Charge']
                    app.canvas.delete('Goblin_Shaman_Charge')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(charge_attack, obj = self)
        def add_charge_attack(actions = None, func = None):
            actions['Charge'] = func
            return actions
        p2 = partial(add_charge_attack, func = p)
        self.action_effects.append(p2)
        # STAT CHANGES
        def boar_move(stat):
            return stat+3
        p3 = partial(boar_move)
        self.move_range_effects.append(p3)
        def boar_stat(stat):
            return stat+3
        p4 = partial(boar_stat)
        self.str_effects.append(p4)
        self.end_effects.append(p4)
        self.agl_effects.append(p4)
        def boar_move_type(type):
            return 'charge'
        p5 = partial(boar_move_type)
        self.move_type_effects.append(p5)
        def un(ent, p2, p3, p4, p5, lockname = None):
            ent.action_effects.remove(p2)
            ent.move_range_effects.remove(p3)
            ent.str_effects.remove(p4)
            ent.agl_effects.remove(p4)
            ent.end_effects.remove(p4)
            ent.move_type_effects.remove(p5)
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2, p3, p4)
        n = 'charge' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Boar_Mount', undo_func = u, duration = self.get_abl('psyche'), level = self.get_abl('psyche'))
        self.finish_call_mount()
        
    def call_eyegaunt(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= 4
        self.acts -= 1
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = self.loc[:])
        def cleanup_smn():
            del app.vis_dict['Summon']
            app.canvas.delete('Summon')
        root.after(1999, cleanup_smn)
        self.init_eyegaunt_anims()
        # EFFECTS, bombard, mortar-like?
        def bombard_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : do_bombard(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : do_bombard(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def do_bombard(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/mortar.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                lock(Entity.ranged_attack, obj, sqr, 'Pain')
                ents = [v for k,v in app.all_ents().items() if dist(v.loc,sqr)<=1 and 'flying' != v.get_move_type()]
                def cleanup_bombard(n):
                    del app.vis_dict[n]
                    app.canvas.delete(n)
                def bombard_loop(obj, ents):
                    if ents == []:
                        cancel_attack()
                    else:
                        ent = ents[0]
                        ents = ents[1:]
                        app.get_focus(ent.id)
                        n = 'bombard'+str(app.count)
                        app.count += 1
                        app.vis_dict[n] = Vis(name = 'Pain', loc = ent.loc)
                        root.after(1666, lambda n = n : cleanup_bombard(n))
                        my_mm = obj.get_abl('mm')
                        tar_dod = ent.get_abl('dodge')
                        if to_hit(my_mm, tar_dod) == True:
                            my_msl = obj.get_abl('msl')
                            tar_end = ent.get_abl('end')
                            d = damage(my_msl, tar_end)
                            lock(apply_damage, obj, ent, -d, 'explosive', 'Bombard', 'ranged')
                            bombard_loop(obj, ents)
                        else:
                            miss(ent.loc)
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda obj = obj, ents = ents : bombard_loop(obj, ents))
                bombard_loop(obj, ents)
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                app.rebind_all()
                app.canvas.delete('text')
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(bombard_attack, obj = self)
        def add_bombard_attack(actions = None, func = None):
            actions['Bombard'] = func
            return actions
        p2 = partial(add_bombard_attack, func = p)
        self.action_effects.append(p2)
        # STAT CHANGES
        def eyegaunt_move(stat):
            return stat+2
        p3 = partial(eyegaunt_move)
        self.move_range_effects.append(p3)
        def eyegaunt_mm(stat):
            return stat+6
        p4 = partial(eyegaunt_mm)
        self.mm_effects.append(p4)
        self.msl_effects.append(p4)
        def eyegaunt_bls(stat):
            return stat+4
        p5 = partial(eyegaunt_bls)
        self.bls_effects.append(p5)
        def eye_wkns(ts):
            return ts+['elec']
        p6 = partial(eye_wkns)
        self.weak_effects.append(p6)
        def eye_fly(mt):
            return 'flying'
        p7 = partial(eye_fly)
        self.move_type_effects.append(p7)
        def un(ent, p2, p3, p4, p5, p6, p7, lockname = None):
            ent.action_effects.remove(p2)
            ent.move_range_effects.remove(p3)
            ent.mm_effects.remove(p4)
            ent.msl_effects.remove(p4)
            ent.bls_effects.remove(p5)
            ent.weak_effects.remove(p6)
            ent.move_type_effects.remove(p7)
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2, p3, p4, p5, p6, p7)
        n = 'bombard' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Eyegaunt_Mount', undo_func = u, duration = self.get_abl('psyche'), level = self.get_abl('psyche'))
        self.finish_call_mount()
            
            
    def finish_call_mount(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        

# other beastmaster stuff, orions call- all nrby? animal types moved to front of init q like time warp
# spiritual hammer- adj agl v agl, str v end crsh spl, on tar psy save fail rmv from init q
# heel- all nrby? animal types get -1 mvs 1 turn
class Beastmaster(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Spiritual Hammer':self.spiritual_hammer, "Wyld Hunt":self.wyld_hunt, 'Unsummon':self.unsummon, 'Sigil':self.sigil, "Orion's Call":self.orions_call, 'Heel':self.heel, 'Swarm':self.swarm}
            self.str = 7
            self.agl = 7
            self.end = 7
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 8
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.spirit = 35
            self.magick = 25
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        elif level == 2:
            self.actions = {'Move':self.move, 'Spiritual Hammer':self.spiritual_hammer, "Wyld Hunt":self.wyld_hunt, 'Unsummon':self.unsummon, 'Sigil':self.sigil, "Orion's Call":self.orions_call, 'Heel':self.heel, 'Swarm':self.swarm}
            self.str = 7
            self.agl = 7
            self.end = 7
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 8
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.spirit = 35
            self.magick = 25
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['piercing', 'slashing', 'crushing']
        super().__init__(name, id, img, loc, owner)
        
    def swarm(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_swarm)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_swarm(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Swarm', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_swarm(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_swarm(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/brambles.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Swarm', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Swarm', justify ='center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2 and 'animal' in v.get_types() and 'Swarm' not in [j.name for i,j in v.effects_dict.items()]]
        def cleanup_swarm(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        def swarm_loop(ents):
            if ents == []:
                self.finish_swarm()
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                s = ent.loc[:]
                u = 'Swarm' + str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Swarm', loc = s)
                app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = '+1 moves, move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = '+1 moves, move range', justify ='center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
                def swarm_move(stat):
                    return max(0,stat+1)
                p = partial(swarm_move)
                ent.mvs_effects.append(p)
                ent.move_range_effects.append(p)
                def un(ent, p, lockname = None):
                    ent.mvs_effects.remove(p)
                    ent.move_range_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                uf = partial(un, ent, p)
                n = 'swarm' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Swarm', undo_func = uf, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1555, lambda name = u : cleanup_swarm(name))
                root.after(1666, lambda ents = ents : swarm_loop(ents))
        swarm_loop(ents)
            
            
    def finish_swarm(self, event = None):
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.exists_check(app.active_ent)
        
    def heel(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_heel)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_heel(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Heel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_heel(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_heel(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Heel', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Heel', justify = 'center', fill = 'limegreen', font = ('chalkduster', 16), tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= 2 and 'animal' in v.get_types()]
        if ids == []:
            root.after(1666, self.finish_heel)
        else:
            self.heel_loop(ids)
    
    def heel_loop(self, ids):
        if ids == []:
            self.finish_heel()
        else:
            id = ids[0]
            ids = ids[1:]
            ent = app.ent_dict[id]
            un = 'heel'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Heel', loc = ent.loc[:])
            def cleanup_heel_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            if self.save_check('wis') == 'Pass':
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Heel, -1 moves', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Heel, -1 moves', justify = 'center', fill = 'limegreen', font = ('chalkduster', 16), tags = 'text')
                def heel_moves(stat):
                    return max(0,stat-1)
                p = partial(heel_moves)
                ent.mvs_effects.append(p)
                def undo(ent, p, lockname = None):
                    ent.mvs_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                
                root.after(1666, lambda un = un : cleanup_heel_vis(un))
                root.after(1777, lambda ids = ids : self.heel_loop(ids))
            else:
                miss(ent.loc)
                root.after(1555, lambda un = un : cleanup_heel(un))
                root.after(1666, lambda ids = ids : self.heel_loop(ids))
        
    def finish_heel(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
        
    def spiritual_hammer(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_spiritual_hammer)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_spiritual_hammer(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Spiritual Hammer Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_spiritual_hammer(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spiritual_hammer(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if self.magick < 1:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
        self.magick -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/assail.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Spiritual_Hammer'] = Vis(name = 'Spiritual_Hammer', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            # if animal type, remove from init q
            if 'animal' in ent.get_types():
                if ent.id in app.init_q:
                    app.init_q.remove(ent.id)
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Spiritual Hammer', 'spell')
            root.after(111, self.cancel_spiritual_hammer)
        else:
            miss(sqr)
            root.after(1777, self.cancel_spiritual_hammer)
        
    def cancel_spiritual_hammer(self, event = None):
        self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Spiritual_Hammer']
            app.canvas.delete('Spiritual_Hammer')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    # all nrby animal type moved to front of init q 
    def orions_call(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_orions_call)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_orions_call(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = "Confirm Orion's Call", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_orions_call(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_orions_call(self, event = None, sqrs = None):
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = "Orion's Call", justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = "Orion's Call", justify = 'center', fill = 'limegreen', font = ('chalkduster', 16), tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= 2 and 'animal' in v.get_types()]
        if ids == []:
            root.after(1666, self.finish_orions_call)
        else:
            self.orions_call_loop(ids)
    
    def orions_call_loop(self, ids):
        if ids == []:
            self.finish_orions_call()
        else:
            id = ids[0]
            ids = ids[1:]
            ent = app.ent_dict[id]
            un = 'orioncall'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = "Orion's_Call", loc = ent.loc[:])
            def cleanup_orion_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            if self.save_check('wis') == 'Pass':
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = "Orion's Call", justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = "Orion's Call", justify = 'center', fill = 'limegreen', font = ('chalkduster', 16), tags = 'text')
                if ent.id in app.init_q:
                    app.init_q.remove(ent.id)
                app.init_q = [ent.id]+app.init_q
                root.after(1666, lambda un = un : cleanup_orion_vis(un))
                root.after(1777, lambda ids = ids : self.orions_call_loop(ids))
            else:
                miss(ent.loc)
                root.after(1555, lambda un = un : cleanup_orion_vis(un))
                root.after(1666, lambda ids = ids : self.orions_call_loop(ids))
        
    def finish_orions_call(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
        
    def wyld_hunt(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_wyld_hunt)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_wyld_hunt(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Wyld Hunt', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_wyld_hunt(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wyld_hunt(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.id+'Wyld_Wolf' in app.all_ents().keys():
            return
        if self.id+'Wyld_Boar' in app.all_ents().keys():
            return
        if self.id+'Wyld_Eagle' in app.all_ents().keys():
            return
        if self.magick < 6:
            return
        self.magick -= 6
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        # smn Wolf, Boar, Eagle
        cs = [c for c in app.coords if app.grid[c[0]][c[1]]=='']
        if len(cs) < 3:
            app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Not enough locations...', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
            app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Not enough locations...', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 16), tags = 'text')
            root.after(1666,self.finish_wyld_hunt)
        else:
            def cleanup_summon(n):
                app.canvas.delete(n)
                del app.vis_dict[n]
            for wyld in ['Wyld_Wolf','Wyld_Boar','Wyld_Eagle']:
                loc = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, cs)
                cs.remove(loc)
                n = 'smn'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Summon', loc = loc[:])
                root.after(1666, lambda n = n : cleanup_summon(n))
                img = ImageTk.PhotoImage(Image.open('summon_imgs/'+wyld+'.png'))
                id = self.id+wyld
                app.ent_dict[id] =  eval(wyld)(name = wyld, id = id, img = img, loc = loc[:], owner = self.owner, level = self.level)
                app.grid[loc[0]][loc[1]] = id
            self.finish_wyld_hunt()
        
    def finish_wyld_hunt(self, event = None):
        app.generic_cancel()
        
    # destroy an adj animal smn, its owner draws 1 (do not allow campaign mode?)
    def unsummon(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_unsummon)
        sqrs = [c for c in app.coords if dist(self.loc, c)==1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_unsummon(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Unsummon Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_unsummon(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_unsummon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'animal' not in ent.get_types():
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Unsummon, draw 1', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Unsummon, draw 1', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Unsummon'] = Vis(name = 'Unsummon', loc = sqr[:])
        lock(app.kill, ent.id)
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        if witch.library != []:
            witch.in_hand.append(witch.library[0])
        witch.library = witch.library[1:]
        root.after(1666, self.finish_unsummon)
        
    def finish_unsummon(self, event = None):
        try: 
            del app.vis_dict['Unsummon']
            app.canvas.delete('Unsummon')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    # animal type gets resist or weak added
    def sigil(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_sigil)
        sqrs = [c for c in app.coords if dist(self.loc, c)==1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_sigil(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Sigil Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_sigil(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_sigil(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.spell_target_ents().keys()]:
            return
        ent = app.ent_dict[id]
        if 'animal' not in ent.get_types():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        if 'Sigil' in [v.name for k,v in ent.effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/devils_mark.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Sigil'] = Vis(name = 'Sigil', loc = sqr[:])
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(15, 15, text= 'Choose Type...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        kinds = ['slashing', 'piercing', 'crushing', 'fire', 'cold', 'elec', 'acid', 'poison', 'explosive', 'magick']
        for kind in kinds:
            b = tk.Button(app.context_menu, text = kind, wraplength = 190, font = ('chalkduster', 16), fg = 'tan3', highlightbackground = 'tan3', command = lambda ent = ent, kind = kind : self.choose_sigil_type(ent, kind))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            
    def choose_sigil_type(self, ent, kind):
        app.depop_context(event = None)
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(15, 15, text= 'Choose Resist or Weakness...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        wk_rst = ['Resist', 'Weakness']
        for weak_resist in wk_rst:
            b = tk.Button(app.context_menu, text = weak_resist, wraplength = 190, font = ('chalkduster', 16), fg = 'tan3', highlightbackground = 'tan3', command = lambda ent = ent, kind = kind, weak_resist = weak_resist : self.choose_sigil_weak_resist(ent, kind, weak_resist))
            b.pack(side = 'top')
            app.context_buttons.append(b)
    
    def choose_sigil_weak_resist(self, ent, kind, weak_resist):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = str(weak_resist)+' '+str(kind), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = str(weak_resist)+' '+str(kind), justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
        # add wkns or resist to ent
        if weak_resist == 'Resist':
            def sigil_resist(ts, kind = None):
                return ts+[kind]
            p = partial(sigil_resist, kind = kind)
            ent.resist_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.resist_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
        else:
            def sigil_weak(ts, kind = None):
                return ts+[kind]
            p = partial(sigil_weak, kind = kind)
            ent.weak_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.weak_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
        n = 'sigil'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Sigil', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_sigil)
        
    def cleanup_sigil(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Sigil']
            app.canvas.delete('Sigil')
        except: pass
        app.canvas.delete('text')


class Artificer(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Lost Artifact':self.lost_artifact, 'Globe of Invulnerability':self.globe, 'Globe Hover':self.globe_hover, 'Globe Roll':self.globe_roll, 'Recall Globe':self.recall_globe, 'Pyrrhic Gnomes':self.pyrrhic_gnomes, 'Bottle Gnomes':self.bottle_gnomes}
            self.str = 2
            self.agl = 6
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 7
            self.wis = 9
            self.rsn = 6
            self.san = 12
            self.init = 7
            self.spirit = 23
            self.magick = 27
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        elif level == 2:
            self.actions = {'Move':self.move, 'Lost Artifact':self.lost_artifact, 'Globe of Invulnerability':self.globe, 'Globe Hover':self.globe_hover, 'Globe Roll':self.globe_roll, 'Recall Globe':self.recall_globe, 'Pyrrhic Gnomes':self.pyrrhic_gnomes, 'Bottle Gnomes':self.bottle_gnomes}
            self.str = 3
            self.agl = 7
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 8
            self.wis = 10
            self.rsn = 7
            self.san = 13
            self.init = 8
            self.spirit = 29
            self.magick = 36
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        self.level = level
        self.move_type = 'normal'
        self.weak = ['slashing']
        self.resist = ['fire', 'explosive']
        super().__init__(name, id, img, loc, owner)
        
    # if a tomb in your discard is uniq among tombs in play, exile the card, put tomb in play at 1 spirit
    # choose target?
    def lost_artifact(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_lost_artifact)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_lost_artifact(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Lost Artifact', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_lost_artifact(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_lost_artifact(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        imprints = [v.imprint for k,v in app.all_ents().items() if isinstance(v,Tomb)]
        uniq_dis_tombs = [c for c in witch.discard if c not in app.summons_list and c not in imprints]
        if uniq_dis_tombs == []:
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(14, 14, text= 'Choose Arcana...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
        bg.create_text(15, 15, text= 'Choose Arcana...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        self.acts -= 1
        app.vis_dict['Lost_Artifact'] = Vis(name = 'Lost_Artifact', loc = self.loc[:])
        def cleanup_lost_art():
            del app.vis_dict['Lost_Artifact']
            app.canvas.delete('Lost_Artifact')
        root.after(1999, cleanup_lost_art)
        self.page_lost_art(cards=uniq_dis_tombs)
                    
                    
    def page_lost_art(self, event = None, cards = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, card in enumerate(cards[index:index+5]):
            i += 1
            p = partial(self.lost_art_return, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-5 : self.page_lost_art(cards = cards, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-5 : self.page_lost_art(cards = cards, index = i))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+5 : self.page_lost_art(cards = cards, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+5 : self.page_lost_art(cards = cards, index = i))
                    
                    
    def lost_art_return(self, event = None, card = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        # Exile card
        witch.discard.remove(card)
        witch.exile.append(card)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Exile '+card.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Exile '+card.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        cs = [c for c in app.coords if app.grid[c[0]][c[1]]=='']
        sqr = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b,cs)
        spell = witch.arcane_dict[card]
        witch.arcane_dict[card] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint+1,spell.times_cast)
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(witch.summon_ids)
        witch.summon_ids += 1
        def cleanup_lost_art(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        n = 'lost_art'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Lost_Artifact', loc = sqr[:])
        root.after(1666, lambda n = n : cleanup_lost_art(n))
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
        app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level, imprint = card)
        app.grid[sqr[0]][sqr[1]] = id
        app.ent_dict[id].spirit = 1
        root.after(1999, self.finish_lost_artifact)
            
            
    def finish_lost_artifact(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # map effect, atk and def efct (reduce incoming and outgoing dmg to max 2), move range -5, max 1 in play
    def globe(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_globe)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_globe(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Globe of Invulnerability Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_globe(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_globe(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Globe_of_Invulnerability' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        if 'Globe_of_Invulnerability'+self.id in [k for c in app.coords for k,v in app.loc_dict[tuple(c)].effects_dict.items()]:
            return
        if self.magick < 6:
            return
        if app.grid[sqr[0]][sqr[1]] in app.all_ents():
            ent = app.grid[sqr[0]][sqr[1]]
            if isinstance(ent, Witch):
                return
        self.magick -= 6
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Globe of Invulnerability', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Globe of Invulnerability', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
        un = 'Globe_of_Invulnerability' + str(self.id)
        app.vis_dict[un] = Vis(name = 'Globe_of_Invulnerability', loc = sqr[:])
        def globe_efct(stat):
            return max(0,stat-5)
        p = partial(globe_efct)
        def globe_attack(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                if amt < -2:
                    amt = -2
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+54-app.moved_down, text = 'Globe reduces attack', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+55-app.moved_down, text = 'Globe reduces attack', justify ='center', font = ('chalkduster', 13), fill = 'green3', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p2 = partial(globe_attack)
        def globe_defense(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                if amt < -2:
                    amt = -2
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Globe reduces attack', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Globe reduces attack', justify ='center', font = ('chalkduster', 13), fill = 'green3', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p3 = partial(globe_defense)
        app.loc_dict[tuple(sqr)].move_range_effects.append(p)
        app.loc_dict[tuple(sqr)].atk_effects.append(p2)
        app.loc_dict[tuple(sqr)].def_effects.append(p3)
        def undo(s, un, p, p2, p3, lockname = None):
            # need to get current sqr
            cs = [c for c in app.coords]
            sqr = [c for c in cs for k,v in app.loc_dict[tuple(c)].effects_dict.items() if k == un]
            sqr = sqr[0]
            app.loc_dict[tuple(sqr)].move_range_effects.remove(p)
            app.loc_dict[tuple(sqr)].atk_effects.remove(p2)
            app.loc_dict[tuple(sqr)].def_effects.remove(p3)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p, p2, p3)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Globe_of_Invulnerability', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = -5)
        root.after(1999, self.cleanup_globe)
        
    def cleanup_globe(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
    # relocate globe and any occupying ent to a loc wi range rsn
    def globe_hover(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_globe_hover)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_globe_hover(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = "Choose Caster's Globe", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_globe_hover(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_globe_hover(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'Globe_of_Invulnerability'+self.id not in app.loc_dict[tuple(sqr)].effects_dict.keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        id = app.grid[sqr[0]][sqr[1]]
        if id in app.all_ents().keys():
            ent = app.ent_dict[id]
            if ent.immovable == True:
                return
            has_ent = True
        else:
            has_ent = False
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.rebind_arrows()
        app.bind('<q>', app.generic_cancel)
        # choose location
        if has_ent == True:
            sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        else:
            sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_globe_hover)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, has_ent = has_ent, sqr = grid_pos, sqrs = sqrs : self.cont_globe_hover(e, id = id, has_ent = has_ent, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, has_ent = has_ent, sqr = grid_pos, sqrs = sqrs : self.cont_globe_hover(e, id=id, has_ent=has_ent, sqr=sqr, sqrs=sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
        
    def cont_globe_hover(self, event = None, id = None, has_ent = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        # move globe incrmntly, and ent if exists, move same time, use fly-type move
        global selected, selected_vis
        selected_vis.append('Globe_of_Invulnerability'+self.id)
        vis = app.vis_dict['Globe_of_Invulnerability'+self.id]
        if has_ent == True:
            selected.append(id)
        app.focus_square(sqr)
        effect1 = mixer.Sound('Sound_Effects/traced.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        x = vis.loc[0]*100+50-app.moved_right
        y = vis.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = vis.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 60 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep, id = ''):
            if acm >= tic:
                acm = 0
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)# +self.id for uniquely owned map effect
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_globe_hover(end_sqr, start_sqr, vis, id)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep, id = id : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys, id))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep, id)
            
        
    def finish_globe_hover(self, end_sqr, start_sqr, vis, id):
        global selected, selected_vis
        sound_effects.stop()
        selected_vis.remove('Globe_of_Invulnerability'+self.id)
        vis.loc = end_sqr[:]
        app.loc_dict[tuple(end_sqr)] = app.loc_dict[tuple(start_sqr)]
        app.loc_dict[tuple(start_sqr)] = Loc(start_sqr)
        if id != '':
            selected.remove(id)
            app.grid[end_sqr[0]][end_sqr[1]] = id
            app.grid[start_sqr[0]][start_sqr[1]] = ''
            app.ent_dict[id].loc = end_sqr[:]
        self.cancel_globe_hover()
        
    def cancel_globe_hover(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def recall_globe(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_recall_globe)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_recall_globe(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Recall Globe', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_recall_globe(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_recall_globe(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'Globe_of_Invulnerability'+self.id not in [k for c in app.coords for k,v in app.loc_dict[tuple(c)].effects_dict.items()]:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.rebind_arrows()
        # move globe incrmntly, and ent if exists, move same time, use fly-type move
        global selected, selected_vis
        selected_vis = ['Globe_of_Invulnerability'+self.id]
        vis = app.vis_dict['Globe_of_Invulnerability'+self.id]
        app.focus_square(sqr)
        effect1 = mixer.Sound('Sound_Effects/traced.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        x = vis.loc[0]*100+50-app.moved_right
        y = vis.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = vis.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 60 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep, id = ''):
            if acm >= tic:
                acm = 0
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)# +self.id for uniquely owned map effect
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                if id != '':
                    ent = app.ent_dict[id]
                    ent.rotate_image()
                    app.canvas.delete(ent.tags)
                    app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_recall_globe(end_sqr, start_sqr, vis, id)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
        
    def finish_recall_globe(self, end_sqr, start_sqr, vis, id):
        global selected, selected_vis
        sound_effects.stop()
        if id != '':
            selected.remove(id)
        selected_vis.remove('Globe_of_Invulnerability'+self.id)
        vis.loc = end_sqr[:]
        app.loc_dict[tuple(end_sqr)] = app.loc_dict[tuple(start_sqr)]
        app.loc_dict[tuple(start_sqr)] = Loc(start_sqr)
        self.cancel_recall_globe()
        
    def cancel_recall_globe(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
        
    # move globe (and ent inside) laterally at range psyche (unless impeded by 'block' loc), if ent is inside, any interceding ents are attacked by the occupying ent at its str vs end crushing melee
    def globe_roll(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_globe_roll)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_globe_roll(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = "Choose Caster's Globe", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_globe_roll(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_globe_roll(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'Globe_of_Invulnerability'+self.id not in app.loc_dict[tuple(sqr)].effects_dict.keys():
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.immovable == True:
            return
        if self.magick < 4:
            return
        self.magick -= 4
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.rebind_arrows()
        sqrs = lateral_sqrs(sqr[:], self.get_abl('psyche'), blocked='blocks')
        dirs = [c for c in app.coords if dist(c,sqr[:])==1]
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_globe_hover)
        else:
            app.animate_squares(dirs)
            root.bind('<a>', lambda e, ent = ent, sqr = grid_pos, sqrs = dirs : self.cont_globe_roll(e, ent = ent, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Direction', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, ent = ent, sqr = grid_pos, sqrs = dirs : self.cont_globe_roll(e, ent, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
        
    def cont_globe_roll(self, event = None, ent = None, sqr = None, sqrs = None):
        global selected, selected_vis
        if sqr not in sqrs:
            return
        app.cleanup_squares()
        app.unbind_all()
        app.depop_context(event = None)
        if ent.loc[0] < sqr[0]:
            dir = 'east'
        elif ent.loc[1] < sqr[1]:
            dir = 'south'
        elif ent.loc[0] > sqr[0]:
            dir = 'west'
        elif ent.loc[1] > sqr[1]:
            dir = 'north'
        sqrs = lateral_sqrs(ent.loc[:], self.get_abl('psyche'), blocked='blocks', dir=dir)
        sqr = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, sqrs)
        # move globe incrmntly, and ent if exists, move same time, use fly-type move
        selected_vis.append('Globe_of_Invulnerability'+self.id)
        vis = app.vis_dict['Globe_of_Invulnerability'+self.id]
        selected.append(ent.id)
#         app.grid[ent.loc[0]][ent.loc[1]] = ''
        app.focus_square(sqr)
        effect1 = mixer.Sound('Sound_Effects/traced.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        x = vis.loc[0]*100+50-app.moved_right
        y = vis.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = vis.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 60 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep, ent):
            if acm >= tic:
                acm = 0
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)# +self.id for uniquely owned map effect
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                ent.rotate_image()
                app.canvas.delete(ent.tags)
                app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                ent.rotate_image()
                app.canvas.delete(ent.tags)
                app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                ent.rotate_image()
                app.canvas.delete(ent.tags)
                app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                ent.rotate_image()
                app.canvas.delete(ent.tags)
                app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                vis.rotate_image()
                app.canvas.delete(vis.name+self.id)
                app.canvas.create_image(x, y, image = vis.img, tags = vis.name+self.id)
                ent.rotate_image()
                app.canvas.delete(ent.tags)
                app.canvas.create_image(x, y, image = ent.img, tags = ent.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_globe_roll(end_sqr, start_sqr, vis, ent)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep, ent = ent : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys, ent))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep, ent)
            
        
    def finish_globe_roll(self, end_sqr, start_sqr, vis, ent):
        global selected, selected_vis
        sound_effects.stop()
        # move any occupying ent at loc to nrst '' sqr, get all interceding ents, perform ent's atk
        if start_sqr[0] < end_sqr[0]:
            dir = 'east'
        elif start_sqr[1] < end_sqr[1]:
            dir = 'south'
        elif start_sqr[0] > end_sqr[0]:
            dir = 'west'
        elif start_sqr[1] > end_sqr[1]:
            dir = 'north'
        path = lateral_sqrs(start_sqr, dist(start_sqr,end_sqr), blocked='blocks', dir=dir)
        oldid = app.grid[end_sqr[0]][end_sqr[1]]
        ents = [v for k,v in app.all_ents().items() if v.loc in path and v != ent and k != oldid]
        if oldid in app.all_ents().keys():
            e = app.ent_dict[oldid]
            cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
            nrst = reduce(lambda a,b : a if dist(a,e.loc)<dist(b,e.loc) else b,cs)
            lock(Bot.do_move, e, nrst)
        selected.remove(ent.id)
        selected_vis.remove('Globe_of_Invulnerability'+self.id)
        vis.loc = end_sqr[:]
        app.loc_dict[tuple(end_sqr)] = app.loc_dict[tuple(start_sqr)]
        app.loc_dict[tuple(start_sqr)] = Loc(start_sqr)
        app.grid[end_sqr[0]][end_sqr[1]] = ent.id
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.ent_dict[ent.id].loc = end_sqr[:]
        self.final_globe(ent, ents, path)
        
    def final_globe(self, globe_ent, ents, path):
        for e in ents:
            cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and c not in path]
            nrst = reduce(lambda a,b : a if dist(a,e.loc)<dist(b,e.loc) else b,cs)
            # perform atk, globe_ent on e
            if e.loc != path[-1] and e.save_check('dodge', mod = -4) == 'Pass':
                app.canvas.create_text(e.loc[0]*100-app.moved_right+49, e.loc[1]*100-app.moved_down+34, text = 'Dodge save...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(e.loc[0]*100-app.moved_right+50, e.loc[1]*100-app.moved_down+35, text = 'Dodge save...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            else:
                d = damage(globe_ent.get_abl('str'),e.get_abl('end'))
                lock(apply_damage, globe_ent, e, -d, 'crushing', 'Globe Roll', 'globe_roll')
                if e.id in app.all_ents().keys():
                    lock(Bot.ai_flying_move, e, nrst)
        root.after(1666, self.cancel_globe_roll)
        
    def cancel_globe_roll(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    # summon inert ent, on init choose a smn type, gnome seeks the smn type if it exists, will only occupy locs as near as possible to targets otherwise not affecting them, has death trigger that does 3*turns_since_init to adjacent ents
    # max 2-3?
    def pyrrhic_gnomes(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pyrrhic_gnomes)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1 and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_pyrrhic_gnomes(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Pyrrhic Gnomes", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_pyrrhic_gnomes(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pyrrhic_gnomes(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if len([k for k,v in app.all_ents().items() if v.id.startswith(self.id) and v.name == 'Pyrrhic_Gnome']) > 1:
            return
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Gnome_Assemble'] = Vis(name = 'Gnome_Assemble', loc = sqr[:])
        def cleanup_summon():
            app.canvas.delete('Gnome_Assemble')
            del app.vis_dict['Gnome_Assemble']
        root.after(2333, cleanup_summon)
        root.after(2333, lambda s = sqr[:] : self.continue_pyrrhic_gnomes(s))
        
    def continue_pyrrhic_gnomes(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Pyrrhic_Gnome.png'))
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        id = self.id+'Pyrrhic_Gnome'+str(witch.summon_ids)
        witch.summon_ids += 1
        app.ent_dict[id] =  Pyrrhic_Gnome(name = 'Pyrrhic_Gnome', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_pyrrhic_gnomes()
        
    def finish_pyrrhic_gnomes(self, event = None):
        app.generic_cancel()
        
    # inert ent that wanders, atks randomly, has death trigger- owner witch gains 1 magick
    # max 2-3?
    def bottle_gnomes(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bottle_gnomes)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1 and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bottle_gnomes(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Bottle Gnomes", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bottle_gnomes(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bottle_gnomes(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if len([k for k,v in app.all_ents().items() if v.id.startswith(self.id) and v.name == 'Bottle_Gnome']) > 4:
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Gnome_Assemble'] = Vis(name = 'Gnome_Assemble', loc = sqr[:])
        def cleanup_summon():
            app.canvas.delete('Gnome_Assemble')
            del app.vis_dict['Gnome_Assemble']
        root.after(2333, cleanup_summon)
        root.after(2333, lambda s = sqr[:] : self.continue_bottle_gnomes(s))
        
    def continue_bottle_gnomes(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Bottle_Gnome.png'))
        if self.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        id = self.id+'Bottle_Gnome'+str(witch.summon_ids)
        witch.summon_ids += 1
        app.count += 1
        app.ent_dict[id] =  Bottle_Gnome(name = 'Bottle_Gnome', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_bottle_gnomes()
        
    def finish_bottle_gnomes(self, event = None):
        app.generic_cancel()
    


class Diabolist(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Efface':self.efface, 'Graverob':self.graverob, 'Lobotomy':self.lobotomy, 'Poison Weapon':self.poison_weapon, 'Infiltrate':self.infiltrate, 'Retreating Strike':self.retreating_strike}
            self.str = 5
            self.agl = 8
            self.end = 4
            self.mm = 7
            self.msl = 0
            self.bls = 0
            self.dodge = 8
            self.psyche = 5
            self.wis = 5
            self.rsn = 5
            self.san = 14
            self.init = 9
            self.spirit = 17
            self.magick = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Efface':self.efface, 'Graverob':self.graverob, 'Lobotomy':self.lobotomy, 'Poison Weapon':self.poison_weapon, 'Infiltrate':self.infiltrate, 'Retreating Strike':self.retreating_strike}
            self.str = 6
            self.agl = 9
            self.end = 5
            self.mm = 8
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 6
            self.wis = 6
            self.rsn = 6
            self.san = 15
            self.init = 10
            self.spirit = 23
            self.magick = 17
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison']
        super().__init__(name, id, img, loc, owner)
        
    # choose a tomb you own and a tomb opnt owns with imprints != '', remove those imprints from owners
    def efface(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_efface)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc)]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_efface(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Your Tomb', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_efface(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_efface(self, event = None, sqr = None, sqrs = None):
        if self.magick < 3:
            return
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        tomb = app.ent_dict[id]
        if tomb.imprint == '':
            return
        if tomb.owner != self.owner:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        app.cleanup_squares()
        root.bind('<q>', self.cleanup_efface)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs, tomb1 = tomb: self.cont_efface(e, sqr = sqr, sqrs = sqrs, tomb1 = tomb1))
        b = tk.Button(app.context_menu, text = 'Choose Second Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs, tomb1 = tomb : self.cont_efface(event = e, sqr = sqr, sqrs = sqrs, tomb1 = tomb1))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
            
            
    def cont_efface(self, event = None, sqr = None, sqrs = None, tomb1 = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        tomb2 = app.ent_dict[id]
        if isinstance(tomb2, Tomb) == False:
            return
        if tomb1.owner == tomb2.owner:
            return
        if tomb2.imprint == '':
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= 3
        self.acts -= 1
        if self.owner == 'p1':
            witch1 = app.ent_dict[app.p1_witch]
            spell = witch1.arcane_dict[tomb1.imprint]
            witch1.arcane_dict[tomb1.imprint] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
            witch2 = app.ent_dict[app.p2_witch]
            spell = witch2.arcane_dict[tomb2.imprint]
            witch2.arcane_dict[tomb2.imprint] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
        else:
            witch1 = app.ent_dict[app.p2_witch]
            spell = witch1.arcane_dict[tomb1.imprint]
            witch1.arcane_dict[tomb1.imprint] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
            witch2 = app.ent_dict[app.p1_witch]
            spell = witch2.arcane_dict[tomb2.imprint]
            witch2.arcane_dict[tomb2.imprint] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
        tomb1.imprint = ''
        tomb2.imprint = ''
        def cleanup_efface(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        n1 = 'efface'+str(app.count)
        app.count += 1
        n2 = 'efface'+str(app.count)
        app.count += 1
        app.vis_dict[n1] = Vis(name = 'Efface', loc = tomb1.loc)
        app.vis_dict[n2] = Vis(name = 'Efface', loc = tomb2.loc)
        root.after(1999, lambda n1 = n1 : cleanup_efface(n1))
        root.after(1999, lambda n2 = n2 : cleanup_efface(n2))
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+34, text = 'Remove Imprints', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+35, text = 'Remove Imprints', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        root.after(2111, self.cleanup_efface)
    
    
    def cleanup_efface(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # remove a card from opnt dscrd to heal 6 sprt/mgk self
    def graverob(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_graverob)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_graverob(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Graverob', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_graverob(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_graverob(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if app.num_players == 1:
            return
        if self.owner == 'p1':
            witch = app.ent_dict[app.p2_witch]
        else:
            witch = app.ent_dict[app.p1_witch]
        if witch.discard == []:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Graverob', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Graverob', justify = 'center', fill = 'gray', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Graverob'] = Vis(name = 'Graverob', loc = sqr[:])
        self.page_graverob(cards = witch.discard[:])
        
    def page_graverob(self, event = None, cards = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, card in enumerate(cards[index:index+5]):
            i += 1
            p = partial(self.graverob_remove, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda name = card : action_description(name))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-5 : self.page_graverob(cards = cards, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-5 : self.page_graverob(cards = cards, index = i))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+5 : self.page_graverob(cards = cards, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+5 : self.page_graverob(cards = cards, index = i))
                    
                    
            
    def graverob_remove(self, event = None, card = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        if self.owner == 'p1':
            witch = app.ent_dict[app.p2_witch]
        else:
            witch = app.ent_dict[app.p1_witch]
        witch.discard.remove(card)
        witch.exile.append(card)
        apply_heal(self, self, 6)
        self.magick += 6
        if self.magick > self.base_magick:
            self.magick = self.base_magick
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Remove '+str(card).replace('_',' ')+' +6 spirit,magick', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Remove '+str(card).replace('_',' ')+' +6 spirit,magick', justify = 'center', fill = 'gray', font = ('chalkduster', 16), tags = 'text')
        root.after(1999, self.finish_graverob)
            
            
    def finish_graverob(self, event = None):
        try:
            del app.vis_dict['Graverob']
            app.canvas.delete('Graverob')
        except:
            pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # adj any tar agl vs agl str vs end, on hit witch, search library for 1 and remove
    def lobotomy(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_lobotomy)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_lobotomy(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Lobotomy', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_lobotomy(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_lobotomy(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Lobotomy'] = Vis(name = 'Lobotomy', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            if isinstance(ent,Witch):
                if ent.library == []:
                    lock(apply_damage, self, ent, -d, 'piercing', 'Lobotomy', 'melee')
                    root.after(111, self.cancel_lobotomy)
                else:
                    self.page_lobotomy(cards = ent.library[:], ent = ent)
            else:
                lock(apply_damage, self, ent, -d, 'piercing', 'Lobotomy', 'melee')
                root.after(111, self.cancel_lobotomy)
        else:
            miss(sqr)
            root.after(1999, self.cancel_lobotomy)
        
    def page_lobotomy(self, cards = None, index = 0, ent = None):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, card in enumerate(cards[index:index+5]):
            i += 1
            p = partial(self.lobotomy_remove, card = card, witch = ent)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-5, ent = ent : self.page_lobotomy(cards = cards, index = i, ent = ent))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-5, ent = ent : self.page_lobotomy(cards = cards, index = i, ent = ent))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+5, ent = ent : self.page_lobotomy(cards = cards, index = i, ent = ent))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+5, ent = ent : self.page_lobotomy(cards = cards, index = i, ent = ent))
                    
                    
            
    def lobotomy_remove(self, event = None, card = None, witch = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        witch.library.remove(card)
        witch.exile.append(card)
        shuffle(witch.library)
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Remove '+str(card).replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Remove '+str(card).replace('_',' '), justify = 'center', fill = 'gray', font = ('chalkduster', 16), tags = 'text')
        my_str = self.get_abl('str')
        target_end = witch.get_abl('end')
        d = damage(my_str, target_end)
        lock(apply_damage, self, witch, -d, 'piercing', 'Lobotomy', 'melee')
        root.after(111, self.cancel_lobotomy)
    
    def cancel_lobotomy(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Lobotomy']
            app.canvas.delete('Lobotomy')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # an adjacent ent gains an attack effect that changes melee or ranged to poison and adds eot 3 psn dmg at duration rsn and level str
    def poison_weapon(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_poison_weapon)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_poison_weapon(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Poison Weapon Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_poison_weapon(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_poison_weapon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Poison_Weapon' in ent.effects_dict.keys():
            return
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Poison_Weapon'] = Vis(name = 'Poison_Weapon', loc = sqr[:])
        def psn_wpn_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged':
                type = 'poison'
                n = 'psn_wpn'+str(app.count)
                def take_3(ent, lockname = None):
                    app.get_focus(ent.id)
                    lock(apply_damage, self, ent, -3, 'poison', 'Poison Weapon', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                eot = partial(take_3, dfndr)
                def un(lockname = None):
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un)
                dfndr.effects_dict[n] = Effect(name = 'Weapon_Poison', eot_func = eot , undo_func = u, duration = atkr.get_abl('rsn'), level = atkr.get_abl('str'))
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(psn_wpn_atk)
        ent.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        ent.effects_dict['Poison_Weapon'] = Effect(name = 'Poison_Weapon', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Poison Attack', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Poison Attack', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        root.after(2111, self.finish_poison_weapon)
        
        
    def finish_poison_weapon(self, event = None):
        try: 
            del app.vis_dict['Poison_Weapon']
            app.canvas.delete('Poison_Weapon')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    # caster and adj frndly are rlctd among the closest empty sqrs to target loc wi rng rsn, both gain invis until eot
    def infiltrate(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_infiltrate)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.finish_infiltrate)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc)<=self.get_abl('move_range')]
        app.cleanup_squares()
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, ent = ent, sqr = grid_pos, sqrs = sqrs : self.do_infiltrate(e, ent = ent, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, ent = ent, sqr = grid_pos, sqrs = sqrs : self.do_infiltrate(e, ent, sqr, sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_infiltrate(self, event = None, ent = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/throw.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        def cleanup_infil(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for e in [self, ent]:
            def infil_invis(ts):
                return ts+['invisibility']
            p = partial(infil_invis)
            e.type_effects.append(p)
            def undo(e, p, lockname = None):
                e.type_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, e, p)
            n = 'infiltrate'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Infiltrate', loc = e.loc)
            root.after(1666, lambda n = n : cleanup_infil(n))
            e.effects_dict[n] = Effect(name = 'Infiltrate', undo_func = u, duration = 1, level = self.get_abl('wis'))
        if len(cs) < 2:
            self.finish_infiltrate()
        else:
            loc1 = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b ,cs)
            cs.remove(loc1)
            loc2 = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b ,cs)
            root.after(333, lambda ents = [self,ent], locs = [loc1,loc2] : self.cont_infiltrate(ents, locs))
        
    def cont_infiltrate(self, ents, locs):
        lock(Bot.ai_teleport_move, ents[0], locs[0])
        lock(Bot.ai_teleport_move, ents[1], locs[1])
        root.after(333, self.finish_infiltrate)
    
    def finish_infiltrate(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # atk adj and rlct to any wi move range, gain invis 1 turn
    def retreating_strike(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_retreating_strike)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_strike(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_strike(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_strike(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.finish_retreating_strike)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc)<=self.get_abl('move_range') and app.grid[c[0]][c[1]]=='']
        app.cleanup_squares()
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, ent = ent, sqr = grid_pos, sqrs = sqrs : self.do_retreating_strike(e, ent = ent, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, ent = ent, sqr = grid_pos, sqrs = sqrs : self.do_retreating_strike(e, ent, sqr, sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_retreating_strike(self, event = None, ent = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        s = sqr[:]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/throw.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        # atk ent, rlct self to sqr
        if to_hit(self.get_abl('agl'), ent.get_abl('agl')):
            d = damage(self.get_abl('str'), ent.get_abl('end'))
            lock(apply_damage, self, ent, -d, 'slashing', 'Retreating Strike', 'melee')
            root.after(111, lambda sqr = s : self.cont_retreating_strike(sqr))
        else:
            miss(ent.loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, lambda sqr = s : self.cont_retreating_strike(sqr))
            
    def cont_retreating_strike(self, sqr):
        lock(Bot.ai_teleport_move, self, sqr)
        app.get_focus(self.id)
        app.vis_dict['Retreating_Strike'] = Vis(name = 'Retreating_Strike', loc = sqr)
        def infil_invis(ts):
            return ts+['invisibility']
        p = partial(infil_invis)
        self.type_effects.append(p)
        def undo(e, p, lockname = None):
            e.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'r_strike'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Retreating_Strike', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(1666, self.finish_retreating_strike)
    
    def finish_retreating_strike(self, event = None):
        try:
            del app.vis_dict['Retreating_Strike']
            app.canvas.delete('Retreating_Strike')
        except:
            pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()


class Illusionist(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Pyrotechnics':self.pyrotechnics, 'Simulacrum':self.simulacrum,'Gate':self.gate, 'Mortar':self.mortar, 'Smoke Bomb':self.smoke_bomb, 'Analyze':self.analyze}
            self.str = 2
            self.agl = 4
            self.end = 4
            self.mm = 7
            self.msl = 4
            self.bls = 8
            self.dodge = 7
            self.psyche = 5
            self.wis = 6
            self.rsn = 6
            self.san = 14
            self.init = 7
            self.spirit = 14
            self.magick = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Pyrotechnics':self.pyrotechnics, 'Simulacrum':self.simulacrum,'Gate':self.gate, 'Mortar':self.mortar, 'Smoke Bomb':self.smoke_bomb, 'Analyze':self.analyze, 'Tracer Grenade':self.tracer_grenade, 'Doubling Cube':self.doubling_cube}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 8
            self.msl = 6
            self.bls = 9
            self.dodge = 7
            self.psyche = 6
            self.wis = 7
            self.rsn = 7
            self.san = 13
            self.init = 8
            self.spirit = 21
            self.magick = 17
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'teleport'
        self.weak = ['crushing']
        self.resist = ['explosive', 'fire']
        super().__init__(name, id, img, loc, owner)

    def analyze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_analyze)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_analyze(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Analyze Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_analyze(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_analyze(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Analyze', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Analyze', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Analyze'] = Vis(name = 'Analyze', loc = sqr[:])
        vis = app.vis_dict['Analyze']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Analyze')
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            def analyze_resist(rs):
                return [r for r in rs if r != 'slashing' and r != 'piercing' and r != 'crushing' and r != 'explosive']
            p1 = partial(analyze_resist)
            ent.resist_effects.append(p1)
            def undo(id, p1, lockname = None):
                app.ent_dict[id].resist_effects.remove(p1)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1)
            n = 'Analyze' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Analyze', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Remove physical resists', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Remove physical resists', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_analyze)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.finish_analyze)

        
    def finish_analyze(self, event = None):
        try: 
            del app.vis_dict['Analyze']
            app.canvas.delete('Analyze')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()


    def smoke_bomb(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Spore_Cloud' in loc_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_smoke_bomb)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_smoke_bomb(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Smoke Bomb Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_smoke_bomb(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_smoke_bomb(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Smoke_Bomb' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Smoke Bomb', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Smoke Bomb', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Smoke_Bomb' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Smoke_Bomb', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def smoke_effect(types):
            return types+['invisibility']
        p = partial(smoke_effect)
        app.loc_dict[tuple(sqr)].type_effects.append(p)
        def undo(s, un, p_ef, lockname = None):
            app.loc_dict[tuple(s)].type_effects.remove(p_ef)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Smoke_Bomb', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('mm'), loc = sqr[:], avoid = -5)
        root.after(1666, self.cleanup_smoke_bomb)
        
    def cleanup_smoke_bomb(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass

    def doubling_cube(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_doubling_cube)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_doubling_cube(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Doubling Cube Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_doubling_cube(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_doubling_cube(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if 'Doubling_Cube' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Doubling Cube', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Doubling Cube', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
        def cleanup_dubcube(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        s = ent.loc[:]
        uniq = 'Doubling_Cube'+str(app.count)
        app.count += 1
        app.vis_dict[uniq] = Vis(name = 'Doubling_Cube', loc = s)
        root.after(2555, lambda n = uniq : cleanup_dubcube(n))
        app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Doubling_Cube')
        app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+64, text = 'Doubled...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+65, text = 'Doubled...', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
        def doubled(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' and (type == 'slashing' or type == 'piercing' or type == 'crushing') and amt < 0:
                if to_hit(atkr.get_abl('psyche'),dfndr.get_abl('psyche')):
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+74, text = 'Attacker psyche hit, avoids double...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+75, text = 'Attacker psyche hit, avoids double...', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
                else:
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+74, text = 'Double Absorbs, dmg reduced to 1', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+75, text = 'Double Absorbs, dmg reduced to 1', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(doubled)
        ent.defense_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.defense_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Doubling_Cube'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Doubling_Cube', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_doubling_cube)
        
        
        
    def finish_doubling_cube(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)


    def tracer_grenade(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_mortar)
        sqrs = [s for s in app.coords if (self.get_abl('bls')) < dist(self.loc, s) <= (self.get_abl('bls')+2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_tracer_grenade(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Grenade', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_tracer_grenade(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tracer_grenade(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/mortar.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Tracer_Grenade'] = Vis(name = 'Tracer_Grenade', loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
        selected_vis.append('Tracer_Grenade')
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def mortar_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                app.vis_dict['Tracer_Grenade'].rotate_image()
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.continue_tracer_grenade(end_sqr)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : mortar_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        mortar_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
        
    def continue_tracer_grenade(self, sqr):
        global selected_vis
        app.canvas.delete('text')
        del app.vis_dict['Tracer_Grenade']
        app.canvas.delete('Tracer_Grenade')
        selected_vis.remove('Tracer_Grenade')
        effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict['Tracer_Exploded'] = Vis(name = 'Tracer_Exploded', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Tracer_Exploded'].img, tags = 'Tracer_Exploded')
        def cleanup_explode():
            del app.vis_dict['Tracer_Exploded']
            app.canvas.delete('Tracer_Exploded')
        root.after(999, cleanup_explode)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 2 and 'Tracer_Grenade' not in [j.name for j in v.effects_dict.values()]]
        # mortar loop
        def mortar_loop(ents):
            if ents == []:
                self.cleanup_mortar()
            else:
                effect1 = mixer.Sound('Sound_Effects/traced.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                n = 'Traced' + str(app.count)
                app.count += 1
                loc = app.ent_dict[id].loc[:]
                app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Traced', loc = loc)
                def cleanup_vis(name):
                    app.canvas.delete('text')
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')):
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Traced...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Traced...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    def tracer_effect(stat):
                        stat -= 4
                        if stat < 1:
                            return 1
                        else:
                            return stat
                    p = partial(tracer_effect)
                    app.ent_dict[id].dodge_effects.append(p)
                    def tracer_strip(types):
                        return [t for t in types if t != 'invisibility']
                    p2 = partial(tracer_strip)
                    app.ent_dict[id].type_effects.append(p2)
                    def undo(id, p, p2, lockname = None):
                        app.ent_dict[id].dodge_effects.remove(p)
                        app.ent_dict[id].type_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p, p2)
                    app.ent_dict[id].effects_dict['Tracer_Grenade'] = Effect(name = 'Tracer_Grenade', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('bls'))
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
                else:
                    miss(app.ent_dict[id].loc[:])
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
        mortar_loop(ents)
        
    def cleanup_tracer_grenade(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
#         app.unbind_all()
        app.rebind_all()



    def mortar(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_mortar)
        sqrs = [s for s in app.coords if self.get_abl('bls') < dist(self.loc, s) <= (self.get_abl('bls')+2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_mortar(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Mortar', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mortar(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mortar(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/mortar.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Mortar'] = Vis(name = 'Mortar', loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
        selected_vis.append('Mortar')
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def mortar_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                app.vis_dict['Mortar'].rotate_image()
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.continue_mortar(end_sqr)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : mortar_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        mortar_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
        
    def continue_mortar(self, sqr):
        global selected_vis
        app.canvas.delete('text')
        del app.vis_dict['Mortar']
        app.canvas.delete('Mortar')
        selected_vis.remove('Mortar')
        effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.vis_dict['Mortar_Exploded'] = Vis(name = 'Mortar_Exploded', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mortar_Exploded'].img, tags = 'Mortar_Exploded')
        def cleanup_explode():
            del app.vis_dict['Mortar_Exploded']
            app.canvas.delete('Mortar_Exploded')
        root.after(999, cleanup_explode)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 2]
        # mortar loop
        def mortar_loop(ents):
            if ents == []:
                self.cleanup_mortar()
            else:
                effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                n = 'Pain_Explode' + str(app.count)
                app.count += 1
                loc = app.ent_dict[id].loc[:]
#                 root.after(13,lambda loc = loc : app.focus_square(loc))
                app.focus_square(loc)
#                 app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Pain_Explode', loc = loc)
                def cleanup_vis(name):
                    app.canvas.delete('text')
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
                    d = max(1,(self.get_abl('msl')-choice([1,2,3])))
                    root.after(1666, lambda name = n : cleanup_vis(name))
                    lock(apply_damage, self, app.ent_dict[id], -d, 'explosive', 'Mortar', 'ranged')
                    mortar_loop(ents)
                else: # MISS
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
        mortar_loop(ents)
        
    def cleanup_mortar(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
#         app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def pyrotechnics(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_pyrotechnics)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pyrotechnics(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Pyrotechnics', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pyrotechnics(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pyrotechnics(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Pyrotechnics'] = Vis(name = 'Pyrotechnics', loc = sqr[:])
        vis = app.vis_dict['Pyrotechnics']
        if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
            d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
            root.after(1666, lambda e = None : self.cleanup_pyrotechnics(event = e))
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Pyrotechnics', 'ranged')
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, lambda e = None : self.cleanup_pyrotechnics(event = e))
        
    def cleanup_pyrotechnics(self, event = None):
        try: 
            del app.vis_dict['Pyrotechnics']
            app.canvas.delete('Pyrotechnics')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def simulacrum(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_simulacrum)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_simulacrum(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Simulacrum', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_simulacrum(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_simulacrum(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 2:
            return
        if 'Simulacrum' in ent.effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 2
        # DO SIMULACRUM EFFECTS
        def simulacrum_effect(stat):
            stat += 3
            return stat
        p = partial(simulacrum_effect)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        def un(ent, func, lockname = None):
            ent.agl_effects.remove(func)
            ent.dodge_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Simulacrum' + str(app.count)
        ent.effects_dict['Simulacrum'] = Effect(name = 'Simulacrum', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        # DO SIMULACRUM VISUALS
        start_loc = ent.loc[:]
        app.vis_dict['Simulacrum'] = Vis(name = 'Simulacrum', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Simulacrum'].img, tags = ('Simulacrum','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Simulacrum'].img, tags = ('Simulacrum','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Simulacrum', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Simulacrum', font = ('chalkduster', 14), fill = 'lightcyan', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis.append('Simulacrum')
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Simulacrum','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Simulacrum', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Simulacrum','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                def rmv_vis():
                    selected_vis.remove('Simulacrum')
                root.after(555, rmv_vis)
                root.after(666, self.cleanup_simulacrum)
            else:
                root.after(100, lambda vis = 'Simulacrum', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Simulacrum', x, y, end_left, id)
        simulacrum_loop_right('Simulacrum', x, y, end_right, id)
        
        
    def cleanup_simulacrum(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Simulacrum']
            app.canvas.delete('Simulacrum')
        except: pass
        app.canvas.delete('text')
        
        
    def gate(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_gate)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if app.ent_dict[id].immovable == True:
            return
        if self.magick < 2:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_gate)
        distance = self.get_abl('rsn')
        app.cleanup_squares()
        sqrs = [c for c in app.coords if dist(self.loc,c)<=distance and app.grid[c[0]][c[1]]=='']
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_gate)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id = id, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
    
    def do_gate(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        self.magick -= 2
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_gate(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        n = 'gate'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Gate', loc = ent.loc[:])
        root.after(1666, lambda n = n : cleanup_gate(n))
        n = 'gate'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Gate', loc = sqr[:])
        root.after(1999, lambda n = n : cleanup_gate(n))
        lock(Bot.ai_teleport_move, ent, sqr)
        self.cleanup_gate()
    
    def cleanup_gate(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
class Umbrae_Wolf(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift}
            self.str = 5
            self.agl = 5
            self.end = 4
            self.mm = 7
            self.msl = 6
            self.bls = 5
            self.dodge = 5
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 13
            self.init = 5
            self.spirit = 17
            self.magick = 9
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Darkblast':self.darkblast, 'Stalk':self.stalk, 'Phase Shift':self.phase_shift}
            self.str = 6
            self.agl = 8
            self.end = 6
            self.mm = 7
            self.msl = 8
            self.bls = 6
            self.dodge = 8
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 12
            self.init = 8
            self.spirit = 22
            self.magick = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = ['elec']
        self.resist = ['cold']
        self.form = 'umbrae_wolf'
        super().__init__(name, id, img, loc, owner)
        
    def init_normal_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        if self.form == 'umbrae_wolf':
            anims = [a for r,d,a in walk('./animations/Umbrae_Wolf/')][0]
            anims = [a for a in anims[:] if a[-3:] == 'png']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/Umbrae_Wolf/' + anim))
                self.anim_dict[i] = a
        elif self.form == 'umbrae_mist':
            anims = [a for r,d,a in walk('./animations/Umbrae_Mist/')][0]
            anims = [a for a in anims[:] if a[-3:] == 'png']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/Umbrae_Mist/' + anim))
                self.anim_dict[i] = a
        
    def phase_shift(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_phase_shift)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_phase_shift(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Phase Shift', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_phase_shift(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_phase_shift(self, event = None):
        global selected
        selected.append(self.tags)
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.acts -= 1
        app.canvas.delete(self.tags)
        app.vis_dict['Phase_Shift'] = Vis(name = 'Phase_Shift', loc = self.loc[:])
        vis = app.vis_dict['Phase_Shift']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Phase_Shift')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Phase Shift', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Phase Shift', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # shift from one phase to the other...
        if self.form == 'umbrae_wolf':
            if self.level == 1:
                self.form = 'umbrae_mist'
                self.str = 2
                self.agl = 4
                self.end = 3
                self.mm = 3
                self.msl = 3
                self.bls = 6
                self.dodge = 7
                self.psyche = 7
                self.wis = 7
                self.rsn = 6
                self.san = 12
                self.init = 4
                old_base = self.base_spirit
                self.base_spirit = 15
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 19
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'ethereal'
                self.weak = ['explosive']
                self.resist = ['magick', 'slashing', 'piercing', 'crushing']
                self.actions = {'Mist Move':self.move, 'Drain Life':self.drain_life, 'Muddle':self.muddle, 'Pierce Shield':self.pierce_shield, 'Haste':self.haste, 'Rend Space':self.rend_space, 'Phase Shift':self.phase_shift}
                def legal_moves(obj):
                    move_list = []
                    for c in app.coords:
                        if app.grid[c[0]][c[1]] == '':
                            if dist(obj.loc, c) <= obj.get_abl('move_range'):
                                move_list.append(c)
                    return move_list
                p = partial(legal_moves, self)
                self.legal_moves = p
            elif self.level == 2:
                self.form = 'umbrae_mist'
                self.str = 3
                self.agl = 5
                self.end = 4
                self.mm = 3
                self.msl = 3
                self.bls = 6
                self.dodge = 6
                self.psyche = 9
                self.wis = 8
                self.rsn = 7
                self.san = 16
                self.init = 5
                old_base = self.base_spirit
                self.base_spirit = 19
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 33
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'ethereal'
                self.weak = ['explosive']
                self.resist = ['magick', 'slashing', 'piercing', 'crushing']
                self.actions = {'Mist Move':self.move, 'Drain Life':self.drain_life, 'Muddle':self.muddle, 'Pierce Shield':self.pierce_shield, 'Haste':self.haste, 'Rend Space':self.rend_space, 'Phase Shift':self.phase_shift, 'Warpfire':self.warpfire, 'Tendrils of Chaos':self.tendrils_of_chaos}
                def legal_moves(obj):
                    move_list = []
                    for c in app.coords:
                        if app.grid[c[0]][c[1]] == '':
                            if dist(obj.loc, c) <= obj.get_abl('move_range'):
                                move_list.append(c)
                    return move_list
                p = partial(legal_moves, self)
                self.legal_moves = p
        elif self.form == 'umbrae_mist':
            if self.level == 1:
                self.form = 'umbrae_wolf'
                self.str = 5
                self.agl = 5
                self.end = 4
                self.mm = 7
                self.msl = 6
                self.bls = 5
                self.dodge = 5
                self.psyche = 3
                self.wis = 3
                self.rsn = 3
                self.san = 13
                self.init = 5
                self.move_range = 4
                old_base = self.base_spirit
                self.base_spirit = 17
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 9
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.weak = ['elec']
                self.resist = ['cold']
                self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift}
                def legal_moves(obj):
                    loc = obj.loc[:]
                    mvlist = []
                    sqr_cost_map = {}
                    def findall(loc, start, distance):
                        if start > distance:
                            return
                        adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                        for s in adj:
                            if tuple(s) in sqr_cost_map:
                                if sqr_cost_map[tuple(s)] < start:
                                    continue
                            sqr_cost_map[tuple(s)] = start
                            if s not in mvlist:
                                mvlist.append(s)
                            findall(s, start+1, distance)
                    findall(loc, 1, self.get_abl('move_range'))
                    return mvlist
                p = partial(legal_moves, self)
                self.legal_moves = p
            elif self.level == 2:
                self.form = 'umbrae_wolf'
                self.str = 6
                self.agl = 8
                self.end = 6
                self.mm = 7
                self.msl = 8
                self.bls = 6
                self.dodge = 8
                self.psyche = 4
                self.wis = 4
                self.rsn = 4
                self.san = 12
                self.init = 8
                self.move_range = 4
                old_base = self.base_spirit
                self.base_spirit = 22
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 13
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.weak = ['elec']
                self.resist = ['cold']
                self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift, 'Darkblast':self.darkblast, 'Stalk':self.stalk}
                def legal_moves(obj):
                    loc = obj.loc[:]
                    mvlist = []
                    sqr_cost_map = {}
                    def findall(loc, start, distance):
                        if start > distance:
                            return
                        adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                        for s in adj:
                            if tuple(s) in sqr_cost_map:
                                if sqr_cost_map[tuple(s)] < start:
                                    continue
                            sqr_cost_map[tuple(s)] = start
                            if s not in mvlist:
                                mvlist.append(s)
                            findall(s, start+1, distance)
                    findall(loc, 1, self.get_abl('move_range'))
                    return mvlist
                p = partial(legal_moves, self)
                self.legal_moves = p
        def reappear():
            global selected
            selected.remove(self.tags)
        root.after(2111, self.init_normal_anims)
        root.after(2222, reappear)
        root.after(2333, self.cancel_phase_shift)
        
    def cancel_phase_shift(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Phase_Shift']
            app.canvas.delete('Phase_Shift')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
        
    def gaze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_gaze)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gaze(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Gaze', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gaze(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gaze(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'Gaze' in [v.name for k,v in ent.effects_dict.items()]:
            return
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Gaze'] = Vis(name = 'Gaze', loc = visloc)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Gaze', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Gaze', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        my_mm = self.get_abl('mm')
        tar_dod = ent.get_abl('dodge')
        if to_hit(my_mm, tar_dod):
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '-3 move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '-3 move range', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            def gaze_effect(stat):
                if stat > 0:
                    return max(1,stat-3)
                else:
                    return stat
            p = partial(gaze_effect)
            ent.move_range_effects.append(p)
            def undo(ent, func, lockname = None):
                ent.move_range_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Gaze'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Gaze', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('mm'))
        else:
            miss(ent.loc)
        root.after(1666, lambda e = None : self.finish_gaze(event = e))
        
    def finish_gaze(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Gaze']
            app.canvas.delete('Gaze')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
        
    def encumber(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_encumber)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_encumber(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Encumber', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_encumber(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_encumber(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 1:
            return
        if 'Encumber' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/haste.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 1
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        # DO Encumber VISUALS
        start_loc = ent.loc[:]
        app.vis_dict['Encumber'] = Vis(name = 'Encumber', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = ent.img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = ent.img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Encumber'].img, tags = ('Encumber','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Encumber'].img, tags = ('Encumber','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Encumber', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Encumber', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis.append('Encumber')
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Encumber','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Encumber', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Encumber','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                def rmv_vis():
                    selected_vis.remove('Encumber')
                root.after(555, rmv_vis)
                root.after(666, self.cleanup_encumber)
            else:
                root.after(100, lambda vis = 'Encumber', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Encumber', x, y, end_left, id)
        simulacrum_loop_right('Encumber', x, y, end_right, id)
        # End visuals
        if to_hit(my_wis, tar_wis):
            def encumber_init(stat):
                return max(1,stat-4)
            p1 = partial(encumber_init)
            ent.init_effects.append(p1)
            def encumber_abl(stat):
                return max(1,stat-2)
            p2 = partial(encumber_abl)
            ent.agl_effects.append(p2)
            ent.mm_effects.append(p2)
            ent.dodge_effects.append(p2)
            ent.move_range_effects.append(p2)
            def encumber_mvs(stat):
                return stat-1
            p3 = partial(encumber_mvs)
            ent.mvs_effects.append(p3)
            ent.mvs -= 1
            def undo(id, p1, p2, p3, lockname = None):
                app.ent_dict[id].init_effects.remove(p1)
                app.ent_dict[id].agl_effects.remove(p2)
                app.ent_dict[id].mm_effects.remove(p2)
                app.ent_dict[id].dodge_effects.remove(p2)
                app.ent_dict[id].move_range_effects.remove(p2)
                app.ent_dict[id].mvs_effects.remove(p3)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2, p3)
            n = 'Encumber' + str(app.count)
            ent.effects_dict['Encumber'] = Effect(name = 'Encumber', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(ent.loc)
            root.after(1333, self.cleanup_encumber)
        
    def cleanup_encumber(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Encumber']
            app.canvas.delete('Encumber')
        except: pass
        app.canvas.delete('text')
        
        
    def haste(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_haste)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_haste(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Haste', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_haste(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_haste(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, (Witch,Tomb)):
            return
        if self.magick < 5:
            return
        if 'Haste' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 5
        def haste_init(stat):
            return stat+4
        p1 = partial(haste_init)
        ent.init_effects.append(p1)
        def haste_abl(stat):
            return stat+1
        p2 = partial(haste_abl)
        ent.agl_effects.append(p2)
        ent.dodge_effects.append(p2)
        ent.mvs_effects.append(p2)
        ent.mvs += 1
        def undo(id, p1, p2, lockname = None):
            app.ent_dict[id].init_effects.remove(p1)
            app.ent_dict[id].agl_effects.remove(p2)
            app.ent_dict[id].dodge_effects.remove(p2)
            app.ent_dict[id].mvs_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p1, p2)
        n = 'Haste' + str(app.count)
        app.ent_dict[id].effects_dict['Haste'] = Effect(name = 'Haste', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        # DO Haste VISUALS
        start_loc = app.ent_dict[id].loc[:]
        app.vis_dict['Haste'] = Vis(name = 'Haste', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Haste'].img, tags = ('Haste','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Haste'].img, tags = ('Haste','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Haste', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Haste', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis.append('Haste')
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Haste','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Haste', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Haste','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                def rmv_vis():
                    selected_vis.remove('Haste')
                root.after(555, rmv_vis)
                root.after(666, self.cleanup_haste)
            else:
                root.after(100, lambda vis = 'Haste', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Haste', x, y, end_left, id)
        simulacrum_loop_right('Haste', x, y, end_right, id)
        
    def cleanup_haste(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Haste']
            app.canvas.delete('Haste')
        except: pass
        app.canvas.delete('text')
        
        
    def rend_space(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_rend_space)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_rend_space(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_rend_space(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rend_space(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Rend Space', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Rend Space', justify = 'center', fill = 'darkorchid1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Rend_Space'] = Vis(name = 'Rend_Space', loc = sqr[:])
        vis = app.vis_dict['Rend_Space']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Rend_Space')
        ent = app.ent_dict[id]
        d = 3*len([k for k in app.loc_dict[tuple(sqr)].effects_dict.keys()])
        lock(apply_damage, self, ent, -d, 'explosive', 'Rend Space', 'spell')
        root.after(2333, self.finish_rend_space)
        
    def finish_rend_space(self, event = None):
        try: 
            del app.vis_dict['Rend_Space']
            app.canvas.delete('Rend_Space')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def pierce_shield(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pierce_shield)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_pierce_shield(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Pierce Shield Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_pierce_shield(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pierce_shield(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Pierce Shield', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Pierce Shield', justify = 'center', fill = 'darkorchid1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Pierce_Shield'] = Vis(name = 'Pierce_Shield', loc = sqr[:])
        vis = app.vis_dict['Pierce_Shield']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Pierce_Shield')
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            def pierce_shield_types(ts):
                return [t for t in ts if t != 'psyshield']
            p1 = partial(pierce_shield_types)
            ent.type_effects.append(p1)
            def pierce_shield_abls(stat):
                return max(1,stat-1)
            p2 = partial(pierce_shield_abls)
            ent.wis_effects.append(p2)
            ent.psyche_effects.append(p2)
            def undo(id, p1, p2, lockname = None):
                app.ent_dict[id].type_effects.remove(p1)
                app.ent_dict[id].wis_effects.remove(p2)
                app.ent_dict[id].psyche_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2)
            n = 'Pierce_Shield' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Pierce_Shield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            sqr = ent.loc
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Lose psyshield, -1 psy, wis', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Lose psyshield, -1 psy, wis', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_pierce_shield)
        else:
            miss(app.ent_dict[id].loc)
            root.after(2333, self.finish_pierce_shield)
        
    def finish_pierce_shield(self, event = None):
        try: 
            del app.vis_dict['Pierce_Shield']
            app.canvas.delete('Pierce_Shield')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def tendrils_of_chaos(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_tendrils_of_chaos)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_tendrils_of_chaos(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Tendrils of Chaos', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_tendrils_of_chaos(e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tendrils_of_chaos(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.spell_target_ents().keys()]:
            return
        ent = app.ent_dict[id]
        if self.magick < 2:
            return
        self.magick -= 2
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/tendrils_of_chaos.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = ent.loc[:]
        app.vis_dict['Tendrils_of_Chaos'] = Vis(name = 'Tendrils_of_Chaos', loc = visloc)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Tendrils of Chaos', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Tendrils of Chaos', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # -2 rand stat, cumulative
        if to_hit(self.get_abl('wis'), ent.get_abl('wis')) == True:
            def tendrils_effect(stat):
                return max(1, stat-2)
            f = tendrils_effect
            any = choice(['str','end','agl','mm','dodge','psyche','wis','rsn','san','init'])
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+84-app.moved_down, text = '-2 '+any, justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+85-app.moved_down, text = '-2 '+any, justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            if any == 'str':
                ent.str_effects.append(f)
            elif any == 'end':
                ent.end_effects.append(f)
            elif any == 'agl':
                ent.agl_effects.append(f)
            elif any == 'dodge':
                ent.dodge_effects.append(f)
            elif any == 'mm':
                ent.mm_effects.append(f)
            elif any == 'psyche':
                ent.psyche_effects.append(f)
            elif any == 'wis':
                ent.wis_effects.append(f)
            elif any == 'rsn':
                ent.rsn_effects.append(f)
            elif any == 'san':
                ent.san_effects.append(f)
            elif any == 'init':
                ent.init_effects.append(f)
            def un(ent, ef_type, lockname = None):
                if ef_type == 'str':
                    ent.str_effects.remove(tendrils_effect)
                elif ef_type == 'end':
                    ent.end_effects.remove(tendrils_effect)
                elif ef_type == 'agl':
                    ent.agl_effects.remove(tendrils_effect)
                elif ef_type == 'mm':
                    ent.mm_effects.remove(tendrils_effect)
                elif ef_type == 'dodge':
                    ent.dodge_effects.remove(tendrils_effect)
                elif ef_type == 'psyche':
                    ent.psyche_effects.remove(tendrils_effect)
                elif ef_type == 'wis':
                    ent.wis_effects.remove(tendrils_effect)
                elif ef_type == 'rsn':
                    ent.rsn_effects.remove(tendrils_effect)
                elif ef_type == 'san':
                    ent.san_effects.remove(tendrils_effect)
                elif ef_type == 'init':
                    ent.init_effects.remove(tendrils_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p_undo = partial(un, ent, any)
            n = 'Tendrils_Drain' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Tendrils_Drain', undo_func = p_undo, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda e = None : self.finish_tendrils_of_chaos(event = e))
        
    def finish_tendrils_of_chaos(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Tendrils_of_Chaos']
            app.canvas.delete('Tendrils_of_Chaos')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
    # Warpfire effect key is 'Warpfire'+caster.id, to limit 1 Warpfire per caster?
    def warpfire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_warpfire)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_warpfire(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Warpfire Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_warpfire(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_warpfire(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Warpfire' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        if 'Warpfire'+self.id in [k for c in app.coords for k,v in app.loc_dict[tuple(c)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/warpfire.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Warpfire', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Warpfire', font = ('chalkduster', 14), fill = 'deeppink', tags = 'text')
        un = 'Warpfire' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Warpfire', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def warp_move(s, lockname):
            app.focus_square(s)
            ents = [k for k,v in app.all_ents().items() if dist(v.loc,s) <= 3 and v.immovable == False]
            es = [c for c in app.coords if dist(c,s) <= 3 and app.grid[c[0]][c[1]] == '']
            for id in ents:
                if es == []:
                    break
                loc = app.ent_dict[id].loc[:]
                endloc = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b, es)
                es.remove(endloc)
                un = 'Warpfire'+str(app.count)
                app.count += 1
                def cleanup_warpfire(n):
                    del app.vis_dict[n]
                    app.canvas.delete(n)
                app.vis_dict[un] = Vis(name = 'Portal', loc = loc[:])
                vis = app.vis_dict[un]
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = vis.img, tags = un)
                root.after(1888, lambda n = un : cleanup_warpfire(n))
                app.grid[loc[0]][loc[1]] = ''
                app.canvas.delete(id)
                app.ent_dict[id].loc = endloc[:]
                app.grid[endloc[0]][endloc[1]] = id
                un2 = 'Portal'+str(app.count)
                app.count += 1
                app.vis_dict[un2] = Vis(name = 'Portal', loc = endloc[:])
                vis2 = app.vis_dict[un2]
                app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis2.img, tags = un2)
                root.after(1888, lambda n = un2 : cleanup_warpfire(n))
                app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
                try: app.canvas.tag_lower((app.ent_dict[id].tags), 'large')
                except: pass
                app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
            root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
        sot2 = partial(warp_move, sqr[:])
        def warp_eot(sqr, lockname = None):
            if ent := [v for k,v in app.all_ents().items() if v.loc == sqr]:
                ent = ent[0]
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-4 Sanity', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-4 Sanity', font = ('chalkduster', 14), fill = 'deeppink', tags = 'text')
                def warp_insane(stat):
                    return max(1, stat-4)
                p = partial(warp_insane)
                ent.san_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.san_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Warp_Insane'+str(app.count)
                app.count += 1
                ent.effects_dict[n] = Effect(name = 'Warp_Insane', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(888, lambda t = 'text' : app.canvas.delete(t))
                root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(warp_eot, sqr[:])
        def undo(s, un, myid, lockname = None):
            del app.vis_dict[un]
            app.canvas.delete('Warpfire'+myid)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, self.id)
        app.loc_dict[tuple(sqr)].effects_dict['Warpfire'+self.id] = Local_Effect(name = 'Warpfire', undo_func = u, sot_func = sot2, eot_func = eot, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = 6)
        root.after(1666, self.cleanup_warpfire)
        
    def cleanup_warpfire(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
        
        
    def stalk(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_stalk)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_stalk(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Stalk Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_stalk(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stalk(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if 'Stalk' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/stalk.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Stalk', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Stalk', justify = 'center', fill = 'gray88', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Stalk'] = Vis(name = 'Stalk', loc = sqr[:])
        vis = app.vis_dict['Stalk']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Stalk')
        if to_hit(self.get_abl('mm'), app.ent_dict[id].get_abl('dodge')):
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Stalked...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Stalked...', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
            def stalk_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
                if (type == 'piercing' or type == 'slashing' or type == 'crushing') and amt < 0 and (st == 'melee' or st == 'ranged'):
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+49, text = '+2 Stalk', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+50, text = '+2 Stalk', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
                    root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt-2, type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            app.ent_dict[id].defense_effects.append(stalk_effect)
            def un(id, lockname = None):
                app.ent_dict[id].defense_effects.remove(stalk_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id)
            n = 'Stalk' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Stalk', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('bls'))
            root.after(2111, self.finish_stalk)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(2111, self.finish_stalk)
        
    def finish_stalk(self, event = None):
        try: 
            del app.vis_dict['Stalk']
            app.canvas.delete('Stalk')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def darkblast(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_darkblast)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_darkblast(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Darkblast Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_darkblast(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_darkblast(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Darkblast'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Darkblast', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_darkb(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_darkb(n))
        if app.ent_dict[id].owner != self.owner:
            my_mm = self.get_abl('mm')
            tar_dodge = app.ent_dict[id].get_abl('dodge')
            if to_hit(my_mm, tar_dodge) == True:
                my_msl = self.get_abl('msl')
                tar_end = app.ent_dict[id].get_abl('end')
                d = damage(my_msl, tar_end)
                lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Darkblast', 'ranged')
                if id not in app.all_ents().keys():
                    root.after(666, lambda e = None : self.finish_darkblast(event = e))
                else:# ent still alive, attempt dispel target effect (must create interface to target) then finish_darkblast
                    app.depop_context(event = None)
                    app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
                    bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
                    bg.pack(side = 'top')
                    bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
                    bg.create_text(14, 14, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
                    bg.create_text(15, 15, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
                    app.context_buttons.append(bg)
                    efs_tuples = [(k, v) for k,v in app.ent_dict[id].effects_dict.items()]
                    if efs_tuples == []:
                        root.after(1666, lambda e = None : self.finish_darkblast(event = e))
                    else:# MAKE BUTTONS becomes page effects like page actions
                        self.page_darkblast(efs_tuples = efs_tuples, id = id)
            else:# MISS
                miss(app.ent_dict[id].loc)
                root.after(2666, lambda e = None : self.finish_darkblast(event = e))
        else:# FRIENDLY ENT, heal 3 then attempt target dispel
            if app.ent_dict[id].owner == self.owner:# heal if summon, else just dispel friendly
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Heal 3 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Heal 3 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                apply_heal(self, app.ent_dict[id], 3)
            app.depop_context(event = None)
            app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
            bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
            bg.pack(side = 'top')
            bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
            bg.create_text(14, 14, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
            bg.create_text(15, 15, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
            app.context_buttons.append(bg)
            efs_tuples = [(k, v) for k,v in app.ent_dict[id].effects_dict.items()]
            if efs_tuples == []:
                root.after(2666, lambda e = None : self.finish_darkblast(event = e))
            else:
                self.page_darkblast(efs_tuples = efs_tuples, id = id)
                    
                    
    def page_darkblast(self, event = None, efs_tuples = None, id = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, key_ef in enumerate(efs_tuples[index:index+5]):
            i += 1
            key = key_ef[0]
            ef = key_ef[1]
            p = partial(self.darkblast_dispel, id = id, ef_name = ef.name, key = key)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ ef.name.replace('_', ' '), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            # below should become effect_description_popup, (there is no equivalent to more info popup, effect desc shown in more info
#             b1.bind('<Button-2>', lambda ef = ef : app.effect_description(ef))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda eft = efs_tuples, id = id, i = index-5 : self.page_darkblast(efs_tuples = eft , id = id, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, eft = efs_tuples, id = id, i = index-5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
            app.context_buttons.append(b4)
        if len(efs_tuples) > len(efs_tuples[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda eft = efs_tuples, id = id, i = index+5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, eft = efs_tuples, id = id, i = index+5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
                    
                    
            
    def darkblast_dispel(self, event = None, id = None, ef_name = None, key = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        if app.ent_dict[id].effects_dict[key].dispel(self.get_abl('msl')) == 'Dispelled':
            del app.ent_dict[id].effects_dict[key]
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Dispel '+ef_name.replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Dispel '+ef_name.replace('_',' '), justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_darkblast)
        else:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Dispel failed...'+ef_name.replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Dispel failed...'+ef_name.replace('_',' '), justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_darkblast)
            
            
    def finish_darkblast(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def dark_shroud(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_dark_shroud)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_dark_shroud(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Dark Shroud', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_dark_shroud(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dark_shroud(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Dark_Shroud_Invis' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/dark_shroud.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Dark Shroud', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Dark Shroud', justify = 'center', fill = 'thistle1', font = ('chalkduster', 13), tags = 'text')
        def dshroud_invis(types):
            return types + ['invisibility']
        p = partial(dshroud_invis)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Dark_Shroud_Invis'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Dark_Shroud_Invis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,ent.loc) <= 1 and v.owner == self.owner]
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = 'Invisibility', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = 'Invisibility', justify = 'center', fill = 'lightblue', font = ('chalkduster', 13), tags = 'text')
        for id in ids:
            s = app.ent_dict[id].loc[:]
            uniq = 'Dark_Shroud'+str(app.count)
            app.count += 1
            app.vis_dict[uniq] = Vis(name = 'Dark_Shroud', loc = s)
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Dark_Shroud')
            app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+64, text = '+2 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+65, text = '+2 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            # text, heal
            apply_heal(self, app.ent_dict[id], 2)
            # dodge bonus effect if eff does not exist
            ks = [k for k,v in app.ent_dict[id].effects_dict.items() if v.name == 'Dark_Shroud']
            if ks == []:
                app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+84, text = '+1 dodge', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+85, text = '+1 dodge', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                def dark_shroud_effect(stat):
                    return stat+1
                f = dark_shroud_effect
                app.ent_dict[id].dodge_effects.append(f)
                def un(i, func, lockname = None):
                    app.ent_dict[i].dodge_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, id, f)
                n = 'Dark_Shroud' + str(app.count)
                app.ent_dict[id].effects_dict[n] = Effect(name = 'Dark_Shroud', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3333, self.finish_dark_shroud)
            
            
    def finish_dark_shroud(self, event = None):
        try:
            ks = list(app.vis_dict.keys())
            for k in ks:
                if k.startswith('Dark_Shroud') == True:
                    del app.vis_dict[k]
            app.canvas.delete('Dark_Shroud')
        except: pass
        app.cleanup_squares()
#         app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def drain_life(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_drain_life)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_drain_life(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Drain Life Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_drain_life(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_drain_life(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/drain_life.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Drain_Life'] = Vis(name = 'Drain_Life', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            pre = app.ent_dict[id].spirit
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Drain Life', 'spell')
            if id not in app.all_ents().keys():
                d = pre
            else:
                post = app.ent_dict[id].spirit
                d = pre - post
            max_heal = round(d//2)
            if max_heal < 0:
                max_heal = 0
            apply_heal(self, self, max_heal)
            app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Heal ' + str(max_heal) + ' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Heal ' + str(max_heal) + ' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1666, self.finish_drain_life)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_drain_life)
        
    def finish_drain_life(self, event = None):
        try: 
            del app.vis_dict['Drain_Life']
            app.canvas.delete('Drain_Life')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
#         app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def muddle(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_muddle)
        sqrs = [c for c in app.coords if 1 <= dist(c, self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_muddle(e, sqr, sqrs))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Muddle', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs: self.do_muddle(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_muddle(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Muddle' in [ef.name for k,ef in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/muddle.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Muddle'] = Vis(name = 'Muddle', loc = sqr[:])
        vis = app.vis_dict['Muddle']
        if to_hit(self.get_abl('wis'), ent.get_abl('wis')) == True:
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+74, text = 'Muddled...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+75, text = 'Muddled...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def un(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = un
            # EOT FUNC
            def attack_self(id, lockname = None):
                app.get_focus(id)
                my_agl = app.ent_dict[id].get_abl('agl')
                if to_hit(my_agl, my_agl) == True:
                    my_str = app.ent_dict[id].get_abl('str')
                    my_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_str, my_end)
                    lock(apply_damage, app.ent_dict[id], app.ent_dict[id], -d, 'crushing', 'Muddle', 'melee')
                else:
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+74-app.moved_down, text = 'Muddle miss...', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+75-app.moved_down, text = 'Muddle miss...', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(attack_self, id)
            n = 'Muddle' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Muddle', undo_func = p, duration = 3, level = self.get_abl('wis'), eot_func = eot)
            root.after(3333, lambda e = None : self.finish_muddle(event = e))
        else:
            miss(app.ent_dict[id].loc)
            root.after(3333, lambda e = None : self.finish_muddle(event = e))
    
    def finish_muddle(self, event = None):
        app.canvas.delete('text')
        try:
            del app.vis_dict['Muddle']
            app.canvas.delete('Muddle')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    def umbrae_strike(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_umbrae_strike)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_umbrae_strike(e, sqr, sqrs))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Attack', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs: self.do_umbrae_strike(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_umbrae_strike(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/umbrae_strike.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        my_mm = self.get_abl('mm')
        target_dodge = app.ent_dict[id].get_abl('dodge')
        app.vis_dict['Umbrae_Strike'] = Vis(name = 'Umbrae_Strike', loc = sqr[:])
        vis = app.vis_dict['Umbrae_Strike']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Umbrae_Strike')
        def cleanup_vis():
            app.canvas.delete('text')
            try:
                del app.vis_dict['Umbrae_Strike']
                app.canvas.delete('Umbrae_Strike')
            except: pass
        if to_hit(my_mm, target_dodge) == True:
            my_msl = self.get_abl('msl')
            target_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, target_end)
            root.after(1999, cleanup_vis)
            lock(apply_damage, self, app.ent_dict[id], -d, 'cold', 'Umbrae Strike', 'ranged')
            self.finish_umbrae_strike()

        else:
            miss(sqr)
            root.after(1999, self.finish_umbrae_strike)
    
    def finish_umbrae_strike(self, event = None):
        app.canvas.delete('text')
        try:
            del app.vis_dict['Umbrae_Strike']
            app.canvas.delete('Umbrae_Strike')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
class Wurdulak(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Entrance':self.entrance, 'Enthrall':self.enthrall, 'Chill Touch':self.chill_touch, 'Enervating Grasp':self.enervating_grasp, 'Bat Form':self.bat_form, 'Wolf Form':self.wolf_form}
            self.str = 7
            self.agl = 4
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 7
            self.wis = 5
            self.rsn = 4
            self.san = 12
            self.init = 4
            self.spirit = 19
            self.magick = 17
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Entrance':self.entrance, 'Enthrall':self.enthrall, 'Chill Touch':self.chill_touch, 'Vampiric Bite':self.vampiric_bite, 'Enervating Grasp':self.enervating_grasp, 'Bat Form':self.bat_form, 'Wolf Form':self.wolf_form}
            self.str = 8
            self.agl = 5
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 8
            self.wis = 6
            self.rsn = 5
            self.san = 14
            self.init = 5
            self.spirit = 29
            self.magick = 23
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
            self.level = level
        self.move_type = 'normal'
        self.resist = ['crushing']
        self.weak = ['fire']
        self.origin_sqr = [1,1] # set on creation of effect that needs it, bat/wolf form
        self.shift_form = 1
        super().__init__(name, id, img, loc, owner)
        self.types = ['undead']
        
        
    def entrance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_entrance)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_entrance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Entrance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_entrance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_entrance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/traced.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Entrance', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Entrance', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        lock(Entity.ranged_attack, self, ent.loc, 'Entrance')
        my_psy = self.get_abl('psyche')
        ent = app.ent_dict[id]
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            def entrance_effect(stat):
                return max(1,stat-4)
            p = partial(entrance_effect)
            ent.san_effects.append(p)
            def undo(id, p, lockname = None):
                app.ent_dict[id].san_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Entrance' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Entrance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-4 sanity', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-4 sanity', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_entrance)
        else:
            miss(ent.loc)
            root.after(2333, self.finish_entrance)

        
    def finish_entrance(self, event = None):
        try: 
            del app.vis_dict['Entrance']
            app.canvas.delete('Entrance')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # tar psy vs psy to hit?, -2 str, agl, msl, dod
    def enthrall(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enthrall)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enthrall(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enthrall Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enthrall(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enthrall(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Enthrall' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/muddle.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Enthrall', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Enthrall', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        lock(Entity.ranged_attack, self, ent.loc, 'Enthrall')
        my_psy = self.get_abl('psyche')
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            def enthrall_effect(stat):
                return max(1,stat-3)
            p = partial(enthrall_effect)
            ent.msl_effects.append(p)
            ent.mm_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.mm_effects.remove(p)
                ent.msl_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Enthrall' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Enthrall', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-3 mm, msl', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-3 mm, msl', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_enthrall)
        else:
            miss(ent.loc)
            root.after(2333, self.finish_enthrall)

        
    def finish_enthrall(self, event = None):
        try: 
            del app.vis_dict['Enthrall']
            app.canvas.delete('Enthrall')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # on hit agl vs agl to hit, str vs end cold, -1 wis cumulative
    def chill_touch(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chill_touch)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chill_touch(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Chill Touch Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chill_touch(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chill_touch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Chill_Touch'] = Vis(name = 'Chill_Touch', loc = sqr[:])
        vis = app.vis_dict['Chill_Touch']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Chill_Touch')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            def chill_touch_effect(stat):
                return max(1,stat-1)
            p = partial(chill_touch_effect)
            ent.wis_effects.append(p)
            def undo(ent, f, lockname = None):
                ent.wis_effects.remove(f)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            un = 'Chill_Touch'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Chill_Touch', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-1 wisdom', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-1 wisdom', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'cold', 'Chill Touch', 'melee')
            root.after(111, self.finish_chill_touch)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_chill_touch)
        
    def finish_chill_touch(self, event = None):
        try: 
            del app.vis_dict['Chill_Touch']
            app.canvas.delete('Chill_Touch')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    # drain magick  agl vs agl to hit
    def enervating_grasp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enervating_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enervating Grasp Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enervating_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Enervating_Grasp'] = Vis(name = 'Enervating_Grasp', loc = sqr[:])
        vis = app.vis_dict['Enervating_Grasp']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Enervating_Grasp')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_psy = self.get_abl('psyche')
            tar_end = ent.get_abl('end')
            d = damage(my_psy, tar_end)
            tar_mgk = ent.magick
            if tar_mgk < d:
                d = tar_mgk
            ent.magick -= d
            self.magick += d
            if self.magick > self.base_magick:
                self.magick = self.base_magick
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            root.after(1999, self.finish_enervating_grasp)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_enervating_grasp)
        
    def finish_enervating_grasp(self, event = None):
        try: 
            del app.vis_dict['Enervating_Grasp']
            app.canvas.delete('Enervating_Grasp')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # minus phys stats plus spl, mv range 7 flying, use Effect dur 1, on undo return to self.origin_sqr
    def bat_form(self, event = None):
        if self.shift_form < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_bat_form)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_bat_form(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Bat Form', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_bat_form(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bat_form(self, event = None):
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.shift_form -= 1
        app.vis_dict['Bat_Form'] = Vis(name = 'Bat_Form', loc = self.loc[:])
        vis = app.vis_dict['Bat_Form']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Bat_Form')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bat Form', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bat Form', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
        def bat_effect(stat):
            return max(1,stat-3)
        p = partial(bat_effect)
        self.str_effects.append(p)
        self.agl_effects.append(p)
        self.end_effects.append(p)
        def bat_dodge(stat):
            return stat+4
        p3 = partial(bat_dodge)
        self.dodge_effects.append(p3)
        def bat_move(stat):
            return stat+3
        p2 = partial(bat_move)
        self.move_range_effects.append(p2)
        self.move_type = 'flying'
        def legal_moves(obj):
            move_list = []
            for c in app.coords:
                if app.grid[c[0]][c[1]] == '':
                    if dist(obj.loc, c) <= obj.get_abl('move_range'):
                        move_list.append(c)
            return move_list
        l_mvs = partial(legal_moves, self)
        self.legal_moves = l_mvs
        def undo(ent, p, p2, p3, lockname = None):
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.end_effects.remove(p)
            ent.dodge_effects.remove(p3)
            ent.move_range_effects.remove(p2)
            ent.move_type = 'normal'
            def legal_moves(obj):
                loc = obj.loc[:]
                mvlist = []
                sqr_cost_map = {}
                def findall(loc, start, distance):
                    if start > distance:
                        return
                    adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                    for s in adj:
                        if tuple(s) in sqr_cost_map:
                            if sqr_cost_map[tuple(s)] < start:
                                continue
                        sqr_cost_map[tuple(s)] = start
                        if s not in mvlist:
                            mvlist.append(s)
                        findall(s, start+1, distance)
                findall(loc, 1, obj.get_abl('move_range'))
                return mvlist
            leg_mvs = partial(legal_moves, ent)
            ent.legal_moves = leg_mvs
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, p3)
        n = 'Bat_Form'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Bat_Form', undo_func = u, duration = 1, level = self.get_abl('wis'))
        self.init_bat_anims()
        root.after(1999, self.cancel_bat_form)
        
    def init_bat_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Wurdulak_Bat/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Wurdulak_Bat/' + anim))
            self.anim_dict[i] = a
        
    def cancel_bat_form(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Bat_Form']
            app.canvas.delete('Bat_Form')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    # minus spl stats plus phys, mv rang 6 normal, use Effect dur 1, ..
    def wolf_form(self, event = None):
        if self.shift_form < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_wolf_form)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_wolf_form(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Wolf Form', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_wolf_form(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wolf_form(self, event = None):
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.shift_form -= 1
        app.vis_dict['Wolf_Form'] = Vis(name = 'Wolf_Form', loc = self.loc[:])
        vis = app.vis_dict['Wolf_Form']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Wolf_Form')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Wolf Form', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Wolf Form', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
        def wolf_effect(stat):
            return max(1,stat-3)
        def wolf_effect2(stat):
            return stat+4
        p = partial(wolf_effect)
        p2 = partial(wolf_effect2)
        self.psyche_effects.append(p)
        self.wis_effects.append(p)
        self.agl_effects.append(p2)
        def wolf_move(stat):
            return stat+3
        p3 = partial(wolf_move)
        self.move_range_effects.append(p3)
        def undo(ent, p, p2, p3, lockname = None):
            ent.psyche_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.agl_effects.remove(p2)
            ent.move_range_effects.remove(p3)
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, p3)
        n = 'Wolf_Form'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Wolf_Form', undo_func = u, duration = 1, level = self.get_abl('wis'))
        self.init_wolf_anims()
        root.after(1999, self.cancel_wolf_form)
        
    def init_wolf_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Wurdulak_Wolf/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Wurdulak_Wolf/' + anim))
            self.anim_dict[i] = a
        
    def cancel_wolf_form(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Wolf_Form']
            app.canvas.delete('Wolf_Form')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    def vampiric_bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_vampiric_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_vampiric_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Vampiric Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_vampiric_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vampiric_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Vampiric_Bite'] = Vis(name = 'Vampiric_Bite', loc = sqr[:])
        vis = app.vis_dict['Vampiric_Bite']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Vampiric_Bite')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            def vamp_effect(stat):
                return stat+3
            p = partial(vamp_effect)
            self.psyche_effects.append(p)
            def undo(ent, f, lockname = None):
                ent.psyche_effects.remove(f)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, self, p)
            if 'Vampiric_Bite' not in [v.name for k,v in self.effects_dict.items()]:
                un = 'Vampiric_Bite'+str(app.count)
                app.count += 1
                self.effects_dict[un] = Effect(name = 'Vampiric_Bite', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+64-app.moved_down, text = '+3 psy', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+65-app.moved_down, text = '+3 psy', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            lock(apply_damage, self, ent, -d, 'piercing', 'Vampiric Bite', 'melee')
            root.after(111, self.finish_vampiric_bite)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_vampiric_bite)
        
    def finish_vampiric_bite(self, event = None):
        try: 
            del app.vis_dict['Vampiric_Bite']
            app.canvas.delete('Vampiric_Bite')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        

class Murrain_Wolf(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Pox':self.pox, 'Paralyze':self.paralyze, 'Scarab Gestation':self.scarab_gestation, 'Leprous Bite':self.leprous_bite, 'Toxic Miasma':self.toxic_miasma}
            self.str = 6
            self.agl = 7
            self.end = 6
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 8
            self.wis = 6
            self.rsn = 4
            self.san = 11
            self.init = 3
            self.spirit = 23
            self.magick = 16
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Pox':self.pox, 'Paralyze':self.paralyze, 'Scarab Gestation':self.scarab_gestation, 'Leprous Bite':self.leprous_bite, 'Toxic Miasma':self.toxic_miasma, 'Spore Cloud':self.spore_cloud, 'Scarab Swarm':self.scarab_swarm}
            self.str = 5
            self.agl = 8
            self.end = 6
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 8
            self.wis = 6
            self.rsn = 4
            self.san = 11
            self.init = 4
            self.spirit = 31
            self.magick = 35
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.resist = ['poison']
        self.weak = ['acid']
        super().__init__(name, id, img, loc, owner)
        # ADD CONTAGION DEATH TRIGGER
        def contagion_trigger(lockname = None):
            effect1 = mixer.Sound('Sound_Effects/contagion.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
            app.focus_square(self.loc)
            sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
            ents = [app.grid[s[0]][s[1]] for s in sqrs if app.grid[s[0]][s[1]] != '' and app.grid[s[0]][s[1]] != 'block']
            ents = [k for k,v in app.all_ents().items() if dist(self.loc,v.loc) == 1 and 'Contagion' not in [j.name for i,j in v.effects_dict.items()]]
            for e in ents:
                n = 'Contagion' + str(app.count)
                def contagion_effect(stat):
                    return max(1,stat-3)
                f = contagion_effect
                app.ent_dict[e].str_effects.append(f)
                app.ent_dict[e].end_effects.append(f)
                app.ent_dict[e].agl_effects.append(f)
                app.ent_dict[e].dodge_effects.append(f)
                def un(id, func, lockname = None):
                    app.ent_dict[id].str_effects.remove(func)
                    app.ent_dict[id].end_effects.remove(func)
                    app.ent_dict[id].agl_effects.remove(func)
                    app.ent_dict[id].dodge_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, e, f)
                app.ent_dict[e].effects_dict[n] = Effect(name = 'Contagion', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                n2 = 'Contagion' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n2] = Vis(name = 'Contagion', loc = app.ent_dict[e].loc[:])
                rand_start_anim = randrange(1,7)
                for i in range(rand_start_anim):
                    app.vis_dict[n2].rotate_image()
                app.canvas.create_text(app.ent_dict[e].loc[0]*100-app.moved_right+49, app.ent_dict[e].loc[1]*100-app.moved_down+89, text = 'CONTAGION', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = ('contagion_text'))
                app.canvas.create_text(app.ent_dict[e].loc[0]*100-app.moved_right+50, app.ent_dict[e].loc[1]*100-app.moved_down+90, text = 'CONTAGION', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = ('contagion_text'))
                app.canvas.create_image(app.ent_dict[e].loc[0]*100+50-app.moved_right, app.ent_dict[e].loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = n2)
            def cleanup_contagion():
                try:
                    keys = [k for k,v in app.vis_dict.items() if v.name == 'Contagion']
                    for k in keys:
                        del app.vis_dict[k]
                    app.canvas.delete('Contagion')
                except: pass
                app.canvas.delete('contagion_text')
            root.after(2222, cleanup_contagion)
            root.after(2333, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(contagion_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Contagion', level = self.get_abl('wis'), undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
    # END CLASS INIT
        
    
    def leprous_bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_leprous_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_leprous_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_leprous_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_leprous_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Leprous_Bite'] = Vis(name = 'Leprous_Bite', loc = sqr[:])
        vis = app.vis_dict['Leprous_Bite']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Leprous_Bite')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            def leper_effect(stat):
                return max(1,stat-1)
            p = partial(leper_effect)
            ent.str_effects.append(p)
            ent.agl_effects.append(p)
            ent.end_effects.append(p)
            ent.mm_effects.append(p)
            ent.psyche_effects.append(p)
            ent.wis_effects.append(p)
            ent.rsn_effects.append(p)
            ent.init_effects.append(p)
            def lepr_san(stat):
                return max(1,stat-3)
            p2 = partial(lepr_san)
            def undo(ent, f, f2, lockname = None):
                ent.str_effects.remove(f)
                ent.agl_effects.remove(f)
                ent.end_effects.remove(f)
                ent.mm_effects.remove(f)
                ent.psyche_effects.remove(f)
                ent.wis_effects.remove(f)
                ent.rsn_effects.remove(f)
                ent.init_effects.remove(f)
                ent.san_effects.remove(f2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            un = 'Leprous_Bite'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Leprous_Bite', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-1 abilities, -3 sanity', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-1 abilities, -3 sanity', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'slashing', 'Leprous Bite', 'melee')
            root.after(111, self.finish_leprous_bite)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_leprous_bite)
        
    def finish_leprous_bite(self, event = None):
        try: 
            del app.vis_dict['Leprous_Bite']
            app.canvas.delete('Leprous_Bite')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    # must choose a scarab, remove (do not kill) and replace with scarab swarm
    def scarab_swarm(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_scarab_swarm)
        scarabs = [k for k,v in app.ent_dict.items() if v.name == 'Scarab' and v.owner == self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
        sqrs = []
        for id in scarabs:
            sqrs.append(app.ent_dict[id].loc[:])
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_scarab_swarm(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Scarab To Transform', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_scarab_swarm(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scarab_swarm(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 1:
            return
        self.magick -= 1
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scarab_swarm.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.delete(id)
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        del app.ent_dict[id]
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_scarab_swarm(s))
        root.after(2666, self.cleanup_scarab_swarm)
        
    def finish_scarab_swarm(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Scarab_Swarm.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Scarab_Swarm(name = 'Scarab_Swarm', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_scarab_swarm(self, event = None):
        try:
            del app.vis_dict['Summon']
            app.canvas.delete('Summon')
        except:
            pass
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def spore_cloud(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Spore_Cloud' in loc_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spore_cloud)
        sqrs = []
        for c in app.coords:
            if dist(self.loc, c) <= 2:
                sqrs.append(c)
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_spore_cloud(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Spore Cloud Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_spore_cloud(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spore_cloud(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Spore_Cloud' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Spore Cloud', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Spore Cloud', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Spore_Cloud' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Spore_Cloud', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def spore_effect(stat):
            return stat+4
        p = partial(spore_effect)
        app.loc_dict[tuple(sqr)].dodge_effects.append(p)
        def spore_def(attacker, defender, amount, type, source, sn, lockname = None):
            if amount < 0 and (type == 'slashing' or type == 'piercing' or type == 'fire') and (sn == 'melee' or sn == 'ranged' or sn == 'spell'):
                app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '-2 (min1) spirit spore cloud', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '-2 (min1) spirit spore cloud', justify ='center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                amount += 2
                if amount > -1:
                    root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1,type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amount,type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amount,type)
        app.loc_dict[tuple(sqr)].def_effects.append(spore_def)
        def undo(s, un, p_ef, lockname = None):
            app.loc_dict[tuple(s)].dodge_effects.remove(p_ef)
            app.loc_dict[tuple(s)].def_effects.remove(spore_def)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Spore_Cloud', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = -5)
        root.after(1666, self.cleanup_spore_cloud)
        
    def cleanup_spore_cloud(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
    
    def scarab_gestation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_scarab_gestation)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_scarab_gestation(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Scarab Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_scarab_gestation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scarab_gestation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, (Scarab, Scarab_Swarm)):
            return
        if 'Scarab_Gestation' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/scarab_gestation.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Scarab Gestation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Scarab Gestation', justify = 'center', fill = 'thistle2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Scarab_Gestation'] = Vis(name = 'Scarab_Gestation', loc = sqr[:])
        vis = app.vis_dict['Scarab_Gestation']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Scarab_Gestation')
        if self.save_check('psyche') == 'Pass':
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Scarab...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Scarab...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            # SCARAB DEATH TRIGGER
            def scarab_effect(id = None, lockname = None):
                s = app.ent_dict[id].loc[:]
                sqr = reduce(lambda a,b : a if dist(a,s) < dist(b,s) else b, [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Scarab.png'))
                if self.owner == 'p1':
                    id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
                    app.ent_dict[app.p1_witch].summon_ids += 1
                else:
                    id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
                    app.ent_dict[app.p2_witch].summon_ids += 1
                app.ent_dict[id] =  Scarab(name = 'Scarab', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
                app.grid[sqr[0]][sqr[1]] = id
                root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
            dt = partial(scarab_effect, id = id)
            def dt_undo(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            dt_inst = Death_Trigger(name = 'Scarab_Gestation', level = self.get_abl('psyche'), undo_func = dt_undo, dt = dt)
            ent.death_triggers.append(dt_inst)
            def un(id, ts, lockname = None):
                for dt in app.ent_dict[id].death_triggers[:]:
                    if dt.ts == ts:
                        app.ent_dict[id].death_triggers.remove(dt)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, dt_inst.ts)
            n = 'Scarab_Gestation' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Scarab_Gestation', undo_func = u, duration = 13, level = self.get_abl('psyche'))
            root.after(1999, self.finish_scarab_gestation)
        else:
            miss(ent.loc)
            root.after(1999, self.finish_scarab_gestation)
        
    def finish_scarab_gestation(self, event = None):
        try: 
            del app.vis_dict['Scarab_Gestation']
            app.canvas.delete('Scarab_Gestation')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def paralyze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_paralyze)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_paralyze(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Paralyze Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_paralyze(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_paralyze(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Paralyze' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 5:
            return
        self.magick -= 5
        effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Paralyze', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Paralyze', justify = 'center', fill = 'thistle2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Paralyze'] = Vis(name = 'Paralyze', loc = sqr[:])
        vis = app.vis_dict['Paralyze']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Paralyze')
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            def paralyze_move(move_range):
                return max(0, move_range-3)
            def paralyze_acts(acts):
                return max(0,acts-1)
            p1 = partial(paralyze_move)
            app.ent_dict[id].move_range_effects.append(p1)
            p2 = partial(paralyze_acts)
            app.ent_dict[id].acts_effects.append(p2)
            app.ent_dict[id].acts -= 1
            def undo(id, p1, p2, lockname = None):
                app.ent_dict[id].move_range_effects.remove(p1)
                app.ent_dict[id].acts_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2)
            n = 'Paralyze' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Paralyze', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-1 actions, -3 move range', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-1 actions, -3 move range', justify = 'center', fill = 'thistle2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_paralyze)
        else:
            miss(app.ent_dict[id].loc)
            root.after(2333, self.finish_paralyze)

        
    def finish_paralyze(self, event = None):
        try: 
            del app.vis_dict['Paralyze']
            app.canvas.delete('Paralyze')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # give all adj units pox Effect if they have no pox effects, causes 2 spirit damage EOT
    def pox(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pox)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_pox(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pox', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_pox(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pox(self, event = None, sqrs = None):
        effect1 = mixer.Sound('Sound_Effects/pox.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.acts -= 1
#         self.init_attack_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        ents = []
        for s in sqrs:
            n2 = 'Pox' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Pox', loc = s)
            rand_start_anim = randrange(1,7)
            for i in range(rand_start_anim):
                app.vis_dict[n2].rotate_image()
            ent = app.grid[s[0]][s[1]]
            if ent in app.all_ents().keys() and isinstance(app.ent_dict[ent], Murrain_Wolf) == False:
                #GIVE POX EFFECT if doesn't exist
                ef_names = [v.name for k,v in app.ent_dict[ent].effects_dict.items()]
                if 'Pox' not in ef_names:
                    n = 'Pox'+str(app.count)
                    def take_2(tar, lockname = None):
                        app.get_focus(tar)
                        lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pox', 'eot')
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    # EOT
                    eot = partial(take_2, ent)
                    # UNDO
                    def un(lockname = None):
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un)
                    # POX VIS
                    app.ent_dict[ent].effects_dict[n] = Effect(name = 'Pox', eot_func = eot , undo_func = u, duration = 4, level = 6)
                    app.canvas.create_text(app.ent_dict[ent].loc[0]*100-app.moved_right+49, app.ent_dict[ent].loc[1]*100-app.moved_down+89, text = 'Pox', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(app.ent_dict[ent].loc[0]*100-app.moved_right+50, app.ent_dict[ent].loc[1]*100-app.moved_down+90, text = 'Pox', justify = 'center', fill = 'darkolivegreen3', font = ('chalkduster', 14), tags = 'text')
        root.after(2999, self.finish_pox)
        
    def finish_pox(self, event = None):
#         self.init_normal_anims()
        try:
            keys = [k for k in app.vis_dict.keys() if k.startswith('Pox')]
            for k in keys:
                del app.vis_dict[k]
            app.canvas.delete('Pox')
        except: pass
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
    
    
    def toxic_miasma(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_toxic_miasma)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_toxic_miasma(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Toxic Miasma', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_toxic_miasma(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_toxic_miasma(self, event = None, sqrs = None):
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/toxic_miasma.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Toxic Miasma', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Toxic Miasma', font = ('chalkduster', 13), fill = 'orchid1', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and isinstance(v,Murrain_Wolf) == False and v.owner != self.owner]
        def cleanup_toxic_miasma(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def toxic_miasma_loop(ents):
            if ents == []:
                self.finish_toxic_miasma()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                misscount = 0
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    def miasma_invis(types):
                        return [t for t in types if t != 'invisibility']
                    p = partial(miasma_invis)
                    ent.type_effects.append(p)
                    def undo(id, f, lockname = None):
                        app.ent_dict[id].type_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p)
                    n = 'Toxic_Miasma'+str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Miasma_Invis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+24, text = 'Lose invisibility', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+25, text = 'Lose invisibility', justify = 'center', fill = 'orchid1', font = ('chalkduster', 14), tags = 'text')
                    misscount += 1
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    def miasma_abls(stat):
                        return max(1,stat-1)
                    p2 = partial(miasma_abls)
                    ent.san_effects.append(p2)
                    ent.rsn_effects.append(p2)
                    def undo(id, f, lockname = None):
                        app.ent_dict[id].san_effects.remove(f)
                        app.ent_dict[id].rsn_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u2 = partial(undo, id, p2)
                    n = 'Toxic_Miasma'+str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Miasma_Drain', undo_func = u2, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+44, text = '-1 san, rsn', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+45, text = '-1 san, rsn', justify = 'center', fill = 'orchid1', font = ('chalkduster', 14), tags = 'text')
                    misscount += 1
                if misscount == 0:
                    miss(ent.loc)
                n = 'Toxic_Miasma' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Toxic_Miasma', loc = ent.loc[:])
                app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1555, lambda n = n : cleanup_toxic_miasma(n))
                root.after(1666, lambda ents = ents : toxic_miasma_loop(ents))
        toxic_miasma_loop(ents)

        
    def finish_toxic_miasma(self, event = None):
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
    
    

class Scarab_Swarm(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 6
            self.agl = 13
            self.end = 9
            self.mm = 8
            self.msl = 4
            self.bls = 7
            self.dodge = 9
            self.psyche = 5
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 9
            self.spirit = 23
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2: # level should start at 2 unless spell gained early...same stats as lvl 1 for now
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 6
            self.agl = 13
            self.end = 9
            self.mm = 8
            self.msl = 4
            self.bls = 7
            self.dodge = 9
            self.psyche = 5
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 9
            self.spirit = 23
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.level = level
        self.move_type = 'flying'
        self.weak = ['crushing']
        self.resist = ['magick', 'slashing', 'piercing', 'fire', 'poison', 'elec']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        
        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
# summoned by haunted cairn(spell)
# spawn user-owned, computer-controlled ghast units...
class Haunted_Cairn(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {}
            self.str = 1
            self.agl = 1
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 2
            self.wis = 3
            self.rsn = 1
            self.san = 20
            self.init = 1
            self.spirit = 10
            self.magick = 12
            self.acts = 1
            self.mvs = 0
            self.move_range = 0
            self.level = level
        elif level == 2:
            self.actions = {}
            self.str = 1
            self.agl = 1
            self.end = 7
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 3
            self.wis = 4
            self.rsn = 1
            self.san = 20
            self.init = 1
            self.spirit = 13
            self.magick = 15
            self.acts = 1
            self.mvs = 0
            self.move_range = 0
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['slashing', 'fire', 'piercing', 'poison', 'cold', 'magick', 'elec', 'acid']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['nonsentient']
        # EOT smn ghast to adj sqr if any
        def eot(lockname = None):
            app.get_focus(self.id)
            self.effects_dict['control'].duration += 1 # permanent effect, each call increases duration
            sqrs = [c for c in app.coords if dist(c,self.loc)==1 and app.grid[c[0]][c[1]]=='']
            if sqrs == []:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                s = choice(sqrs)
                app.vis_dict['Summon'] = Vis(name = 'Summon', loc = s)
                if self.owner == 'p1':
                    witch = app.ent_dict[app.p1_witch]
                    prefix = 'a'
                else:
                    witch = app.ent_dict[app.p2_witch]
                    prefix = 'b'
                num = witch.summon_ids
                witch.summon_ids += 1
                id = prefix + str(num)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Ghast.png'))
                app.ent_dict[id] = Ghast(name = 'Ghast', id = id, img = img, loc = s[:], owner = self.owner, level = self.level)
                app.grid[s[0]][s[1]] = id
                def cleanup_smn():
                    del app.vis_dict['Summon']
                    app.canvas.delete('Summon')
                root.after(1666, cleanup_smn)
                root.after(1777, lambda ln = lockname : app.dethloks[ln].set(1))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Cairn", eot_func = e, undo_func = u, duration = 666, level = 666)




class Ghast(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Cut':self.cut}
            self.str = 4
            self.agl = 12
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 12
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 9
            self.init = 9
            self.magick = 0
            self.spirit = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        elif level == 2:
            self.actions = {}
            self.str = 4
            self.agl = 12
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 12
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 9
            self.init = 9
            self.magick = 0
            self.spirit = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        self.level = level
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['slashing', 'piercing']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['animal', 'undead']
        
        
        # CHANGE to include ghast_attack, not just pursuit/adjacent goals
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner and v.get_inert()==False]
            goals = unique([c for c in app.coords for el in els if dist(el,c)==1 and app.grid[c[0]][c[1]]==''])
            moves = self.legal_moves()
            gs = intersect(goals, moves)
            if gs == []:
                if els == []:
                    root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    # get closest el and if moves exist, reduce to move that is closest to closest el
                    if moves == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        # at this point, no goals in legal moves, some els and moves exist, not ncsrly goals
                        if goals == []:
                            # no goals, just move to loc that minimizes dist to closest el
                            el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                            move = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, moves)
                            app.focus_square(move)
                            lock(Bot.do_move, self, move)
                            root.after(222, lambda ln = lockname : app.dethloks[ln].set(1))
                        else:
                            # goals exist but not ncsrly path
                            # try path to all goals, if None returned by bfs() just do same as above (move closest to closest)
                            if path := bfs(self.loc, goals, app.grid[:]):
                                moves = intersect(path, moves)
                                move = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, moves)
                                app.focus_square(move)
                                lock(Bot.do_move, self, move)
                                root.after(222, lambda ln = lockname : app.dethloks[ln].set(1))
                            else:
                                el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                                move = reduce(lambda a,b : a if dist(a,el)<dist(b,el) else b, moves)
                                app.focus_square(move)
                                lock(Bot.do_move, self, move)
                                root.after(222, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                # choose target and do atk
                lock(Bot.do_move, self, g)
                adj = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1 and v.owner != self.owner]
                if adj:
                    ent = choice(adj)
                    app.get_focus(ent.id)
                    lock(self.cut, ent.id)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Ghast", eot_func = e, undo_func = u, duration = 666, level = 666)
        
        
    def cut(self, id, lockname):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_knight_attack.ogg')
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        if to_hit(self.get_abl('agl'), ent.get_abl('agl')) == True:
            d = damage(self.get_abl('str'), ent.get_abl('end'))
            lock(apply_damage, self, ent, -d, 'slashing', 'Cut', 'melee')
            root.after(111, self.init_normal_anims)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1555, self.init_normal_anims)
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))


class Guardian_of_the_Chthonic_Gate(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Warpfire Cloud':self.warpfire_cloud}
            self.str = 12
            self.agl = 9
            self.end = 9
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 9
            self.wis = 11
            self.rsn = 4
            self.san = 1
            self.init = 12
            self.magick = 39
            self.spirit = 29
            self.acts = 2
            self.mvs = 0
            self.move_range = 0
        elif level == 2:
            self.actions = {'Warpfire Cloud':self.warpfire_cloud}
            self.str = 12
            self.agl = 9
            self.end = 9
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 9
            self.wis = 11
            self.rsn = 4
            self.san = 1
            self.init = 12
            self.magick = 39
            self.spirit = 29
            self.acts = 2
            self.mvs = 0
            self.move_range = 0
        self.level = level
        self.move_type = 'normal'
        self.weak = ['elec']
        self.resist = ['cold','fire','magick']
        super().__init__(name, id, img, loc, owner)
#         self.inert = True
        # add prox efct on init
        def guard_san_ef(stat):
            return max(1,stat-4)
        p = partial(guard_san_ef)
        prox_ef = Proximity_Effect(name = 'Chthonic_Anguish', ent = self, range = (1,3), abls = ['san'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys()]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Chthonic_Anguish'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(ent, prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, prx_name)
        self.effects_dict['Chthonic_Anguish'] = Effect(name = 'Chthonic_Anguish', undo_func = u, duration = 666, level = 666)
        # guardian usually fails sanity and flails during turn, on eot does warpfire cloud
        # has perm prox efct -4 san range 3
        def eot(lockname = None):
            # NOTE bug, existence of 'control' key in inert ents effect_dict is assumed to always exist,
            # this relies on the fact that level is 666, impossible to dispel/remove under current game conditions,
            # but could change in the future...
            self.effects_dict['control'].duration += 1 # permanent effect, each call increases duration
            self.effects_dict['Chthonic_Anguish'].duration += 1 # permanent effect, each call increases duration
            app.get_focus(self.id)
            if 'Warpfire Cloud' in self.actions.keys():
                # get all ents in range reason, 
                self.warpfire_cloud(lockname)
            else:
                root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Abomination", eot_func = e, undo_func = u, duration = 666, level = 666)
        
    def sanity_check(self):
        return 'Fail'
        
    def warpfire_cloud(self, lockname):
        app.get_focus(self.id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/pestilence.ogg')
        sound_effects.play(effect1, 0)
        def cleanup_wcloud():
            del app.vis_dict['Warpfire_Cloud']
            app.canvas.delete('Warpfire_Cloud')
        app.vis_dict['Warpfire_Cloud'] = Vis(name = 'Warpfire_Cloud', loc = self.loc[:])
        root.after(2666, cleanup_wcloud)
        ents = [v for k,v in app.all_ents().items() if 1 <= dist(v.loc,self.loc) <= 2]
#         def cleanup_wcloud(n):
#             del app.vis_dict[n]
#             app.canvas.delete(n)
#         for e in ents:
#             n = 'wcloud'+str(app.count)
#             app.count += 1
#             app.vis_dict[n] = Vis(name = 'Warpfire_Cloud', loc = e.loc[:])
#             root.after(1666, lambda n = n : cleanup_wcloud(n))
        def warp_loop(ents):
            if ents == []:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')) == True:
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+44, text = '-2 wis, psyche, san, rsn', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+45, text = '-2 wis, psyche, san, rsn', justify = 'center', fill = 'orchid1', font = ('chalkduster', 14), tags = 'text')
                    # add -2 mental stats wis, psy, rsn, san,
                    def wcloud_efct(stat):
                        return max(1,stat-2)
                    p = partial(wcloud_efct)
                    ent.wis_effects.append(p)
                    ent.psyche_effects.append(p)
                    ent.rsn_effects.append(p)
                    ent.san_effects.append(p)
                    def un(ent, p, lockname = None):
                        ent.wis_effects.remove(p)
                        ent.psyche_effects.remove(p)
                        ent.rsn_effects.remove(p)
                        ent.san_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, ent, p)
                    name = 'wcloud' + str(app.count)
                    ent.effects_dict[name] = Effect(name = 'Chthonic_Spiral', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1777, lambda ents = ents : warp_loop(ents))
                else: # miss
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ents = ents : warp_loop(ents))
        warp_loop(ents)


class Nightgaunt(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Grasp':self.grasp}
            self.str = 4
            self.agl = 11
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 19
            self.init = 9
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        elif level == 2:
            self.actions = {'Move':self.move, 'Grasp':self.grasp}
            self.str = 4
            self.agl = 11
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 19
            self.init = 9
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        self.level = level
        self.move_type = 'flying'
        self.weak = ['elec']
        self.resist = ['magick', 'fire', 'cold']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']

        
    def grasp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Grasp Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.immovable == True:
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        # insert choose location
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs, ent = ent : self.choose_grasp(event = e, sqr = sqr, sqrs = sqrs, ent = ent))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs, ent = ent : self.choose_grasp(event = e, sqr = sqr, sqrs = sqrs, ent = ent))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_grasp(self, event = None, sqr = None, sqrs = None, ent = None):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Grasp_of_the_Old_Ones', loc = ent.loc[:])
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            # flying move ent to sqr, flying move self to nrst empty
            cs = [c for c in app.coords if app.grid[c[0]][c[1]]=='' and c != sqr]
            sqr2 = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b,cs)
            Bot.ai_flying_move(ent, sqr)
            lock(Bot.ai_flying_move, self, sqr2)
            self.finish_grasp()
        else:
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.finish_grasp)
            
        
    def finish_grasp(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)


class Migo(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Proboscis':self.proboscis}
            self.str = 3
            self.agl = 10
            self.end = 14
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 9
            self.wis = 9
            self.rsn = 5
            self.san = 19
            self.init = 11
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        elif level == 2:
            self.actions = {'Move':self.move, 'Proboscis':self.proboscis}
            self.str = 3
            self.agl = 10
            self.end = 14
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 9
            self.wis = 9
            self.rsn = 5
            self.san = 19
            self.init = 11
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        self.level = level
        self.move_type = 'flying'
        self.weak = []
        self.resist = ['fire', 'cold']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']

        
    def proboscis(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_proboscis)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_proboscis(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Proboscis Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_proboscis(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_proboscis(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Lunge', loc = sqr[:])
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            # add effct -1 psy,wis,rsn,san
            def probos_efct(stat):
                return max(1,stat-1)
            p = partial(probos_efct)
            ent.psyche_effects.append(p)
            ent.wis_effects.append(p)
            ent.rsn_effects.append(p)
            ent.san_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.psyche_effects.remove(p)
                ent.wis_effects.remove(p)
                ent.rsn_effects.remove(p)
                ent.san_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'proboscis'+str(app.count)
            app.count += 1
            ent.effects_dict[n] = Effect(name = 'Proboscis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '-1 psy, wis, rsn, san', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '-1 psy, wis, rsn, san', justify = 'center', fill = 'orchid1', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_proboscis)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_proboscis)
        
    def finish_proboscis(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)


class Scarab(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 6
            self.agl = 11
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 7
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 6
            self.agl = 11
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 7
            self.magick = 0
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.level = level
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['magick', 'slashing', 'piercing', 'fire', 'poison', 'elec']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']

        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
    
class Plague_Vermin(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 10
            self.init = 11
            self.magick = 0
            self.spirit = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        elif level == 2:
            self.actions = {'Move':self.move, 'Bite':self.bite}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 10
            self.init = 11
            self.magick = 0
            self.spirit = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']

        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            def take_2(ent, lockname = None):
                app.get_focus(ent.id)
                lock(apply_damage, self, ent, -2, 'poison', 'Vermin Poison', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, ent)
            n = 'vermin'+str(app.count)
            app.count += 1
            def undo(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo)
            ent.effects_dict[n] = Effect(name = 'Vermin_Poison', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = 'Vermin Poison', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = 'Vermin Poison', justify = 'center', fill = 'limegreen', font = ('chalkduster', 13), tags = 'text')
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'poison', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
class Chirurgeon(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.level = level
        if level == 1:
            self.actions = {'Move':self.move, 'Stitch Cadaver':self.stitch_cadaver, 'Bone Pincers':self.bone_pincers, 'Willful Perambulation':self.willful_perambulation, 'Corrosive Glands':self.corrosive_glands, 'Alacrity':self.alacrity, 'Farsight':self.farsight, 'Enervating Grasp':self.enervating_grasp}
            self.str = 3
            self.agl = 4
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 4
            self.wis = 7
            self.rsn = 5
            self.san = 16
            self.init = 5
            self.spirit = 12
            self.magick = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Stitch Cadaver':self.stitch_cadaver, 'Bone Pincers':self.bone_pincers, 'Willful Perambulation':self.willful_perambulation, 'Corrosive Glands':self.corrosive_glands, 'Alacrity':self.alacrity, 'Farsight':self.farsight, 'Enervating Grasp':self.enervating_grasp}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 5
            self.wis = 8
            self.rsn = 5
            self.san = 17
            self.init = 6
            self.spirit = 17
            self.magick = 28
            self.acts = 2
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['fire', 'magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def enervating_grasp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enervating_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enervating Grasp Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enervating_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Enervating_Grasp'] = Vis(name = 'Enervating_Grasp', loc = sqr[:])
        vis = app.vis_dict['Enervating_Grasp']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Enervating_Grasp')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_psy = self.get_abl('psyche')
            tar_end = ent.get_abl('end')
            d = damage(my_psy, tar_end)
            tar_mgk = ent.magick
            if tar_mgk < d:
                d = tar_mgk
            ent.magick -= d
            self.magick += d
            if self.magick > self.base_magick:
                self.magick = self.base_magick
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            root.after(1999, self.finish_enervating_grasp)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_enervating_grasp)
        
    def finish_enervating_grasp(self, event = None):
        try: 
            del app.vis_dict['Enervating_Grasp']
            app.canvas.delete('Enervating_Grasp')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def farsight(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_farsight)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_farsight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Grant Farsight to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_farsight(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_farsight(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.name != 'Cadaver':
            return
        if 'Farsight' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 4:
            return
        self.magick -= 4
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/farsight.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Farsight'] = Vis(name = 'Farsight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Farsight'].img, tags = 'Farsight')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Farsight', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Farsight', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = '+6 mm, +2 bls, +1 msl', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = '+6 mm, +2 bls, +1 msl', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # +6 mm, +2 bls, +4 msl
        def alacrity_mm(stat):
            return stat+6
        p1 = partial(alacrity_mm)
        ent.mm_effects.append(p1)
        def alacrity_bls(stat):
            return stat+2
        p2 = partial(alacrity_bls)
        ent.bls_effects.append(p2)
        def alacrity_msl(stat):
            return stat+4
        p3 = partial(alacrity_msl)
        ent.msl_effects.append(p3)
        def un(ent, p1, p2, p3, lockname = None):
            ent.mm_effects.remove(p1)
            ent.bls_effects.remove(p2)
            ent.msl_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p1, p2, p3)
        n = 'Farsight' + str(app.count)
        ent.effects_dict['Farsight'] = Effect(name = 'Farsight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_farsight)
        
        
    def cleanup_farsight(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Farsight']
            app.canvas.delete('Farsight')
        except: pass
        app.canvas.delete('text')
        
        
    def alacrity(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_alacrity)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_alacrity(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Grant Alacrity to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_alacrity(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_alacrity(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.name != 'Cadaver':
            return
        if 'Alacrity' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 4:
            return
        self.magick -= 4
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/alacrity.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Alacrity'] = Vis(name = 'Alacrity', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Alacrity'].img, tags = 'Alacrity')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Alacrity', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Alacrity', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = '+5 agl, +2 move range, +1 moves', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = '+5 agl, +2 move range, +1 moves', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # +4 mv rng, str, +5 agl
        def alac_ef1(stat):
            return stat+4
        p1 = partial(alac_ef1)
        ent.str_effects.append(p1)
        ent.move_range_effects.append(p1)
        def alac_ef2(stat):
            return stat+5
        p2 = partial(alac_ef2)
        ent.agl_effects.append(p2)
        def un(ent, p1, p2, lockname = None):
            ent.str_effects.remove(p1)
            ent.move_range_effects.remove(p1)
            ent.agl_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p1, p2)
        n = 'Alacrity' + str(app.count)
        ent.effects_dict['Alacrity'] = Effect(name = 'Alacrity', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_alacrity)
        
        
    def cleanup_alacrity(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Alacrity']
            app.canvas.delete('Alacrity')
        except: pass
        app.canvas.delete('text')
        
        
        
        
    def willful_perambulation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_willful_p)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_willful_p(event = e, sqr = s, sqrs = sqrs)) 
        ##
        b = tk.Button(app.context_menu, text = 'Grant Willful Perambulation to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_willful_p(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_willful_p(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Willful_Move' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/bone_pincers.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Willful_Perambulation'] = Vis(name = 'Willful_Perambulation', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Willful_Perambulation'].img, tags = 'Willful_Perambulation')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Willful Perambulation', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Willful Perambulation', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Move Granted', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Move Granted', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        # ADD ACTION TO TARGET
        def add_move(actions = None, ent = None):
            actions['Move'] = ent.move
            return actions
        p2 = partial(add_move, ent = ent)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Willful_Move' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Willful_Move', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_willful_p)
        
    def finish_willful_p(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Willful_Perambulation']
            app.canvas.delete('Willful_Perambulation')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def corrosive_glands(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_c_glands)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_c_glands(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Grant Corrosive Glands to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_c_glands(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_c_glands(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Corrosive_Attack' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/corrosive_glands.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Corrosive_Glands'] = Vis(name = 'Corrosive_Glands', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Corrosive_Glands'].img, tags = 'Corrosive_Glands')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Corrosive Glands', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Corrosive Glands', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Corrosive Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Corrosive Attack', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def c_glands_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(obj.loc,c) <= obj.get_abl('bls')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Corrosive Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/corrosive_attack.ogg')
#                 effect1.set_volume(app.effects_volume.get())
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = ent.loc[:]
                app.vis_dict['Corrosive_Attack'] = Vis(name = 'Corrosive_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Corrosive_Attack'].img, tags = 'Corrosive_Attack')
                my_mm = obj.get_abl('mm')
                tar_dodge = ent.get_abl('dodge')
                if to_hit(my_mm, tar_dodge):
                    my_msl = obj.get_abl('msl')
                    tar_end = ent.get_abl('end')
                    d = damage(my_msl, tar_end)
                    lock(apply_damage, obj, ent, -d, 'acid', 'Corrosive Attack', 'ranged')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Corrosive_Attack']
                    app.canvas.delete('Corrosive_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(c_glands_attack, obj = ent)
        def add_c_glands_attack(actions = None, func = None):
            actions['Corrosive Attack'] = func
            return actions
        p2 = partial(add_c_glands_attack, func = p)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Corrosive_Attack' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Corrosive_Attack', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_c_glands)
        
    def finish_c_glands(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Corrosive_Glands']
            app.canvas.delete('Corrosive_Glands')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def bone_pincers(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bone_pincers)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_bone_pincers(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Graft Bone Pincers to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_bone_pincers(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bone_pincers(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Bone_Pincer_Attack' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/bone_pincers.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Bone_Pincers'] = Vis(name = 'Bone_Pincers', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Bone_Pincers'].img, tags = 'Bone_Pincers')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bone Pincers', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bone Pincers', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Bone Pincer Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Bone Pincer Attack', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def pincer_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Bone Pincer Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/pincer_attack.ogg')
#                 effect1.set_volume(app.effects_volume.get())
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Bone_Pincer_Attack'] = Vis(name = 'Bone_Pincer_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Bone_Pincer_Attack'].img, tags = 'Bone_Pincer_Attack')
                my_agl = obj.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    my_str = obj.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    lock(apply_damage, obj, ent, -d, 'slashing', 'Bone Pincers', 'melee')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Bone_Pincer_Attack']
                    app.canvas.delete('Bone_Pincer_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(pincer_attack, obj = ent)
        def add_pincer_attack(actions = None, func = None):
            actions['Bone Pincer Attack'] = func
            return actions
        p2 = partial(add_pincer_attack, func = p)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Bone_Pincer_Attack' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Bone_Pincer_Attack', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_bone_pincers)
        
    def finish_bone_pincers(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Bone_Pincers']
            app.canvas.delete('Bone_Pincers')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
        
    def stitch_cadaver(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_stitch_cadaver)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_stitch_cadaver(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Cadaver", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_stitch_cadaver(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stitch_cadaver(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id != '':
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        vis = app.vis_dict['Summon']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Summon')
        def cleanup_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(2666, cleanup_summon)
        root.after(2333, lambda s = sqr[:] : self.continue_stitch_cadaver(s))
        
    def continue_stitch_cadaver(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Cadaver.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Cadaver(name = 'Cadaver', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_stitch_cadaver()
        
    def finish_stitch_cadaver(self, event = None):
        app.generic_cancel()
        
        
class Fell_Evolver(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Assail':self.assail, 'Wooden Skin':self.wooden_skin, 'Calcify':self.calcify, 'Unstable Fervor':self.unstable_fervor, 'Chimeric Mutation':self.chimeric_mutation, 'Moldering Effluvium':self.moldering_effluvium, 'Squamous Carapace':self.squamous_carapace, 'Winnowing_Verdure':self.winnowing_verdure, 'Noxious_Respiration':self.noxious_respiration}
            self.str = 5
            self.agl = 5
            self.end = 5
            self.mm = 5
            self.msl = 5
            self.bls = 5
            self.dodge = 5
            self.psyche = 5
            self.wis = 5
            self.rsn = 5
            self.san = 13
            self.init = 5
            self.spirit = 21
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Assail':self.assail, 'Wooden Skin':self.wooden_skin, 'Calcify':self.calcify, 'Unstable Fervor':self.unstable_fervor, 'Chimeric Mutation':self.chimeric_mutation, 'Moldering Effluvium':self.moldering_effluvium, 'Squamous Carapace':self.squamous_carapace, 'Winnowing Verdure':self.winnowing_verdure, 'Noxious Respiration':self.noxious_respiration}
            self.str = 6
            self.agl = 6
            self.end = 6
            self.mm = 6
            self.msl = 6
            self.bls = 6
            self.dodge = 6
            self.psyche = 6
            self.wis = 6
            self.rsn = 6
            self.san = 12
            self.init = 6
            self.spirit = 25
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['slashing','piercing','crushing','fire','cold','elec']
        self.resist = []
        self.evolved = False
        super().__init__(name, id, img, loc, owner)
        
        
    # atk efct, add efct -3 rsn, mv rng, atk type becomes poison, rmv all wkns, add all rsts
    def noxious_respiration(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_noxious_respiration)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_noxious_respiration(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Noxious Respiration', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_noxious_respiration(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_noxious_respiration(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Moldering_Effluvium' not in [v.name for v in self.effects_dict.values()] and 'Squamous_Carapace' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Noxious_Respiration' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Winnowing_Verdure' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Noxious Respiration', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Noxious Respiration', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Noxious_Respiration'] = Vis(name = 'Noxious_Respiration', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'atk adds -3 rsn and mv rng, +3 psyche, resist poison', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'atk adds -3 rsn and mv rng, +3 psyche, resist poison', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATTACK EFFECT
        def noxious_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            loc = dfndr.loc[:]
            type = 'poison'
            if (st == 'melee' or st == 'ranged' or st == 'spell') and 'Noxious_Venom' not in [v.name for k,v in dfndr.effects_dict.items()]:
                def nox_abl(stat):
                    return max(0,stat-3)
                p = partial(nox_abl)
                dfndr.rsn_effects.append(p)
                dfndr.move_range_effects.append(p)
                n = 'nox_venom'+str(app.count)
                app.count += 1
                def undo(ent, p, lockname = None):
                    ent.rsn_effects.remove(p)
                    ent.move_range_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, dfndr, p)
                dfndr.effects_dict[n] = Effect(name = 'Noxious_Venom', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Noxious Venom, -3 rsn, mv rng', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Noxious Venom, -3 rsn, mv rng', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(noxious_atk)
        # PSY bonus
        def nox_psy(stat):
            return stat+3
        p = partial(nox_psy)
        self.psyche_effects.append(p)
        # RESIST / WEAK
        def noxious_resist(types):
            return types+['poison']
        self.resist_effects.append(noxious_resist)
        def noxious_weak(types):
            return [t for t in types if t != 'poison']
        self.weak_effects.append(noxious_weak)
        def undo(ent, p, lockname = None):
            ent.psyche_effects.remove(p)
            ent.attack_effects.remove(noxious_atk)
            ent.resist_effects.remove(noxious_resist)
            ent.weak_effects.remove(noxious_weak)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self)
        self.effects_dict['Noxious_Respiration'] = Effect(name = 'Noxious_Respiration', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_noxious_respiration)
        
    def finish_noxious_respiration(self, event = None):
        try: 
            del app.vis_dict['Noxious_Respiration']
            app.canvas.delete('Noxious_Respiration')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    
    def winnowing_verdure(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_winnowing_verdure)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_winnowing_verdure(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Winnowing Verdure', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_winnowing_verdure(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_winnowing_verdure(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Moldering_Effluvium' not in [v.name for v in self.effects_dict.values()] and 'Squamous_Carapace' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Noxious_Respiration' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Winnowing_Verdure' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Winnowing Verdure', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Winnowing Verdure', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Winnowing_Verdure'] = Vis(name = 'Winnowing_Verdure', loc = sqr[:])
        # enemy rng 3 -4 agl,init, fire wkns
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'enemy rng 3 -4 agl,init, resist slashing', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'enemy rng 3 -4 agl,init, resist slashing', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # WEAK/RESIST
        def verdure_weak(types):
            return [t for t in types if t != 'slashing']
        self.weak_effects.append(verdure_weak)
        def verdure_resist(types):
            return types+['slashing']
        self.resist_effects.append(verdure_resist)
        def verdure_ef(stat):
            return max(1,stat-4)
        p = partial(verdure_ef)
        prox_ef = Proximity_Effect(name = 'Winnowing_Verdure', ent = self, range = (1,2), abls = ['agl'], abl_func = p)
        prox_ef2 = Proximity_Effect(name = 'Winnowing_Verdure', ent = self, range = (1,2), abls = ['init'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prox_ef2.get_locs = p2
        prx_name = 'Winnowing_Verdure'+str(app.count)
        app.count+=1
        prx_name2 = 'Winnowing_Verdure'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        app.proximity_effects_dict[prx_name2] = prox_ef2
        def un(ent, prx_key, prx_key2, lockname = None):
            ent.weak_effects.remove(verdure_weak)
            ent.resist_effects.remove(verdure_resist)
            del app.proximity_effects_dict[prx_key]
            del app.proximity_effects_dict[prx_key2]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, prx_name, prx_name2)
        n = 'Winnowing_Verdure' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Winnowing_Verdure', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_winnowing_verdure)
        
    def finish_winnowing_verdure(self, event = None):
        try: 
            del app.vis_dict['Winnowing_Verdure']
            app.canvas.delete('Winnowing_Verdure')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # base melee attack, changed by other actions... starts as piercing melee
    def assail(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_assail)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_assail(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Assail Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_assail(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_assail(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/assail.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Assail'] = Vis(name = 'Assail', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_assail():
                del app.vis_dict['Assail']
                app.canvas.delete('Assail')
            root.after(1666, cleanup_assail)
            lock(apply_damage, self, ent, -d, 'slashing', 'Assail', 'melee')
            root.after(111, self.cancel_assail)
        else:
            miss(sqr)
            root.after(1777, self.cancel_assail)
        
    def cancel_assail(self, event = None):
        self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Assail']
            app.canvas.delete('Assail')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def wooden_skin(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_wooden_skin)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_wooden_skin(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Wooden Skin', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_wooden_skin(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wooden_skin(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Calcify' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Wooden_Skin' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Wooden Skin', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Wooden Skin', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Wooden_Skin'] = Vis(name = 'Wooden_Skin', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Crushing splinters attack, resist piercing, +3 str', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Crushing splinters attack, resist piercing, +3 str', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATTACK EFFECT
        def wooden_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            loc = dfndr.loc[:]
            if st == 'melee':
                if st == 'melee':
                    type = 'crushing'
                if 'Splinters' not in [v.name for k,v in dfndr.effects_dict.items()]:
                    def take_2(ent, lockname = None):
                        app.get_focus(ent.id)
                        lock(apply_damage, self, ent, -2, 'piercing', 'Splinters', 'eot')
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    eot = partial(take_2, dfndr)
                    n = 'Splinters'+str(app.count)
                    app.count += 1
                    def undo(lockname = None):
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo)
                    dfndr.effects_dict[n] = Effect(name = 'Splinters', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Splinters...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Splinters...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                    return dmg,type
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(wooden_atk)
        # RESIST / WEAK
        def wooden_resist(types):
            return types+['piercing']
        self.resist_effects.append(wooden_resist)
        def wooden_weak(types):
            return [t for t in types if t != 'piercing']
        self.weak_effects.append(wooden_weak)
        # STR bonus
        def wdn_str(stat):
            return stat+3
        p = partial(wdn_str)
        self.str_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.attack_effects.remove(wooden_atk)
            ent.resist_effects.remove(wooden_resist)
            ent.weak_effects.remove(wooden_weak)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Wooden_Skin'] = Effect(name = 'Wooden_Skin', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_wooden_skin)
        
    def finish_wooden_skin(self, event = None):
        try: 
            del app.vis_dict['Wooden_Skin']
            app.canvas.delete('Wooden_Skin')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def calcify(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_calcify)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_calcify(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Calcify', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_calcify(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_calcify(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Calcify' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Wooden_Skin' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Calcify', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Calcify', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Calcify'] = Vis(name = 'Calcify', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+3 wis, psy, piercing atk, resist magick', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+3 wis, psy, piercing atk, resist magick', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATK EFFECT
        def calcify_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'piercing'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(calcify_atk)
        # +ABLS
        def calcify_efct(stat):
            return stat+3
        p = partial(calcify_efct)
        self.wis_effects.append(p)
        self.psyche_effects.append(p)
        # RESIST / WEAK
        def calc_resist(types):
            return types+['magick']
        self.resist_effects.append(calc_resist)
        def calc_weak(types):
            return [t for t in types if t != 'magick']
        self.weak_effects.append(calc_weak)
        def undo(ent, p, lockname = None):
            ent.wis_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.resist_effects.remove(calc_resist)
            ent.weak_effects.remove(calc_weak)
            ent.attack_effects.remove(calcify_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Calcify'] = Effect(name = 'Calcify', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_calcify)
        
    def finish_calcify(self, event = None):
        try: 
            del app.vis_dict['Calcify']
            app.canvas.delete('Calcify')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with chimeric mutation, +1 acts, mvs, +5 init, removes all resist, must have wooden skin or calcify
    def unstable_fervor(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_unstable_fervor)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_unstable_fervor(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Unstable Fervor', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_unstable_fervor(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_unstable_fervor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Chimeric_Mutation' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Unstable_Fervor' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Unstable Fervor', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Unstable Fervor', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Unstable_Fervor'] = Vis(name = 'Unstable_Fervor', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+1 acts, resist elec, +3 end', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+1 acts, resist elec, +3 end', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # +ABLS
        def unst_fer_efct(stat):
            return stat+1
        p = partial(unst_fer_efct)
        self.acts_effects.append(p)
        def unst_end(stat):
            return stat+3
        p2 = partial(unst_end)
        self.end_effects.append(p2)
        # RESIST / WEAK
        def unst_fer_resist(types):
            return types+['elec']
        self.resist_effects.append(unst_fer_resist)
        def unst_fer_weak(types):
            return [t for t in types if t != 'elec']
        self.weak_effects.append(unst_fer_weak)
        def undo(ent, p, p2, lockname = None):
            ent.acts_effects.remove(p)
            ent.end_effects.remove(p2)
            ent.resist_effects.remove(unst_fer_resist)
            ent.weak_effects.remove(unst_fer_weak)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2)
        self.effects_dict['Unstable_Fervor'] = Effect(name = 'Unstable_Fervor', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_unstable_fervor)
        
    def finish_unstable_fervor(self, event = None):
        try: 
            del app.vis_dict['Unstable_Fervor']
            app.canvas.delete('Unstable_Fervor')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with unstable fervor, changes move type to flying, +5 mv rng, removes all wkns, gets new action: ranged fire dmg to all dist1, must have wooden skin or calcify
    def chimeric_mutation(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chimeric_mutation)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chimeric_mutation(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Chimeric Mutation', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chimeric_mutation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chimeric_mutation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Chimeric_Mutation' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Unstable_Fervor' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Chimeric Mutation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Chimeric Mutation', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Chimeric_Mutation'] = Vis(name = 'Chimeric_Mutation', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'flying, +4 mv rng, +3 mm, add fire resist, scorch fire attack', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'flying, +4 mv rng, +3 mm, add fire resist, scorch fire attack', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # +ABLS
        def chi_mu_efct(stat):
            return stat+2
        p = partial(chi_mu_efct)
        self.move_range_effects.append(p)
        def chi_mv_type(type):
            return 'flying'
        p2 = partial(chi_mv_type)
        self.move_type_effects.append(p2)
        # MM bonus
        def chi_mm(stat):
            return stat+3
        p3 = partial(chi_mm)
        self.mm_effects.append(p3)
        # RESIST / WEAK
        def chi_mu_weak(types):
            return [t for t in types if t != 'fire']
        self.weak_effects.append(chi_mu_weak)
        def chi_mu_rst(types):
            return types+['fire']
        self.resist_effects.append(chi_mu_rst)
        # ADD SCORCH
        def scorch_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(obj.loc,c) <= obj.get_abl('bls')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Scorch', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/flare.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                def cleanup_scorch(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                ids = [k for k,v in app.all_ents().items() if dist(v.loc,sqr)<=1 and v.owner != self.owner]
                for id in ids:
                    ent = app.ent_dict[id]
                    n = 'scorch'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Immolate', loc = ent.loc)
                    root.after(1666, lambda n = n : cleanup_scorch(n))
                def scorch_loop(ids):
                    if ids == []:
                        cancel_attack(None, obj)
                    else:
                        id = ids[0]
                        ids = ids[1:]
                        ent = app.ent_dict[id]
                        my_mm = obj.get_abl('mm')
                        tar_dod = ent.get_abl('dodge')
                        if to_hit(my_mm, tar_dod) == True:
                            my_msl = obj.get_abl('msl')
                            tar_end = ent.get_abl('end')
                            d = damage(my_msl, tar_end)
                            lock(apply_damage, obj, ent, -d, 'fire', 'Scorch', 'ranged')
                            root.after(111, lambda ids = ids : scorch_loop(ids))
                        else:
                            miss(ent.loc)
                            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1444, lambda ids = ids : scorch_loop(ids))
                scorch_loop(ids)
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                app.rebind_all()
                app.canvas.delete('text')
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        ap = partial(scorch_attack, obj = self)
        def add_scorch(actions = None, func = None):
            actions['Scorch'] = func
            return actions
        ap2 = partial(add_scorch, func = ap)
        self.action_effects.append(ap2)
        def undo(ent, p, p2, p3, ap2, lockname = None):
            ent.mm_effects.remove(p3)
            ent.move_range_effects.remove(p)
            ent.move_type_effects.remove(p2)
            ent.weak_effects.remove(chi_mu_weak)
            ent.resist_effects.remove(chi_mu_rst)
            ent.action_effects.remove(ap2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, p3, ap2)
        self.effects_dict['Chimeric_Mutation'] = Effect(name = 'Chimeric_Mutation', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_chimeric_mutation)
        
    def finish_chimeric_mutation(self, event = None):
        try: 
            del app.vis_dict['Chimeric_Mutation']
            app.canvas.delete('Chimeric_Mutation')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def moldering_effluvium(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_moldering_effluvium)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_moldering_effluvium(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Moldering Effluvium', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_moldering_effluvium(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_moldering_effluvium(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Moldering_Effluvium' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Squamous_Carapace' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Moldering Effluvium', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Moldering Effluvium', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Moldering_Effluvium'] = Vis(name = 'Moldering_Effluvium', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'eot -4 end adjacent, resist acid, acid atk', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'eot -4 end adjacent, resist acid, acid atk', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # EOT EFCT
        def mold_plag(caster, lockname = None):
            def mold_plag_loop(ids):
                if ids == []:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                elif 'Moldering_Effluvium_Plague' in [v.name for v in app.ent_dict[ids[0]].effects_dict.values()] or isinstance(app.ent_dict[ids[0]], (Tomb,Witch)):
                    ids = ids[1:]
                    mold_plag_loop(ids)
                else:
                    id = ids[0]
                    ids = ids[1:]
                    ent = app.ent_dict[id]
                    app.get_focus(id)
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '-4 endurance', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '-4 endurance', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    def mold_plag(stat):
                        return max(1,stat-4)
                    p = partial(mold_plag)
                    ent.end_effects.append(p)
                    def un(ent, p, lockname = None):
                        ent.end_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, ent, p)
                    n = 'mold_effl_plag' + str(app.count)
                    app.count += 1
                    ent.effects_dict[n] = Effect(name = 'Moldering_Effluvium_Plague', undo_func = u, duration = caster.get_abl('rsn'), level = caster.get_abl('wis'))
                    root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1444, lambda ids = ids : mold_plag_loop(ids))
            ids = [k for k,v in app.all_ents().items() if dist(v.loc,caster.loc)==1 and v.owner != caster.owner]
            mold_plag_loop(ids)
        eot = partial(mold_plag, self)
        # ATK EFFECT
        def mold_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'acid'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(mold_atk)
        # RESIST / WEAK
        def mol_eff_resist(types):
            return types+['acid']
        self.resist_effects.append(mol_eff_resist)
        def mol_eff_wkns(types):
            return [t for t in types if t != 'acid']
        self.weak_effects.append(mol_eff_wkns)
        # DODGE bonus
        def mold_dod(stat):
            return stat+3
        p = partial(mold_dod)
        self.dodge_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.dodge_effects.remove(p)
            ent.resist_effects.remove(mol_eff_resist)
            ent.weak_effects.remove(mol_eff_wkns)
            ent.attack_effects.remove(mold_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Moldering_Effluvium'] = Effect(name = 'Moldering_Effluvium', undo_func = u, eot_func = eot, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_moldering_effluvium)
        
    def finish_moldering_effluvium(self, event = None):
        try: 
            del app.vis_dict['Moldering_Effluvium']
            app.canvas.delete('Moldering_Effluvium')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def squamous_carapace(self, even = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_squamous_carapace)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_squamous_carapace(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Squamous Carapace', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_squamous_carapace(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_squamous_carapace(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Moldering_Effluvium' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Squamous_Carapace' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Squamous Carapace', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Squamous Carapace', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Squamous_Carapace'] = Vis(name = 'Squamous_Carapace', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'eot heal 4, remove wkns crushing, +3 dod, agl', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'eot heal 4, remove wkns crushing, +3 dod, agl', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # EOT EFCT
        def squam_eot(ent, lockname = None):
            app.focus_square(ent.loc)
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '+4 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '+4 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            apply_heal(ent, ent, 4)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
            root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(squam_eot, self)
#         ATK EFFECT
#         def squam_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
#             if st == 'melee' or st == 'ranged' or st == 'spell':
#                 type = 'cold'
#                 root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
#                 return dmg,type
#             else:
#                 root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
#                 return dmg,type
#         self.attack_effects.append(squam_atk)
        # RESIST / WEAK
        def squam_wkns(types):
            return [t for t in types if t != 'crushing']
        self.weak_effects.append(squam_wkns)
        def squam_rst(types):
            return types+['crushing']
        self.resist_effects.append(squam_rst)
        # ABL
        def squam_abl(stat):
            return stat+3
        p = partial(squam_abl)
        self.dodge_effects.append(p)
        self.agl_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.weak_effects.remove(squam_wkns)
            ent.resist_effects.remove(squam_rst)
            ent.dodge_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.attack_effects.remove(squam_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Squamous_Carapace'] = Effect(name = 'Squamous_Carapace', undo_func = u, eot_func = eot, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_squamous_carapace)
        
    def finish_squamous_carapace(self, event = None):
        try: 
            del app.vis_dict['Squamous_Carapace']
            app.canvas.delete('Squamous_Carapace')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
class Hexmage(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Nimbus of Oppression':self.nimbus_of_oppression, 'Halo of Encumberance':self.halo_of_encumberance, 'Psychic Suffocation':self.psychic_suffocation, 'Torpor Field':self.torpor_field, 'Cloak of Minerva':self.cloak_of_minerva, 'Rebuking Shield':self.rebuking_shield, 'Nix':self.nix, 'Feedback':self.feedback, 'Trenchant Lunula':self.trenchant_lunula, 'Pierce the Heart':self.pierce_the_heart}
            self.str = 5
            self.agl = 7
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 7
            self.wis = 7
            self.rsn = 5
            self.san = 15
            self.init = 7
            self.spirit = 19
            self.magick = 18
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Nimbus of Oppression':self.nimbus_of_oppression, 'Halo of Encumberance':self.halo_of_encumberance, 'Psychic Suffocation':self.psychic_suffocation, 'Torpor Field':self.torpor_field, 'Cloak of Minerva':self.cloak_of_minerva, 'Rebuking Shield':self.rebuking_shield, 'Nix':self.nix, 'Feedback':self.feedback, 'Trenchant Lunula':self.trenchant_lunula, 'Pierce the Heart':self.pierce_the_heart}
            self.str = 5
            self.agl = 8
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 8
            self.wis = 8
            self.rsn = 5
            self.san = 14
            self.init = 8
            self.spirit = 27
            self.magick = 29
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison', 'magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def nix(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_nix)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_nix(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nix', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_nix(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nix(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Nix', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Nix', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Nix'] = Vis(name = 'Nix', loc = self.loc[:])
        spacer = 30
        to_remove = []
        for k,v in self.effects_dict.items():
            if v.name == 'Nimbus_of_Oppression' or v.name == 'Rebuking_Shield' or v.name == 'Cloak_of_Minerva' or v.name == 'Halo_of_Encumberance' or v.name == 'Psychic_Suffocation' or v.name == 'Torpor_Field':
                if v.dispel(self.get_abl('wis')+10) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'Ivory', tags = 'text')
                    spacer += 15
        for k in to_remove:
            del self.effects_dict[k]
        root.after(1999, self.cancel_nix)
        
    def cancel_nix(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Nix']
            app.canvas.delete('Nix')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def pierce_the_heart(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_pierce_the_heart)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_pierce_the_heart(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pierce the Heart', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_pierce_the_heart(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pierce_the_heart(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Pierce_the_Heart'] = Vis(name = 'Pierce_the_Heart', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = '-2 strength', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = '-2 strength', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def pierce_efct(stat):
                return max(1,stat-2)
            p = partial(pierce_efct)
            ent.str_effects.append(p)
            def undo(ent, func, lockname = None):
                    ent.str_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Pierce_the_Heart'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Pierce_the_Heart', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Pierce_the_Heart']
                app.canvas.delete('Pierce_the_Heart')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, ent, -d, 'piercing', 'Pierce the Heart', 'melee')
            root.after(111, self.cancel_pierce_the_heart)
        else:
            miss(sqr)
            root.after(1999, self.cancel_pierce_the_heart)
        
    
    def cancel_pierce_the_heart(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Pierce_the_Heart']
            app.canvas.delete('Pierce_the_Heart')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
        
    def rebuking_shield(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_rebuking_shield)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_rebuking_shield(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Rebuking Shield', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_rebuking_shield(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rebuking_shield(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) == 1 and v.owner == self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Rebuking Shield', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Rebuking Shield', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Rebuking_Shield'] = Vis(name = 'Rebuking_Shield', loc = self.loc[:])
        def rebuke_res(types):
            return types+['slashing','crushing','piercing']
        p = partial(rebuke_res)
        prox_ef = Proximity_Effect(name = 'Rebuking_Shield', ent = self, range = (0,3), resist_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner == self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Rebuking_Shield'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Rebuking_Shield' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Rebuking_Shield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_rebuking_shield)
        
    def finish_rebuking_shield(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Rebuking_Shield']
            app.canvas.delete('Rebuking_Shield')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def psychic_suffocation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_psychic_suffocation)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_psychic_suffocation(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Psychic Suffocation', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_psychic_suffocation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psychic_suffocation(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) == 1 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Psychic Suffocation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Psychic Suffocation', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Psychic_Suffocation'] = Vis(name = 'Psychic_Suffocation', loc = self.loc[:])
        def psy_suff_ef(stat):
            return max(0,stat-1)
        p = partial(psy_suff_ef)
        prox_ef = Proximity_Effect(name = 'Psychic_Suffocation', ent = self, range = (1,1), abls = ['acts'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Psychic_Suffocation'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Psychic_Suffocation' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Psychic_Suffocation', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_psychic_suffocation)
        
    def finish_psychic_suffocation(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Psychic_Suffocation']
            app.canvas.delete('Psychic_Suffocation')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def trenchant_lunula(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_trenchant_lunula)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_trenchant_lunula(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Trenchant Lunula', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_trenchant_lunula(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_trenchant_lunula(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Trenchant_Lunula'] = Vis(name = 'Trenchant_Lunula', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            # -2 reason
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = '-2 reason', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = '-2 reason', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def lunula_efct(stat):
                return max(1,stat-2)
            p = partial(lunula_efct)
            ent.rsn_effects.append(p)
            def undo(ent, func, lockname = None):
                    ent.rsn_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Trenchant_Lunula'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Trenchant_Lunula', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Trenchant_Lunula']
                app.canvas.delete('Trenchant_Lunula')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, ent, -d, 'slashing', 'Trenchant Lunula', 'melee')
            root.after(111, self.cancel_trenchant_lunula)
        else:
            miss(sqr)
            root.after(1999, self.cancel_trenchant_lunula)
        
    
    def cancel_trenchant_lunula(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Trenchant_Lunula']
            app.canvas.delete('Trenchant_Lunula')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def torpor_field(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_torpor_field)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_torpor_field(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Torpor Field', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_torpor_field(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_torpor_field(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Torpor Field', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Torpor Field', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Torpor_Field'] = Vis(name = 'Torpor_Field', loc = self.loc[:])
        def torpor_ef(stat):
            return max(0,stat-4)
        p = partial(torpor_ef)
        prox_ef = Proximity_Effect(name = 'Torpor_Field', ent = self, range = (1,3), abls = ['move_range'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Torpor_Field'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Torpor_Field' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Torpor_Field', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_torpor_field)
        
    def finish_torpor_field(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Torpor_Field']
            app.canvas.delete('Torpor_Field')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def cloak_of_minerva(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_cloak_of_minerva)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_cloak_of_minerva(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Cloak of Minerva', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_cloak_of_minerva(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cloak_of_minerva(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Cloak of Minerva', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Cloak of Minerva', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Cloak_of_Minerva'] = Vis(name = 'Cloak_of_Minerva', loc = self.loc[:])
        def cloak_ef(stat):
            return stat+4
        p = partial(cloak_ef)
        prox_ef = Proximity_Effect(name = 'Cloak_of_Minerva', ent = self, range = (0,3), abls = ['wis'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner == self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Cloak_of_Minerva'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Cloak_of_Minerva' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Cloak_of_Minerva', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_cloak_of_minerva)
        
    def finish_cloak_of_minerva(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Cloak_of_Minerva']
            app.canvas.delete('Cloak_of_Minerva')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
        
    def nimbus_of_oppression(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_nimbus_of_oppression)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_nimbus_of_oppression(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nimbus of Oppression', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_nimbus_of_oppression(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nimbus_of_oppression(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Nimbus of Oppression', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Nimbus of Oppression', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Nimbus_of_Oppression'] = Vis(name = 'Nimbus_of_Oppression', loc = self.loc[:])
        def nimbus_ef(stat):
            return max(1,stat-4)
        p = partial(nimbus_ef)
        prox_ef = Proximity_Effect(name = 'Nimbus_of_Oppression', ent = self, range = (1,3), abls = ['psyche'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Nimbus_of_Oppression'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Nimbus_of_Oppression' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Nimbus_of_Oppression', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_nimbus_of_oppression)
        
    def finish_nimbus_of_oppression(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Nimbus_of_Oppression']
            app.canvas.delete('Nimbus_of_Oppression')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    def halo_of_encumberance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_halo_of_encumberance)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_halo_of_encumberance(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Halo of Encumberance', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_halo_of_encumberance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_halo_of_encumberance(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Rebuking_Shield' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Cloak_of_Minerva' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Halo of Encumberance', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Halo of Encumberance', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Halo_of_Encumberance'] = Vis(name = 'Halo_of_Encumberance', loc = self.loc[:])
        def nimbus_ef(stat):
            return max(1,stat-4)
        p = partial(nimbus_ef)
        prox_ef = Proximity_Effect(name = 'Halo_of_Encumberance', ent = self, range = (1,3), abls = ['str'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Halo_of_Encumberance'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Halo_of_Encumberance' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Halo_of_Encumberance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_halo_of_encumberance)
        
    def finish_halo_of_encumberance(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Halo_of_Encumberance']
            app.canvas.delete('Halo_of_Encumberance')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def feedback(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_feedback)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_feedback(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Feedback Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_feedback(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_feedback(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Feedback'] = Vis(name = 'Feedback', loc = sqr[:])
        def cleanup_feedback():
            del app.vis_dict['Feedback']
            app.canvas.delete('Feedback')
        d = len([k for k,v in ent.effects_dict.items()])
        root.after(1555, cleanup_feedback)
        lock(apply_damage, self, ent, -d, 'elec', 'Feedback', 'melee')
        root.after(111, self.finish_feedback)
        
    def finish_feedback(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
        
        
class Thaumaturge(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Unholy Chant':self.unholy_chant, 'Arrow of Diana' : self.arrow_of_diana, 'Zephyr Lance':self.zephyr_lance, 'Moonlight' : self.moonlight, 'Esuna':self.esuna, 'Concerted Volley':self.concerted_volley}
            self.str = 3
            self.agl = 8
            self.end = 4
            self.mm = 9
            self.msl = 5
            self.bls = 8
            self.dodge = 5
            self.psyche = 4
            self.wis = 7
            self.rsn = 4
            self.san = 14
            self.init = 7
            self.spirit = 16
            self.magick = 15
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Unholy Chant':self.unholy_chant, 'Arrow of Diana' : self.arrow_of_diana, 'Zephyr Lance':self.zephyr_lance, 'Moonlight' : self.moonlight, 'Esuna':self.esuna, 'Aura':self.aura, 'Tranquility':self.tranquility, 'Concerted Volley':self.concerted_volley, "Devil's Mark":self.devils_mark}
            self.str = 4
            self.agl = 9
            self.end = 5
            self.mm = 10
            self.msl = 6
            self.bls = 9
            self.dodge = 9
            self.psyche = 6
            self.wis = 8
            self.rsn = 5
            self.san = 13
            self.init = 8
            self.spirit = 27
            self.magick = 29
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
#             name = 'Ranger' #this works, just need appr anim files
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['slashing']
        super().__init__(name, id, img, loc, owner)
        
        
    def devils_mark(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_devils_mark)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_devils_mark(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Confirm Devil's Mark Target", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_devils_mark(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_devils_mark(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.spell_target_ents().keys()]:
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if self.magick < 2:
            return
        self.magick -= 2
        if "Devil's_Mark" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/devils_mark.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict["Devil's_Mark"] = Vis(name = "Devil's_Mark", loc = sqr[:])
        vis = app.vis_dict["Devil's_Mark"]
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = "Devil's_Mark")
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(15, 15, text= 'Choose Ability...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        abls = ['strength', 'agility', 'endurance', 'marksmanship', 'missle', 'ballistics', 'dodge', 'psyche', 'wisdom', 'reason', 'sanity', 'initiative']
        for abl in abls:
            b = tk.Button(app.context_menu, text = abl, wraplength = 190, font = ('chalkduster', 16), fg = 'tan3', highlightbackground = 'tan3', command = lambda id = id, abl = abl : self.choose_mark(id, abl))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            
    def choose_mark(self, id, abl):
        app.depop_context(event = None)
        app.canvas.delete('text')
        ent = app.ent_dict[id]
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '+1 '+abl, justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '+1 '+abl, justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def devils_mark_efct(stat):
            return stat+1
        p = partial(devils_mark_efct)
        if abl == 'strength':
            ent.str_effects.append(p)
        elif abl == 'agility':
            ent.agl_effects.append(p)
        elif abl == 'endurance':
            ent.end_effects.append(p)
        elif abl == 'marksmanship':
            ent.mm_effects.append(p)
        elif abl == 'missle':
            ent.msl_effects.append(p)
        elif abl == 'ballistics':
            ent.bls_effects.append(p)
        elif abl == 'dodge':
            ent.dodge_effects.append(p)
        elif abl == 'psyche':
            ent.psyche_effects.append(p)
        elif abl == 'wisdom':
            ent.wis_effects.append(p)
        elif abl == 'reason':
            ent.rsn_effects.append(p)
        elif abl == 'sanity':
            ent.san_effects.append(p)
        elif abl == 'initiative':
            ent.init_effects.append(p)
        def undo(id, abl, func, lockname = None):
            if abl == 'strength':
                app.ent_dict[id].str_effects.remove(func)
            elif abl == 'agility':
                app.ent_dict[id].agl_effects.remove(func)
            elif abl == 'endurance':
                app.ent_dict[id].end_effects.remove(func)
            elif abl == 'marksmanship':
                app.ent_dict[id].mm_effects.remove(func)
            elif abl == 'missle':
                app.ent_dict[id].msl_effects.remove(func)
            elif abl == 'ballistics':
                app.ent_dict[id].bls_effects.remove(func)
            elif abl == 'dodge':
                app.ent_dict[id].dodge_effects.remove(func)
            elif abl == 'psyche':
                app.ent_dict[id].psyche_effects.remove(func)
            elif abl == 'wisdom':
                app.ent_dict[id].wis_effects.remove(func)
            elif abl == 'reason':
                app.ent_dict[id].rsn_effects.remove(func)
            elif abl == 'sanity':
                app.ent_dict[id].san_effects.remove(func)
            elif abl == 'initiative':
                app.ent_dict[id].init_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, abl, p)
        n = "Devil's_Mark"+str(app.count)
        ent.effects_dict[n] = Effect(name = "Devil's_Mark", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_devils_mark)
        
    def cleanup_devils_mark(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict["Devil's_Mark"]
            app.canvas.delete("Devil's_Mark")
        except: pass
        app.canvas.delete('text')
        
        
    def aura(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_aura)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_aura(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Aura', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_aura(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aura(self, event = None, sqr = None, sqrs = None):
#         if sqr not in sqrs:
#             return
#         id = app.grid[sqr[0]][sqr[1]]
#         if id == '' or id == 'block':
#             return
#         if id not in app.spell_target_ents().keys():
#             return
        if self.magick < 4:
            return
        self.magick -= 4
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        rng = 3
        ents = [k for k,v in app.all_ents().items() if 1 <= dist(v.loc, self.loc) <= rng and v.owner == self.owner]
        app.get_focus(choice(ents))
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Aura', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Aura', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        for id in ents:
            loc = app.ent_dict[id].loc[:]
            r = randrange(1,self.get_abl('psyche')+1)
            apply_heal(self, app.ent_dict[id], r)
            un = 'Aura' + str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Aura', loc = loc[:])
            vis = app.vis_dict[un]
            app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = vis.img, tags = un)
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = '+'+str(r)+' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = '+'+str(r)+' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def cleanup_aura(un):
                del app.vis_dict[un]
                app.canvas.delete(un)
            root.after(2666, lambda un = un : cleanup_aura(un))
        root.after(2777, self.finish_aura)
        
    def finish_aura(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)

    def tranquility(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_tranquility)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_tranquility(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Tranquility Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_tranquility(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tranquility(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/tranquility.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Tranquility', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Tranquility', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Tranquility'] = Vis(name = 'Tranquility', loc = sqr[:])
        vis = app.vis_dict['Tranquility']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Tranquility')
        app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+74, text = 'Dispel Attempt\n Local Effects', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+75, text = 'Dispel Attempt\n Local Effects', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        to_remove = []
        effect_loc = sqr[:]
        for k,v in app.loc_dict[tuple(sqr[:])].effects_dict.items():
            if v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
        def remove_entry(s, key):
            del app.loc_dict[tuple(s)].effects_dict[key]
        for k in to_remove:
            root.after(333, lambda s = effect_loc, k = k : remove_entry(s, k))
        root.after(2666, self.finish_tranquility)
        
    def finish_tranquility(self, event = None):
        try: 
            del app.vis_dict['Tranquility']
            app.canvas.delete('Tranquility')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def esuna(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_esuna)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_esuna(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Esuna Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_esuna(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_esuna(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/esuna.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Esuna', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Esuna', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Esuna'] = Vis(name = 'Esuna', loc = sqr[:])
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
                if spacer > 300:
                    continue
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
            
        root.after(2666, self.finish_esuna)
        
    def finish_esuna(self, event = None):
        try: 
            del app.vis_dict['Esuna']
            app.canvas.delete('Esuna')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def moonlight(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_moonlight)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_moonlight(event = e, s = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Moonlight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_moonlight(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_moonlight(self, event, s, sqrs):
        global selected_vis
        id = app.grid[s[0]][s[1]]
        if id not in app.spell_target_ents().keys():
            return
        if s not in sqrs:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/moonlight.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         self.init_cast_anims()
        amt = self.get_abl('psyche')
        apply_heal(self, app.ent_dict[id], amt)
        app.vis_dict['Moonlight'] = Vis(name = 'Moonlight', loc = s)
        app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+70-app.moved_down, image = app.vis_dict['Moonlight'].img, tags = 'Moonlight')
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+74-app.moved_down, text = 'Moonlight', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+75-app.moved_down, text = 'Moonlight', font = ('chalkduster', 16), fill = 'azure', tags = 'text')
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+89-app.moved_down, text = '+'+str(amt)+' Spirit', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+90-app.moved_down, text = '+'+str(amt)+' Spirit', font = ('chalkduster', 13), fill = 'azure', tags = 'text')
        selected_vis.append('Moonlight')
        def moonlight_loop(starty, endy, x):
            if starty > endy:
                app.vis_dict['Moonlight'].rotate_image()
                app.canvas.delete('Moonlight')
                app.canvas.create_image(x, starty, image = app.vis_dict['Moonlight'].img, tags = 'Moonlight')
                starty -= 10
                app.canvas.move('Moonlight', 0, -10)
                app.canvas.tag_raise('Moonlight')
            if starty == endy:
                selected_vis.remove('Moonlight')
                root.after(333, self.cleanup_moonlight)
            else:
                root.after(166, lambda sy = starty, ey = endy, x = x : moonlight_loop(sy, ey, x))
        locy = s[1]*100+70-app.moved_down
        locx = s[0]*100+50-app.moved_right
        moonlight_loop(locy, locy-120, locx)
        
    def cleanup_moonlight(self, event = None):
#         self.init_normal_anims()
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Moonlight']
            app.canvas.delete('Moonlight')
        except: pass
        try: app.canvas.delete('text')
        except: pass
        
    def unholy_chant(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_unholy_chant)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_unholy_chant(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Unholy Chant', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_unholy_chant(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_unholy_chant(self, event = None, sqrs = None):
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/unholy_chant.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc, self.loc) <= 2 and 'Unholy_Chant' not in [j.name for i,j in v.effects_dict.items()]]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Unholy Chant', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Unholy Chant', justify = 'center', font = ('chalkduster', 14), fill = 'ivory3', tags = 'text')
        def cleanup_vis(n):
            del app.vis_dict[n]
        for id in ents:
            e = app.ent_dict[id]
            n2 = 'Unholy_Chant' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Unholy_Chant', loc = e.loc)
            app.canvas.create_image(e.loc[0]*100+50-app.moved_right, e.loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = 'Unholy_Chant')
            app.canvas.create_text(e.loc[0]*100+49-app.moved_right, e.loc[1]*100+89-app.moved_down, text = '+1 All Stats', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(e.loc[0]*100+50-app.moved_right, e.loc[1]*100+90-app.moved_down, text = '+1 All Stats', font = ('chalkduster', 12), fill = 'white', tags = 'text')
            root.after(2999, lambda n = n2 : cleanup_vis(n))
            def unholy_chant_effect(stat):
                return stat + 1
            p = partial(unholy_chant_effect)
            e.str_effects.append(p)
            e.end_effects.append(p)
            e.agl_effects.append(p)
            e.mm_effects.append(p)
            e.msl_effects.append(p)
            e.bls_effects.append(p)
            e.dodge_effects.append(p)
            e.psyche_effects.append(p)
            e.wis_effects.append(p)
            e.rsn_effects.append(p)
            e.san_effects.append(p)
            e.init_effects.append(p)
            e.move_range_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                app.ent_dict[i].agl_effects.remove(func)
                app.ent_dict[i].mm_effects.remove(func)
                app.ent_dict[i].msl_effects.remove(func)
                app.ent_dict[i].bls_effects.remove(func)
                app.ent_dict[i].dodge_effects.remove(func)
                app.ent_dict[i].psyche_effects.remove(func)
                app.ent_dict[i].wis_effects.remove(func)
                app.ent_dict[i].rsn_effects.remove(func)
                app.ent_dict[i].san_effects.remove(func)
                app.ent_dict[i].init_effects.remove(func)
                app.ent_dict[i].move_range_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Unholy_Chant' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Unholy_Chant', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(3111, self.finish_unholy_chant)
        
    def finish_unholy_chant(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def concerted_volley(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_concerted_volley)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_concerted_volley(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Concerted Volley', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_concerted_volley(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_concerted_volley(self, event = None, sqrs = None):
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/unholy_chant.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and v.loc in sqrs and v.get_inert()==False and 'Concerted_Volley' not in [j.name for i,j in v.effects_dict.items()]]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Concerted Volley', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Concerted Volley', justify = 'center', font = ('chalkduster', 14), fill = 'ivory3', tags = 'text')
        def cleanup_vis(n):
            del app.vis_dict[n]
        num = min(4, len(ents))
        for id in ents:
            ent = app.ent_dict[id]
            n2 = 'Concerted_Volley' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Concerted_Volley', loc = ent.loc)
            app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = 'Concerted_Volley')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+ '+str(num)+' mm', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+ '+str(num)+' mm', font = ('chalkduster', 12), fill = 'ghostwhite', tags = 'text')
            root.after(1999, lambda n = n2 : cleanup_vis(n))
            def concerted_volley_effect(stat, num = None):
                return stat+num
            p = partial(concerted_volley_effect, num = num)
            ent.mm_effects.append(p)
            def undo(i, func, lockname = None):
                app.ent_dict[i].mm_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Concerted_Volley' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Concerted_Volley', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, self.finish_concerted_volley)
        
    def finish_concerted_volley(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def zephyr_lance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_zephyr_lance)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_zephyr_lance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Zephyr Lance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_zephyr_lance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_zephyr_lance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Zephyr_Lance'] = Vis(name = 'Zephyr_Lance', loc = sqr[:])
        my_wis = self.get_abl('wis')
        def cleanup_zephyr():
            del app.vis_dict['Zephyr_Lance']
            app.canvas.delete('Zephyr_Lance')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(1555, cleanup_zephyr)
            lock(apply_damage, self, ent, -d, 'slashing', 'Zephyr Lance', 'spell')
            root.after(111, self.finish_zephyr_lance)
        else:
            miss(ent.loc)
            root.after(1888, cleanup_zephyr)
            root.after(1999, self.finish_zephyr_lance)
        
    def finish_zephyr_lance(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
    
    
    
    def arrow_of_diana(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_arrow)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_arrow(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Arrow Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_arrow(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_arrow(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Arrow_of_Diana'] = Vis(name = 'Arrow_of_Diana', loc = sqr[:])
        vis = app.vis_dict['Arrow_of_Diana']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Arrow_of_Diana')
        my_mm = self.get_abl('mm')
        def cleanup_arrow():
            del app.vis_dict['Arrow_of_Diana']
            app.canvas.delete('Arrow_of_Diana')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(1555, cleanup_arrow)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Arrow of Diana', 'ranged')
            root.after(111, self.finish_arrow)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1888, cleanup_arrow)
            root.after(1999, self.finish_arrow)
        
    def finish_arrow(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
# finish inquisitor, cleanse with fire- all wi range3 on wis v wis tohit take psy v psy fire spl, persecute- all wi rng3 on wis v wis tohit lose mgk = psy, prophecy- tar gets +3 rsn efct
class Inquisitor(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Cleanse with Fire':self.cleanse_with_fire, 'Persecute':self.persecute, 'Prophecy':self.prophecy, 'Nullify':self.nullify, 'Abeyance':self.abeyance, 'Anoint':self.anoint, 'Reveal':self.reveal}
            self.str = 8
            self.agl = 4
            self.end = 7
            self.mm = 4
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 6
            self.wis = 7
            self.rsn = 5
            self.san = 14
            self.init = 7
            self.spirit = 18
            self.magick = 18
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Cleanse with Fire':self.cleanse_with_fire, 'Persecute':self.persecute, 'Prophecy':self.prophecy, 'Nullify':self.nullify, 'Abeyance':self.abeyance, 'Anoint':self.anoint, 'Reveal':self.reveal}
            self.str = 9
            self.agl = 5
            self.end = 8
            self.mm = 5
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 7
            self.wis = 8
            self.rsn = 6
            self.san = 13
            self.init = 8
            self.spirit = 26
            self.magick = 26
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['cold', 'fire']
        super().__init__(name, id, img, loc, owner)
        
        
    def persecute(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_persecute)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_persecute(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Persecute', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_persecute(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_persecute(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Persecute', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Persecute', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        def cleanup_persecute(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def persecute_loop(ids):
            if ids == []:
                self.finish_persecute()
            else:
                effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                id = ids[0]
                app.get_focus(id)
                ids = ids[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                n = 'Persecute' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Persecute', loc = s)
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = self.get_abl('psyche')
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-'+str(d)+' magick', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-'+str(d)+' magick', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                    ent.magick -= d
                    if ent.magick < 0:
                        ent.magick = 0
                    root.after(1555, lambda n = n : cleanup_persecute(n))
                    root.after(1666, lambda ids = ids : persecute_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1555, lambda n = n : cleanup_persecute(n))
                    root.after(1666, lambda ids = ids : persecute_loop(ids))
        persecute_loop(ids)
        
    def finish_persecute(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def cleanse_with_fire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_cleanse_with_fire)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_cleanse_with_fire(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Cleanse with Fire', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_cleanse_with_fire(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cleanse_with_fire(self, event = None, sqrs = None):
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Cleanse with Fire', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Cleanse with Fire', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner and isinstance(v,Tomb)==False]
        def cleanup_cleanse(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for id in ids:
            ent = app.ent_dict[id]
            n = 'Cleanse' + str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Cleanse_with_Fire', loc = ent.loc[:])
            root.after(1999, lambda n = n : cleanup_cleanse(n))
        def cleanse_loop(ids):
            if ids == []:
                self.finish_cleanse_with_fire()
            else:
                effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                id = ids[0]
                app.get_focus(id)
                ids = ids[1:]
                ent = app.ent_dict[id]
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, ent, -d, 'fire', 'Cleanse with Fire', 'ranged')
                    cleanse_loop(ids)
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : cleanse_loop(ids))
        cleanse_loop(ids)
        
    def finish_cleanse_with_fire(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.exists_check(app.active_ent)
        
        
    # all wi rng, dispel atmpt all efcts
    def nullify(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_nullify)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_nullify(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nullify', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_nullify(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nullify(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/nullify.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Nullify', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Nullify', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and 'psyshield' not in v.get_types() and 'invisibility' not in v.get_types()]
        def cleanup_nullify(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def nullify_loop(ents):
            if ents == []:
                self.finish_nullify()
            else:
                id = ents[0]
                app.get_focus(id)
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Nullify' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Nullify', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Dispel Attempt\nAll Effects', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Dispel Attempt\nAll Effects', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1555, lambda u = u : cleanup_nullify(u))
                root.after(1666, lambda ents = ents : nullify_loop(ents))
        nullify_loop(ents)
        
    def finish_nullify(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    # remove target action
    def abeyance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_abeyance)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_abeyance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Abeyance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_abeyance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_abeyance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/abeyance.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        n = 'Abeyance'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Abeyance', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_abey(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_abey(n))
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove Action', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove Action', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            actions = [(k, v) for k,v in ent.get_actions().items()]
            if actions == []:
                root.after(2666, lambda e = None : self.finish_abeyance(event = e))
            else:
                self.page_abeyance(actions = actions, id = id)
        else:
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda e = None : self.finish_abeyance(event = e))
                    
                    
    def page_abeyance(self, event = None, actions = None, id = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, key_ef in enumerate(actions[index:index+5]):
            i += 1
            key = key_ef[0]
            ef = key_ef[1]
            p = partial(self.abeyance_remove, id = id, func = ef, key = key)
#             root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = key.replace('_', ' '), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            # below should become effect_description_popup, (there is no equivalent to more info popup, effect desc shown in more info
#             b1.bind('<Button-2>', lambda ef = ef : app.effect_description(ef))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda actions = actions, id = id, i = index-5 : self.page_abeyance(actions = actions , id = id, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, actions = actions, id = id, i = index-5 : self.page_abeyance(actions = actions, id = id, index = i))
            app.context_buttons.append(b4)
        if len(actions) > len(actions[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda actions = actions, id = id, i = index+5 : self.page_abeyance(actions = actions, id = id, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, actions = actions, id = id, i = index+5 : self.page_abeyance(actions = actions, id = id, index = i))
                    
            
    def abeyance_remove(self, id, func, key):
        app.depop_context(event = None)
        app.canvas.delete('text')
        ent = app.ent_dict[id]
        def abey_rmv(actions_dict):
            if key in actions_dict.keys():
                del actions_dict[key]
            return actions_dict
        p = partial(abey_rmv)
        ent.action_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Abeyance'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Abeyance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = key+' Removed', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = key+' Removed', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
        root.after(1999, self.finish_abeyance)
        
    def finish_abeyance(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
    def prophecy(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_prophecy)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_prophecy(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Prophecy', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_prophecy(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_prophecy(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if self.magick < 4:
            return
        if 'Prophecy' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 4
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Prophecy', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Prophecy', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Prophecy'] = Vis(name = 'Prophecy', loc = ent.loc[:])
        def prophecy_effect(stat):
            return stat+3
        p = partial(prophecy_effect)
        ent.rsn_effects.append(p)
        def un(id, func, lockname = None):
            app.ent_dict[id].rsn_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p)
        n = 'Prophecy' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Prophecy', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+3 reason', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+3 reason', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(1999, self.cleanup_prophecy)
        
        
    def cleanup_prophecy(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Prophecy']
            app.canvas.delete('Prophecy')
        except: pass
        app.canvas.delete('text')
        
        
        
    # +1 wisdom to target
    def anoint(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_anoint)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_anoint(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Anoint', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_anoint(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_anoint(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if self.magick < 1:
            return
        if 'Anoint' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Anoint', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Anoint', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Anoint'] = Vis(name = 'Anoint', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Anoint'].img, tags = 'Anoint')
        def anoint_effect(stat):
            return stat+1
        p = partial(anoint_effect)
        ent.wis_effects.append(p)
        def un(id, func, lockname = None):
            app.ent_dict[id].wis_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p)
        n = 'Anoint' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Anoint', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 wisdom', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 wisdom', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(1999, self.cleanup_anoint)
        
        
    def cleanup_anoint(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Anoint']
            app.canvas.delete('Anoint')
        except: pass
        app.canvas.delete('text')
        
        
    # on to-hit, if tar has psysh, efct strips psysh, else efct strips invis
    def reveal(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_reveal)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_reveal(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Reveal Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_reveal(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_reveal(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/reveal.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            if 'psyshield' in ent.get_types():
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove psyshield', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove psyshield', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                def reveal_psyshield(ts):
                    return [t for t in ts if t != 'psyshield']
                p = partial(reveal_psyshield)
                ent.type_effects.append(p)
                def un(id, func, lockname = None):
                    app.ent_dict[id].type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, id, p)
                n = 'Reveal' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Reveal_Psyshield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1999, self.finish_reveal)
            else:
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove invisibility', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove invisibility', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                def reveal_invisibility(ts):
                    return [t for t in ts if t != 'invisibility']
                p = partial(reveal_invisibility)
                ent.type_effects.append(p)
                def un(id, func, lockname = None):
                    app.ent_dict[id].type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, id, p)
                n = 'Reveal' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Reveal_Invisibility', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1999, self.finish_reveal)
        else:
            miss(ent.loc)
            root.after(1999, self.finish_reveal)
        
    def finish_reveal(self, event = None):
        try: 
            del app.vis_dict['Reveal']
            app.canvas.delete('Reveal')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
class Pixie(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Elemental Langour':self.elemental_langour, 'Asthenia':self.asthenia, 'Detox':self.detox, 'Geomantic Clutch':self.geomantic_clutch, 'Biotranspose':self.biotranspose, 'Glammering':self.glammering}
            self.str = 3
            self.agl = 8
            self.end = 3
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 8
            self.psyche = 7
            self.wis = 7
            self.rsn = 6
            self.san = 14
            self.init = 8
            self.spirit = 17
            self.magick = 21
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Elemental Langour':self.elemental_langour, 'Detox':self.detox, 'Geomantic Clutch':self.geomantic_clutch, 'Needle Storm':self.needle_storm, 'Biotranspose':self.biotranspose, 'Glammering':self.glammering, 'Pixie Dust':self.pixie_dust}
            self.str = 4
            self.agl = 9
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 6
            self.wis = 8
            self.rsn = 7
            self.san = 14
            self.init = 10
            self.spirit = 21
            self.magick = 35
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'flying'
        self.weak = ['crushing']
        self.resist = ['magick', 'explosive']
        super().__init__(name, id, img, loc, owner)
        
    def pixie_dust(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pixie_dust)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pixie_dust(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Pixie Dust', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pixie_dust(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pixie_dust(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 2:
            return
        self.magick -= 2
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Pixie_Dust'] = Vis(name = 'Pixie_Dust', loc = ent.loc[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Pixie Dust', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Pixie Dust', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = 'invisibility', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = 'invisibility', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        def pdust_effect(types):
            return types + ['psyshield']
        p = partial(pdust_effect)
        ent.type_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.type_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Pixie_Dust'+str(app.count)
        ent.effects_dict[n] = Effect(name = 'Pixie_Dust', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1666, lambda e = None : self.finish_pixie_dust(event = e))
        
    def finish_pixie_dust(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Pixie_Dust']
            app.canvas.delete('Pixie_Dust')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)
        
        
    def glammering(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_glammering)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_glammering(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Glammering', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_glammering(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_glammering(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 2:
            return
        self.magick -= 2
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Glammering'] = Vis(name = 'Glammering', loc = ent.loc[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Glammering', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Glammering', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '-2 rsn, move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '-2 rsn, move range', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            def gaze_effect(stat):
                return max(1,stat-2)
            p = partial(gaze_effect)
            ent.rsn_effects.append(p)
            ent.move_range_effects.append(p)
            def undo(ent, func, lockname = None):
                ent.rsn_effects.remove(func)
                ent.move_range_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Glammering'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Glammering', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(ent.loc)
        root.after(1666, lambda e = None : self.finish_glammering(event = e))
        
    def finish_glammering(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Glammering']
            app.canvas.delete('Glammering')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)
        
        
    def biotranspose(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_biotranspose)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_biotranspose(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Biotranspose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_biotranspose(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_biotranspose(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        if 'Biotranspose' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/biotranspose.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Biotranspose'] = Vis(name = 'Biotranspose', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Switch strength and psyche', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Switch strength and psyche', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            str = ent.get_abl('str')
            psy = ent.get_abl('psyche')
            str_mod = psy-str
            psy_mod = str-psy
            def bio_str(abl, mod = 0):
                return max(1, abl+mod)
            p = partial(bio_str, mod = str_mod)
            def bio_psy(abl, mod  = 0):
                return max(1, abl+mod)
            p2 = partial(bio_psy, mod = psy_mod)
            ent.str_effects.append(p)
            ent.psyche_effects.append(p2)
            def undo(ent, p, p2, lockname = None):
                ent.str_effects.remove(p)
                ent.psyche_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            ent.effects_dict['Biotranspose'] = Effect(name = 'Biotranspose', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_biotranspose)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_biotranspose)
        
    def finish_biotranspose(self, event = None):
        try: 
            del app.vis_dict['Biotranspose']
            app.canvas.delete('Biotranspose')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
    def detox(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_detox)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_detox(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Detox Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_detox(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_detox(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/esuna.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Detox', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Detox', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Detox'] = Vis(name = 'Detox', loc = sqr[:])
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.eot_func != None:
                if v.dispel(self.get_abl('wis')) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                    spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
        root.after(2666, self.finish_detox)
        
    def finish_detox(self, event = None):
        try: 
            del app.vis_dict['Detox']
            app.canvas.delete('Detox')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def needle_storm(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_needle_storm)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_needle_storm(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Needle Storm Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_needle_storm(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_needle_storm(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        ent = app.ent_dict[id]
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/geomantic_clutch.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Needle_Storm'] = Vis(name = 'Needle_Storm', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            def needle_dodge(stat):
                return max(1,stat-1)
            p = partial(needle_dodge)
            ent.dodge_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.dodge_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            un = 'Needle_Storm'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Needle_Storm', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            lock(apply_damage, self, ent, -d, 'piercing', 'Needle Storm', 'spell')
            root.after(111, self.finish_needle_storm)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_needle_storm)
        
    def finish_needle_storm(self, event = None):
        try: 
            del app.vis_dict['Needle_Storm']
            app.canvas.delete('Needle_Storm')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def geomantic_clutch(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_geomantic_clutch)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_geomantic_clutch(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Geomantic Clutch Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_geomantic_clutch(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_geomantic_clutch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 4:
            return
        ent = app.ent_dict[id]
        self.magick -= 4
        effect1 = mixer.Sound('Sound_Effects/geomantic_clutch.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Geomantic_Clutch'] = Vis(name = 'Geomantic_Clutch', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            if 'Geomantic_Clutch' not in [v.name for k,v in ent.effects_dict.items()]:
                def clutch_move_range(abl):
                    return max(0,abl-3)
                p = partial(clutch_move_range)
                ent.move_range_effects.append(p)
                if ent.get_move_type() == 'flying':
                    d += 3
                    def clutch_move(type):
                        return 'normal'
                    p2 = partial(clutch_move)
                    ent.move_type_effects.append(p2)
                    def undo(ent, p, p2, lockname = None):
                        ent.move_range_effects.remove(p)
                        ent.move_type_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p, p2)
                else:
                    def undo(ent, p, lockname = None):
                        ent.move_range_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                ent.effects_dict['Geomantic_Clutch'] = Effect(name = 'Geomantic_Clutch', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            elif ent.get_move_type() == 'flying':
                d += 3
            lock(apply_damage, self, ent, -d, 'crushing', 'Geomantic Clutch', 'spell')
            root.after(111, self.finish_geomantic_clutch)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_geomantic_clutch)
        
    def finish_geomantic_clutch(self, event = None):
        try: 
            del app.vis_dict['Geomantic_Clutch']
            app.canvas.delete('Geomantic_Clutch')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def asthenia(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_asthenia)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_asthenia(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Asthenia Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_asthenia(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_asthenia(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        if 'Asthenia' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if 'Elemental_Langour' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/discord.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Asthenia'] = Vis(name = 'Asthenia', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Weak Physical Damage', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Weak Physical Damage', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def asthenia_resist(types):
                return [t for t in types if t != 'slashing' and t != 'piercing' and t != 'crushing']
            ent.resist_effects.append(asthenia_resist)
            def asthenia_weak(types):
                return types+['slashing','piercing','crushing']
            ent.weak_effects.append(asthenia_weak)
            def undo(ent, lockname = None):
                ent.resist_effects.remove(asthenia_resist)
                ent.weak_effects.remove(asthenia_weak)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent)
            ent.effects_dict['Asthenia'] = Effect(name = 'Asthenia', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_asthenia)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_asthenia)
        
    def finish_asthenia(self, event = None):
        try: 
            del app.vis_dict['Asthenia']
            app.canvas.delete('Asthenia')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
    def elemental_langour(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_elemental_langour)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_elemental_langour(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Elemental Langour Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_elemental_langour(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_elemental_langour(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        if 'Asthenia' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if 'Elemental_Langour' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/drain_life.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Elemental_Langour'] = Vis(name = 'Elemental_Langour', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Weak Elemental Damage', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Weak Elemental Damage', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def langour_resist(types):
                return [t for t in types if t != 'fire' and t != 'elec' and t != 'cold']
            ent.resist_effects.append(langour_resist)
            def langour_weak(types):
                return types+['fire','cold','elec']
            ent.weak_effects.append(langour_weak)
            def undo(ent, lockname = None):
                ent.resist_effects.remove(langour_resist)
                ent.weak_effects.remove(langour_weak)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent)
            ent.effects_dict['Elemental_Langour'] = Effect(name = 'Elemental_Langour', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_elemental_langour)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_elemental_langour)
        
    def finish_elemental_langour(self, event = None):
        try: 
            del app.vis_dict['Elemental_Langour']
            app.canvas.delete('Elemental_Langour')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
class Drake(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Spit Venom':self.spit_venom, 'Hindering Mucilage':self.hindering_mucilage, 'Wing Buffet':self.wing_buffet, 'Chameleon Camouflage':self.chameleon_camouflage, 'Shimmering Scales':self.shimmering_scales}
            self.str = 6
            self.agl = 7
            self.end = 6
            self.mm = 8
            self.msl = 5
            self.bls = 4
            self.dodge = 4
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 9
            self.init = 9
            self.spirit = 21
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Spit Venom':self.spit_venom, 'Hindering Mucilage':self.hindering_mucilage, 'Wing Buffet':self.wing_buffet, 'Screech':self.screech, 'Chameleon Camouflage':self.chameleon_camouflage, 'Shimmering Scales':self.shimmering_scales}
            self.str = 7
            self.agl = 8
            self.end = 8
            self.mm = 9
            self.msl = 6
            self.bls = 5
            self.dodge = 5
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 11
            self.init = 10
            self.spirit = 29
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'flying'
        self.weak = ['elec']
        self.resist = ['poison']
        super().__init__(name, id, img, loc, owner)
        
    def wing_buffet(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_wing_buffet)
        max = self.get_abl('bls')
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= max]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_wing_buffet(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Wing Buffet', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_wing_buffet(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wing_buffet(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/psionic_push.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.vis_dict['Wing_Buffet'] = Vis(name = 'Wing_Buffet', loc = sqr[:])
        if to_hit(self.get_abl('mm'),ent.get_abl('dodge')) == True:
            locs = [c for c in app.coords if dist(c,ent.loc) <= self.get_abl('str') and app.grid[c[0]][c[1]] == '']
            if locs != []:
                newloc = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, locs)
                lock(ent.throw_move, newloc)
                app.canvas.delete('text')
                app.get_focus(id)
            d = damage(self.get_abl('msl'),ent.get_abl('end'))
            root.after(1666, self.cleanup_wing_buffet)
            lock(apply_damage, self, ent, -d, 'explosive', 'Wing Buffet', 'ranged')
        else:
            miss(ent.loc)
            root.after(1666, self.cleanup_wing_buffet)
        
    def cleanup_wing_buffet(self, event = None):
        try: 
            del app.vis_dict['Wing_Buffet']
            app.canvas.delete('Wing_Buffet')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
    def chameleon_camouflage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chameleon_camouflage)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chameleon_camouflage(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Chameleon Camouflage', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chameleon_camouflage(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chameleon_camouflage(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Chameleon_Camouflage' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Shimmering_Scales' in [v.name for v in self.effects_dict.values()]:
            return
        effect1 = mixer.Sound('Sound_Effects/discord.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Chameleon Camouflage', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Chameleon Camouflage', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Chameleon_Camouflage'] = Vis(name = 'Chameleon_Camouflage', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Invisible', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Invisible', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def chameleon_effect(types):
            return types + ['invisibility']
        p = partial(chameleon_effect)
        self.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Chameleon_Camouflage'] = Effect(name = 'Chameleon_Camouflage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_chameleon_camouflage)
        
    def finish_chameleon_camouflage(self, event = None):
        try: 
            del app.vis_dict['Chameleon_Camouflage']
            app.canvas.delete('Chameleon_Camouflage')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def shimmering_scales(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_shimmering_scales)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_shimmering_scales(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Shimmering Scales', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_shimmering_scales(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_shimmering_scales(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Chameleon_Camouflage' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Shimmering_Scales' in [v.name for v in self.effects_dict.values()]:
            return
        effect1 = mixer.Sound('Sound_Effects/biotranspose.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Shimmering Scales', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Shimmering Scales', justify = 'center', fill = 'lightseagreen', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Shimmering_Scales'] = Vis(name = 'Shimmering_Scales', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Psyshield', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Psyshield', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def scales_effect(types):
            return types + ['psyshield']
        p = partial(scales_effect)
        self.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Shimmering_Scales'] = Effect(name = 'Shimmering_Scales', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_shimmering_scales)
        
    def finish_shimmering_scales(self, event = None):
        try: 
            del app.vis_dict['Shimmering_Scales']
            app.canvas.delete('Shimmering_Scales')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def hindering_mucilage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_hindering_mucilage)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hindering_mucilage(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Hindering Mucilage Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hindering_mucilage(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hindering_mucilage(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Hindering_Mucilage' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Hindering Mucilage', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Hindering Mucilage', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Hindering_Mucilage' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Hindering_Mucilage', loc = sqr[:])
        # -3 move range, agl, dodge if normal move type
        def mucilage_effect(stat, sqr=None):
            id = list(filter(lambda id : app.ent_dict[id].loc == sqr, app.all_ents().keys()))
            if id != []:
                id = id[0]
                if app.ent_dict[id].get_move_type() == 'normal':
                    return max(1,stat-3)
                else:
                    return stat
            else:
                return stat
        p = partial(mucilage_effect, sqr = sqr)
        app.loc_dict[tuple(sqr)].dodge_effects.append(p)
        app.loc_dict[tuple(sqr)].agl_effects.append(p)
        app.loc_dict[tuple(sqr)].move_range_effects.append(p)
        def undo(s, un, p, lockname = None):
            app.loc_dict[tuple(s)].dodge_effects.remove(p)
            app.loc_dict[tuple(s)].agl_effects.remove(p)
            app.loc_dict[tuple(s)].move_range_effects.remove(p)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Hindering_Mucilage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = -7)
        root.after(1666, self.cleanup_hindering_mucilage)
        
    def cleanup_hindering_mucilage(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def screech(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_screech)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_screech(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Screech', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_screech(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_screech(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.vis_dict['Screech'] = Vis(name = 'Screech', loc = sqr[:])
        if to_hit(self.get_abl('mm'),ent.get_abl('dodge')) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = '-3 san, -1 mv rng', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = '-3 san, -1 mv rng', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
            def screech_san(stat):
                return max(1,stat-3)
            p = partial(screech_san)
            ent.san_effects.append(p)
            def screech_mvrng(stat):
                return max(0,stat-1)
            p2 = partial(screech_mvrng)
            ent.move_range_effects.append(p2)
            def undo(ent, p, p2, lockname=None):
                ent.san_effects.remove(p)
                ent.move_range_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            n = 'Screech' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Screech', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
            root.after(1666, lambda e = None : self.cleanup_screech(event = e))
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cleanup_screech(event = e))
        
    def cleanup_screech(self, event = None):
        try: 
            del app.vis_dict['Screech']
            app.canvas.delete('Screech')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def spit_venom(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spit_venom)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_spit_venom(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Spit Venom', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_spit_venom(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spit_venom(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.vis_dict['Spit_Venom'] = Vis(name = 'Spit_Venom', loc = sqr[:])
        if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
            def undo(lockname=None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo)
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -2, 'poison', 'Drake Venom', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, id)
            n = 'Spit_Venom' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Spit_Venom', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
            root.after(1666, lambda e = None : self.cleanup_spit_venom(event = e))
            lock(apply_damage, self, app.ent_dict[id], -d, 'poison', 'Spit Venom', 'ranged')
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, lambda e = None : self.cleanup_spit_venom(event = e))
        
    def cleanup_spit_venom(self, event = None):
        try: 
            del app.vis_dict['Spit_Venom']
            app.canvas.delete('Spit_Venom')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
class Fiend(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Suplex':self.suplex, 'Chain Lightning':self.chain_lightning, 'Hidden Haymaker':self.hidden_haymaker, 'Overload':self.overload, 'Roar' : self.roar}
            self.str = 8
            self.agl = 6
            self.end = 6
            self.mm = 6
            self.msl = 5
            self.bls = 4
            self.dodge = 4
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 9
            self.init = 5
            self.spirit = 21
            self.magick = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Suplex':self.suplex, 'Chain Lightning':self.chain_lightning, 'Hidden Haymaker':self.hidden_haymaker, 'Overload':self.overload, 'Roar' : self.roar}
            self.str = 9
            self.agl = 7
            self.end = 7
            self.mm = 7
            self.msl = 6
            self.bls = 5
            self.dodge = 5
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 11
            self.init = 6
            self.spirit = 29
            self.magick = 16
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['elec']
        self.pounce_anims = {}
        for k,v in app.pounce_anims.items():
            self.pounce_anims[k] = v
        super().__init__(name, id, img, loc, owner)
        
    def init_pounce_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.pounce_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
        
    def overload(self, event = None):
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_overload)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_overload(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Overload', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_overload(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_overload(self, event, sqr, sqrs):
        if self.acts < 1:
            return
        if 'Overload' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.get_abl('str') < self.str+2 or self.get_abl('psyche') < self.psyche+2:
            return
        if sqr not in sqrs:
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Overload', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Overload', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Overload'] = Vis(name = 'Overload', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+1 acts', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+1 acts', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def overload_efct(stat):
            return stat+1
        p = partial(overload_efct)
        self.acts_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.acts_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Overload'] = Effect(name = 'Overload', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_overload)
        
    def finish_overload(self, event = None):
        try: 
            del app.vis_dict['Overload']
            app.canvas.delete('Overload')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def hidden_haymaker(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_hidden_strike)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_hidden_strike(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Choose target for Hidden Haymaker', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_hidden_strike(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hidden_strike(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'invisibility' not in self.get_types():
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Hidden_Strike'] = Vis(name = 'Hidden_Strike', loc = sqr[:])
        my_str = self.get_abl('str')
        target_end = app.ent_dict[id].get_abl('end')
        d = damage(my_str, target_end)
        def cleanup_slash():
            del app.vis_dict['Hidden_Strike']
            app.canvas.delete('Hidden_Strike')
        root.after(1666, cleanup_slash)
        lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Hidden Strike', 'melee')
        root.after(111, self.cancel_hidden_strike)
        
    def cancel_hidden_strike(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    def chain_lightning(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_chain_lightning)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_chain_lightning(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Chain Lightning', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_chain_lightning(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chain_lightning(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        hit = []
        def clean_vis(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def chain_loop(id):
            if id == None:
                self.cleanup_chain_lightning()
            else:
                hit.append(id)
                ent = app.ent_dict[id]
                effect1 = mixer.Sound('Sound_Effects/energize.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                n = 'Chain_Lightning'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Chain_Lightning', loc = ent.loc[:])
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
                    d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
                    root.after(1666, lambda n = n : clean_vis(n))
                    lock(apply_damage, self, ent, -d, 'elec', 'Chain Lightning', 'ranged')
                    ids = [k for k,v in app.all_ents().items() if k not in hit and v != self and dist(v.loc,ent.loc) <= 2]
                    if ids != []:
                        id = choice(ids)
                        chain_loop(id)
                    else:
                        self.cleanup_chain_lightning()
                else:
                    miss(ent.loc)
                    root.after(1666, lambda n = n : clean_vis(n))
                    root.after(1666, self.cleanup_chain_lightning)
        chain_loop(id)
        
    def cleanup_chain_lightning(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
    # jump to loc wi agl that is adj to an ent, atk all adj
    def pounce(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_pounce)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '' and [s for s in app.coords if dist(c,s) == 1 and app.grid[s[0]][s[1]] in app.all_ents().keys() and app.ent_dict[app.grid[s[0]][s[1]]].owner != self.owner] != []]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_pounce(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pounce', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_pounce(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pounce(self, event = None, sqrs = None, sqr = None):
        global selected
        if sqr not in sqrs:
            return
        self.acts -= 1
        self.init_pounce_anims()
#         effect1 = mixer.Sound('Sound_Effects/pounce.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected.append(self.id)
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda e = end_sqr, s = start_sqr : self.finish_pounce(e, s))
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_pounce(self, end_sqr, start_sqr):
        global selected
        selected.remove('Pounce')
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        ents = [e for e in app.all_ents().values() if dist(e.loc, self.loc) == 1 and e.owner != self.owner]
        def pounce_loop(ents):
            if ents == []:
                self.cancel_pounce()
            else:
                ent = ents[0]
                ents = ents[1:]
                my_agl = self.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    my_str = self.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    lock(apply_damage, self, ent, -d, 'slashing', 'Pounce', 'melee')
                    pounce_loop(ents)
                else:
                    miss(ent.loc)
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ents = ents : pounce_loop(ents))
        pounce_loop(ents)
        
    def cancel_pounce(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
        
        
    # on save_check frndly  +2 san, on to-hit enmy -2 san
    def roar(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_roar)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_roar(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Roar', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_roar(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_roar(self, event = None, sqrs = None):
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/roar.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Roar', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Roar', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        def cleanup_roar(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def roar_loop(ents):
            if ents == []:
                self.finish_roar()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                if ent.owner != self.owner and 'Roar_Enemy' not in [v.name for v in ent.effects_dict.values()]:
                    app.focus_square(s)
                    u = 'Roar' + str(app.count) # not an effect, just need unique int
                    app.count += 1 # that is why this is incr manually here, no Effect init
                    app.vis_dict[u] = Vis(name = 'Roar', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                    root.after(1555, lambda u = u : cleanup_roar(u))
                    my_str = self.get_abl('str')
                    tar_str = ent.get_abl('str')
                    if to_hit(my_str, tar_str):
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '-3 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '-3 san', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        def roar_effect(stat):
                            return max(1,stat-3)
                        p = partial(roar_effect)
                        ent.san_effects.append(p)
                        n = 'Roar' + str(app.count)
                        def un(i, p, lockname = None):
                            app.ent_dict[i].san_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(un, id, p)
                        ent.effects_dict[n] = Effect(name = 'Roar_Enemy', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                    else:
                        miss(ent.loc)
                        root.after(999, lambda ents = ents : roar_loop(ents))
                elif ent.owner == self.owner and 'Roar_Friendly' not in [v.name for v in ent.effects_dict.values()]:
                    app.focus_square(s)
                    u = 'Roar' + str(app.count) # not an effect, just need unique int
                    app.count += 1 # that is why this is incr manually here, no Effect init
                    app.vis_dict[u] = Vis(name = 'Roar', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                    root.after(1555, lambda u = u : cleanup_roar(u))
                    if ent.save_check('wis') == 'Pass':
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '+2 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '+2 san', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        def roar_effect(stat):
                            return stat+2
                        p = partial(roar_effect)
                        ent.san_effects.append(p)
                        n = 'Roar' + str(app.count)
                        def un(i, p, lockname = None):
                            app.ent_dict[i].san_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(un, id, p)
                        ent.effects_dict[n] = Effect(name = 'Roar_Friendly', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                    else:
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Wisdom save fail...', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Wisdom save fail...', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                else:
                    roar_loop(ents)
        roar_loop(ents)
        
    def finish_roar(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def suplex(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_suplex)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if app.ent_dict[id].immovable == True:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_suplex)
        distance = self.get_abl('str')
        sqrs = [c for c in app.coords if dist(c,self.loc)==1 and app.grid[c[0]][c[1]] != 'block']
        app.cleanup_squares()
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_suplex(e, id = id, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_suplex(e, id, sqr, sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
    
    def do_suplex(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/suplex.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            oldloc = app.ent_dict[id].loc[:]
            newloc = sqr[:]
            root.after(333, lambda newloc = newloc, id = id : self.finish_suplex(newloc, id))
        else:
            miss(ent.loc)
            root.after(1666, self.cleanup_suplex)
        
    # CHANGE add dmg crshing
    def finish_suplex(self, newloc, id):
        mv2 = None
        ent = app.ent_dict[id]
        if app.grid[newloc[0]][newloc[1]] in app.all_ents().keys():
            # get rand empt sqr (should include original target loc)
            id2 = app.grid[newloc[0]][newloc[1]]
            ent2 = app.ent_dict[id2]
            cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
            cs.append(ent.loc[:])
            mv2 = reduce(lambda a,b : a if dist(ent2.loc,a) < dist(ent2.loc,b) else b, cs)
        lock(ent.throw_move, newloc)
        # add dmg, already hit...
        my_str = self.get_abl('str')
        tar_end = ent.get_abl('end')
        d = damage(my_str, tar_end)
        if mv2:
            start = ent2.loc[:]
            lock(ent2.throw_move, mv2)
            app.grid[start[0]][start[1]] = ent.id
        lock(apply_damage, self, ent, -d, 'crushing', 'Suplex', 'melee')
        if mv2:
            tar2_end = ent2.get_abl('end')
            d = damage(my_str, tar2_end)
            app.get_focus(ent2.id)
            lock(apply_damage, self, ent2, -d, 'crushing', 'Suplex', 'melee')
        root.after(333, self.cleanup_suplex)
        
    def cleanup_suplex(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
class White_Dragon_Top(Bot):
    def __init__(self, name, img, loc, owner, id, waiting = False):
        self.id = id
        self.actions = {}
        self.str = 12
        self.agl = 12
        self.end = 10
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 14
        self.wis = 13
        self.rsn = 8
        self.init = 8
        self.spirit = 136
        self.magick = 99
        self.san = 27
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.resist = ['crushing', 'slashing', 'cold', 'piercing', 'magick']
        self.weak = []
        super().__init__(name, img, loc, owner, type = 'large')
        self.move_type = 'flying'
        self.immovable = True
        
        
class White_Dragon(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Rake':self.rake, 'Iceblast':self.iceblast}
        self.str = 12
        self.agl = 12
        self.end = 10
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 14
        self.wis = 13
        self.rsn = 7
        self.init = 8
        self.spirit = 136
        self.magick = 99
        self.san = 27
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.move_type = 'flying'
        self.waiting = waiting
        self.resist = ['crushing', 'slashing', 'cold', 'piercing', 'magick']
        self.weak = []
        self.summoned_kobolds = False
        self.summoned_orcs = False
        self.free_fly = False
        anims = [a for r,d,a in walk('./animations/White_Dragon_Ascend/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.ascend_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Ascend/' + anim))
            self.ascend_anims.append(a)
        anims = [a for r,d,a in walk('./animations/White_Dragon_Flight/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.flight_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Flight/' + anim))
            self.flight_anims.append(a)
        anims = [a for r,d,a in walk('./animations/White_Dragon_Descend/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.descend_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Descend/' + anim))
            self.descend_anims.append(a)
        super().__init__(name, img, loc, owner, type = 'large_bottom')
        self.immovable = True
        # create top half
        img = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Top/0.png'))
        app.ent_dict[self.id+'top'] = White_Dragon_Top(name = 'White_Dragon_Top', img = img, loc = [self.loc[0],self.loc[1]], owner = 'p2', id = self.id+'top')
        
    def large_undo(self):
        app.canvas.delete(self.id+'top')
        del app.ent_dict[self.id+'top']
        
    def init_ascend_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.ascend_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
            
    def init_flight_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.flight_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
            
    def init_descend_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.descend_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            melee_atks = [k for k,v in app.action_target_ents().items() if dist(self.loc, v.loc) == 1 and v.owner != self.owner]
            # RAKE ADJACENT
            if melee_atks != [] and self.acts > 0:
                id = choice(melee_atks)
                app.get_focus(id)
                self.acts -= 1
                root.after(666, lambda id = id : self.rake(id))
            # MOVE ADJACENT TO AN ENT WI MOVE RANGE
            elif [c for c in app.coords for k,v in app.all_ents().items() if dist(c,v.loc) == 1 and v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(c,self.loc) <= self.get_abl('move_range')] and self.mvs > 0:
                goals = [c for c in app.coords for k,v in app.all_ents().items() if dist(c,v.loc) == 1 and v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(c,self.loc) <= self.get_abl('move_range')]
                goal = choice(goals)
                app.focus_square(goal)
                self.mvs -= 1
                root.after(666, lambda g = goal : self.white_dragon_move(g))
            # MOVE TOWARDS CLOSEST ENT
            elif self.mvs > 0:
                ents = [v for k,v in app.all_ents().items() if v.owner != self.owner]
                ent = reduce(lambda a,b : a if dist(a.loc,self.loc) < dist(b.loc,self.loc) else b, ents)
                mvs = self.legal_moves()
                mv = reduce(lambda a,b : a if dist(a,ent.loc) < dist(b,ent.loc) else b, mvs)
                app.focus_square(mv)
                self.mvs -= 1
                root.after(666, lambda mv = mv : self.white_dragon_move(mv))
            # FREE FLY MOVE
            elif self.free_fly == False and [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner] and self.acts < 1:
                print('in free_fly dragon')
                self.free_fly = True
                goals = unique([c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c,v.loc)<=self.get_abl('rsn') and app.grid[c[0]][c[1]] == ''])
                mvs = intersect(self.legal_moves(), goals)
                if mvs == [] and self.legal_moves() != []:
                    els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
                    mvs = self.legal_moves()
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                    app.focus_square(mv)
                    root.after(666, lambda mv = mv : self.white_dragon_move(mv))
                else:
                    els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
                    mvs = self.legal_moves()
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                    app.focus_square(mv)
                    root.after(666, lambda mv = mv : self.white_dragon_move(mv))
            # ATTEMPT ICEBLAST
            else:
                ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner]
                if ids == [] or self.magick < 4:
                    app.handle_action()
                else:
                    self.magick -= 4
                    id = choice(ids)
                    app.get_focus(id)
                    # EXIT TO HANDLEACTION through iceblast
                    root.after(666, lambda id = id : self.iceblast(id))
                
                
                
                
    def rake(self, id):
        ent = app.ent_dict[id]
#         self.start_melee_anims()
        effect1 = mixer.Sound('Sound_Effects/dragon_melee.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        app.vis_dict['Rake'] = Vis(name = 'Rake', loc = ent.loc[:])
        def cleanup_rake():
            del app.vis_dict['Rake']
        root.after(1777, cleanup_rake)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'slashing', 'Rake', 'melee')
            root.after(666, self.do_round)
        else:
            miss(ent.loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
                
            
    def white_dragon_move(self, endloc):
        global selected
        selected += [self.id, self.id+'top']
        app.canvas.delete(self.id)
        app.canvas.delete(self.id+'top')
        self.init_ascend_anims()
        app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+40, image = self.img, tags = self.tags)
        self.type = 'large'
        self.tags = (self.id, 'large')
        effect1 = mixer.Sound('Sound_Effects/dragon_flight.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        def ascend_loop(timer):
            if timer == 0:
                self.dragon_flight(endloc)
            else:
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+30, image = self.img, tags = self.tags)
                timer -= 1
                app.canvas.tag_raise('cursor')
                app.canvas.tag_raise('init_q')
                app.canvas.tag_raise('init_ents')
                root.after(333, lambda t = timer : ascend_loop(t))
        root.after(333, lambda t = 2 : ascend_loop(t))
            
    def dragon_flight(self, endloc):
        global selected
        id = self.id
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = endloc[0]*100+50-app.moved_right
        endy = endloc[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = endloc[:]
        self.init_flight_anims()
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, tics):
            if tics == 0:
                tics = 5
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            tics -= 1
            app.canvas.tag_raise('cursor')
            app.canvas.tag_raise('init_q')
            app.canvas.tag_raise('init_ents')
            if x == endx and y == endy:
                self.finish_move(id, end_sqr, start_sqr)
            else:
                root.after(66, lambda id = id, x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, t = tics : move_loop(id, x, y, e, e2, s, s2, t))
        move_loop(id, x, y, endx, endy, start_sqr, end_sqr, 4)
            
    def finish_move(self, id, end_sqr, start_sqr):
        self.loc = end_sqr[:]
        app.focus_square(end_sqr)
        app.ent_dict[id+'top'].loc = [end_sqr[0],end_sqr[1]]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_descend_anims()
        app.canvas.delete(self.id)
        app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+40, image = self.img, tags = self.tags)
        def descend_loop(timer):
            if timer == 0:
                sound_effects.stop()
                self.finish_descend()
            else:
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+50, image = self.img, tags = self.tags)
                timer -= 1
                app.canvas.tag_raise('cursor')
                app.canvas.tag_raise('init_q')
                app.canvas.tag_raise('init_ents')
                root.after(333, lambda t = timer : descend_loop(t))
        root.after(333, lambda t = 2 : descend_loop(t))
        
    def finish_descend(self):
        global selected
        self.init_normal_anims()
        self.type = 'large_bottom'
        self.tags = self.id
        selected.remove(self.id)
        selected.remove(self.id+'top')
        app.canvas.delete(self.id)
        app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+50, image = self.img, tags = self.tags)
        self.do_round()
    
    def iceblast(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/iceblast.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Iceblast'] = Vis(name = 'Iceblast', loc = [self.loc[0],self.loc[1]-100])
#         app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Iceblast'].img, tags = 'Iceblast')
        selected_vis.append('Iceblast')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Iceblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Iceblast'].img, tags = 'Iceblast')
                app.canvas.tag_raise('Iceblast')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Iceblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Iceblast'].img, tags = 'Iceblast')
                app.canvas.tag_raise('Iceblast')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Iceblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Iceblast'].img, tags = 'Iceblast')
                app.canvas.tag_raise('Iceblast')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Iceblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Iceblast'].img, tags = 'Iceblast')
                app.canvas.tag_raise('Iceblast')
                # debug here, if within certain range...
            app.vis_dict['Iceblast'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(111, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(20, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100-50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        global selected_vis
        selected_vis.remove('Iceblast')
        del app.vis_dict['Iceblast']
#         app.canvas.delete('Iceblast')
        loc = app.ent_dict[id].loc[:]
        # iceblast vis and loop
        # do all vis now, staggered
        def iceblast_vis_loop(index):
            for sqr in [s for s in app.coords if dist(s, loc) == index]:
                n = 'Iceblast' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Iceblast', loc = sqr[:])
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1666, lambda n = n : cleanup_vis(n))
            if index == 1:
                ids = [k for k,v in app.all_ents().items() if dist(v.loc, loc) <= 1 and v != self]
                self.continue_iceblast(ids, loc)
            else:
                root.after(111, lambda j = index+1 : iceblast_vis_loop(j))
        iceblast_vis_loop(0)
        
    # dmg ents based on dist from sqr (main target)
    def continue_iceblast(self, ids, sqr):
        def iceblast_loop(ids):
            if ids == []:
                app.handle_action()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                loc = app.ent_dict[id].loc[:]
                app.focus_square(loc)
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, ent, -d, 'cold', 'Iceblast', 'spell')
                    root.after(111, lambda t = 'text' : app.canvas.delete(t))
                    root.after(222, lambda ids = ids : iceblast_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : iceblast_loop(ids))
        app.canvas.delete('text')
        iceblast_loop(ids)
        
        
        
        
        
        
class Tortured_Soul(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Agony':self.ranged_attack, 'Rend':self.melee_attack}
        self.str = 8
        self.agl = 5
        self.end = 8
        self.mm = 9
        self.msl = 8
        self.bls = 0
        self.dodge = 9
        self.psyche = 9
        self.wis = 9
        self.rsn = 6
        self.init = 7
        self.spirit = 23
        self.magick = 17
        self.san = 12
        self.acts = 1
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'explosive', 'poison']
        self.weak = []
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Agony' in self.actions.keys()]:
                self.magick -= 1
                self.acts -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.ranged_attack(target)
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Rend' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/agony.ogg')
        sound_effects.play(effect1, 0)
        app.vis_dict['Agony'] = Vis(name = 'Agony', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Agony'].img, tags = 'Agony')
        def cleanup_agony():
            del app.vis_dict['Agony']
            app.canvas.delete('Agony')
            app.canvas.delete('text')
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, target_dod):# HIT
            my_msl = self.get_abl('msl')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_msl, tar_psy)
            root.after(1666, self.init_normal_anims)
            root.after(1666, cleanup_agony)
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Agony', 'spell')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, cleanup_agony)
            root.after(1666, self.finish_attack)
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Rend', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
            
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
class Cacodemon(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Abyssal Maw':self.abyssal_maw}
        self.str = 5
        self.agl = 8
        self.end = 11
        self.mm = 7
        self.msl = 7
        self.bls = 5
        self.dodge = 8
        self.psyche = 6
        self.wis = 6
        self.rsn = 5
        self.init = 8
        self.spirit = 28
        self.magick = 0
        self.san = 13
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['explosive','fire']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        self.types = ['demon']
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Abyssal Maw' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.acts -= 1
                self.abyssal_maw(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
    def abyssal_maw(self, id):
        self.init_attack_anims()
        loc = app.ent_dict[id].loc[:]
        lock(Entity.ranged_attack, self, loc, 'Flare')
        self.init_normal_anims()
        my_mm = self.get_abl('mm')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Abyssal Maw', 'ranged')
            root.after(111, self.do_round)
        else:# MISS
            miss(loc)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
        
        
        
class Cyberdemon(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Blast':self.blast}
        self.str = 13
        self.agl = 6
        self.end = 13
        self.mm = 9
        self.msl = 11
        self.bls = 6
        self.dodge = 5
        self.psyche = 9
        self.wis = 9
        self.rsn = 9
        self.init = 11
        self.spirit = 666
        self.magick = 0
        self.san = 15
        self.acts = 3
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['explosive','fire']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        self.types = ['demon']
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Blast' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.acts -= 1
                self.blast(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
    def blast(self, id):
        self.init_attack_anims()
        loc = app.ent_dict[id].loc[:]
        lock(Entity.ranged_attack, self, loc, 'Pain')
        self.init_normal_anims()
        my_mm = self.get_abl('mm')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'explosive', 'Blast', 'ranged')
            root.after(111, self.do_round)
        else:# MISS
            miss(loc)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
        
        
class Skeleton_Archer(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Barrage':self.ranged_attack}
        self.str = 3
        self.agl = 5
        self.end = 3
        self.mm = 7
        self.msl = 4
        self.bls = 9
        self.dodge = 5
        self.psyche = 3
        self.wis = 3
        self.rsn = 1
        self.init = 5
        self.spirit = 13
        self.magick = 0
        self.san = 10
        self.acts = 2
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'slashing', 'poison']
        self.weak = ['crushing', 'magick', 'fire']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Barrage' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.acts -= 1
                self.ranged_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        lock(Entity.ranged_attack, self, loc, 'Barrage')
        my_mm = self.get_abl('mm')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Barrage', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
            
class Ghost(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Willowisp':self.willowisp, 'Slow':self.slow, 'Fear':self.fear, 'Wail':self.wail}
        self.str = 8
        self.agl = 11
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 13
        self.psyche = 13
        self.wis = 13
        self.rsn = 10
        self.init = 12
        self.spirit = 99
        self.magick = 666
        self.san = 21
        self.acts = 2
        self.mvs = 2
        self.move_range = 11
        self.waiting = waiting
        self.retreated_once = False
        self.move_type = 'ethereal'
        self.resist = ['slashing', 'piercing', 'crushing', 'poison']
        self.weak = ['elec', 'cold']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
    #  GHOST AI
    # all level-based movement should be handled in handle_eot_campaign()
    # change to: cast fear, slow, or willowisp w/i range, then Wail(equake no dmg), then move randomly w/i 4
    # only act if ent w/i range of spells
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else: # ATTEMPT ATTACK FROM STARTLOC
            action_ents = [k for k,v in app.action_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
            spell_ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
            slow_ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn') and 'Slow' not in [j.name for i,j in v.effects_dict.items()]]
            rando = []
            if action_ents != [] and 'Fear' in self.actions.keys():
                rando.append('action')
            if spell_ents != [] and 'Willowisp' in self.actions.keys():
                rando.append('spell')
            if slow_ents != [] and 'Slow' in self.actions.keys():
                rando.append('slow')
            if rando != [] and self.acts > 0:
                self.acts -= 1
                r = choice(rando)
                if r == 'action':
                    id = choice(action_ents)
                    kind = 'fear'
                elif r == 'spell':
                    id = choice(spell_ents)
                    kind = 'willowisp'
                elif r == 'slow':
                    id = choice(slow_ents)
                    kind = 'slow'
                root.after(666, lambda id = id : app.get_focus(id))
                root.after(1333, lambda id = id, kind = kind : self.do_attack(id, kind))
            else:
                self.cleanup_attack()
                    
    # change to cast one of 3 rand spells
    def do_attack(self, id, kind):
        app.get_focus(id)
        if kind == 'fear':
            self.fear(id)
        elif kind == 'willowisp':
            self.willowisp(id)
        elif kind == 'slow':
            self.slow(id)
    
    # tar gets psy reduction, mov reduce by 1, and psy v psy atk with psy v psy dmg
    def fear(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Fear', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Fear', justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'text')
        ent = app.ent_dict[id]
        ents = [k for k,v in app.action_target_ents().items() if dist(v.loc, ent.loc) <= 1 and v.owner == ent.owner]
        def cleanup_fear(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def fear_loop(ents):
            if ents == []:
                self.do_round()
            else:
                effect1 = mixer.Sound('Sound_Effects/terror.ogg')
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                ent = app.ent_dict[id]
                # do dmg
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                loc = ent.loc[:]
                n = 'Fear'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Fear', loc = ent.loc[:])
                app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1555, lambda n = n : cleanup_fear(n))
                if to_hit(my_wis, tar_wis):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, ent, -d, 'cold', 'Fear', 'spell')
                    if 'Fear' not in [v.name for k,v in ent.effects_dict.items()]:
                        def fear_move(move_range):
                            return max(0,move_range-1)
                        p = partial(fear_move)
                        ent.move_range_effects.append(p)
                        def fear_effect(stat):
                            return max(0, stat-1)
                        p2 = partial(fear_effect)
                        ent.psyche_effects.append(p2)
                        def undo(ent, p, p2, lockname = None):
                            ent.move_range_effects.remove(p)
                            ent.psyche_effects.remove(p2)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p, p2)
                        n = 'Fear'+str(app.count)
                        app.count += 1
                        ent.effects_dict[n] = Effect(name = 'Fear', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Fear...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Fear...', justify = 'center', fill = 'bisque2', font = ('chalkduster', 13), tags = 'text')
                        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                        root.after(1666, lambda ents = ents : fear_loop(ents))
                    else:
                        miss(ent.loc)
                        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                        root.after(1666, lambda ents = ents : fear_loop(ents))
                else:
                    miss(loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ents = ents : fear_loop(ents))
        fear_loop(ents)
    
    # tar gets move reduce by 3 and atk efct dmg halved rounded down min1
    def slow(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Slow', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Slow', justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'text')
        ent = app.ent_dict[id]
        ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc, ent.loc) <= 1 and v.owner == ent.owner]
        def cleanup_slow(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def slow_loop(ents):
            if ents == []:
                self.do_round()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                if 'Slow' not in [v.name for k,v in ent.effects_dict.items()]:
                    app.get_focus(id)
                    n = 'Slow'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Slow', loc = ent.loc[:])
                    app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                    root.after(1666, lambda n = n : cleanup_slow(n))
                    loc = ent.loc[:]
                    def slow_move(move_range):
                        return max(0,move_range-2)
                    p = partial(slow_move)
                    ent.move_range_effects.append(p)
                    def slow_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
                        loc = atkr.loc[:]
                        if st == 'melee' or st == 'ranged':
                            app.get_focus(atkr.id)
                            app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Attack Slowed...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                            app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Attack Slowed...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                            if dmg < 0:
                                return (min(-1, dmg//2), type)
                            else:
                                return (dmg, type)
                        else:
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            return (dmg, type)
                    p2 = partial(slow_atk)
                    ent.attack_effects.append(p2)
                    def undo(ent, p, p2, lockname = None):
                        ent.move_range_effects.remove(p)
                        ent.attack_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p, p2)
                    n = 'Slow'+str(app.count)
                    app.count += 1
                    ent.effects_dict[n] = Effect(name = 'Slow', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Slowed...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Slowed...', justify = 'center', fill = 'bisque2', font = ('chalkduster', 13), tags = 'text')
                    root.after(2000, lambda t = 'text' : app.canvas.delete(t))
                    root.after(2111, lambda ents = ents : slow_loop(ents))
                else:
                    slow_loop(ents)
        slow_loop(ents)

    # psy v end dmg, end save at -2 or get burn effect, move target to rand sqr w/i rang 4 (use normal move pathing)
    def willowisp(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = "Will o'Wisp", justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'wisp_text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = "Will o'Wisp", justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'wisp_text')
        root.after(1666, lambda t = 'wisp_text' : app.canvas.delete(t))
        ent = app.ent_dict[id]
        def cleanup_willowisp(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        n = 'Willowisp'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Willowisp', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        root.after(1555, lambda n = n : cleanup_willowisp(n))
        my_psy = self.get_abl('psyche')
        tar_end = ent.get_abl('end')
        d = damage(my_psy, tar_end)
        lock(apply_damage, self, ent, -d, 'fire', "Will o' Wisp", 'spell')
        if id in app.all_ents().keys():
            if 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                loc = ent.loc[:]
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Burned...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'burn_text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Burned...', justify = 'center', fill = 'orangered2', font = ('chalkduster', 14), tags = 'burn_text')
                root.after(999, lambda t = 'burn_text' : app.canvas.delete(t))
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and (st == 'melee' or st == 'ranged' or st == 'spell'):
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                p = partial(burn_effect)
                ent.defense_effects.append(p)
                def undo(ent, p, lockname = None):
                    ent.defense_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Burn'+str(app.count)
                app.count += 1
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                # insert rndmly move tar
                sqrs = [s for s in app.coords if dist(s, loc) <= 4 and app.grid[s[0]][s[1]] == '' and bfs(loc, [s], app.grid) and len(bfs(loc, [s], app.grid)) <= 5]
                if sqrs == []:
                    root.after(666, self.cleanup_attack)
                else:
                    sqr = choice(sqrs)
                    root.after(666, lambda s = sqr[:] : app.focus_square(s))
                    lock(Bot.ai_normal_move, ent, sqr)
                    root.after(666, self.do_round)
            else:
                root.after(666, self.do_round)
        else:
            root.after(666, self.do_round)
        
    def cleanup_attack(self):
#         self.init_normal_anims()
        try: 
            app.canvas.delete('text')
        except: pass
        if 'Wail' in self.actions.keys():
            self.wail()
        else:
            self.wander()
        
    # change to ensure path is no greater than 2 or 3, only move to increase distance from ghost
    def wail(self):
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Wail', font = ('chalkduster', 17), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Wail', font = ('chalkduster', 17), fill = 'bisque2', tags = 'text')
        root.after(1666, lambda t = 'text' : app.canvas.delete(t))
        ents = [k for k,v in app.all_ents().items() if v.owner != self.owner and v.loc in sqrs ]
        def cleanup_wail(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        n = 'Wail'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Wail', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        root.after(2666, lambda n = n : cleanup_wail(n))
        def wail_loop(ents):
            if ents == []:
                self.wander()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                loc = ent.loc
                app.get_focus(id)
                n = 'Wail'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Wail', loc = loc[:])
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1666, lambda n = n : cleanup_wail(n))
#                 sqrs = [s for s in app.coords if dist(s, loc) <= 4 and app.grid[s[0]][s[1]] == '' and dist(s,self.loc) >= dist(loc,self.loc) and bfs(loc, [s], app.grid) and len(bfs(loc, [s], app.grid)) <= 5]
                sqrs = ent.legal_moves()
                if sqrs == []:
                    root.after(666, lambda ents = ents : wail_loop(ents))
                else:
                    sqr = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, sqrs)
                    app.focus_square(sqr)
                    def staff_ef(ts):
                        return [t for t in ts if t != 'psyshield' and t != 'invisibility']
                    p = partial(staff_ef)
                    ent.type_effects.append(p)
                    def undo(ent, p, lockname = None):
                        ent.type_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    n = 'Wail' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Wail', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    mt = ent.get_move_type()
                    if mt == 'normal' or mt == 'charge':
                        lock(Bot.ai_normal_move, ent, sqr)
                    elif mt == 'teleport':
                        lock(Bot.ai_teleport_move, ent, sqr)
                    else:
                        lock(Bot.ai_flying_move, ent, sqr)
                    root.after(666, lambda ents = ents : wail_loop(ents))
        root.after(2666, lambda ents = ents : wail_loop(ents))
        
    def wander(self):
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('move_range') and app.grid[s[0]][s[1]] == '']
        if sqrs == []:
            app.handle_action()
        else:
            sqr = choice(sqrs)
            lock(self.do_move, sqr)
            app.handle_action()
            
        
class Revenant(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Terror':self.ranged_attack}
        self.str = 4
        self.agl = 5
        self.end = 5
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 5
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.init = 8
        self.spirit = 16
        self.magick = 17
        self.san = 10
        self.acts = 1
        self.mvs = 2
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'ethereal'
        self.resist = ['slashing', 'piercing', 'crushing', 'poison']
        self.weak = ['fire', 'elec', 'cold', 'acid']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            app.get_focus(self.id)
            if self.acts > 0 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner] and 'Terror' in self.actions.keys():
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.acts -= 1
                root.after(999, lambda t = target : app.get_focus(t))
                root.after(1111, lambda t = target : self.ranged_attack(t))
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/terror.ogg')
        sound_effects.play(effect1, 0)
        app.vis_dict['Terror'] = Vis(name = 'Terror', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Terror'].img, tags = 'Terror')
        def cleanup_terror():
            del app.vis_dict['Terror']
            app.canvas.delete('Terror')
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, target_wis):# HIT
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(2111, cleanup_terror)
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Terror', 'spell')
            root.after(333, self.finish_attack)
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(2111, cleanup_terror)
            root.after(2111, self.finish_attack)
            
    def finish_attack(self):
#         self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
            
        
        
class Kensai(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Lacerate':self.lacerate, 'Lunge':self.lunge, 'Riposte':self.riposte}
        self.str = 7
        self.agl = 17
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 11
        self.psyche = 9
        self.wis = 13
        self.rsn = 4
        self.init = 13
        self.spirit = 46
        self.magick = 0
        self.san = 18
        self.acts = 4
        self.mvs = 3
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != [] and choice([0,1]):
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner and 'Riposte' not in [j.name for i,j in v.effects_dict.items()]] and 'Riposte' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner and 'Riposte' not in [j.name for i,j in v.effects_dict.items()]])
                self.acts -= 1
                self.riposte(target)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Lacerate' in self.get_actions().keys() and choice([0,1]):
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.lacerate(target)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Lunge' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.lunge(target)
            # debug legal moves not empty but cannot make move for some reason in melee_pursue() or whatever used to move
            # such as all enemy invisible... so no goals to move towards...
            elif self.mvs < 1 or self.legal_moves() == []:
                app.handle_action()
            else:
                self.do_round()
        
    
    def riposte(self, id):
        self.init_attack_anims()
        root.after(1666, self.init_normal_anims)
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Riposte'] = Vis(name = 'Riposte', loc = ent.loc[:])
        def cleanup_lacer():
            del app.vis_dict['Riposte']
            app.canvas.delete('Riposte')
        root.after(1777, cleanup_lacer)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            def riposte_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
                if st == 'melee' and to_hit(atkr.get_abl('agl'),dfndr.get_abl('agl')) == False:
                    app.canvas.create_text(atkr.loc[0]*100-app.moved_right+49, atkr.loc[1]*100-app.moved_down+14, text = 'Riposte miss...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(atkr.loc[0]*100-app.moved_right+50, atkr.loc[1]*100-app.moved_down+15, text = 'Riposte miss...', justify = 'center', fill = 'gray88', font = ('chalkduster', 14), tags = 'text')
                    root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1777, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (1, type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return(amt, type)
            p = partial(riposte_atk)
            ent.attack_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.attack_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Riposte'+str(app.count)
            app.count += 1
            ent.effects_dict[n] = Effect(name = 'Riposte', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = 'Riposte...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = 'Riposte...', justify = 'center', fill = 'gray88', font = ('chalkduster', 14), tags = 'text')
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, self.do_round)
        else:
            miss(ent.loc)
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, self.do_round)
                    
        
    def lacerate(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Lacerate'] = Vis(name = 'Lacerate', loc = ent.loc[:])
        def cleanup_lacer():
            del app.vis_dict['Lacerate']
            app.canvas.delete('Lacerate')
        root.after(1777, cleanup_lacer)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, ent, -d, 'slashing', 'Lacerate', 'melee')
            root.after(333, self.do_round)
        else:# MISS
            miss(ent.loc)
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
            
    def lunge(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lunge.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Lunge'] = Vis(name = 'Lunge', loc = ent.loc[:])
        def cleanup_lunge():
            del app.vis_dict['Lunge']
            app.canvas.delete('Lunge')
        root.after(1777, cleanup_lunge)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, ent, -d, 'piercing', 'Lunge', 'melee')
            root.after(333, self.do_round)
        else:# MISS
            miss(ent.loc)
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
        
        
class Kobold_Cleric(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Bless':self.bless, 'Hex':self.hex, 'Scratch':self.melee_attack}
        self.str = 3
        self.agl = 6
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 8
        self.wis = 6
        self.rsn = 4
        self.init = 6
        self.spirit = 15
        self.magick = 11
        self.san = 12
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'fire']
        self.weak = ['slashing']
        super().__init__(name, img, loc, owner)
        self.types = ['animal']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v != self and v.owner == self.owner and v.spirit <= v.base_spirit-self.get_abl('psyche')] != []:
                self.magick -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner == self.owner and v != self and v.spirit <= v.base_spirit-self.get_abl('psyche')])
                self.acts -= 1
                root.after(666, lambda t = target : self.bless(t))
            elif self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]]:
                self.magick -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]])
                self.acts -= 1
                root.after(666, lambda t = target : self.hex(t))
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Scratch' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Scratch', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
            
    def bless(self, id):
        app.get_focus(id)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Bless', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Bless', justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        
        visloc = ent.loc[:]
        def cleanup_bless(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        name = 'Bless' + str(app.count)
        app.count += 1
        app.vis_dict[name] = Vis(name = 'Bless', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict[name].img, tags = name)
        amt = self.get_abl('psyche')
        apply_heal(ent, self, amt)
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Heal '+str(amt), justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Heal '+str(amt), justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        root.after(1555, lambda name = name : cleanup_bless(name))
        root.after(1666, self.do_round)

    def hex(self, id):
        app.get_focus(id)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Hex', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Hex', justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        
        visloc = ent.loc[:]
        def cleanup_hex(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        name = 'Hex' + str(app.count)
        app.count += 1
        app.vis_dict[name] = Vis(name = 'Hex', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict[name].img, tags = name)
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Hex, -1 stats', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Hex, -1 stats', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
            def hex_effect(stat):
                stat -= 1
                if stat < 1:
                    return 1
                else:
                    return stat
            f = hex_effect
            app.ent_dict[id].str_effects.append(f)
            app.ent_dict[id].end_effects.append(f)
            app.ent_dict[id].agl_effects.append(f)
            app.ent_dict[id].mm_effects.append(f)
            app.ent_dict[id].dodge_effects.append(f)
            app.ent_dict[id].psyche_effects.append(f)
            app.ent_dict[id].wis_effects.append(f)
            app.ent_dict[id].rsn_effects.append(f)
            app.ent_dict[id].san_effects.append(f)
            app.ent_dict[id].init_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].str_effects.remove(hex_effect)
                app.ent_dict[i].end_effects.remove(hex_effect)
                app.ent_dict[i].agl_effects.remove(hex_effect)
                app.ent_dict[i].mm_effects.remove(hex_effect)
                app.ent_dict[i].dodge_effects.remove(hex_effect)
                app.ent_dict[i].psyche_effects.remove(hex_effect)
                app.ent_dict[i].wis_effects.remove(hex_effect)
                app.ent_dict[i].rsn_effects.remove(hex_effect)
                app.ent_dict[i].san_effects.remove(hex_effect)
                app.ent_dict[i].init_effects.remove(hex_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            n = 'Hex' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Hex', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1555, lambda name = name : cleanup_hex(name))
            root.after(1666, self.do_round)
        else:
            miss(ent.loc)
            root.after(1555, lambda name = name : cleanup_hex(name))
            root.after(1666, self.do_round)
            
        


class Kobold_Shaman(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Firebolt':self.ranged_attack, 'Scratch':self.melee_attack, 'Snuffle':self.snuffle}
        self.str = 3
        self.agl = 5
        self.end = 3
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 6
        self.wis = 5
        self.rsn = 4
        self.init = 7
        self.spirit = 11
        self.magick = 13
        self.san = 11
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'fire']
        self.weak = ['crushing']
        super().__init__(name, img, loc, owner)
        self.types = ['animal']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Firebolt' in self.actions.keys()]:
                self.magick -= 1
                self.acts -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.ranged_attack(target)
            elif self.acts > 0 and [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Snuffle' in self.actions.keys() and 'invisibility' in v.get_types()]:
                self.acts -= 1
                target = choice([k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Snuffle' in self.actions.keys() and 'invisibility' in v.get_types()])
                self.snuffle(target)
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Scratch' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def snuffle(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/staff_of_vecna.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_snuffle():
            del app.vis_dict['Snuffle']
            app.canvas.delete('Snuffle')
        app.vis_dict['Snuffle'] = Vis(name = 'Snuffle', loc = ent.loc[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Snuffle', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Snuffle', font = ('chalkduster', 16), fill = 'antiquewhite', tags = 'text')
        def snuffle_ef(ts):
            return [t for t in ts if t != 'invisibility']
        p = partial(snuffle_ef)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Snuffle' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Snuffle', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose invisibility', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose invisibility', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        root.after(1999, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, cleanup_snuffle)
        root.after(2111, self.do_round)
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Scratch', 'melee')
            self.do_round()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.do_round)
                
            
    def ranged_attack(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flare.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Flare'] = Vis(name = 'Flare', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Flare'].img, tags = 'Flare')
        selected_vis.append('Flare')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
                # debug here, if within certain range...
            app.vis_dict['Flare'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Flare')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Flare']
                app.canvas.delete('Flare')
            except: pass
        if to_hit(my_wis, target_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Firebolt', 'spell')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
        
        

class Ghoul(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Claw Rake':self.melee_attack}
        self.str = 4
        self.agl = 5
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 3
        self.psyche = 4
        self.wis = 4
        self.rsn = 4
        self.init = 4
        self.spirit = 13
        self.magick = 0
        self.san = 10
        self.acts = 1
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing', 'piercing', 'poison']
        self.weak = ['crushing', 'fire']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Claw Rake' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            else:
                app.handle_action()

        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Claw Rake', 'melee')
            if id in app.all_ents().keys() and 'Ghoul_Venom' not in app.ent_dict[id].effects_dict.keys():# HIT, NO KILL add ghoul_venom if not exists
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+84, text = 'Ghoul Venom...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+85, text = 'Ghoul Venom...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                def ghoul_effect(stat):
                    stat -= 1
                    if stat < 1:
                        return 1
                    else:
                        return stat
                app.ent_dict[id].str_effects.append(ghoul_effect)
                app.ent_dict[id].end_effects.append(ghoul_effect)
                def un(i, lockname = None):
                    app.ent_dict[i].str_effects.remove(ghoul_effect)
                    app.ent_dict[i].end_effects.remove(ghoul_effect)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, id)
                # EOT FUNC
                def take_2(tar, lockname = None):
                    app.get_focus(tar)
                    lock(apply_damage, self, app.ent_dict[tar], -2, 'poison', 'Ghoul Venom', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                eot = partial(take_2, id)
                app.ent_dict[id].effects_dict['Ghoul_Venom'] = Effect(name = 'Ghoul_Venom', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(999, self.finish_attack)
            else:
                root.after(111, self.finish_attack)
        else:# MISS
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Skeleton(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Bone Strike':self.melee_attack}
        self.str = 5
        self.agl = 3
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 2
        self.psyche = 2
        self.wis = 2
        self.rsn = 1
        self.init = 3
        self.spirit = 9
        self.magick = 0
        self.san = 9
        self.acts = 1
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing', 'piercing', 'poison']
        self.weak = ['crushing', 'fire']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Bone Strike' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Bone Strike', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Imp(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Fireball':self.fireball, 'Carve':self.melee_attack}
        self.str = 6
        self.agl = 9
        self.end = 8
        self.mm = 7
        self.msl = 6
        self.bls = 4
        self.dodge = 5
        self.psyche = 7
        self.wis = 4
        self.rsn = 5
        self.init = 8
        self.spirit = 19
        self.magick = 16
        self.san = 10
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing', 'piercing', 'fire']
        self.weak = ['cold']
        super().__init__(name, img, loc, owner)
        self.types = ['demon']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Fireball' in self.actions.keys()]:
                self.magick -= 1
                self.acts -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.fireball(target)
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Carve' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def fireball(self, id):
        self.init_attack_anims()
        loc = app.ent_dict[id].loc[:]
        lock(Entity.ranged_attack, self, loc, 'Flare')
        self.init_normal_anims()
        my_mm = self.get_abl('mm')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Fireball', 'ranged')
            root.after(111, self.do_round)
        else:# MISS
            miss(loc)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Carve', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Undead_Knight(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Cleave':self.melee_attack}
        self.str = 10
        self.agl = 9
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 7
        self.wis = 7
        self.rsn = 4
        self.init = 6
        self.spirit = 86
        self.magick = 19
        self.san = 15
        self.acts = 3
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'fire', 'poison']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        self.types = ['undead']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self. acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Cleave' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_knight_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Cleave', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Troll(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Pummel':self.melee_attack}
        self.str = 9
        self.agl = 7
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 5
        self.psyche = 3
        self.wis = 3
        self.rsn = 2
        self.init = 8
        self.spirit = 35
        self.magick = 0
        self.san = 11
        self.acts = 1
        self.mvs = 1
        self.move_range = 8
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'slashing', 'piercing']
        self.weak = ['fire', 'acid']
        self.regen_this_round = False
        super().__init__(name, img, loc, owner)
        self.types = ['animal']
        
    def troll_regen(self):
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text='Regen 2 Spirit', font= ('chalkduster', 13), fill = 'black', tags = 'regen_text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text='Regen 2 Spirit', font= ('chalkduster', 13), fill = 'white', tags = 'regen_text')
        root.after(999, lambda t = 'regen_text' : app.canvas.delete(t))
        self.spirit += 2
        if self.spirit > 35:
            self.spirit = 35
        self.regen_this_round = True
        
    def do_round(self):
        # TROLL REGEN (regen_this_round reset in app.end_turn)
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        elif self.spirit < 35 and self.regen_this_round == False:
            self.troll_regen()
            root.after(1666, self.do_round)
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Pummel' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/orc_axeman_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Pummel', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Warlock(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Undead':self.summon_undead, 'Duress':self.duress, "Tourach's Hymn":self.tourachs_hymn, 'Staff of Vecna':self.staff_of_vecna}
        self.str = 6
        self.agl = 12
        self.end = 9
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 16
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 9
        self.spirit = 89
        self.magick = 266
        self.san = 22
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_undead = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['magick', 'fire', 'elec', 'cold', 'acid']
        self.weak = []
        super().__init__(name, img, loc, owner)
        self.info_text = 'Warlock is immune to all effects that alter abilities, including acts and moves.'
        
    # OVERRIDE BASE METHOD, WARLOCK ABLS NOT AFFECTED BY EFFECTS
    def get_abl(self, abl):
        if abl == 'str':
            return self.str
        elif abl == 'agl':
            return self.agl
        elif abl == 'end':
            return self.end
        elif abl == 'mm':
            return self.mm
        elif abl == 'msl':
            return self.msl
        elif abl == 'bls':
            return self.bls
        elif abl == 'dodge':
            return self.dodge
        elif abl == 'psyche':
            return self.psyche
        elif abl == 'wis':
            return self.wis
        elif abl == 'rsn':
            return self.rsn
        elif abl == 'init':
            return self.init
        elif abl == 'san':
            return self.san
        elif abl == 'acts':
            return self.base_acts
        elif abl == 'mvs':
            return self.base_mvs
        elif abl == 'move_range':
            return self.move_range
            
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.summoned_undead == False:
                self.summoned_undead = True
                root.after(333, self.summon_undead)
            # DURESS WI RANGE
            elif self.acts > 0 and self.magick >= 5 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')>=v.get_abl('str') and v.get_inert()==False] != []:
                self.magick -= 5
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')>=v.get_abl('str')])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.duress(t))
            # TOURACHS HYMN WI RANGE
            elif self.acts > 0 and self.magick >= 3 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')<=v.get_abl('str') and v.get_inert()==False] != []:
                self.magick -= 3
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')<=v.get_abl('str') and v.get_inert()==False])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.tourachs_hymn(t))
            # FREE DISPEL PSYSHIELD WI RANGE STAFF OF VECNA
            elif [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()] != []:
                target = choice([k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types() and v.get_inert()==False])
                app.get_focus(target)
                root.after(666, lambda t = target : self.staff_of_vecna(t))
            # RANGED PURSUE
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()
            
            
    def summon_undead(self):
        effect1 = mixer.Sound('Sound_Effects/warlock_summon.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.count += 3 # skip existing ent ids
        uniq_num = app.count
        app.count += 1
        # get random empty location
        coords = [c for c in app.coords if dist(c, self.loc) <= 9 and app.grid[c[0]][c[1]] == '']
        if len(coords) > 2:
            undead_loc = choice(coords)
            coords.remove(undead_loc)
            undead_loc2 = choice(coords)
            coords.remove(undead_loc2)
            undead_loc3 = choice(coords)
            n ='su'+str(app.count)
            app.count += 1
            n2 = 'su'+str(app.count)
            app.count += 1
            n3 = 'su'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Summon_Skeleton', loc = undead_loc[:])
            app.vis_dict[n2] = Vis(name = 'Summon_Skeleton', loc = undead_loc2[:])
            app.vis_dict[n3] = Vis(name = 'Summon_Skeleton', loc = undead_loc3[:])
            app.canvas.create_image(undead_loc[0]*100+50-app.moved_right, undead_loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
            app.canvas.create_image(undead_loc2[0]*100+50-app.moved_right, undead_loc2[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = n2)
            app.canvas.create_image(undead_loc3[0]*100+50-app.moved_right, undead_loc3[1]*100+50-app.moved_down, image = app.vis_dict[n3].img, tags = n3)
            def cleanup_vis(name):
                del app.vis_dict[name]
                app.canvas.delete(name)
            root.after(2222, lambda name = n : cleanup_vis(name))
            root.after(2222, lambda name = n2 : cleanup_vis(name))
            root.after(2222, lambda name = n3 : cleanup_vis(name))
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Summon Undead', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Summon Undead', justify = 'center', font = ('chalkduster', 14), fill = 'magenta2', tags = 'text')
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Skeleton.png'))
            img2 = ImageTk.PhotoImage(Image.open('summon_imgs/Ghoul.png'))
            ent = Skeleton(name = 'Skeleton', img = img, loc = undead_loc[:], owner = 'p2')
            ent2 = Skeleton(name = 'Skeleton', img = img, loc = undead_loc2[:], owner = 'p2')
            ent3 = Ghoul(name = 'Ghoul', img = img2, loc = undead_loc3[:], owner = 'p2')
            app.ent_dict[ent.id] = ent
            app.ent_dict[ent2.id] = ent2
            app.ent_dict[ent3.id] = ent3
            app.grid[ent.loc[0]][ent.loc[1]] = ent.id
            app.grid[ent2.loc[0]][ent2.loc[1]] = ent2.id
            app.grid[ent3.loc[0]][ent3.loc[1]] = ent3.id
#             app.canvas.create_image(undead_loc[0]*100+50-app.moved_right, undead_loc[1]*100+50-app.moved_down, image = img, tags = ent.tags)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
        root.after(1333, lambda s = undead_loc[:] : app.focus_square(s))
        root.after(2333, lambda s = undead_loc2[:] : app.focus_square(s))
        root.after(3333, lambda s = undead_loc3[:] : app.focus_square(s))
        root.after(4333, self.do_round)
            
            
    
    def duress(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/warlock_duress.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_duress():
            del app.vis_dict['Duress']
            app.canvas.delete('Duress')
        visloc = ent.loc[:]
        app.vis_dict['Duress'] = Vis(name = 'Duress', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Duress'].img, tags = 'Duress')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Duress', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Duress', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            # add -4 rsn, -7 san
            def rsn_ef(stat):
                return max(1,stat-4)
            p = partial(rsn_ef)
            ent.rsn_effects.append(p)
            def san_ef(stat):
                return max(1,stat-7)
            p2 = partial(san_ef)
            ent.san_effects.append(p2)
            def undo(ent, p, p2, lockname = None):
                ent.rsn_effects.remove(p)
                ent.san_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            n = 'Duress' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Duress', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-3 rsn, -7 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-3 rsn, -7 san', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_duress)
            lock(apply_damage, self, ent, -d, 'magick', 'Duress', 'spell')
            root.after(333, self.do_round)
        else:
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, cleanup_duress)
            root.after(2111, self.do_round)
            
            
    def tourachs_hymn(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/tourachs_hymn.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_hymn():
            del app.vis_dict["Tourach's_Hymn"]
            app.canvas.delete("Tourach's_Hymn")
        visloc = ent.loc[:]
        app.vis_dict["Tourach's_Hymn"] = Vis(name = "Tourach's_Hymn", loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict["Tourach's_Hymn"].img, tags = "Tourach's_Hymn")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = "Tourach's Hymn", font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = "Tourach's Hymn", font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            # add -4 str, agl
            def hymn_ef(stat):
                return max(1,stat-4)
            p = partial(hymn_ef)
            ent.str_effects.append(p)
            ent.agl_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.str_effects.remove(p)
                ent.agl_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = "Tourach's_Hymn" + str(app.count)
            ent.effects_dict[n] = Effect(name = "Tourach's_Hymn", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+24-app.moved_down, text = '-4 str, agl', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+25-app.moved_down, text = '-4 str, agl', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_hymn)
            lock(apply_damage, self, ent, -d, 'magick', "Tourach's Hymn", 'spell')
            root.after(333, self.do_round)
        else:
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, cleanup_hymn)
            root.after(2111, self.do_round)
            
    def staff_of_vecna(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/staff_of_vecna.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_staff():
            del app.vis_dict['Staff_of_Vecna']
            app.canvas.delete('Staff_of_Vecna')
        visloc = ent.loc[:]
        app.vis_dict['Staff_of_Vecna'] = Vis(name = 'Staff_of_Vecna', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Staff_of_Vecna'].img, tags = 'Staff_of_Vecna')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        def staff_ef(ts):
            return [t for t in ts if t != 'psyshield']
        p = partial(staff_ef)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Staff_of_Vecna' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Staff_of_Vecna', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
        root.after(1999, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, cleanup_staff)
        root.after(2111, self.do_round)
        
        
        
class Void_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Static Storm':self.static_storm}
        self.str = 5
        self.agl = 15
        self.end = 5
        self.mm = 13
        self.msl = 9
        self.bls = 7
        self.dodge = 15
        self.psyche = 8
        self.wis = 9
        self.rsn = 5
        self.init = 9
        self.spirit = 48
        self.magick = 366
        self.san = 17
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['elec', 'cold']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            # STATIC STORM, if close ents have effects and choice01
            if len([j for k,v in app.all_ents().items() for i,j in v.effects_dict.items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]) >= 2 and self.acts > 0 and 'Static Storm' in self.get_actions().keys():
                self.acts -= 1
                self.static_storm()
            # RANGED FLYING PURSUE (teleport)
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                # -1 range to get more in effect of static storm
                Ai_man.ranged_flying_pursue(self, self.get_abl('rsn')-1, 'spell')
            else:
                app.handle_action()
                
    def static_storm(self):
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'gray', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]
        def cleanup_static(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def static_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                n = 'Static_Storm'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Static_Storm', loc = ent.loc[:])
                root.after(1777, lambda n = n : cleanup_static(n))
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                root.after(1888, lambda ids = ids : static_loop(ids))
        root.after(1777, lambda t = 'text' : app.canvas.delete(t))
        root.after(1888, lambda ids = ids : static_loop(ids))
        
        
        
        
        
        
class Air_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Static Storm':self.static_storm, 'Cyclonic Rift':self.cyclonic_rift, 'Breath of Life':self.breath_of_life, 'Summon Air Elementals':self.summon_elementals}
        self.str = 5
        self.agl = 15
        self.end = 5
        self.mm = 13
        self.msl = 9
        self.bls = 7
        self.dodge = 15
        self.psyche = 8
        self.wis = 9
        self.rsn = 5
        self.init = 9
        self.spirit = 48
        self.magick = 366
        self.san = 17
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['elec', 'cold']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            air_elems = [v for k,v in app.all_ents().items() if v.name == 'Air_Elemental']
            tot_cur_sprt = sum([ent.spirit for ent in air_elems])
            tot_base_sprt = sum([ent.base_spirit for ent in air_elems])
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # BREATH OF LIFE if any air elem exist and total current spirit is at least 15 less than total base spirit
            elif (tot_cur_sprt+15)<=tot_base_sprt and self.acts > 0 and 'Breath of Life' in self.get_actions().keys():
                self.acts -= 1
                self.breath_of_life()
            # STATIC STORM, if close ents have effects and choice01
            elif len([j for k,v in app.all_ents().items() for i,j in v.effects_dict.items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]) >= 3 and self.acts > 0 and 'Static Storm' in self.get_actions().keys() and choice([0,1]):
                self.acts -= 1
                self.static_storm()
            # CYCLONIC RIFT any in range
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')] != [] and self.acts > 0 and 'Cyclonic Rift' in self.get_actions().keys():
                target = choice([k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.cyclonic_rift(t))
            # RANGED FLYING PURSUE (teleport)
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.ranged_flying_pursue(self, self.get_abl('rsn'), 'spell')
            else:
                app.handle_action()
#########

    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
                    effect1.set_volume(app.effects_volume.get())
                    sound_effects.play(effect1, 0)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Air Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Air Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Air_Elemental.png'))
                    ent = Air_Elemental(name = 'Air_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
                
            
                
    
    def static_storm(self):
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'gray', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]
        def cleanup_static(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def static_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                n = 'Static_Storm'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Static_Storm', loc = ent.loc[:])
                root.after(1777, lambda n = n : cleanup_static(n))
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                root.after(1888, lambda ids = ids : static_loop(ids))
        root.after(1777, lambda t = 'text' : app.canvas.delete(t))
        root.after(1888, lambda ids = ids : static_loop(ids))
                
                    
                    
    # dmg and teleport one target
    def cyclonic_rift(self, id):
#         effect1 = mixer.Sound('Sound_Effects/cyclone.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        ent = app.ent_dict[id]
        app.focus_square(loc)
        app.vis_dict['Cyclone'] = Vis(name = 'Cyclone', loc = loc[:])
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Cyclone'].img, tags = 'Cyclone')
        def cleanup_rift():
            del app.vis_dict['Cyclone']
            app.canvas.delete('Cyclone')
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Cyclonic Rift', 'spell')
            if id in app.ent_dict.keys():
                cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(ent.loc,c)<=self.get_abl('psyche')]
                if cs == []:
                    self.do_round()
                else:
                    self.cyclone_teleport(id, choice(cs))
            else:
                root.after(1888, cleanup_rift)
                self.do_round()
        else:
            miss(ent.loc)
            root.after(1888, cleanup_rift)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
    
    def cyclone_teleport(self, id, loc):
        global selected
        selected.append(id)
        del app.vis_dict['Cyclone']
        app.canvas.delete('Cyclone')
        app.canvas.delete('text')
        app.vis_dict['Cyclone'] = Vis(name = 'Cyclone', loc = loc[:])
        app.focus_square(loc)
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Cyclone'].img, tags = 'Cyclone')
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        app.canvas.delete(id)
        root.after(1666, lambda id = id, loc = loc : self.finish_cyclone(id, loc))
        
    def finish_cyclone(self, id, loc):
        global selected
        app.ent_dict[id].loc = loc[:]
        app.grid[loc[0]][loc[1]] = id
        del app.vis_dict['Cyclone']
        app.canvas.delete('Cyclone')
        app.get_focus(id)
        app.canvas.create_image(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        selected.remove(id)
        try: app.canvas.tag_lower((app.ent_dict[id].tags), 'large')
        except: pass
        app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
        self.do_round()
        
    # only called when summons exist, heal whatever summons remain for some amount, give them stat boost effect
    def breath_of_life(self):
        effect1 = mixer.Sound('Sound_Effects/moonlight.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Breath of Life', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Breath of Life', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
#         app.vis_dict['Breath_of_Life'] = Vis(name = 'Breath_of_Life', loc = self.loc[:])
#         app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Breath_of_Life'].img, tags = 'Breath_of_Life')
        ents = [k for k,v in app.all_ents().items() if v.name == 'Air_Elemental']
        def clean_breath_vis(name):
            app.canvas.delete('text')
            del app.vis_dict[name]
            app.canvas.delete('Breath_of_Life')
        def breath_loop(ents):
            if ents == []:
                self.do_round()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                loc = ent.loc[:]
                app.focus_square(loc)
                n = 'Breath_of_Life'+str(app.count)
                app.count += 1
                app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+74-app.moved_down, text = '+10 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+75-app.moved_down, text = '+10 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                app.vis_dict[n] = Vis(name = 'Breath_of_Life', loc = loc[:])
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = 'Breath_of_Life')
                # HEAL, DISPEL
                apply_heal(self, ent, 10)
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(2333, lambda t = 'text' : app.canvas.delete(t))
                root.after(2333, lambda n = n : clean_breath_vis(n))
                root.after(2555, lambda e = ents : breath_loop(e))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda e = ents : breath_loop(e))
                
                
                    

class Air_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Gale':self.gale}
        self.str = 5
        self.agl = 9
        self.end = 5
        self.mm = 9
        self.msl = 6
        self.bls = 5
        self.dodge = 9
        self.psyche = 5
        self.wis = 5
        self.rsn = 4
        self.init = 9
        self.spirit = 22
        self.magick = 0
        self.san = 16
        self.acts = 1
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['elec', 'cold']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Gale' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.gale(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
#                 Ai_man.ranged_flying_pursue(self, self.get_abl('bls'), 'action')
            else:
                app.handle_action()
        
                
            
    def gale(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/gale.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Gale'] = Vis(name = 'Gale', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Gale'].img, tags = 'Gale')
        selected_vis.append('Gale')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
                # debug here, if within certain range...
            app.vis_dict['Gale'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Gale')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Gale']
                app.canvas.delete('Gale')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Gale', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
# water mage, dehydrate- give fire wkns, wis vs wis psy v psy acid spell
# fog- -3 mvrng, 2 cold dmg aoe
# purify- any tar w at least 2 efcts that are not dehydrate, esuna like dispel
class Water_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Dehydrate':self.dehydrate, 'Fog':self.fog, 'Purify':self.purify, 'Summon Water Elementals':self.summon_elementals}
        self.str = 9
        self.agl = 10
        self.end = 9
        self.mm = 12
        self.msl = 11
        self.bls = 6
        self.dodge = 13
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 8
        self.spirit = 76
        self.magick = 666
        self.san = 17
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_elementals = False
        self.purify_used = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['fire', 'crushing', 'explosive']
        self.weak = ['elec']
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            purify_tars = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and len([i for i,j in v.effects_dict.items() if j.name != 'Dehydrate' and j.name != 'Fog'])>=2]
            dehy_tars = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn') and 'Dehydrate' not in [j.name for i,j in v.effects_dict.items()]]
            fog_tars = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn') and 'Fog' not in [j.name for i,j in v.effects_dict.items()]]
            # SUMMON ELEMENTALS
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # PURIFY (free action)
            elif purify_tars != [] and 'Purify' in self.get_actions().keys() and self.purify_used == False:
                target = choice(purify_tars)
                self.purify_used = True
                app.get_focus(target)
                root.after(666, lambda t = target : self.purify(t))
            # FOG
            elif fog_tars != [] and self.acts > 0 and 'Fog' in self.get_actions().keys():
                target = choice(fog_tars)
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.fog(t))
            # DEHYDRATE
            elif dehy_tars != [] and self.acts > 0 and 'Dehydrate' in self.get_actions().keys():
                target = choice(dehy_tars)
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.dehydrate(t))
            # RANGED FLYING PURSUE
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.ranged_flying_pursue(self, self.get_abl('rsn'), 'spell')
            else:
                app.handle_action()
#########

    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Water Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Water Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Water_Elemental.png'))
                    ent = Water_Elemental(name = 'Water_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
        
    
                
    def dehydrate(self, id):
#         effect1 = mixer.Sound('Sound_Effects/dehydrate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Dehydrate', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Dehydrate', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
#             app.vis_dict['Dehydrate'] = Vis(name = 'Dehydrate', loc = self.loc[:])
        ids = [k for k,v in app.all_ents().items() if dist(ent.loc, v.loc) <= 2 and v.owner != self.owner]
        def cleanup_dehy(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def dehydrate_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.focus_square(ent.loc)
                name = 'Dehydrate' + str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Dehydrate', loc = ent.loc[:])
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis):
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Fire weakness', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Fire weakness', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
                    my_psy = self.get_abl('psyche')
                    tar_psy = ent.get_abl('psyche')
                    d = damage(my_psy, tar_psy)
                    lock(apply_damage, self, ent, -d, 'acid', 'Dehydrate', 'spell')
                    if id in app.all_ents().keys():
                        def dehy_wk(wks):
                            return wks+['fire']
                        p = partial(dehy_wk)
                        ent.weak_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.weak_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                        n = 'Dehydrate' + str(app.count)
                        ent.effects_dict[n] = Effect(name = 'Dehydrate', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                        root.after(222, lambda name = name : cleanup_dehy(name))
                        root.after(333, lambda ids = ids : dehydrate_loop(ids))
                    else:
                        root.after(222, lambda name = name : cleanup_dehy(name))
                        root.after(333, lambda ids = ids : dehydrate_loop(ids))
                else:
                    miss(ent.loc[:])
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda name = name : cleanup_dehy(name))
                    root.after(1999, lambda ids = ids : dehydrate_loop(ids))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda ids = ids : dehydrate_loop(ids))
            
            
# fog- -3 mvrng, 3 cold dmg aoe
    def fog(self, id):
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/fog.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Fog', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Fog', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
        def cleanup_fog(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        ids = [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) <= 2 and v.owner != self.owner]
        def fog_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.focus_square(ent.loc)
                name = 'Fog' + str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Fog', loc = ent.loc[:])
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis):
                    if 'Fog' not in [v.name for k,v in ent.effects_dict.items()]:
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-3 move range', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-3 move range', font = ('chalkduster', 13), fill = 'cyan', tags = 'text')
                        def fog_effect(stat):
                            return max(0,stat-3)
                        p = partial(fog_effect)
                        ent.move_range_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.move_range_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                        n = 'Fog' + str(app.count)
                        ent.effects_dict[n] = Effect(name = 'Fog', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    lock(apply_damage, self, ent, -3, 'cold', 'Fog', 'spell')
                    root.after(111, lambda t = 'text' : app.canvas.delete(t))
                    root.after(111, lambda name = name : cleanup_fog(name))
                    root.after(333, lambda ids = ids : fog_loop(ids))
                else:
                    miss(ent.loc[:])
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda name = name : cleanup_fog(name))
                    root.after(1999, lambda ids = ids : fog_loop(ids))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda ids = ids : fog_loop(ids))
                
# purify- any tar w at least 2 efcts that are not dehydrate, esuna like dispel atmpt all (wis)
    def purify(self, id):
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/purify.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Purify', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Purify', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
        def cleanup_purify():
            del app.vis_dict['Purify']
            app.canvas.delete('Purify')
        app.vis_dict['Purify'] = Vis(name = 'Purify', loc = ent.loc[:])
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Purify', font = ('chalkduster', 12), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Purify', font = ('chalkduster', 12), fill = 'cyan', tags = 'text')
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.name != 'Dehydrate' and v.name != 'Fog' and v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
                if spacer > 300:
                    continue
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
                spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
        root.after(2333, cleanup_purify)
        root.after(2444, lambda t = 'text' : app.canvas.delete(t))
        root.after(2444, self.do_round)
                

# change to move in straight line, make ranged atk, die when running into obstacle (block, maybe ent)
class Water_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Surge':self.surge}
        self.str = 5
        self.agl = 8
        self.end = 6
        self.mm = 9
        self.msl = 4
        self.bls = 4
        self.dodge = 11
        self.psyche = 7
        self.wis = 7
        self.rsn = 4
        self.init = 13
        self.spirit = 7
        self.magick = 0
        self.san = 16
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['fire', 'crushing', 'explosive']
        self.weak = ['elec']
        self.direction = choice(['up','down','left','right'])
        super().__init__(name, img, loc, owner)
        
        
    # first try to attack, then try to move setting 'dissipating' to True if legal_moves() shorter than move_range (move obstructed)
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            # SURGE ATTACK
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Surge' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.surge(target)
            # MOVE
            elif self.mvs > 0:
                mvs = self.legal_moves()
                if mvs == []:
                    self.dissipate()
                else:
                    mv = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b , mvs)
                    app.focus_square(mv)
                    self.mvs -= 1
                    lock(Bot.ai_normal_move, self, mv)
                    if len(mvs) < self.get_abl('move_range'):
                        self.dissipate()
                    else:
                        self.do_round()
            else:
                app.handle_action()
        
    def surge(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/surge.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Surge'] = Vis(name = 'Surge', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Surge'].img, tags = 'Surge')
        selected_vis.append('Surge')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
                # debug here, if within certain range...
            app.vis_dict['Surge'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Surge')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Surge']
                app.canvas.delete('Surge')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Surge', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
    def dissipate(self):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Water Elemental dissipates\n   into a puddle...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Water Elemental dissipates\n   into a puddle...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        name = 'dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(1222, lambda t = 'text' : app.canvas.delete(t))
        root.after(333, lambda id = self.id, name = name : app.kill(id, name))
        root.wait_variable(app.dethloks[name])
        app.handle_action()
            
            
    # get only squares in self.direction
    def legal_moves(self):
        s = self.loc[:]
        mvlist = []
        if self.direction == 'up':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0],s[1]-i] in app.coords and app.grid[s[0]][s[1]-i] == '':
                    mvlist.append([s[0],s[1]-i])
                else:
                    break
        elif self.direction == 'down':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0],s[1]+i] in app.coords and app.grid[s[0]][s[1]+i] == '':
                    mvlist.append([s[0],s[1]+i])
                else:
                    break
        elif self.direction == 'left':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0]-i,s[1]] in app.coords and app.grid[s[0]-i][s[1]] == '':
                    mvlist.append([s[0]-i,s[1]])
                else:
                    break
        elif self.direction == 'right':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0]+i,s[1]] in app.coords and app.grid[s[0]+i][s[1]] == '':
                    mvlist.append([s[0]+i,s[1]])
                else:
                    break
        return list(filter(lambda x : dist(x, self.loc) <= self.get_abl('move_range'), mvlist))
        
        
class Earth_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Earth Elementals':self.summon_elementals, 'Earthquake':self.earthquake}
        self.str = 6
        self.agl = 6
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 6
        self.wis = 6
        self.rsn = 2
        self.init = 4
        self.spirit = 58
        self.magick = 466
        self.san = 18
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['slashing', 'piercing', 'crushing', 'elec']
        self.weak = ['cold', 'explosive', 'acid']
        super().__init__(name, img, loc, owner)
        self.info_text = 'Earth Mage gets +1 to abls, besides acts and moves, for each Earth Elemental that exists. Earthquake can still be cast even if removed from actions.'
        
    # OVERRIDE BASE METHOD, +1 for each alive elemental
    def get_abl(self, abl):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get all prox efcts of same abl
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.abl == abl and self.loc in ef.get_locs():
                prox_efcts.append(ef.abl_func)
        # Earth elementals alive bonus
        elems = [k for k,v in app.ent_dict.items() if v.name == 'Earth_Elemental']
        bonus = len(elems)
        if abl == 'str':
            q = self.str_effects + prox_efcts + app.loc_dict[tuple(self.loc)].str_effects
            base = self.str+bonus
        elif abl == 'agl':
            q = self.agl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].agl_effects
            base = self.agl+bonus
        elif abl == 'end':
            q = self.end_effects + prox_efcts + app.loc_dict[tuple(self.loc)].end_effects
            base = self.end+bonus
        elif abl == 'mm':
            q = self.mm_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mm_effects
            base = self.mm
        elif abl == 'msl':
            q = self.msl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].msl_effects
            base = self.msl
        elif abl == 'bls':
            q = self.bls_effects + prox_efcts + app.loc_dict[tuple(self.loc)].bls_effects
            base = self.bls
        elif abl == 'dodge':
            q = self.dodge_effects + prox_efcts + app.loc_dict[tuple(self.loc)].dodge_effects
            base = self.dodge+bonus
        elif abl == 'psyche':
            q = self.psyche_effects + prox_efcts + app.loc_dict[tuple(self.loc)].psyche_effects
            base = self.psyche+bonus
        elif abl == 'wis':
            q = self.wis_effects + prox_efcts + app.loc_dict[tuple(self.loc)].wis_effects
            base = self.wis+bonus
        elif abl == 'rsn':
            q = self.rsn_effects + prox_efcts + app.loc_dict[tuple(self.loc)].rsn_effects
            base = self.rsn+bonus
        elif abl == 'init':
            q = self.init_effects + prox_efcts + app.loc_dict[tuple(self.loc)].init_effects
            base = self.init+bonus
        elif abl == 'san':
            q = self.san_effects + prox_efcts + app.loc_dict[tuple(self.loc)].san_effects
            base = self.san+bonus
        elif abl == 'acts':
            q = self.acts_effects + prox_efcts + app.loc_dict[tuple(self.loc)].acts_effects
            base = self.base_acts
        elif abl == 'mvs':
            q = self.mvs_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mvs_effects
            base = self.base_mvs
#         elif abl == 'cantrips':
#             q = self.cantrips_effects + app.loc_dict[tuple(self.loc)].cantrips_effects
#             base = self.base_cantrips
        elif abl == 'smns':
            q = self.smns_effects + prox_efcts + app.loc_dict[tuple(self.loc)].smns_effects
            base = self.base_smns
        elif abl == 'move_range':
            q = self.move_range_effects + prox_efcts + app.loc_dict[tuple(self.loc)].move_range_effects
            base = self.move_range+bonus
        for func in q:
            base = func(base)
        return base
            
    # summon elems once
    # use earthquake
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # goals are any w enemy ent wi rng rsn reduced to maximally close to all enemy, if none then move towards the max close
            elif self.mvs > 0 and self.legal_moves() != [] and [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != []:
                gs = unique([c for c in app.coords for k,v in app.action_target_ents().items() if v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(v.loc,c)<=self.get_abl('rsn')])
                if gs == []:
                    # get empty sqr that is closest to as many enemy ents as possible
                    g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b , [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                else:
                    mvs = intersect(gs,self.legal_moves())
                    if mvs == []:# no goals wi rng, move towards best g
                        g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, gs)
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                    else:# some g in rng, get best g in mvs
                        mv = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, mvs)
                # move to mv
                app.get_focus(self.id)
                root.after(999, lambda s = mv[:] : app.focus_square(s))
                self.mvs -= 1
                lock(Bot.ai_teleport_move, self, mv)
                root.after(333, self.do_round)
            # do earthquake
            elif self.acts > 0 and self.magick > 9:
                self.magick -= 9
                self.acts -= 1
                self.earthquake()
            else:
                app.handle_action()
            
            
    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Earth Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Earth Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Earth_Elemental.png'))
                    ent = Earth_Elemental(name = 'Earth_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
            
            
    
    # earthquake, dmg near ents (non-flying/ethereal) and move them 'back'
    def earthquake(self):
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/earthquake.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('rsn')]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Earthquake', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Earthquake', font = ('chalkduster', 16), fill = 'orange4', tags = 'text')
        app.vis_dict['Earthquake'] = Vis(name = 'Earthquake', loc = self.loc[:])
        def cleanup_equake():
            del app.vis_dict['Earthquake']
            app.canvas.delete('Earthquake')
        root.after(2666, cleanup_equake)
        # get all ents in vicinity
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.get_move_type() != 'flying' and v.get_move_type() != 'ethereal' and v.immovable != True and v != self and v.name != 'Earth_Elemental']
        def earthquake_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                loc = ent.loc[:]
                my_psyche = self.get_abl('psyche')
                target_agl = ent.get_abl('agl')
                d = damage(my_psyche, target_agl)
                lock(apply_damage, self, ent, -d, 'crushing', 'Earthquake', 'spell')
                if id not in app.all_ents().keys():
                    earthquake_loop(ids)
                else: # ENT NOT KILLED, move it 'away' from caster
                    sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('rsn') and app.grid[c[0]][c[1]] == '' and dist(c,ent.loc)<=4]
                    if sqrs == []:
                        earthquake_loop(ids)
                    else:
                        # change to: sqr must be some dist from ent itself...
                        sqr = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, sqrs)
                        app.focus_square(sqr)
                        lock(ent.throw_move, sqr)
                        earthquake_loop(ids)
        root.after(1666, lambda t = 'text' : app.canvas.delete(t))
        root.after(1777, lambda ids = ids : earthquake_loop(ids))
            
            
class Earth_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Rock Punch':self.rock_punch}
        self.str = 10
        self.agl = 7
        self.end = 13
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 4
        self.psyche = 4
        self.wis = 4
        self.rsn = 3
        self.init = 3
        self.spirit = 8
        self.magick = 0
        self.san = 23
        self.acts = 1
        self.mvs = 1
        self.move_range = 7
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['slashing', 'piercing', 'crushing', 'elec', 'poison']
        self.weak = ['acid', 'explosive']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Rock Punch' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.rock_punch(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
#                 Ai_man.melee_pursue(self, 'action') # PURSUE UNTIL NO MVS OR ADJ ENEMY
            else:
                app.handle_action()

        
    def rock_punch(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/rock_punch.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Rock Punch', 'melee')
            self.do_round()
        else:# MISS
            miss(ent.loc[:])
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
        
        
# casts firewall after teleporting randomly within a dist, resummons fire elementals if they all die
# immune to move_effects, does not use legal_moves
class Fire_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Fire Elementals':self.summon_elementals, 'Firewall':self.firewall, 'Sirocco':self.sirocco}
        self.str = 7
        self.agl = 8
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 12
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 7
        self.spirit = 66
        self.magick = 566
        self.san = 21
        self.acts = 1
        self.mvs = 1
        self.move_range = 7
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['elec', 'fire', 'poison', 'acid', 'magick']
        self.weak = ['cold']
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # goals are any w enemy ent wi rng rsn reduced to maximally close to all enemy, if none then move towards the max close
            elif self.mvs > 0 and self.legal_moves() != [] and [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != []:
                gs = unique([c for c in app.coords for k,v in app.action_target_ents().items() if v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(v.loc,c)<=self.get_abl('rsn')])
                if gs == []:
                    # get empty sqr that is closest to as many enemy ents as possible
                    g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b , [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                else:
                    mvs = intersect(gs,self.legal_moves())
                    if mvs == []:# no goals wi rng, move towards best g
                        g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, gs)
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                    else:# some g in rng, get best g in mvs
                        mv = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, mvs)
                # move to mv
                app.get_focus(self.id)
                root.after(999, lambda s = mv[:] : app.focus_square(s))
                self.mvs -= 1
                lock(Bot.ai_teleport_move, self, mv)
                root.after(333, self.do_round)
            # do firewall
            elif self.acts > 0 and self.magick > 9:
                self.magick -= 9
                self.acts -= 1
                self.firewall()
            else:
                app.handle_action()
            
            
    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Fire Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Fire Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Fire_Elemental.png'))
                    ent = Fire_Elemental(name = 'Fire_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
            
            
    def sirocco(self, id):
        pass
            
    def firewall(self):
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/firewall.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        sqrs = []
        for c in app.coords:
            if c[0] == self.loc[0] and abs(c[1] - self.loc[1]) <= self.get_abl('rsn'):
                sqrs.append(c)
            elif abs(c[0] - self.loc[0]) <= self.get_abl('rsn') and c[1] == self.loc[1]:
                sqrs.append(c)
        sqrs.remove(self.loc)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Firewall', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Firewall', font = ('chalkduster', 16), fill = 'firebrick', tags = 'text')
        names = []
        for s in sqrs:
            u_name = 'Firewall' + str(app.count)
            app.count += 1
            app.vis_dict[u_name] = Vis(name = 'Firewall', loc = s[:])
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u_name].img, tags = 'Firewall')
            names.append(u_name)
        # get all ents in paths
        ents = [k for k,v in app.all_ents().items() if v.name != 'Fire_Elemental' and v.loc in sqrs]
        if ents != []:
            # check for dmg and create text object
            def firewall_loop(ents):
                if ents == []:
                    self.cleanup_firewall(names)
                else:
                    app.canvas.delete('text')
                    id = ents[0]
                    ents = ents[1:]
                    app.get_focus(id)
                    my_psyche = self.get_abl('psyche')
                    target_psy = app.ent_dict[id].get_abl('psyche')
                    d = damage(my_psyche, target_psy)
                    lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Firewall', 'spell')
                    firewall_loop(ents)
            root.after(1666, lambda e = ents : firewall_loop(e))
        else: # cleanup vis / cont ai_loop
            root.after(1999, lambda names = names : self.cleanup_firewall(names))
            
        
    def cleanup_firewall(self, names):
        for n in names:
            del app.vis_dict[n]
            app.canvas.delete(n)
        app.canvas.delete('text')
        self.do_round()
        
class Sorceress(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Fireblast':self.fireblast, 'Teleport':self.teleport, 'Charged Bolt':self.charged_bolt, 'Staff of Vecna':self.staff_of_vecna}
        self.str = 4
        self.agl = 12
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 12
        self.psyche = 12
        self.wis = 15
        self.rsn = 7
        self.init = 6
        self.spirit = 46
        self.magick = 366
        self.san = 18
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'teleport'
        self.teleport_used = False
        self.resist = ['magick', 'fire', 'elec']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            # try free teleport other
            if self.teleport_used == False:
                self.teleport_used = True
                ents = [v for k,v in app.all_ents().items() if dist(self.loc,v.loc) <= self.get_abl('rsn') and v.owner == self.owner and v != self]
                if ents == []:
                    self.do_round()
                else:
                    app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Teleport', font = ('chalkduster', 16), fill = 'black', tags = 'text')
                    app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Teleport', font = ('chalkduster', 16), fill = 'cyan2', tags = 'text')
                    # grab ent who is maximally dist from all enemy ents
                    ent = reduce(lambda a,b : a if sum([dist(a.loc,v.loc) for k,v in app.all_ents().items() if v.owner != a.owner])>sum([dist(b.loc,v.loc) for k,v in app.all_ents().items() if v.owner != b.owner]) else b, ents)
                    # move it among the locs wi range rsn that puts it minimally distant to any enemy ent
                    cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(self.loc,c)<=self.get_abl('rsn')]
                    c = reduce(lambda a,b : a if sum([dist(v.loc,a) for k,v in app.all_ents().items() if v.owner != self.owner])<sum([dist(v.loc,b) for k,v in app.all_ents().items() if v.owner != self.owner]) else b, cs)
                    app.focus_square(c)
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    lock(Bot.ai_teleport_move, ent, c)
                    root.after(333, self.do_round)
            # use fireblast or charged bolt on any spell target wi range
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')] != [] and self.acts > 0 and self.magick >= 4:
                self.magick -= 4
                ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')]
                id = choice(ents)
                self.acts -= 1
                app.get_focus(self.id)
                root.after(999, lambda id = id : app.get_focus(id))
                if choice([0,1]):
                    root.after(999, lambda id = id : self.fireblast(id))
                else:
                    root.after(999, lambda id = id : self.charged_bolt(id))
            # FREE DISPEL PSYSHIELD WI RANGE STAFF OF VECNA
            elif [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()] != []:
                target = choice([k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()])
                app.get_focus(target)
                root.after(666, lambda t = target : self.staff_of_vecna(t))
            # ranged pursue
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                app.get_focus(self.id)
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()

    def staff_of_vecna(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/staff_of_vecna.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_staff():
            del app.vis_dict['Staff_of_Vecna']
            app.canvas.delete('Staff_of_Vecna')
        visloc = ent.loc[:]
        app.vis_dict['Staff_of_Vecna'] = Vis(name = 'Staff_of_Vecna', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Staff_of_Vecna'].img, tags = 'Staff_of_Vecna')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        def staff_ef(ts):
            return [t for t in ts if t != 'psyshield']
        p = partial(staff_ef)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Staff_of_Vecna' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Staff_of_Vecna', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
        root.after(1999, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, cleanup_staff)
        root.after(2111, self.do_round)
    
    def fireblast(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Fireblast'] = Vis(name = 'Fireblast', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
        selected_vis.append('Fireblast')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            app.vis_dict['Fireblast'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_fireblast(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_fireblast(self, id):
        ent = app.ent_dict[id]
        loc = ent.loc[:]
        my_wis = self.get_abl('wis')
        target_wis = ent.get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Fireblast')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Fireblast']
                app.canvas.delete('Fireblast')
            except: pass
        if to_hit(my_wis, target_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            if 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                loc = ent.loc[:]
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Burned...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Burned...', justify = 'center', fill = 'firebrick1', font = ('chalkduster', 14), tags = 'text')
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and (st == 'melee' or st == 'ranged' or st == 'spell'):
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'firebrick1', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                p = partial(burn_effect)
                def undo(ent, p, lockname = None):
                    ent.defense_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Burn'+str(app.count)
                app.count += 1
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_fireball)
            lock(apply_damage, self, ent, -d, 'fire', 'Fireblast', 'spell')
            if id in app.all_ents().keys() and 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                ent.defense_effects.append(p)
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
    def charged_bolt(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Charged_Bolt'] = Vis(name = 'Charged_Bolt', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
        selected_vis.append('Charged_Bolt')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            app.vis_dict['Charged_Bolt'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_charged_bolt(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_charged_bolt(self, id):
        loc = app.ent_dict[id].loc[:]
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Charged_Bolt')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Charged_Bolt']
                app.canvas.delete('Charged_Bolt')
            except: pass
        if to_hit(my_wis, target_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Charged Bolt', 'spell')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)

    # here just for purposes of occupying action dict, teleport action handled in do_round
    def teleport(self):
        pass
        
        
        
class Orc_Axeman(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Chop':self.melee_attack}
        self.str = 11
        self.agl = 7
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 4
        self.wis = 4
        self.rsn = 3
        self.init = 6
        self.spirit = 21
        self.magick = 0
        self.san = 11
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'fire', 'poison']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        self.types = ['animal']
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Chop' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()

    def pass_priority(self):
        app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/orc_axeman_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Chop', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
class Alien_Warrior(Bot):
    def __init__(self, name, img, loc, owner, waiting = False, timer = 3):
        self.actions = {'Eviscerate':self.melee_attack}
        self.str = 12
        self.agl = 12
        self.end = 12
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 10
        self.psyche = 4
        self.wis = 4
        self.rsn = 3
        self.init = 12
        self.spirit = 39
        self.magick = 0
        self.san = 19
        self.acts = 2
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.timer = timer
        self.move_type = 'normal'
        self.resist = []
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            self.timer -= 1
            if self.timer <= 0:
                self.waiting = False
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Eviscerate' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
                
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/orc_axeman_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Eviscerate', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
class Fire_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Flare':self.flare}
        self.str = 5
        self.agl = 8
        self.end = 6
        self.mm = 8
        self.msl = 7
        self.bls = 4
        self.dodge = 8
        self.psyche = 8
        self.wis = 4
        self.rsn = 4
        self.init = 7
        self.spirit = 17
        self.magick = 0
        self.san = 11
        self.acts = 2
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['elec', 'fire', 'poison', 'acid', 'magick']
        self.weak = ['cold', 'explosive']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Flare' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.flare(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
                
            
    def flare(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flare.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Flare'] = Vis(name = 'Flare', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Flare'].img, tags = 'Flare')
        selected_vis.append('Flare')
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
                # debug here, if within certain range...
            app.vis_dict['Flare'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(111, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(25, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis.remove('Flare')
            self.init_normal_anims()
            try: 
                del app.vis_dict['Flare']
                app.canvas.delete('Flare')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Flare', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
        
        
        
class Barbarian(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Frenzy':self.frenzy, 'Shout':self.shout, 'Leap':self.leap}
        self.str = 11
        self.agl = 14
        self.end = 12
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 4
        self.wis = 4
        self.rsn = 4
        self.init = 9
        self.spirit = 113
        self.magick = 0
        self.san = 14
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.leap_used = False
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['slashing', 'piercing', 'crushing', 'cold', 'elec', 'fire', 'poison']
        self.weak = ['magick']
        self.leap_anims = {}
        anims = [a for r,d,a in walk('./animations/Barbarian_Leap/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Barbarian_Leap/' + anim))
            self.leap_anims[i] = a
        super().__init__(name, img, loc, owner)

        
    def init_leap_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.leap_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            # MOVE charge move towards goal
            if self.mvs>0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            # LEAP to move towards best goal
            elif self.leap_used == False and self.leap_moves() != [] and 'Leap' in self.get_actions().keys():
                self.leap_used = True
                # leap to sqr that has most adj, non-invis enemy ents
                goals = unique([c for c in app.coords for k,v in app.action_target_ents().items() if app.grid[c[0]][c[1]] == '' and dist(v.loc,c)==1 and v.owner != self.owner])
                if intersect(goals,self.leap_moves())==[]:# no goals in range or no goals, leap closest to an enemy ent
                    mvs = self.leap_moves()
                    g = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, [v.loc for k,v in app.action_target_ents().items() if v.owner != self.owner])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, mvs)
                    app.focus_square(mv)
                    root.after(999, lambda mv = mv : self.leap(mv))
                else: # can leap to a goal, find best goal in leap moves
                    goal = reduce(lambda a,b : a if len([c for c in app.coords if dist(c,a)==1 and app.grid[c[0]][c[1]] in app.action_target_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner])>len([c for c in app.coords if dist(c,b)==1 and app.grid[c[0]][c[1]] in app.action_target_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]) else b, [g for g in goals if dist(g,self.loc)<=self.get_abl('move_range')])
                    app.focus_square(goal)
                    root.after(999, lambda g = goal[:] : self.leap(g))
            # FRENZY if any adj enemy, also hit frndly, ww hits invis altho barbarian does not pursue invis
            elif self.acts > 0 and 'Frenzy' in self.get_actions().keys() and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc)==1 and v.owner != self.owner]:
                self.acts -= 1
                self.frenzy()
            # SHOUT, -1 sanity all enemy range rsn
            elif 'Shout' in self.get_actions().keys() and self.acts>0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc)<=self.get_abl('str') and v.owner != self.owner] != []:
                self.acts -= 1
                self.shout()
            else:
                app.handle_action()
                
                
        
    def leap_moves(self):
        cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c,self.loc)<=self.get_abl('move_range')]
        return cs
        
    def leap(self, sqr):
        global selected
        self.init_leap_anims()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected.append(self.id)
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda es = end_sqr, ss = start_sqr : self.finish_leap(es, ss)) # EXIT
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_leap(self, end_sqr, start_sqr):
        global selected
        selected.remove(self.id)
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        root.after(666, self.do_round)
        
    
    def shout(self):
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Shout', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Shout', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        def cleanup_shout(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def shout_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                un = 'Shout'+str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Shout', loc = ent.loc[:])
                my_str = self.get_abl('str')
                target_psy = ent.get_abl('psyche')
                if to_hit(my_str, target_psy):
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = '-2 sanity, lose invis', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = '-2 sanity, lose invis', justify = 'center', fill = 'indianred', font = ('chalkduster', 15), tags = 'text')
                    def shout_effect(stat):
                        return max(1,stat-2)
                    p = partial(shout_effect)
                    ent.san_effects.append(p)
                    def staff_ef(ts):
                        return [t for t in ts if t != 'invisibility']
                    p2 = partial(staff_ef)
                    ent.type_effects.append(p2)
                    def undo(ent, p, p2, lockname = None):
                        ent.san_effects.remove(p)
                        ent.type_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p, p2)
                    n = 'Shout' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Shout', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
                    root.after(1555, lambda un = un : cleanup_shout(un))
                    root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1777, lambda ids = ids : shout_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda un = un : cleanup_shout(un))
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : shout_loop(ids))
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda ids = ids : shout_loop(ids))


        
    def frenzy(self):
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Frenzy', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Frenzy', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        def cleanup_ww(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def ww_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                sqr = ent.loc[:]
                un = 'Frenzy'+str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Frenzy', loc = sqr[:])
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                root.after(1999, lambda un = un : cleanup_ww(un))
                my_agl = self.get_abl('agl')
                target_agl = ent.get_abl('agl')
                if to_hit(my_agl, target_agl):
                    my_str = self.get_abl('str')
                    target_end = ent.get_abl('end')
                    d = damage(my_str, target_end)
                    lock(apply_damage, self, ent, -d, 'slashing', 'Frenzy', 'melee')
                    ww_loop(ids)
                else:
                    miss(sqr)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : ww_loop(ids))
        root.after(999, lambda ids = ids : ww_loop(ids))
        
        
    # if no ent within immediate move/attack range, only move toward witch
class Minotaur_Top(Bot):
    def __init__(self, name, img, loc, owner, id, waiting = False):
        self.id = id
        self.actions = {}
        self.str = 14
        self.agl = 9
        self.end = 11
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.init = 8
        self.spirit = 666
        self.magick = 0
        self.san = 19
        self.acts = 1
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.resist = ['crushing', 'piercing', 'magick']
        self.weak = []
        super().__init__(name, img, loc, owner, type = 'large')
        self.move_type = 'normal'
        self.immovable = True
        
    def init_stomp_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Stomp_Top/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Stomp_Top/' + anim))
            self.anim_dict[i] = a
            
    def init_move_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Move_Top/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Move_Top/' + anim))
            self.anim_dict[i] = a
            
    # 'tall' ent, bigger than 100 pixels height, needs to be split into 2 images so the 'top' image is 'large' (raised above 'maptop', bottom part of ent is hidden behind 'maptop'
class Minotaur(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Charge':self.charge, 'Stomp':self.stomp, 'Pound':self.pound}
        self.str = 12
        self.agl = 9
        self.end = 13
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 9
        self.wis = 9
        self.rsn = 5
        self.init = 8
        self.spirit = 666
        self.magick = 0
        self.san = 23
        self.acts = 1
        self.mvs = 2
        self.move_range = 5
        self.waiting = waiting
        self.resist = ['crushing', 'piercing', 'magick']
        self.weak = []
        self.move_type = 'normal'
        super().__init__(name, img, loc, owner, type = 'large_bottom')
        self.immovable = True
        self.info_text = 'Minotaur Charge, Pound, and Stomp cannot be removed.'
        # create top half
        img = ImageTk.PhotoImage(Image.open('animations/Minotaur_Top/0.png'))
        app.ent_dict[self.id+'top'] = Minotaur_Top(name = 'Minotaur_Top', img = img, loc = [self.loc[0],self.loc[1]], owner = 'p2', id = self.id+'top')
        
        
    def large_undo(self):
        app.canvas.delete(self.id+'top')
        del app.ent_dict[self.id+'top']
        
        
    def legal_moves(self):
        mt = self.get_move_type()
        if mt == 'normal':
            return self.normal_moves()
        elif mt == 'ethereal' or mt == 'flying' or mt == 'teleport':
            return self.flying_moves()
        elif mt == 'charge':
            return self.charge_moves()
        else:
            print('unknown move type legal moves')
            
    def charge_moves(self):
        loc = self.loc
        # get all cs in each lateral direction, filter by move range
        mvs = []
        cs = app.coords
        def north(dst):
            if [loc[0],loc[1]-dst] in cs and app.grid[loc[0]][loc[1]-dst] == '':
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
        north(1)
        def south(dst):
            if [loc[0],loc[1]+dst] in cs and app.grid[loc[0]][loc[1]+dst] == '':
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
        south(1)
        def west(dst):
            if [loc[0]-dst,loc[1]] in cs and app.grid[loc[0]-dst][loc[1]] == '':
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
        west(1)
        def east(dst):
            if [loc[0]+dst,loc[1]] in cs and app.grid[loc[0]+dst][loc[1]] == '':
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
        east(1)
        mvs = list(filter(lambda x : dist(x, self.loc) <= self.move_range, mvs))
        return mvs
        
    def flying_moves(self):
        loc = self.loc[:]
        mvlist = []
        for c in app.coords:
            if dist(loc, c) <= self.move_range and app.grid[c[0]][c[1]] == '':
                mvlist.append(c)
        return mvlist
        
    def normal_moves(self):
        loc = self.loc[:]
        mvlist = []
        sqr_cost_map = {}
        def findall(loc, start, distance):
            if start > distance:
                return
            adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
            for s in adj:
                if tuple(s) in sqr_cost_map:
                    if sqr_cost_map[tuple(s)] < start:
                        continue
                sqr_cost_map[tuple(s)] = start
                if s not in mvlist:
                    mvlist.append(s)
                findall(s, start+1, distance)
        findall(loc, 1, self.move_range)
        return mvlist
        
        
    def init_stomp_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Stomp_Bot/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Stomp_Bot/' + anim))
            self.anim_dict[i] = a
            
    def init_move_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Move_Bot/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Move_Bot/' + anim))
            self.anim_dict[i] = a
        
    # takes 2 locs that share 1 axis, returns True if all sqrs between are empty ('')
    def clear_path(self, myloc, enloc):
        if myloc[0] == enloc[0]:
            def check_loop(start, end):
                if start[0] > end[0]:
                    x = start[0] - 1
                    start = [x,start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
                elif start[0] < end[0]:
                    x = start[0] + 1
                    start = [x,start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
            return check_loop(myloc[:], enloc[:])
        elif myloc[1] == enloc[1]:
            def check_loop(start, end):
                if start[0] > end[0]:
                    x = start[0] - 1
                    start = [x, start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
                elif start[0] < end[0]:
                    x = start[0] + 1
                    start = [x, start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
            return check_loop(myloc[:], enloc[:])
        else:
            return False
            
    def charge(self, id):
        global selected
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_charge_attack.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        self.init_move_anims()
        app.ent_dict[self.id+'top'].init_move_anims()
        selected = [self.id, self.id+'top']
        start_sqr = self.loc[:]
        goals = [c for c in app.coords if dist(c, ent.loc) == 1]
        path = bfs(start_sqr, goals, app.grid)
        end_sqr = path[-1]
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(x, y, endx, endy, start_sqr, end_sqr, path, acm, speed):
            if speed > 15:
                speed -= 1
            acm += 10
            if acm >= 40:
                app.ent_dict[self.id+'top'].rotate_image()
                self.rotate_image()
                acm = 0
            if x > endx:
                x -= 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if x < endx: 
                x += 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if y > endy: 
                y -= 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if y < endy: 
                y += 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.finish_charge(end_sqr, start_sqr, id)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(x, y, endx, endy, start_sqr, end_sqr, path, acm, speed)
            else: # CONTINUE LOOP
                root.after(speed, lambda x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path, acm = acm, spd = speed : move_loop(x, y, ex, ey, s, s2, p, acm, spd))
        move_loop(x, y, endx, endy, start_sqr, end_sqr, path, 0, 60)
        
    def finish_charge(self, end_sqr, start_sqr, id):
        global selected
        sound_effects.stop()
        self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        app.ent_dict[self.id+'top'].loc = [end_sqr[0],end_sqr[1]]
        root.after(666, lambda id = id : app.get_focus(id))
        root.after(1333, lambda id = id : self.charge_hit(id)) # EXIT THROUGH ATTACK
        
    def charge_hit(self, id):
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_attack.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.get_focus(id)
        app.ent_dict[self.id+'top'].init_attack_anims()
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl): # HIT
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Charge', 'melee')
            root.after(666, lambda id = id : self.cleanup_charge(id)) # EXIT THROUGH CLEANUP_ATTACK()
        else: # MISS
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(2111, lambda id = id : self.cleanup_charge(id))
            
    def cleanup_charge(self, id):
        app.ent_dict[self.id+'top'].init_normal_anims()
        app.canvas.delete('text')
        self.do_round()
        
        
    #  Minotaur AI
    # if no other enemy is within atk range, will always attempt moving towards witch
    def do_round(self):
        if self.waiting == True or self.id not in app.all_ents().keys():
            app.handle_action()
        else:
            w = app.ent_dict[app.p1_witch]
            charge_ents = [k for k,v in app.all_ents().items() if self.get_abl('move_range') <= dist(v.loc, self.loc) <= self.get_abl('move_range')*2 and (v.loc[0] == self.loc[0] or v.loc[1] == self.loc[1]) and self.clear_path(self.loc[:], v.loc[:]) == True and v.owner != self.owner]
            # IF CAN CHARGE WITCH
            if self.get_abl('move_range') <= dist(w.loc, self.loc) <= self.get_abl('move_range')*2 and (w.loc[0] == self.loc[0] or w.loc[1] == self.loc[1]) and self.clear_path(self.loc[:], w.loc[:]) and self.acts > 0:
                self.acts -= 1
                app.get_focus(w.id)
                root.after(666, lambda id = w.id : self.charge(id)) # CHARGE WITCH
            # CHARGE NON-WITCH
            elif charge_ents != [] and self.acts > 0:
                self.acts -= 1
                id = choice(charge_ents)
                app.get_focus(id)
                root.after(666, lambda id = id : self.charge(id))# CHARGE ANY
            # ATTEMPT POUND ATTACK ADJ
            elif self.acts > 0 and [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner]:
                adj_ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner]
                self.acts -= 1
                id = choice(adj_ents)
                app.get_focus(id)
                root.after(666, lambda id = id : self.pound(id))
            # MOVE ADJ TO AN ENT WI MOVE RANGE
            elif intersect(self.legal_moves(), [c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c, v.loc) == 1 and app.grid[c[0]][c[1]] == '']) != [] and self.mvs > 0:
                goals = [c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c, v.loc) == 1 and app.grid[c[0]][c[1]] == '']
                path = bfs(self.loc[:], goals, app.grid)
                self.mvs -= 1
                app.focus_square(path[-1])
                root.after(666, lambda s = path[-1] : self.minotaur_move(s))
            elif self.mvs > 0: # OTHERWISE PURSUE WITCH
                # if no path on grid, use egrid, then stomp
                goals = [c for c in app.coords if dist(c, w.loc) == 1 and app.grid[c[0]][c[1]] != 'block'] # doesn't matter if they are occupied here
                path = bfs(self.loc[:], goals, app.grid)
                if path == None:
                    egrid = deepcopy(app.grid)
                    ent_locs = [v.loc for k,v in app.all_ents().items() if v != self]
                    for eloc in ent_locs:
                        egrid[eloc[0]][eloc[1]] = '' # EGRID NOW EMPTIED OF ENTS
                    path = bfs(self.loc[:], goals, egrid)
                moves = intersect(self.legal_moves(), path)
                if moves == []:
                    self.mvs -= 1
                    self.do_round()
                else:
                    move = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, moves)
                    self.mvs -= 1
                    app.focus_square(move)
                    root.after(666, lambda m = move : self.minotaur_move(m))
            # EXIT BACK TO HANDLE_ACTION THROUGH STOMP
            else:
                app.get_focus(self.id)
                root.after(666, self.stomp)
            
    def minotaur_move(self, endloc):
        global selected
        effect1 = mixer.Sound('Sound_Effects/minotaur_move.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        self.init_move_anims()
        app.ent_dict[self.id+'top'].init_move_anims()
        selected = [self.id, self.id+'top']
        id = self.id
        end_sqr = endloc[:] # redundant naming of vars
        path = bfs(self.loc, [end_sqr], app.grid) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path, acm):
            acm += 10
            if acm >= 40:
                app.ent_dict[id+'top'].rotate_image()
                self.rotate_image()
                acm = 0
            if x > endx:
                x -= 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            elif x < endx: 
                x += 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            if y > endy: 
                y -= 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            elif y < endy: 
                y += 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.finish_move(end_sqr, start_sqr)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path, acm)
            else: # CONTINUE LOOP
                root.after(66, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path, acm = acm : move_loop(id, x, y, ex, ey, s, s2, p, acm))
        move_loop(id, x, y, endx, endy, self.loc, end_sqr, path, 0)
        
    def finish_move(self, end_sqr, start_sqr):
        global selected
        sound_effects.stop()
        self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        app.ent_dict[self.id+'top'].loc = [end_sqr[0],end_sqr[1]]
        self.do_round()
#     
    def pound(self, id):
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_attack.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.ent_dict[self.id+'top'].init_attack_anims()
        def pound_loop(ents):
            if ents == []:
                root.after(1999, lambda id = id : self.cleanup_attack(id))
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                my_agl = self.get_abl('agl')
                target_agl = ent.get_abl('agl')
                if to_hit(my_agl, target_agl):
                    my_str = self.get_abl('str')
                    target_end = ent.get_abl('end')
                    d = damage(my_str, target_end)
                    lock(apply_damage, self, ent, -d, 'crushing', 'Pound', 'melee')
                    root.after(222, lambda ents = ents : pound_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ents = ents : pound_loop(ents))
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1]
        pound_loop(ents)
        
            
    def cleanup_attack(self, id):
#         self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        try: 
            app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
    # all non-flying ents w/i range 8 take 8-dist(self.loc,id.loc) and are moved randomly (psi-push)
    # changing to 'pull' ents towards minotaur, move to sqr that minimizes dist between
    def stomp(self):
        app.focus_square(self.loc)
        def stomp_sound():
            effect1 = mixer.Sound('Sound_Effects/minotaur_stomp.ogg')
            effect1.set_volume(app.effects_volume.get())
            sound_effects.play(effect1, 0)
        # insert start_stomp_anims() here
        self.init_stomp_anims()
        app.ent_dict[self.id+'top'].init_stomp_anims()
        # insert stomp vis
        def earthquake_loop(ids):
            global selected
            if ids == []:
                self.cleanup_stomp()
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                loc = app.ent_dict[id].loc[:]
                d = max(1,6-dist(self.loc, loc))
                lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Stomp', 'ranged')
                if id not in app.all_ents().keys():
                    earthquake_loop(ids)
                else: # ENT NOT KILLED, INSERT PSI PUSH
                    start_loc = app.ent_dict[id].loc[:]
                    # recursively check adj sqr of ent that minimizes dist from minotaur
                    sqr = reduce(lambda a,b : a if dist(a, self.loc) < dist(b, self.loc) else b, [s for s in app.coords if dist(start_loc, s) == 1])
                    if app.grid[sqr[0]][sqr[1]] == '':
                        sqr2 = reduce(lambda a,b : a if dist(a, self.loc) < dist(b, self.loc) else b, [s for s in app.coords if dist(sqr, s) == 1])
                        if app.grid[sqr2[0]][sqr2[1]] == '':
                            dest = sqr2
                        else:
                            dest = sqr
                    else:
                        dest = start_loc[:]
                    # end destination logic
                    x = start_loc[0]*100+50-app.moved_right
                    y = start_loc[1]*100+50-app.moved_down
                    endx = dest[0]*100+50-app.moved_right
                    endy = dest[1]*100+50-app.moved_down
                    if start_loc != dest: # do move then go to next eq loop, else go to next eq loop
                        selected = [id]
                        def finish_psionic_push(tar, end_loc, start_loc):
                            global selected
                            selected = []
                            app.ent_dict[tar].loc = end_loc[:]
                            app.grid[start_loc[0]][start_loc[1]] = ''
                            app.grid[end_loc[0]][end_loc[1]] = tar
                            root.after(888, lambda t = 'text' : app.canvas.delete(t))
                            root.after(999, lambda ids = ids : earthquake_loop(ids))
                        def psi_move_loop(ent, x, y, endx, endy, sqr, start_sqr):
                            if x % 25 == 0 and y % 25 == 0:
                                app.ent_dict[ent].rotate_image()
                                app.canvas.delete(ent)
                                app.canvas.create_image(x, y, image = app.ent_dict[ent].img, tags = app.ent_dict[ent].tags)
                            if x > endx:
                                x -= 10
                                app.canvas.move(ent, -10, 0)
                            elif x < endx: 
                                x += 10
                                app.canvas.move(ent, 10, 0)
                            if y > endy: 
                                y -= 10
                                app.canvas.move(ent, 0, -10)
                            elif y < endy: 
                                y += 10
                                app.canvas.move(ent, 0, 10)
                            try: app.canvas.tag_lower(app.ent_dict[ent].tags, 'large')
                            except: pass
                            app.canvas.tag_lower(app.ent_dict[ent].tags, 'maptop')
                            if x == endx and y == endy:
                                root.after(666, lambda e = ent, s = sqr, ss = start_sqr : finish_psionic_push(e, s, ss))
                            else:
                                root.after(50, lambda id = id, x = x, y = y, endx = endx, endy = endy, s = sqr, s2 = start_sqr : psi_move_loop(id, x, y, endx, endy, s, s2))
                        psi_move_loop(id, x, y, endx, endy, dest, start_loc)
                    else:
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ids = ids : earthquake_loop(ids))
            # first call of eq loop, called if affected ents exist
        ents = [k for k,v in app.all_ents().items() if v.immovable != True and v.get_move_type() != 'ethereal' and v.get_move_type() != 'flying']
        root.after(2333, self.init_normal_anims)
        root.after(2333, app.ent_dict[self.id+'top'].init_normal_anims)
        root.after(2111, stomp_sound)
        root.after(2555, lambda ids = ents : earthquake_loop(ids))
        
    def cleanup_stomp(self):
        app.canvas.delete('text')
        app.handle_action()
        
        
class Ogre(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Crush':self.crush}
            self.str = 6
            self.agl = 9
            self.end = 5
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 12
            self.init = 5
            self.spirit = 27
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Crush':self.crush}
            self.str = 13
            self.agl = 8
            self.end = 13
            self.mm = 3
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 11
            self.init = 5
            self.spirit = 45
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        self.move_type = 'charge'
        self.weak = []
        self.resist = []
        super().__init__(name, id, img, loc, owner)
        
    def crush(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_crush)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_crush(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Crush', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_crush(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_crush(self, event = None, sqrs = None):
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        self.init_attack_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Crush', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Crush', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 16), tags = 'text')
        ents = [v for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1 and v.get_move_type() != 'flying']
        if ents == []:
            root.after(1666, self.finish_crush)
        else:
            root.after(1666, self.init_normal_anims)
            self.crush_loop(ents)
    
    def crush_loop(self, ents):
        if ents == []:
            self.finish_crush()
        else:
            ent = ents[0]
            ents = ents[1:]
            un = 'crush'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Crush', loc = ent.loc[:])
            def cleanup_crush(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
            my_agl = self.get_abl('agl')
            tar_agl = ent.get_abl('agl')
            if to_hit(my_agl, tar_agl) == True:
                my_str = self.get_abl('str')
                tar_end = ent.get_abl('end')
                d = damage(my_str, tar_end)
                root.after(1666, lambda un = un : cleanup_crush(un))
                lock(apply_damage, self, ent, -d, 'crushing', 'Crush', 'melee')
                self.crush_loop(ents)
            else:
                miss(ent.loc)
                root.after(1555, lambda un = un : cleanup_crush(un))
                root.after(1666, lambda ents = ents : self.crush_loop(ents))
        
    def finish_crush(self, event = None):
        self.init_normal_anims()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
        
        
class Berserker(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Leap':self.leap, 'Slash':self.slash, 'Howl From Beyond':self.howl_from_beyond, 'Track':self.track}
            self.str = 6
            self.agl = 9
            self.end = 5
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 12
            self.init = 5
            self.spirit = 27
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Leap':self.leap, 'Slash':self.slash, 'Whirlwind':self.whirlwind, 'Howl From Beyond':self.howl_from_beyond, 'Track':self.track,  'Hurl':self.hurl, 'Rage':self.rage, 'Molten Claws':self.molten_claws, 'Bane Claws':self.bane_claws}
            self.str = 6
            self.agl = 10
            self.end = 6
            self.mm = 3
            self.msl = 0
            self.bls = 0
            self.dodge = 8
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 12
            self.init = 9
            self.spirit = 35
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        self.move_type = 'charge'
        self.weak = []
        self.resist = ['poison', 'fire']
        self.leap_used = False
        self.leap_anims = {}
        for k,v in app.leap_anims.items():
            self.leap_anims[k] = v
        super().__init__(name, id, img, loc, owner)
        
    def init_leap_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.leap_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
        
    def track(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_track)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_track(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Track', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_track(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_track(self, event = None, sqrs = None):
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/howl.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = 'Track', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = 'Track', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        def cleanup_track(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def track_loop(ents):
            if ents == []:
                self.finish_track()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Track' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Track', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_track(u))
                my_agl = self.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Lose Invisibility', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Lose Invisibility', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                    def track_effect(ts):
                        return [t for t in ts if t != 'invisibility']
                    p = partial(track_effect)
                    ent.type_effects.append(p)
                    n = 'Track' + str(app.count)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p)
                    n = 'Track' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Track', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : track_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(999, lambda ents = ents : track_loop(ents))
        track_loop(ents)
        
    def finish_track(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def howl_from_beyond(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_howl)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_howl(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Howl From Beyond', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_howl(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_howl(self, event = None, sqrs = None):
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/howl_from_beyond.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Howl From Beyond', font = ('chalkduster', 13), fill = 'gray33', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Howl From Beyond', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner and 'Howl_From_Beyond' not in [j.name for i,j in v.effects_dict.items()] and isinstance(v,Witch)==False]
        def cleanup_howl(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def howl_loop(ents):
            if ents == []:
                self.finish_howl()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Howl_From_Beyond' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Howl_From_Beyond', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_howl(u))
                my_str = self.get_abl('str')
                tar_str = ent.get_abl('str')
                if to_hit(my_str, tar_str):
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '-3 rsn, -2 san', font = ('chalkduster', 13), fill = 'gray33', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '-3 rsn, -2 san', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
                    def howl_effect(stat):
                        return max(1,stat-3)
                    def howl_rsn_effect(stat):
                        return max(1, stat-2)
                    p = partial(howl_effect)
                    p2 = partial(howl_rsn_effect)
                    ent.san_effects.append(p2)
                    ent.rsn_effects.append(p)
                    n = 'Howl_From_Beyond' + str(app.count)
                    def un(i, p, p2, lockname = None):
                        app.ent_dict[i].san_effects.remove(p2)
                        app.ent_dict[i].rsn_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p, p2)
                    ent.effects_dict[n] = Effect(name = 'Howl_From_Beyond', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : howl_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : howl_loop(ents))
        howl_loop(ents)
        
    def finish_howl(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def whirlwind(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_whirlwind)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_whirlwind(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Whirlwind', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_whirlwind(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_whirlwind(self, event = None, sqrs = None):
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        self.init_attack_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Whirlwind', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Whirlwind', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1]
        if ents == []:
            root.after(1666, self.finish_whirlwind)
        else:
            root.after(1666, self.init_normal_anims)
            self.whirlwind_loop(ents)
    
    def whirlwind_loop(self, ents):
        if ents == []:
            self.finish_whirlwind()
        else:
            id = ents[0]
            ents = ents[1:]
            sqr = app.ent_dict[id].loc[:]
            un = 'Whirlwind'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Berserker_Slash', loc = sqr[:])
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
            def cleanup_whirlwind_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            my_agl = max(1, self.get_abl('agl')-3)
            target_agl = app.ent_dict[id].get_abl('agl')
            if to_hit(my_agl, target_agl) == True:
                my_str = self.get_abl('str')
                target_end = app.ent_dict[id].get_abl('end')
                d = damage(my_str, target_end)
                root.after(1666, lambda un = un : cleanup_whirlwind_vis(un))
                lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Whirlwind', 'melee')
                self.whirlwind_loop(ents)
            else:
                miss(sqr)
                root.after(1555, lambda un = un : cleanup_whirlwind_vis(un))
                root.after(1666, lambda ents = ents : self.whirlwind_loop(ents))
        
    def finish_whirlwind(self, event = None):
        self.init_normal_anims()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.exists_check(app.active_ent)
        
    def rage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_rage)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_rage(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Rage', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_rage(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rage(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Rage', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Rage', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Rage'] = Vis(name = 'Rage', loc = sqr[:])
        vis = app.vis_dict['Rage']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Rage')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Attempt Dispel Effects\n +3 str, end, +4 psy', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Attempt Dispel Effects\n +3 str, end, +4 psy', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        to_remove = []
        for k,v in self.effects_dict.items():
            if v.dispel(self.get_abl('str')) == 'Dispelled':
                to_remove.append(k)
        for k in to_remove:
            del self.effects_dict[k]
        # add effects
        def rage_effect(stat):
            return stat+3
        p = partial(rage_effect)
        self.str_effects.append(p)
        self.end_effects.append(p)
        def rage_effect2(stat):
            return stat+4
        p2 = partial(rage_effect)
        self.psyche_effects.append(p2)
        def rage_actions(act_dict):
            new_acts_dict = dict()
            for k,v in act_dict.items():
                if v.name == 'Rage' or v.name == 'Whirlwind' or v.name == 'Leap' or v.name == 'Move':
                    pass
                else:
                    new_acts_dict[k] = v
            return new_acts_dict
        p3 = partial(rage_actions)
        self.actions_effects.append(p3)
        def undo(ent, p, p2, p3, lockname = None):
            ent.str_effects.remove(p)
            ent.end_effects.remove(p)
            ent.psyche_effects.remove(p2)
            ent.actions_effects.remove(p3)
            d = 3
            lock(apply_damage, ent, ent, -d, 'magick', 'Rage', 'undo')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, p3)
        self.effects_dict['Rage'] = Effect(name = 'Rage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('str'))
        root.after(1999, self.finish_rage)
        
    def finish_rage(self, event = None):
        try: 
            del app.vis_dict['Rage']
            app.canvas.delete('Rage')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def molten_claws(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_molten_claws)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_molten_claws(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Molten Claws', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_molten_claws(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_molten_claws(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Molten_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Bane_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Molten Claws', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Molten Claws', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Molten_Claws'] = Vis(name = 'Molten_Claws', loc = sqr[:])
        # add effects
        def molten_attack(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'fire'
                amt -= 2
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = '+2 spirit, fire dmg, Molten Claws', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = '+2 spirit, fire dmg, Molten Claws', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, 'fire')
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(molten_attack)
        self.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'Molten_Claws'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Molten_Claws', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, self.finish_molten_claws)
        
    def finish_molten_claws(self, event = None):
        try: 
            del app.vis_dict['Molten_Claws']
            app.canvas.delete('Molten_Claws')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def bane_claws(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bane_claws)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bane_claws(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Bane Claws', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bane_claws(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bane_claws(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Bane_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Molten_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bane Claws', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bane Claws', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Bane_Claws'] = Vis(name = 'Bane_Claws', loc = sqr[:])
        # add effects
        def bane_attack(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'poison'
                def undo(lockname = None):
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo)
                def take_2(ent, lockname = None):
                    app.get_focus(ent.id)
                    lock(apply_damage, self, ent, -2, 'poison', 'Bane Poison', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                n = 'Bane_Poison' + str(app.count)
                eot = partial(take_2, dfndr)
                dfndr.effects_dict[n] = Effect(name = 'Bane_Poison', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Bane Poison, poison dmg, Bane Claws', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Bane Poison, poison dmg, Bane Claws', justify ='center', font = ('chalkduster', 13), fill = 'green3', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, 'poison')
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(bane_attack)
        self.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'Bane_Claws'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Bane_Claws', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, self.finish_bane_claws)
        
    def finish_bane_claws(self, event = None):
        try: 
            del app.vis_dict['Bane_Claws']
            app.canvas.delete('Bane_Claws')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
        
    def hurl(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_throw)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if app.ent_dict[id].immovable == True:
            return
        if app.ent_dict[id].owner != self.owner:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_throw)
        distance = self.get_abl('str')
        sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('str') and app.grid[c[0]][c[1]] == '']
        app.cleanup_squares()
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_throw)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_throw(e, id = id, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_throw(e, id, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
    
    def do_throw(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/throw.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        oldloc = app.ent_dict[id].loc[:]
        newloc = sqr[:]
        root.after(333, lambda newloc = newloc, id = id : self.finish_throw(newloc, id))
        
    def finish_throw(self, newloc, id):
        lock(app.ent_dict[id].throw_move, newloc)
        root.after(333, self.cleanup_throw)
    
    def cleanup_throw(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # TO IMPLEMENT GUARD: redirect dmg in a way that can not cause infi loops
    # either by hardcoding a check for guard(or other potential redirecting effects) OR limiting the amount of redirects OR limiting the number of 'redirect' type effects 'in play' OR changing atk/def loops...
#     def guard(self, event = None):
#         if self.attack_used == True:
#             return
#         app.unbind_nonarrows()
#         root.bind('<q>', self.cancel_attack)
#         sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
#         app.animate_squares(sqrs)
#         app.depop_context(event = None)
#         root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_guard(event = e, sqrs = sqrs, sqr = sqr)) 
#         b = tk.Button(app.context_menu, text = 'Confirm Guard', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_guard(event = e, sqrs = sqrs, sqr = sqr))
#         b.pack(side = 'top')
#         app.context_buttons.append(b)
#         
#     def do_guard(self, event = None, sqrs = None, sqr = None):
#         if sqr not in sqrs:
#             return
#         id = app.grid[sqr[0]][sqr[1]]
#         if id == '' or id == 'block':
#             return
#         if app.ent_dict[id].owner != self.owner:
#             return
#         self.attack_used = True
#         effect1 = mixer.Sound('Sound_Effects/guard.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
#         app.depop_context(event = None)
#         app.unbind_all()
#         app.cleanup_squares()
#         app.vis_dict['Guard'] = Vis(name = 'Guard', loc = sqr[:])
#         app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Guard'].img, tags = 'Guard')
#         app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Guard', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
# 
#         app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Guard', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
#         # EFFECT
#         def guard_effect(attacker, defender, amount, type, redir_obj = None):
#             if amount < 0:
#                 app.canvas.create_text(defender.loc[0]*100-app.moved_right+49, defender.loc[1]*100-app.moved_down+84, text = 'Guard Redirect', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.canvas.create_text(defender.loc[0]*100-app.moved_right+50, defender.loc[1]*100-app.moved_down+85, text = 'Guard Redirect', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.get_focus(redir_obj.number)
#                 pre = redir_obj.spirit
#                 lock(apply_damage, attacker, redir_obj, amount, type)
#                 post = redir_obj.spirit
#                 d = pre - post
#                 app.canvas.create_text(redir_obj.loc[0]*100-app.moved_right+49, redir_obj.loc[1]*100-app.moved_down+74, text = str(d)+' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.canvas.create_text(redir_obj.loc[0]*100-app.moved_right+50, redir_obj.loc[1]*100-app.moved_down+75, text = str(d)+' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                 root.after(1888, lambda t = 'guard_text' : app.canvas.delete(t))
#                 # check for guard death...
#                 if redir_obj.spirit <= 0:
#                     app.canvas.create_text(defender.loc[0]*100-app.moved_right+49, defender.loc[1]*100-app.moved_down+14, text = 'Guard Death', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                     app.canvas.create_text(defender.loc[0]*100-app.moved_right+50, defender.loc[1]*100-app.moved_down+15, text = 'Guard Death', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                     name = 'dethlok'+str(app.death_count)
#                     app.death_count += 1
#                     app.dethloks[name] = tk.IntVar(0)
#                     root.after(999, lambda id = redir_obj.number, name = name : app.kill(id, name))
#                     root.wait_variable(app.dethloks[name])
#                     defender.defense_effects.remove(guard_effect)
#                     defender.effects_dict.remove(guard_effect)
#                 return 0
#             else:
#                 return amount
#         f = partial(guard_effect, redir_obj = self)
#         app.ent_dict[id].defense_effects.append(f)
#         # give self a death trigger to remove guard from obj
#         def death_trigger(obj, f):
#             app.canvas.create_text(obj.loc[0]*100-app.moved_right+49, obj.loc[1]*100-app.moved_down+34, text = 'Guard Removed', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#             app.canvas.create_text(obj.loc[0]*100-app.moved_right+50, obj.loc[1]*100-app.moved_down+35, text = 'Guard Removed', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#             root.after(2222, lambda t = 'guard_text' : app.canvas.delete(t))
#             obj.defense_effects.remove(f)
#         dt = partial(death_trigger, app.ent_dict[id], f)
#         self.death_triggers.append(dt)
#         def un(i, f, dt):
#             self.death_triggers.remove(dt)
#             app.ent_dict[id].defense_effects.remove(f)
#             return None
#         u = partial(un, id, f, dt)
#         # EOT FUNC
#         def nothing():
#             return None
#         eot = nothing
#         n = 'Guard' + str(app.count)
#         app.ent_dict[id].effects_dict[n] = Effect(name = 'Guard', info = 'Guard, redir dmg', eot_func = eot, undo = u, duration = 3, level = 8)
#         root.after(2666, lambda e = None: self.cancel_attack(e))
        
        
    # could change leap to use variable int amount of 'uses' that can be incr/decr...
    # could also change leap to use acts?
    # currently lvl1 war can act twice AND leap...
    def leap(self, event = None):
        if self.leap_used == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.end_leap)
        sqrs = []
        for c in app.coords:
            if dist(self.loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '':
                sqrs.append(c)
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_leap(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Leap', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_leap(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_leap(self, event = None, sqrs = None, sqr = None):
        global selected
        if sqr not in sqrs:
            return
        self.leap_used = True
        self.init_leap_anims()
#         effect1 = mixer.Sound('Sound_Effects/leap.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected = [self.id]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda es = end_sqr, ss = start_sqr : self.finish_leap(es, ss)) # EXIT
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_leap(self, end_sqr, start_sqr):
        global selected
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        self.end_leap()
        
    def end_leap(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def slash(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_slash)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_slash(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_slash(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_slash(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Berserker_Slash'] = Vis(name = 'Berserker_Slash', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Berserker_Slash'].img, tags = 'Berserker_Slash')
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            my_str = self.get_abl('str')
            target_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Berserker_Slash']
#                 app.canvas.delete('Berserker_Slash')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Slash', 'melee')
            root.after(111, self.cancel_slash)
        else:
            miss(sqr)
            root.after(1999, self.cancel_slash)
        
    
    def cancel_slash(self, event = None):
        self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Berserker_Slash']
#             app.canvas.delete('Berserker_Slash')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
                    
                    
    # confuse, target must make psyche check before attack
    # fuse trap, set global effect on sqr, when effect ends all ents within range 2 take 5 dmg 
class Familiar_Homunculus(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Mesmerize':self.mesmerize, 'Fuse Trap':self.fuse_trap}
            self.str = 3
            self.agl = 6
            self.end = 3
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 3
            self.san = 11
            self.init = 9
            self.magick = 11
            self.spirit = 6
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Mesmerize':self.mesmerize, 'Fuse Trap':self.fuse_trap}
            self.str = 4
            self.agl = 7
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 10
            self.magick = 15
            self.spirit = 9
            self.acts = 1
            self.mvs = 1
            self.move_range = 7
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['magick', 'explosive']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        def familiar_trigger(lockname = None):
            if self.owner == 'p1':
                witch = app.p1_witch
            else:
                witch = app.p2_witch
            loc = app.ent_dict[witch].loc[:]
            app.focus_square(loc)
            lock(apply_damage, app.ent_dict[witch], app.ent_dict[witch], -5, 'magick', 'Familiar Death', 'dt')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(familiar_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Familiar_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
                    
                    
    def fuse_trap(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_fuse_trap)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] != 'block']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fuse_trap(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Square For Fuse Trap', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fuse_trap(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    # place in unoccupied sqr?
    def do_fuse_trap(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        visuals = [v.name for k,v in app.vis_dict.items() if v.loc == sqr]
        if 'Fuse_Trap' in visuals:
            return
        effect1 = mixer.Sound('Sound_Effects/fuse_trap.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.acts -= 1
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Fuse Trap', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        if 'Fuse_Trap' not in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            un = 'Fuse_Trap' + str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Fuse_Trap', loc = sqr[:])
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
            def undo(sqr = None, name = None, lockname = None):
                del app.vis_dict[name]
                app.canvas.delete(name)
                app.focus_square(sqr)
                effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3]
                def clean_explosion(n):
                    del app.vis_dict[n]
                    app.canvas.delete(n)
                    app.canvas.delete('text')
                def fuse_loop(ents):
                    if ents == []:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = ents[0]
                        app.get_focus(id)
                        ents = ents[1:]
                        ent = app.ent_dict[id]
                        loc = ent.loc[:]
                        n = 'Fuse_Explosion'+str(app.count)
                        app.count += 1
                        app.vis_dict[n] = Vis(name = 'Fuse_Explosion', loc = loc[:])
                        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                        lock(apply_damage, self, ent, -3, 'explosive', 'Fuse Trap', 'undo')
                        root.after(111, lambda n = n : clean_explosion(n))
                        root.after(222, lambda ents = ents : fuse_loop(ents))
                fuse_loop(ents)
            u = partial(undo, sqr = sqr[:], name = un)
            app.loc_dict[tuple(sqr[:])].effects_dict[un] = Local_Effect(name = 'Fuse_Trap', undo_func = u, duration = 1, level = 5, loc = sqr[:], avoid = 5)
        self.cleanup_fuse_trap()
                    
    def cleanup_fuse_trap(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
                    
    def mesmerize(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_mesmerize)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mesmerize(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Mesmerize', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mesmerize(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    # add mesmerize fail text
    def do_mesmerize(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,(Tomb,Witch)):
            return
        effs = [k for k in ent.effects_dict.keys()]
        if 'Mesmerize' in effs:
            return
        if self.magick < 1:
            return
        self.magick -= 1
        effect1 = mixer.Sound('Sound_Effects/mesmerize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        app.vis_dict['Mesmerize'] = Vis(name = 'Mesmerize', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mesmerize'].img, tags = 'Mesmerize')
        if to_hit(my_wis, tar_wis):
            def un(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            # SOT FUNC
            def mesmerized(tar, lockname = None):
                app.get_focus(tar)
                ent = app.ent_dict[tar]
                if app.ent_dict[tar].save_check('psyche', mod = 0) == 'Fail':
                    def mesmer_efct(stat):
                        return max(0, stat-1)
                    p = partial(mesmer_efct)
                    ent.acts_effects.append(p)
                    def undo(ent, p, lockname=None):
                        ent.acts_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    ent.effects_dict['Mesmerized'] = Effect(name = 'Mesmerized', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    my_str = ent.get_abl('str')
                    my_end = ent.get_abl('end')
                    d = damage(my_str, my_end)
                    lock(apply_damage, ent, ent, -d, 'crushing', 'Mesmerized', 'melee')
                    root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    app.canvas.create_text(app.ent_dict[tar].loc[0]*100+49-app.moved_right, app.ent_dict[tar].loc[1]*100+69-app.moved_down, text = 'Mesmerize Psyche Save', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(app.ent_dict[tar].loc[0]*100+50-app.moved_right, app.ent_dict[tar].loc[1]*100+70-app.moved_down, text = 'Mesmerize Psyche Save', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
            sot = partial(mesmerized, id)
            ent.effects_dict['Mesmerize'] = Effect(sot_func = sot, name = 'Mesmerize', undo_func = un, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = 'Mesmerized...', fill = 'black', font = ('chalkduster', 14), tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Mesmerized...', fill = 'ghostwhite', font = ('chalkduster', 14), tags = 'text')
            root.after(2333, self.cancel_mesmerize)
        else:
            miss(ent.loc)
            root.after(1999, self.cancel_mesmerize)
        
        
    def cancel_mesmerize(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Mesmerize']
            app.canvas.delete('Mesmerize')
        except: pass
                    

class Lesser_Demon(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move': self.move, 'Dire Charm':self.dire_charm, 'Baleful Stare':self.baleful_stare, 'Brambles':self.brambles}
            self.str = 4
            self.agl = 4
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 5
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.magick = 19
            self.spirit = 16
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move': self.move, 'Dire Charm':self.dire_charm, 'Baleful Stare':self.baleful_stare, 'Brambles':self.brambles}
            self.str = 6
            self.agl = 6
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 6
            self.wis = 6
            self.rsn = 5
            self.san = 13
            self.init = 9
            self.magick = 27
            self.spirit = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def brambles(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_brambles)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_brambles(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Brambles', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_brambles(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_brambles(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/brambles.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Brambles', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Brambles', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2 and v.owner != self.owner]
        def cleanup_brambles(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        def brambles_loop(ents):
            if ents == []:
                self.finish_brambles()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                s = app.ent_dict[id].loc[:]
                u = 'Brambles' + str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Brambles', loc = s)
                # ADD brambles effects
                if ent.get_move_type() == 'normal':
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = '-1 move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = '-1 move range', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    def brambles_move(move_range):
                        return max(0,move_range-1)
                    p = partial(brambles_move)
                    ent.move_range_effects.append(p)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].move_range_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    uf = partial(un, id, p)
                    n = 'Brambles' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Brambles', undo_func = uf, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Brambles', 'spell')
                    root.after(111, lambda name = u : cleanup_brambles(name))
                    root.after(222, lambda ents = ents : brambles_loop(ents))
                else:
                    root.after(1555, lambda name = u : cleanup_brambles(name))
                    root.after(1666, lambda ents = ents : brambles_loop(ents))
        root.after(666, lambda ents = ents : brambles_loop(ents))
            
            
    def finish_brambles(self, event = None):
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.exists_check(app.active_ent)

    
        
    def baleful_stare(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_baleful_stare)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_baleful_stare(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Baleful Stare', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_baleful_stare(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_baleful_stare(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        efs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Baleful_Stare' in efs:
            return
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = ent.loc[:]
        app.vis_dict['Baleful_Stare'] = Vis(name = 'Baleful_Stare', loc = visloc)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Baleful Stare', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Baleful Stare', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        if to_hit(self.get_abl('wis'), ent.get_abl('wis')) == True:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+74-app.moved_down, text = '-1 psyche, eot 2 acid dmg', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+75-app.moved_down, text = '-1 psyche, eot 2 acid dmg', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            # baleful effect
            def baleful_stare_effect(stat):
                return max(1,stat-2)
            p = partial(baleful_stare_effect)
            ent.end_effects.append(p)
            def un(ent, p, lockname = None):
                ent.end_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, ent, p)
            # EOT FUNC
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -2, 'acid', 'Baleful Stare', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            n = 'Baleful_Stare' + str(app.count)
            eot = partial(take_2, id)
            ent.effects_dict[n] = Effect(name = 'Baleful_Stare', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(ent.loc)
        root.after(2666, lambda e = None : self.finish_baleful_stare(event = e))
        
    def finish_baleful_stare(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Baleful_Stare']
            app.canvas.delete('Baleful_Stare')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
    def dire_charm(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_dire_charm)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_dire_charm(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Dire Charm', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_dire_charm(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dire_charm(self, event = None, sqrs = None):
        if self.magick < 6:
            return
        self.magick -= 6
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/dire_charm.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        app.vis_dict['Dire_Charm'] = Vis(name = 'Dire_Charm', loc = self.loc[:])
        def cleanup_charm(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def dire_charm_loop(ents):
            app.canvas.delete('text')
            if ents == []:
                self.finish_dire_charm()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = app.ent_dict[id].loc[:]
                app.focus_square(s)
                uniq = 'Dire_Charm'+str(app.count)
                app.count += 1
                app.vis_dict[uniq] = Vis(name = 'Dire_Charmed', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Dire_Charm')
                if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
                    d = damage(ent.get_abl('str'), ent.get_abl('end'))
                    root.after(1555, lambda n = uniq : cleanup_charm(n))
                    lock(apply_damage, ent, ent, -d, 'crushing', 'Dire Charmed', 'melee')
                    root.after(111, lambda ents = ents : dire_charm_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda n = uniq : cleanup_charm(n))
                    root.after(1666, lambda ents = ents : dire_charm_loop(ents))
        dire_charm_loop(ents)
            
            
    def finish_dire_charm(self, event = None):
        try:
            del app.vis_dict['Dire_Charm']
            app.canvas.delete('Dire_Charm')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.exists_check(app.active_ent)



class Cenobite(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move': self.move, 'Strength Through Wounding':self.strength_through_wounding, 'Flesh Hooks': self.flesh_hooks, 'Hellfire': self.hellfire}
            self.str = 5
            self.agl = 5
            self.end = 8
            self.mm = 9
            self.msl = 5
            self.bls = 6
            self.dodge = 4
            self.psyche = 8
            self.wis = 9
            self.rsn = 5
            self.san = 15
            self.init = 6
            self.spirit = 16
            self.magick = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move': self.move, 'Strength Through Wounding':self.strength_through_wounding, 'Flesh Hooks': self.flesh_hooks, 'Hellfire': self.hellfire}
            self.str = 6
            self.agl = 6
            self.end = 9
            self.mm = 10
            self.msl = 6
            self.bls = 6
            self.dodge = 5
            self.psyche = 9
            self.wis = 9
            self.rsn = 5
            self.san = 16
            self.init = 7
            self.spirit = 19
            self.magick = 21
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['acid']
        self.resist = ['piercing','slashing','crushing']
        super().__init__(name, id, img, loc, owner)
        
    # all w/i rang3 take 2 piercing, friendly get +1 end, +1 psy for 2 turns
    def strength_through_wounding(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_strength_through_wounding)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_strength_through_wounding(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Strength Through Wounding', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_strength_through_wounding(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_strength_through_wounding(self, event = None, sqrs = None):
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs]
        def cleanup_stw(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def stw_loop(ents):
            if ents == []:
                self.finish_strength_through_wounding()
            else:
                id = ents[0]
                app.get_focus(id)
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Strength_Through_Wounding' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Strength_Through_Wounding', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_stw(u))
                lock(apply_damage, self, ent, -2, 'piercing', 'Strength Through Wounding', 'ranged')
                # give stat bonus if friendly and not dead
                if id in app.all_ents().keys() and ent.owner == self.owner and 'Strength_Through_Wounding' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '+1 End, Psy', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '+1 End, Psy', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    def strength_through_wounding_effect(stat):
                        return stat+1
                    f = strength_through_wounding_effect
                    ent.end_effects.append(f)
                    ent.psyche_effects.append(f)
                    n = 'Strength_Through_Wounding' + str(app.count)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].end_effects.remove(func)
                        app.ent_dict[i].psyche_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    p = partial(un, id, f)
                    n = 'Strength_Through_Wounding' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Strength_Through_Wounding', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : stw_loop(ents))
                else:
                    root.after(111, lambda ents = ents : stw_loop(ents))
        stw_loop(ents)
        
    def finish_strength_through_wounding(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.exists_check(app.active_ent)

        
    # give ranged attack to friendly ent
    def flesh_hooks(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_flesh_hooks)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_flesh_hooks(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Bestow Flesh Hooks', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_flesh_hooks(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_flesh_hooks(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        if app.ent_dict[id].owner != self.owner:
            return
        if 'Hook Attack' in app.ent_dict[id].get_actions().keys():
            return
        if self.magick < 4:
            return
        self.magick -= 4
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flesh_hooks.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Flesh_Hooks'] = Vis(name = 'Flesh_Hooks', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Flesh_Hooks'].img, tags = 'Flesh_Hooks')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Flesh Hooks', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Flesh Hooks', justify = 'center', fill = 'gainsboro', font = ('chalkduster', 14), tags = 'text')
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Hook Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Hook Attack', justify = 'center', fill = 'gainsboro', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def hook_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) <= obj.get_abl('rsn')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Hook Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Hook_Attack'] = Vis(name = 'Hook_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Hook_Attack'].img, tags = 'Hook_Attack')
                my_wis = obj.get_abl('wis')
                target_dodge = app.ent_dict[id].get_abl('dodge')
                if to_hit(my_wis, target_dodge) == True:
                    my_psy = obj.get_abl('psyche')
                    target_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_psy, target_end)
                    lock(apply_damage, obj, app.ent_dict[id], -d, 'piercing', 'Hook Attack', 'ranged')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Hook_Attack']
                    app.canvas.delete('Hook_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(hook_attack, obj = app.ent_dict[id])
        def add_hook_attack(actions = None, func = None):
            actions['Hook Attack'] = func
            return actions
        p2 = partial(add_hook_attack, func = p)
        app.ent_dict[id].action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Hook_Attack' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Hook_Attack', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_flesh_hooks)
        
    def finish_flesh_hooks(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Flesh_Hooks']
            app.canvas.delete('Flesh_Hooks')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
    # damage and possible burn to target
    # vis, self 'glows', target flames
    def hellfire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_hellfire)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hellfire(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Hellfire', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hellfire(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hellfire(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/beleths_command.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Hellfire'] = Vis(name = 'Hellfire', loc = visloc)
        def cleanup_hellfire():
            app.canvas.delete('Hellfire')
            del app.vis_dict['Hellfire']
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(1555, cleanup_hellfire)
            lock(apply_damage, self, ent, -d, 'fire', 'Hellfire', 'spell')
            if id in app.all_ents().keys() and ent.save_check('end', mod = -5) == 'Fail' and 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Burned', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Burned', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
            # burn effect, every time burned ent takes spirit dmg it takes that much dmg plus 2
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and st != 'eot' and st != 'sot' and st != 'undo':
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount,type)
                p = partial(burn_effect)
                ent.defense_effects.append(p)
                def undo(i, func, lockname = None):
                    app.ent_dict[i].defense_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, id, p)
                n = 'Burn' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(999, lambda e = None : self.cancel_hellfire(event = e))
            else:
                root.after(111, lambda e = None : self.cancel_hellfire(event = e))
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cancel_hellfire(event = e))
        
    def cancel_hellfire(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Hellfire']
            app.canvas.delete('Hellfire')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)

        
        
class Familiar_Imp(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Poison Sting':self.poison_sting, 'Darkness':self.darkness, 'Flying Move':self.move}
            self.str = 2
            self.agl = 6
            self.end = 3
            self.mm = 6
            self.msl = 3
            self.bls = 6
            self.dodge = 7
            self.psyche = 4
            self.wis = 6
            self.rsn = 4
            self.san = 12
            self.init = 7
            self.magick = 13
            self.spirit = 5
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Poison Sting':self.poison_sting, 'Darkness':self.darkness, 'Flying Move':self.move}
            self.str = 3
            self.agl = 7
            self.end = 4
            self.mm = 7
            self.msl = 4
            self.bls = 7
            self.dodge = 8
            self.psyche = 5
            self.wis = 7
            self.rsn = 5
            self.san = 13
            self.init = 9
            self.magick = 19
            self.spirit = 8
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
        self.move_type = 'flying'
        self.weak = []
        self.resist = ['magick']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        def familiar_trigger(lockname = None):
            if self.owner == 'p1':
                witch = app.p1_witch
            else:
                witch = app.p2_witch
            loc = app.ent_dict[witch].loc[:]
            app.focus_square(loc)
            lock(apply_damage, app.ent_dict[witch], app.ent_dict[witch], -5, 'magick', 'Familiar Death', 'dt')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(familiar_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Familiar_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
        
        
    def darkness(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Darkness' in g_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_attack)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_darkness(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Darkness', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_darkness(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_darkness(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/darkness.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Darkness', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Darkness', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        # create vis on every sqr within distance 3 from sqr
        affected_sqrs = [c for c in app.coords if dist(c, sqr) <= 1 and app.grid[c[0]][c[1]] != 'block']
        for s in affected_sqrs:
            if 'Darkness' not in [v.name for k,v in app.loc_dict[tuple(s)].effects_dict.items()]:
                un = 'Darkness' + str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Darkness', loc = s[:])
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                def dark_move(move_range, sqr = None):
                    id =  app.grid[sqr[0]][sqr[1]]
                    if id in app.all_ents().keys():
                        ent = app.ent_dict[id]
                        if (ent.get_move_type() == 'normal' or ent.get_move_type() == 'flying') and ent.immovable == False:
                            return max(0, move_range-2)
                        else:
                            return move_range
                    else:
                        return move_range
                p = partial(dark_move, sqr = s)
                app.loc_dict[tuple(s)].move_range_effects.append(p)
                def undo(s, un, p_dark_move, lockname = None):
                    app.loc_dict[tuple(s)].move_range_effects.remove(p_dark_move)
                    del app.vis_dict[un]
                    app.canvas.delete(un)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, s, un, p)
                app.loc_dict[tuple(s)].effects_dict[un] = Local_Effect(name = 'Darkness', undo_func = u, duration = 2, level = self.get_abl('wis'), loc = s[:], avoid = 6)
        self.cleanup_darkness()
        
    def cleanup_darkness(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def poison_sting(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_attack)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_poison_sting(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Poison Sting', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_poison_sting(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_poison_sting(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/poison_sting.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Poison_Sting'] = Vis(name = 'Poison_Sting', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Poison_Sting'].img, tags = 'Poison_Sting')
        ent = app.ent_dict[id]
        my_mm = self.get_abl('mm')
        target_dodge = ent.get_abl('dodge')
        if to_hit(my_mm, target_dodge) == True:
            def poison_sting_effect(stat):
                return max(1,stat-1)
            f = poison_sting_effect
            ent.str_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].str_effects.remove(poison_sting_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            # EOT FUNC
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -1, 'poison', 'Poison Sting', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, id)
            n = 'Poison_Sting' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Poison_Sting', eot_func = eot, undo_func = p, duration = self.get_abl('msl'), level = self.get_abl('bls'))
            my_msl = self.get_abl('msl')
            tar_end = ent.get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, ent, -d, 'poison', 'Poison Sting', 'ranged')
            root.after(111, lambda e = None : self.cancel_attack(event = e))
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cancel_attack(event = e))
        
    def cancel_attack(self, event):
        self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Poison_Sting']
            app.canvas.delete('Poison_Sting')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)

# atk agl v agl psy v psy mgk melee, on hit witch discard at rndm
class Hypnotic_Spectre(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        self.str = 4
        self.agl = 9
        self.end = 5
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 8
        self.wis = 6
        self.rsn = 2
        self.san = 9
        self.init = 8
        self.spirit = 13
        self.magick = 0
        self.acts = 1
        self.mvs = 1
        self.move_range = 5
        self.move_type = 'flying'
        self.attack_range = 4 # this attr is for player-owned, computer-controlled summons
        self.resist = []
        self.weak = ['fire', 'elec']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['animal', 'undead']
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            # move hawk to sqr w/i moverange that is w/i attackrange(5) and maximally distant from all enemies and then atk
            # if no enemies w/i attack range, move to a random sqr w/i move range
            els = [v.loc for k,v in app.action_target_ents().items() if v.owner != self.owner]
            sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                if moves == [] and els == []:
                    # cannot move at all, attempt attack wo moving
                    ents = [v for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
                    if ents == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        x = [e for e in ents if isinstance(e,Witch)]
                        if x:
                            ent = choice(x)
                        else:
                            ent = choice(ents)
                        id = choice(ent.id)
                        app.get_focus(id)
                        root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                else:
                    el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                    move = reduce(lambda a,b : a if dist(a,el)<dist(b,el) else b, moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.hawk_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.hawk_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Hawk", eot_func = e, undo_func = u, duration = 666, level = 666)
                

    def hawk_attack(self, id, lockname):
        ent = app.ent_dict[id]
        old_loc = ent.loc[:]
        origin = self.loc[:]
        lock(Bot.ai_flying_move, self, ent.loc[:])
        lock(Bot.ai_flying_move, self, origin)
        ent.loc = old_loc
        app.grid[old_loc[0]][old_loc[1]] = ent.id
#         ent = app.ent_dict[id]
#         app.vis_dict['Hawk_Attack'] = Vis(name = 'Hawk_Attack', loc = ent.loc[:])
#         app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Hawk_Attack'].img, tags = 'Hawk_Attack')
#         def cleanup_hawk_attack():
#             app.canvas.delete('Hawk_Attack')
#             del app.vis_dict['Hawk_Attack']
#         root.after(1666, cleanup_hawk_attack)
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            # if witch, discard at random
            if isinstance(ent, Witch):
                if ent.in_hand != []:
                    card = choice(ent.in_hand[:])
                    ent.discard.append(card)
                    ent.in_hand.remove(card)
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Discard '+str(card).replace('_',' '), font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Discard '+str(card).replace('_',' '), font = ('chalkduster', 14), fill = 'gray', tags = 'text')
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            lock(apply_damage, self, ent, -d, 'magick', 'Spectre Attack', 'melee')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(app.ent_dict[id].loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def hawk_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_move( end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(66, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)

    def finish_move(self, end, start, lockname):
#         sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
        self.mvs -= 1
        # if enemy w/i range: atk else done
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
        if ents == []:
            root.after(1999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))


class Barrow_Wight(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        self.str = 8
        self.agl = 8
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 5
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.san = 12
        self.init = 9
        self.spirit = 13
        self.magick = 0
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.move_type = 'normal'
        self.attack_range = 1 # this attr is for player-owned, computer-controlled summons
        self.resist = ['magick']
        self.weak = ['fire']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal', 'undead']
        self.inert = True
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect, each call increases duration
            tombs = [v for k,v in app.action_target_ents().items() if v.owner != self.owner and isinstance(v, Tomb)]
            if tombs == []:# no tombs
                root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                goals = unique([c for c in app.coords for t in tombs if dist(c,t.loc)==1 and app.grid[c[0]][c[1]]==''])
                moves = self.legal_moves()
                adj = [v for v in tombs if dist(v.loc,self.loc)==1]
                if adj == []:
                    if moves == []:# CANNOT MOVE, NONE ADJ
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        goal = reduce(lambda a,b : a if dist(a,self.loc) < dist(b,self.loc) else b,goals)
                        move = reduce(lambda a,b : a if dist(a,goal) < dist(b,goal) else b,moves)
                        app.focus_square(move)
                        root.after(666, lambda m = move, ln = lockname : self.hawk_move(m, ln))
                else:#ATK ADJ
                    id = choice(adj)
                    app.get_focus(id.id)
                    root.after(666, lambda id = id.id, ln = lockname : self.hawk_attack(id, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Wight", eot_func = e, undo_func = u, duration = 666, level = 666)
                
    def hawk_attack(self, id, lockname):
        ent = app.ent_dict[id]
        app.vis_dict['Wight_Attack'] = Vis(name = 'Wight_Attack', loc = ent.loc[:])
        def cleanup_hawk_attack():
            app.canvas.delete('Wight_Attack')
            del app.vis_dict['Wight_Attack']
        root.after(1666, cleanup_hawk_attack)
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Wight Attack', 'spell')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def hawk_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_move( end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(66, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)

    def finish_move(self, end, start, lockname):
#         sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
        self.mvs -= 1
        # if enemy w/i range: atk else done
        ents = [k for k,v in app.action_target_ents().items() if 1 <= dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner and isinstance(v,Tomb)]
        if ents == []:
            root.after(1999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                    
                    
class Deaths_Head_Moth(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        self.str = 1
        self.agl = 12
        self.end = 1
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 12
        self.psyche = 4
        self.wis = 4
        self.rsn = 5
        self.san = 10
        self.init = 9
        self.spirit = 5
        self.magick = 0
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.move_type = 'flying'
        self.attack_range = 4
        self.resist = ['magick', 'poison']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['animal']
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            # move hawk to sqr w/i moverange that is w/i attackrange(5) and maximally distant from all enemies and then atk
            # if no enemies w/i attack range, move to a random sqr w/i move range
            els = [v.loc for k,v in app.action_target_ents().items() if v.owner != self.owner and v.get_inert()==False]
            sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                # move to rand sqr in moves
                if moves == [] and els == []:
                    # cannot move at all, attempt attack wo moving
                    ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner and v.get_inert()==False]
                    if ents == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = choice(ents)
                        app.get_focus(id)
                        root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                else:# none in range, can move, seek towards a goal
                    el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                    move = reduce(lambda a,b : a if dist(a,el)<dist(b,el) else b, moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.hawk_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.hawk_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Moth", eot_func = e, undo_func = u, duration = 666, level = 666)
                
    def hawk_attack(self, id, lockname):
        ent = app.ent_dict[id]
        old_loc = ent.loc[:]
        origin = self.loc[:]
        lock(Bot.ai_flying_move, self, ent.loc[:])
        lock(Bot.ai_flying_move, self, origin)
        ent.loc = old_loc
        app.grid[old_loc[0]][old_loc[1]] = ent.id
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            # add eot psn efct
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Moth Poison', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Moth Poison', font = ('chalkduster', 14), fill = 'green', tags = 'text')
            def undo(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo)
            def take_2(ent, lockname = None):
                app.get_focus(ent.id)
                lock(apply_damage, self, ent, -2, 'poison', 'Moth Poison', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            n = 'Moth_Poison' + str(app.count)
            eot = partial(take_2, ent)
            ent.effects_dict[n] = Effect(name = 'Moth_Poison', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            lock(apply_damage, self, ent, -d, 'magick', 'Moth Dust', 'melee')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def hawk_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_move( end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(66, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)

    def finish_move(self, end, start, lockname):
#         sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
        self.mvs -= 1
        # if enemy w/i range: atk else done
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
        if ents == []:
            root.after(1999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                    
                    
                    
class Hunting_Hawk(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        self.str = 2
        self.agl = 8
        self.end = 2
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 3
        self.wis = 4
        self.rsn = 3
        self.san = 15
        self.init = 9
        self.spirit = 9
        self.magick = 0
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.move_type = 'flying'
        self.attack_range = 4
        self.resist = ['magick', 'fire', 'elec', 'cold', 'poison', 'acid']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['animal']
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            # move hawk to sqr w/i moverange that is w/i attackrange(5) and maximally distant from all enemies and then atk
            # if no enemies w/i attack range, move to a random sqr w/i move range
            els = [v.loc for k,v in app.action_target_ents().items() if v.owner != self.owner]
            sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                # move to rand sqr in moves
                if moves == [] and els == []:
                    # cannot move at all, attempt attack wo moving
                    ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
                    if ents == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = choice(ents)
                        app.get_focus(id)
                        root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                else:
                    el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                    move = reduce(lambda a,b : a if dist(a,el)<dist(b,el) else b, moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.hawk_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.hawk_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Hawk", eot_func = e, undo_func = u, duration = 666, level = 666)
                
    def hawk_attack(self, id, lockname):
        ent = app.ent_dict[id]
        old_loc = ent.loc[:]
        origin = self.loc[:]
        lock(Bot.ai_flying_move, self, ent.loc[:])
        lock(Bot.ai_flying_move, self, origin)
        ent.loc = old_loc
        app.grid[old_loc[0]][old_loc[1]] = ent.id
#         ent = app.ent_dict[id]
#         app.vis_dict['Hawk_Attack'] = Vis(name = 'Hawk_Attack', loc = ent.loc[:])
#         app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Hawk_Attack'].img, tags = 'Hawk_Attack')
#         def cleanup_hawk_attack():
#             app.canvas.delete('Hawk_Attack')
#             del app.vis_dict['Hawk_Attack']
#         root.after(1666, cleanup_hawk_attack)
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Hawk Attack', 'melee')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(app.ent_dict[id].loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def hawk_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_move( end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(66, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)

    def finish_move(self, end, start, lockname):
#         sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
        self.mvs -= 1
        # if enemy w/i range: atk else done
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
        if ents == []:
            root.after(1999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
    
        
class Wall_of_Blossoms(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 1
            self.agl = 1
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 1
            self.wis = 1
            self.rsn = 1
            self.san = 30
            self.init = 1
            self.spirit = 7
            self.magick = 0
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
        elif level == 2:
            self.str = 1
            self.agl = 1
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 1
            self.wis = 1
            self.rsn = 1
            self.san = 30
            self.init = 1
            self.spirit = 6
            self.magick = 0
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = []
        self.weak = ['fire']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['nonsentient']
        
        
class Voodoo_Doll(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 1
            self.agl = 1
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 5
            self.wis = 1
            self.rsn = 1
            self.san = 19
            self.init = 1
            self.spirit = 6
            self.magick = 0
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
        elif level == 2:
            self.str = 1
            self.agl = 1
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 5
            self.wis = 1
            self.rsn = 1
            self.san = 19
            self.init = 1
            self.spirit = 6
            self.magick = 0
            self.acts = 0
            self.mvs = 0
            self.move_range = 0
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = []
        self.weak = ['piercing']
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['nonsentient']
        def voodoo_curse(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                ents = [v for k,v in app.all_ents().items() if v.name in app.summons_list]
                for e in ents:
                    lock(apply_damage, atkr, e, -amt, 'magick', 'Voodoo Curse', 'redirect')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(voodoo_curse)
        self.defense_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'vcurse' + str(app.count)
        def eot(key, obj, lockname = None):
            obj.effects_dict[key].duration += 1
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot_f = partial(eot, n, self)
        self.effects_dict[n] = Effect(name = 'Voodoo_Curse', undo_func = u, eot_func = eot_f, duration = 666, level = 666)
        
        
class Bottle_Gnome(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 1
            self.agl = 3
            self.end = 1
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 3
            self.wis = 1
            self.rsn = 1
            self.san = 25
            self.init = 3
            self.spirit = 1
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.str = 1
            self.agl = 3
            self.end = 1
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 3
            self.wis = 1
            self.rsn = 1
            self.san = 25
            self.init = 3
            self.spirit = 1
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['slashing', 'crushing', 'piercing']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        self.inert = True
        
        def explode_trigger(lockname = None):
            app.focus_square(self.loc)
            ents = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1 and v.owner == self.owner]
            amt = self.get_abl('psyche')
            def cleanup_gnomes(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            for ent in ents:
                n = 'gnomes'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Legerdemain', loc = ent.loc)
                root.after(1666, lambda n = n : cleanup_gnomes(n))
                ent.magick += amt
                if isinstance(ent,Witch):
                    pass
                elif ent.magick > ent.base_magick:
                    ent.magick = ent.base_magick
                apply_heal(self, ent, amt)
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '+'+str(amt)+' spirit,magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '+'+str(amt)+' spirit,magick', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(explode_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Gnome_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
        
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            els = [v.loc for k,v in app.all_ents().items() if v.owner == self.owner and v.get_inert()==False]
            sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                # move to rand sqr in moves
                if moves == []:
                    root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    move = choice(moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.gnome_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.gnome_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Bottle Gnome", eot_func = e, undo_func = u, duration = 666, level = 666)
        
    def gnome_move(self, endloc, lockname):
        global selected
        effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        selected = [self.id]
        id = self.id
        start_sqr = self.loc[:]
        path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.gnome_finish_move(endloc, start_sqr, lockname)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
# 
    def gnome_finish_move(self, end_sqr, start_sqr, lockname):
        global selected
        sound_effects.stop()
        self.mvs -= 1
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
        
class Pyrrhic_Gnome(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 1
            self.agl = 3
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 1
            self.wis = 1
            self.rsn = 1
            self.san = 25
            self.init = 3
            self.spirit = 7
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.str = 1
            self.agl = 3
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 1
            self.wis = 1
            self.rsn = 1
            self.san = 25
            self.init = 3
            self.spirit = 7
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.tick = 1
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['slashing', 'crushing', 'piercing']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.inert = True
        self.types = ['animal']
        
        def explode_trigger(lockname = None):
            app.focus_square(self.loc)
            ents = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1]
            d = self.tick*3
            def cleanup_gnomes(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            for ent in ents:
                n = 'gnomes'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Pain_Explode', loc = ent.loc)
                root.after(1666, lambda n = n : cleanup_gnomes(n))
                lock(apply_damage, self, ent, -d, 'explosive', 'Pyrrhic Gnome', 'ranged')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(explode_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Gnome_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
        
        def eot(lockname = None):
            self.tick += 1
            self.effects_dict['control'].duration += 1 # permanent effect
            els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner and v.get_inert()==False]
            goals = unique([c for c in app.coords for el in els if dist(el,c)==1 and app.grid[c[0]][c[1]]==''])
            moves = self.legal_moves()
            gs = intersect(goals, moves)
            if gs == []:
                if els == []:
                    root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    # get closest el and if moves exist, reduce to move that is closest to closest el
                    if moves == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        # at this point, no goals in legal moves, some els and moves exist, not ncsrly goals
                        if goals == []:
                            # no goals, just move to loc that minimizes dist to closest el
                            el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                            move = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, moves)
                            app.focus_square(move)
                            root.after(222, lambda m = move, ln = lockname : self.gnome_move(m, ln))
                        else:
                            # goals exist but not ncsrly path
                            # try path to all goals, if None returned by bfs() just do same as above (move closest to closest)
                            if path := bfs(self.loc, goals, app.grid[:]):
                                moves = intersect(path, moves)
                                move = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, moves)
                                app.focus_square(move)
                                root.after(222, lambda m = move, ln = lockname : self.gnome_move(m, ln))
                            else:
                                el = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, els)
                                move = reduce(lambda a,b : a if dist(a,el)<dist(b,el) else b, moves)
                                app.focus_square(move)
                                root.after(222, lambda m = move, ln = lockname : self.gnome_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.gnome_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Pyrrhic Gnome", eot_func = e, undo_func = u, duration = 666, level = 666)
        
    def gnome_move(self, endloc, lockname):
        global selected
        effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, -1)
        selected = [self.id]
        id = self.id
        start_sqr = self.loc[:]
        path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.gnome_finish_move(endloc, start_sqr, lockname)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
# 
    def gnome_finish_move(self, end_sqr, start_sqr, lockname):
        global selected
        sound_effects.stop()
        self.mvs -= 1
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        adj = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1 and v.owner!=self.owner]
        chance = 20*len(adj)
        if randrange(0,101)< chance:
            lock(app.kill, self.id)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            root.after(222, lambda ln = lockname : app.dethloks[ln].set(1))
        
        
class Carrion_Wyrm(Summon):
    def __init__(self, name, id, img, loc, owner, level, j = 0):
        self.actions = {'Move':self.move, 'Bite':self.bite}
        self.level = level
        if level == 1:
            self.str = 1 + j
            self.agl = 1 + j
            self.end = 1 + j
            self.mm = 1 + j
            self.msl = 1 + j
            self.bls = 1 + j
            self.dodge = 1 + j
            self.psyche = 1 + j
            self.wis = 1 + j
            self.rsn = 1 + j
            self.san = 13
            self.init = 1 + j
            self.spirit = (j+1)*3
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        elif level == 2:
            self.str = 1 + j
            self.agl = 1 + j
            self.end = 1 + j
            self.mm = 1 + j
            self.msl = 1 + j
            self.bls = 1 + j
            self.dodge = 1 + j
            self.psyche = 1 + j
            self.wis = 1 + j
            self.rsn = 1 + j
            self.san = 13
            self.init = 1 + j
            self.spirit = (j+1)*3
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['poison','acid']
        self.weak = ['fire']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal', 'undead']
        
        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
        
class Wyld_Boar(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {'Move':self.move, 'Charge':self.charge}
        self.level = level
        if level == 1:
            self.str = 7
            self.agl = 7
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 11
            self.init = 8
            self.spirit = 19
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.str = 7
            self.agl = 7
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 11
            self.init = 8
            self.spirit = 19
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'charge'
        self.attack_range = 1
        self.resist = ['slashing','piercing','crushing']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        
    def charge(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_charge)
        sqrs = lateral_sqrs(self.loc[:], 1)
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_charge(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Choose Direction', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_charge(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)

    def do_charge(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if self.loc[0] < sqr[0]:
            dir = 'east'
        elif self.loc[1] < sqr[1]:
            dir = 'south'
        elif self.loc[0] > sqr[0]:
            dir = 'west'
        elif self.loc[1] > sqr[1]:
            dir = 'north'
        path = lateral_sqrs(self.loc, self.get_abl('move_range'), blocked='ents', dir=dir)
        if path == []:
            return
        else:
            last = path[-1]
        self.acts -= 1
#                 obj.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        lock(Bot.ai_normal_move, self, last)
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1]
        def charge_loop(ents):
            if ents == []:
                self.cancel_charge()
            else:
                ent = ents[0]
                ents = ents[1:]
                app.vis_dict['Lacerate'] = Vis(name = 'Lacerate', loc = ent.loc[:])
                my_agl = self.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl) == True:
                    my_str = self.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    lock(apply_damage, self, ent, -d, 'slashing', 'Charge', 'melee')
                    charge_loop(ents)
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ents = ents : charge_loop(ents))
        app.get_focus(self.id)
        charge_loop(ents)
        
        
    def cancel_charge(self, event = None):
        app.rebind_all()
        app.canvas.delete('text')
        try:
            del app.vis_dict['Lacerate']
            app.canvas.delete('Lacerate')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.exists_check(app.active_ent)
        
        
class Wyld_Eagle(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {'Move':self.move, 'Dive':self.dive}
        self.level = level
        if level == 1:
            self.str = 3
            self.agl = 9
            self.end = 5
            self.mm = 9
            self.msl = 5
            self.bls = 4
            self.dodge = 9
            self.psyche = 3
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.spirit = 15
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.str = 3
            self.agl = 9
            self.end = 5
            self.mm = 9
            self.msl = 5
            self.bls = 4
            self.dodge = 9
            self.psyche = 3
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.spirit = 15
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'flying'
        self.resist = ['cold']
        self.weak = ['elec']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        
        
    def dive(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_dive)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_dive(e, sqr, sqrs))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Choose Target for Dive', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs: self.do_dive(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dive(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/umbrae_strike.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ent = app.ent_dict[id]
        old_loc = ent.loc[:]
        origin = self.loc[:]
        lock(Bot.ai_flying_move, self, ent.loc[:])
        lock(Bot.ai_flying_move, self, origin)
        ent.loc = old_loc
        app.grid[old_loc[0]][old_loc[1]] = ent.id
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'piercing', 'Dive', 'ranged')
            self.finish_dive()
        else: # miss
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.finish_dive)
            
    def finish_dive(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
        
class Wyld_Wolf(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {'Move':self.move, 'Bite':self.bite}
        self.level = level
        if level == 1:
            self.str = 6
            self.agl = 7
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 5
            self.rsn = 5
            self.san = 11
            self.init = 9
            self.spirit = 17
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.str = 6
            self.agl = 7
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 5
            self.rsn = 5
            self.san = 11
            self.init = 9
            self.spirit = 17
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['fire','cold','elec','poison','acid']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal']
        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.exists_check(app.active_ent)
        
class Cadaver(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 3
            self.agl = 3
            self.end = 5
            self.mm = 4
            self.msl = 2
            self.bls = 3
            self.dodge = 3
            self.psyche = 2
            self.wis = 2
            self.rsn = 2
            self.san = 10
            self.init = 3
            self.spirit = 13
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
        elif level == 2:
            self.str = 4
            self.agl = 4
            self.end = 5
            self.mm = 5
            self.msl = 3
            self.bls = 4
            self.dodge = 3
            self.psyche = 3
            self.wis = 3
            self.rsn = 2
            self.san = 9
            self.init = 3
            self.spirit = 15
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['elec', 'cold', 'poison', 'acid', 'slashing', 'crushing', 'piercing', 'magick']
        self.weak = ['fire']
        super().__init__(name, id, img, loc, owner)
        self.types = ['animal', 'undead']
#         def eot(lockname = None):
#             self.effects_dict['control'].duration += 1 # permanent effect
#             els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
#             sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
#             moves = self.legal_moves()
#             gs = intersect(sqrs, moves)
#             if gs == []:
#                 # move to rand sqr in moves
#                 if moves == []:
#                     # cannot move at all, attempt attack wo moving
#                     ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
#                     if ents == []:
#                         root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
#                     else:
#                         id = choice(ents)
#                         app.get_focus(self.id)
#                         root.after(666, lambda id = id, ln = lockname : self.cadaver_attack(id, ln))
#                 else:
#                     move = choice(moves)
#                     app.focus_square(move)
#                     root.after(666, lambda m = move, ln = lockname : self.cadaver_move(m, ln))
#             else:
#                 g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
#                 app.focus_square(g)
#                 root.after(666, lambda sqr = g[:], ln = lockname : self.cadaver_move(sqr, ln))
#         e = partial(eot)
#         def undo(lockname = None):
#             root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
#         u = partial(undo)
#         self.effects_dict['control'] = Effect(name = self.owner+"'s Cadaver", eot_func = e, undo_func = u, duration = 666, level = 666)
#                 
#     def cadaver_attack(self, id, lockname):
#         my_agl = self.get_abl('agl')
#         tar_agl = app.ent_dict[id].get_abl('agl')
#         if to_hit(my_agl, tar_agl):
#             my_str = self.get_abl('str')
#             tar_end = app.ent_dict[id].get_abl('end')
#             d = damage(my_str, tar_end)
#             lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Cadaver Mob', 'melee')
#             root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
#         else: # miss
#             miss(app.ent_dict[id].loc)
#             root.after(1555, lambda t = 'text' : app.canvas.delete(t))
#             root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
# 
#     def cadaver_move(self, endloc, lockname):
#         global selected
#         effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, -1)
#         selected = [self.id]
#         id = self.id
#         start_sqr = self.loc[:]
#         path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
#         begin = path[0]
#         end = path[1]
#         x = begin[0]*100+50-app.moved_right
#         y = begin[1]*100+50-app.moved_down
#         endx = end[0]*100+50-app.moved_right
#         endy = end[1]*100+50-app.moved_down
#         def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
#             if x % 20 == 0 or y % 20 == 0:
#                 self.rotate_image()
#                 app.canvas.delete(id)
#                 app.canvas.create_image(x, y, image = self.img, tags = self.tags)
#             if x > endx:
#                 x -= 10
#                 app.canvas.move(id, -10, 0)
#             elif x < endx: 
#                 x += 10
#                 app.canvas.move(id, 10, 0)
#             if y > endy: 
#                 y -= 10
#                 app.canvas.move(id, 0, -10)
#             elif y < endy: 
#                 y += 10
#                 app.canvas.move(id, 0, 10)
#             try: app.canvas.tag_lower((self.tags), 'large')
#             except: pass
#             app.canvas.tag_lower((self.tags), 'maptop')
#             app.canvas.tag_raise('cursor')
#             if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
#                 self.cadaver_finish_move(endloc, start_sqr, lockname)
#             elif x == endx and y == endy: # END PORTION OF PATH
#                 path = path[1:]
#                 begin = path[0]
#                 end = path[1]
#                 x = begin[0]*100+50-app.moved_right
#                 y = begin[1]*100+50-app.moved_down
#                 endx = end[0]*100+50-app.moved_right
#                 endy = end[1]*100+50-app.moved_down
#                 move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
#             else: # CONTINUE LOOP
#                 root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
#         move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
# # 
#     def cadaver_finish_move(self, end_sqr, start_sqr, lockname):
#         global selected
#         sound_effects.stop()
#         self.mvs -= 1
#         selected = []
#         self.loc = end_sqr[:]
#         app.grid[start_sqr[0]][start_sqr[1]] = ''
#         app.grid[end_sqr[0]][end_sqr[1]] = self.id
#         ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
#         if ents == []:
#             root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
#         else:
#             id = choice(ents)
#             app.get_focus(id)
#             root.after(666, lambda id = id, ln = lockname : self.cadaver_attack(id, ln))
                    
                    
class Witch(Summon):
    def __init__(self, name, img, loc, owner, level, entomb_deck):
        p = partial(self.page_summons, index = 0)
        self.actions = {'Move':self.move, 'Entomb':self.entomb, 'Arcana':self.arcana}#, 'Summon':p}
        self.level = level
        self.owner = owner
        self.name = name
        self.summon_cap = 6
#         self.summon_level = 1
        self.summon_count = 0
        self.arcane_dict = {}
        self.entomb_deck = entomb_deck
        self.summons = []
        self.in_hand = []
        self.library = []
        self.discard = []
        self.exile = []
        # populate ARCANE dict
        smns = app.summons_list[:]
        for k in entomb_deck:
            if k in smns:# IS SUMMON
                self.summons.append(k)
            else:# IS SPELL
                spl = app.arcane_dict[k]
                func = partial(spl.func, self)
                self.arcane_dict[spl.name] = Spell(spl.name, func, spl.cost, spl.times_imprint, spl.times_cast)
        self.available_summons = []
        self.summon_ids = 0
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.attack_effects = [] # resolved when applying damage
        self.defense_effects = [] # resolved when receiving damage
        self.acts_effects = [] # affect number of actions/arcanespells per round
#         self.cantrips_effects = [] # affect number of cantrips per round
        self.smns_effects = [] # affect number of summons placed per round
        self.mvs_effects = [] # affect number of moves per round
        self.move_range_effects = [] # affect move_range
        self.action_effects = [] # holds effects that grant addtnl actions/spells
        self.resist_effects = [] # obj.resist and obj.weak are in subclass instances
        self.weak_effects = [] # resist/weak resolved in apply_damage()
        self.types = [] # holds invis, psyshield...
        self.type_effects = [] # effects that add/rmv types
        self.death_triggers = []
        self.effects_dict = {}
        self.anim_dict = {}
        self.init_normal_anims()
        self.anim_counter = randrange(0, len(self.anim_dict.keys()))
#         self.entomb_used = False
        self.spell_entomb_used = False
        self.summon_entomb_used = False
        if name == 'Agnes_Sampson':
            if level == 1:
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.str = 4
                self.agl = 4
                self.end = 4
                self.mm = 4
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 6
                self.rsn = 6
                self.san = 15
                self.init = 9
                self.spirit = 40
                self.magick = 0
                self.weak = []
                self.resist = ['poison', 'fire']
                self.base_spirit = 40
#                 self.base_magick = 75
                self.magick_regen = 1
            elif level == 2:
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.str = 7
                self.agl = 7
                self.end = 8
                self.mm = 6
                self.msl = 0
                self.bls = 0
                self.dodge = 8
                self.psyche = 10
                self.wis = 10
                self.rsn = 6
                self.san = 17
                self.init = 9
                self.spirit = 30
                self.magick = 0
                self.weak = []
                self.resist = ['poison', 'fire']
                self.base_spirit = 30
#                 self.base_magick = 85
                self.magick_regen = 1
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Agnes_Sampson_Color/Agnes_Sampson_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Agnes_Sampson_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        elif name == 'Fakir_Ali':
            if level == 1:
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.str = 3
                self.agl = 3
                self.end = 5
                self.mm = 3
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 5
                self.rsn = 6
                self.san = 17
                self.init = 8
                self.spirit = 34
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 50
                self.magick_regen = 1
            elif level == 2:
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'normal'
                self.str = 8
                self.agl = 7
                self.end = 9
                self.mm = 5
                self.msl = 0
                self.bls = 0
                self.dodge = 8
                self.psyche = 9
                self.wis = 9
                self.rsn = 6
                self.san = 16
                self.init = 8
                self.spirit = 34
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 30
                self.magick_regen = 1
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Fakir_Ali_Color/Fakir_Ali_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Fakir_Ali_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        elif name == 'Morgan_LeFay':
            if level == 1:
                self.arcane_dict['Fleet_of_Paw'] = (self.fleet_of_paw, 0)
                self.arcane_dict['Hunting_Hawk'] = (self.hunting_hawk, 0)
                self.arcane_dict['Entangle'] = (self.entangle, 0)
                self.arcane_dict['Boiling_Blood'] = (self.boiling_blood, 0)
                self.arcane_dict['Dark_Sun'] = (self.dark_sun, 0)
                self.arcane_dict['Meditate'] = (self.meditate, 0)
                self.arcane_dict['Legerdemain'] = (self.legerdemain, 0)
                self.arcane_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 0)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 0)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,5)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,3)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Dispel'] = (self.dispel,4)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 5)
                self.arcane_dict['Immolate'] = (self.immolate, 7)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Vengeance'] = (self.vengeance, 4)
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'flying'
                self.str = 3
                self.agl = 3
                self.end = 5
                self.mm = 3
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 5
                self.rsn = 6
                self.san = 17
                self.init = 8
                self.spirit = 50
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 50
            elif level == 2:
                self.cantrip_dict['Fleet_of_Paw'] = (self.fleet_of_paw, 0)
                self.cantrip_dict['Hunting_Hawk'] = (self.hunting_hawk, 0)
                self.cantrip_dict['Entangle'] = (self.entangle, 0)
                self.cantrip_dict['Boiling_Blood'] = (self.boiling_blood, 0)
                self.cantrip_dict['Dark_Sun'] = (self.dark_sun, 0)
                self.cantrip_dict['Meditate'] = (self.meditate, 0)
                self.cantrip_dict['Legerdemain'] = (self.legerdemain, 0)
                self.cantrip_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 0)
                self.cantrip_dict['Foul_Familiar'] = (self.foul_familiar, 0)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,5)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,3)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Dispel'] = (self.dispel,4)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 5)
                self.arcane_dict['Immolate'] = (self.immolate, 7)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Vengeance'] = (self.vengeance, 4)
                self.arcane_dict['Pain'] = (self.pain, 5)
                self.arcane_dict['Torment'] = (self.torment, 5)
                self.arcane_dict['Hatred'] = (self.hatred, 9)
                self.arcane_dict['Entomb'] = (self.entomb, 7)
                self.arcane_dict['Summon_Lesser_Demon'] = (self.summon_lesser_demon, 10)
                self.arcane_dict['Summon_Cenobite'] = (self.summon_cenobite, 10)
#             self.spell_dict['Enchant'] = (self.enchant, 4)
#             self.spell_dict['Counterspell'] = (self.counterspell, 3)
#             self.spell_dict["Nature's_Wrath"] = (self.natures_wrath, 5)
#             self.spell_dict["Ceridwen's_Command"] = (self.ceridwens_command, 6)
#             self.spell_dict['Wild_Hunt'] = (self.wild_hunt, 7)
#                 self.base_cantrips = 1
#                 self.cantrips = 1
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 4
                self.move_type = 'flying'
                self.str = 8
                self.agl = 7
                self.end = 9
                self.mm = 5
                self.msl = 0
                self.bls = 0
                self.dodge = 6
                self.psyche = 9
                self.wis = 9
                self.rsn = 7
                self.san = 17
                self.init = 8
                self.spirit = 60
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 60
#                 self.base_magick = 80
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Morgan_LeFay_Color/Morgan_LeFay_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Morgan_LeFay_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        id = self.name
        super().__init__(name, id, img, loc, owner, type = 'normal')
        
        
    # clean protagonist object (Witch) between levels DEBUG debug change to new...
    def reset_transient_vars(self):
        # attrs directly altered, reset
        self.summon_ids = 0
#         self.cantrips = self.base_cantrips
        self.acts = self.base_acts
        self.mvs = self.base_mvs
        self.smns = self.base_smns
        self.spirit = self.base_spirit
        self.magick = 0
        # attrs altered by effects stacks, reset stacks
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.action_effects = []
        self.attack_effects = []
        self.defense_effects = []
        self.resist_effects = []
        self.weak_effects = []
        self.type_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.move_range_effects = []
        self.death_trigger_effects = []
        self.effects_dict = {}
        self.summon_count = 0
        self.move_type_effects = []
        self.entomb_used = False
        self.libary = []
        self.in_hand = []
        self.discard = []
        self.exile = []
        self.spell_entomb_used = False
        self.summon_entomb_used = False
        for spell in self.arcane_dict.values():
            self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,0,0)
        self.inert_effects = []
    
    
    def page_summons(self, event = None, index = None):
        app.depop_context(event = None)
#         sum_list = ['Berserker','Illusionist','Umbrae_Wolf','Thaumaturge','Murrain_Wolf','Fiend','Wurdulak','Chirurgeon','Hexmage','Fell_Evolver','Drake','Inquisitor','Pixie','Chronomancer']
        sum_list = self.available_summons[:]
        for i, smn in enumerate(sum_list[index:index+7]):
            i += 1
            p = partial(self.place_summon, type = smn)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+smn.replace('_',' '), font = ('chalkduster', 20), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            if self.summon_count >= self.summon_cap or self.smns < 1:
                b1.config(state = 'disabled')
            else:
#                 p2 = partial(self.place_summon
                root.bind(str(i), p)
            app.context_buttons.append(b1)
#             b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda i = index-7 : self.page_summons(index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, i = index-7 : self.page_summons(index = i))
            app.context_buttons.append(b4)
        if len(sum_list) > len(sum_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda i = index+7 : self.page_summons(index = i))
            b3.pack(side = 'top', pady = 2)
            root.bind('<e>', lambda e, i = index+7 : self.page_summons(index = i))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        
    def cancel_placement(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    def place_summon(self, event = None, type = None, sqr = None):
        if type == 'Berserker':
            cls = Berserker
        elif type == 'Illusionist':
            cls = Illusionist
        elif type == 'Umbrae_Wolf':
            cls = Umbrae_Wolf
        elif type == 'Thaumaturge':
            cls = Thaumaturge
        elif type == 'Murrain_Wolf':
            cls = Murrain_Wolf
        elif type == 'Fiend':
            cls = Fiend
        elif type == 'Wurdulak':
            cls = Wurdulak
        elif type == 'Chirurgeon':
            cls = Chirurgeon
        elif type == 'Hexmage':
            cls = Hexmage
        elif type == 'Fell_Evolver':
            cls = Fell_Evolver
        elif type == 'Drake':
            cls = Drake
        elif type == 'Inquisitor':
            cls = Inquisitor
        elif type == 'Pixie':
            cls = Pixie
        elif type == 'Chronomancer':
            cls = Chronomancer
        elif type == 'Enchantress':
            cls = Enchantress
        elif type == 'Diabolist':
            cls = Diabolist
        elif type == 'Artificer':
            cls = Artificer
        elif type == 'Yellow_Priest':
            cls = Yellow_Priest
        elif type == 'Goblin_Shaman':
            cls = Goblin_Shaman
        elif type == 'Beastmaster':
            cls = Beastmaster
        elif type == 'Ogre':
            cls = Ogre
        self.continue_place_summon(cls, sqr)
        
        
#     def continue_place_summon(self, event, summon, sqrs, sqr):
    def continue_place_summon(self, summon, sqr):
        def cleanup_summon():
            app.canvas.delete('Summon_Tomb')
            del app.vis_dict['Summon_Tomb']
        root.after(2666, cleanup_summon)
        if self.owner == 'p1':
            id = 'a' + str(self.summon_ids)
            self.summon_ids += 1
            self.summon_count += 1
        elif self.owner == 'p2':
            id = 'b' + str(self.summon_ids)
            self.summon_ids += 1
            self.summon_count += 1
        if summon == Berserker:
            name = 'Berserker'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Berserker.png'))
        elif summon == Illusionist:
            name = 'Illusionist'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Illusionist.png'))
        elif summon == Umbrae_Wolf:
            name = 'Umbrae_Wolf'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Umbrae_Wolf.png'))
        elif summon == Thaumaturge:
            name = 'Thaumaturge'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Thaumaturge.png'))
        elif summon == Murrain_Wolf:
            name = 'Murrain_Wolf'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Murrain_Wolf.png'))
        elif summon == Fiend:
            name = 'Fiend'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Fiend.png'))
        elif summon == Wurdulak:
            name = 'Wurdulak'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Wurdulak.png'))
        elif summon == Chirurgeon:
            name = 'Chirurgeon'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Chirurgeon.png'))
        elif summon == Hexmage:
            name = 'Hexmage'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Hexmage.png'))
        elif summon == Fell_Evolver:
            name = 'Fell_Evolver'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Fell_Evolver.png'))
        elif summon == Drake:
            name = 'Drake'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Drake.png'))
        elif summon == Inquisitor:
            name = 'Inquisitor'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Inquisitor.png'))
        elif summon == Pixie:
            name = 'Pixie'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Pixie.png'))
        elif summon == Chronomancer:
            name = 'Chronomancer'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Chronomancer.png'))
        elif summon == Enchantress:
            name = 'Enchantress'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Enchantress.png'))
        elif summon == Diabolist:
            name = 'Diabolist'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Diabolist.png'))
        elif summon == Artificer:
            name = 'Artificer'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Artificer.png'))
        elif summon == Yellow_Priest:
            name = 'Yellow_Priest'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Yellow_Priest.png'))
        elif summon == Goblin_Shaman:
            name = 'Goblin_Shaman'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Goblin_Shaman.png'))
        elif summon == Beastmaster:
            name = 'Beastmaster'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Beastmaster.png'))
        elif summon == Ogre:
            name = 'Ogre'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Ogre.png'))
        s = summon(name = name, id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.cleanup_squares()
        app.depop_context(event = None)
        # separate here to finish summon vis, place ent after a sec or two
        root.after(1999, lambda s = s, sqr = sqr, id = id : self.finish_place(s, sqr, id))
        
    def finish_place(self, summon, sqr, id):
        app.ent_dict[id] = summon
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = summon.img, tags = summon.tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.smns -= 1
        app.unbind_all()
        app.rebind_all()
        
        
    def spell(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spell)
        b1 = tk.Button(app.context_menu, wraplength = 190, text = 'Cantrip', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = self.cantrip)
        b1.pack(side = 'top', pady = 2)
        app.context_buttons.append(b1)
        root.bind(str(1), self.cantrip)
        b2 = tk.Button(app.context_menu, wraplength = 190, text = 'Arcane', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = self.arcane)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        root.bind(str(2), self.arcane)
        b6 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 20), highlightbackground = 'tan3', fg='tan3', command = self.cancel_placement)
        b6.pack(side = 'top')
        app.context_buttons.append(b6)
        
#     def cantrip(self, event = None):
#         if self.cantrips < 1:
#             return
#         app.depop_context(event = None)
#         app.unbind_nonarrows()
#         root.bind('<q>', self.cleanup_spell)
#         tup_list = list(self.cantrip_dict.items())
#         self.page_spells(tup_list = tup_list, index = 0)
        
    def arcana(self, event = None):
#         if self.acts < 1:
#             return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spell)
#         tup_list = list(self.arcane_dict.items())
#         tup_list = sorted(tup_list, key=lambda t : t[1][1])
#         self.page_spells(tup_list = tup_list, index = 0)
        spells = sorted(filter(lambda s : s.times_imprint > 0, list(self.arcane_dict.values())),key=lambda s : s.cost)
        self.page_spells(tup_list = spells, index = 0)

###
        
    def page_spells(self, event = None, tup_list = None, index = None):
        app.depop_context(event = None)
        for i,spell in enumerate(tup_list[index:index+7]):
            name = spell.name.replace('_', ' ')
            func = spell.func
            cost = spell.cost
            i += 1
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name + ' •'+str(cost), font = ('chalkduster', 18), fg='tan3', highlightbackground = 'tan3', command = func)
            b1.pack(side = 'top', pady = 2)
            if cost > self.magick or spell.times_cast >= spell.times_imprint:
                b1.config(state = 'disabled')
            else:
                root.bind(str(i), func)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            b3.pack(side = 'top', pady = 2)
            root.bind('<e>', lambda e, t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = self.cleanup_spell)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
    
    def cleanup_spell(self, event = None, name = None):
        global selected, selected_vis
        app.unbind_all()
        self.init_normal_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict[name]
            app.canvas.delete(name)
        except: pass
        try: app.canvas.delete('text')
        except: pass
        selected = []
        selected_vis = []
        app.get_focus(self.id)
        app.rebind_all()
        
        
        # SPELLS
        # available to all through powerups
    # drain_life cantrip, deal 2 to any enemy target, heal 2 spirit?
    # exchange positions of friendly summon and enemy summon, or any two summons?
    # cantrip boost stats of a summon for multiple turns, non-stacking?
    
    # destroy familiar..., make a little taller and resemble the imp in some way, image should be combo of imp and homunc
    def summon_lesser_demon(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Summon_Lesser_Demon' : self.cleanup_spell(name = name))
        familiars = [k for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc,self.loc) <= self.get_abl('rsn') and (v.name == 'Familiar_Imp' or v.name == 'Familiar_Homunculus')]
        sqrs = []
        for id in familiars:
            sqrs.append(app.ent_dict[id].loc[:])
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_summon_lesser_demon(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Familiar To Transform', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_summon_lesser_demon(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_summon_lesser_demon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        my_ent_names = [v.name for k,v in app.all_ents().items() if v.owner == self.owner]
        if 'Lesser_Demon' in my_ent_names:
            return
        id = app.grid[sqr[0]][sqr[1]]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_lesser_demon.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Summon_Lesser_Demon'].cost
        spell = self.arcane_dict['Summon_Lesser_Demon']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.canvas.delete(id)
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        del app.ent_dict[id]
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_summon_lesser_demon(s))
        root.after(1999, self.cleanup_summon_lesser_demon)
        root.after(2111, lambda name = 'Summon_Lesser_Demon' : self.cleanup_spell(name = name))
        
    def finish_summon_lesser_demon(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Lesser_Demon.png'))
        app.ent_dict[id] = Lesser_Demon(name = 'Lesser_Demon', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_summon_lesser_demon(self):
        del app.vis_dict['Summon']
        app.canvas.delete('Summon')
    
    
    def haunted_cairn(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Haunted_Cairn' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn') and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_haunted_cairn(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_haunted_cairn(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_haunted_cairn(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        my_ent_names = [v.name for k,v in app.all_ents().items() if v.owner == self.owner]
        if 'Haunted_Cairn' in my_ent_names:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Haunted_Cairn'].cost
        spell = self.arcane_dict['Haunted_Cairn']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_haunted_cairn(s))
        root.after(1777, self.cleanup_haunted_cairn)
        root.after(1999, lambda name = 'Haunted_Cairn' : self.cleanup_spell(name = name))
        
    def finish_haunted_cairn(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Haunted_Cairn.png'))
        app.ent_dict[id] = Haunted_Cairn(name = 'Haunted_Cairn', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_haunted_cairn(self):
        del app.vis_dict['Summon']
        app.canvas.delete('Summon')
    
    
    def voodoo_doll(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Voodoo_Doll' : self.cleanup_spell(name = name))
        sqrs = [c for c in app.coords if dist(self.loc, c)==1 and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_voodoo_doll(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_voodoo_doll(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_voodoo_doll(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Voodoo_Doll' in [v.name for k,v in app.all_ents().items() if v.owner == self.owner]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Voodoo_Doll'].cost
        spell = self.arcane_dict['Voodoo_Doll']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr)
        def cleanup():
            del app.vis_dict['Curse_of_Oriax']
            app.canvas.delete('Curse_of_Oriax')
        root.after(1555, cleanup)
        root.after(1666, lambda s = sqr : self.finish_voodoo_doll(s))
        root.after(1999, lambda name = 'Voodoo_Doll' : self.cleanup_spell(name = name))
        
    def finish_voodoo_doll(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Voodoo_Doll.png'))
        app.ent_dict[id] = Voodoo_Doll(name = 'Voodoo_Doll', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
    
    
    def summon_cenobite(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Summon_Cenobite' : self.cleanup_spell(name = name))
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_summon_cenobite(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_summon_cenobite(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_summon_cenobite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        my_ent_names = [v.name for k,v in app.all_ents().items() if v.owner == self.owner]
        if 'Cenobite' in my_ent_names:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Summon_Cenobite'].cost
        spell = self.arcane_dict['Summon_Cenobite']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_summon_cenobite(s))
        root.after(1777, self.cleanup_summon_cenobite)
        root.after(1999, lambda name = 'Summon_Cenobite' : self.cleanup_spell(name = name))
        
    def finish_summon_cenobite(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Cenobite.png'))
        app.ent_dict[id] = Cenobite(name = 'Cenobite', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_summon_cenobite(self):
        del app.vis_dict['Summon']
        app.canvas.delete('Summon')
        
        
        
    def sirens_call(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = "Siren's_Call" : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_sirens_call(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Siren's Call", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_sirens_call(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_sirens_call(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict["Siren's_Call"].cost
        spell = self.arcane_dict["Siren's_Call"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict["Siren's_Call"] = Vis(name = "Siren's_Call", loc = sqr)
        ents = [v for k,v in app.all_ents().items() if v.owner != self.owner and v.get_inert() == False and isinstance(v,Witch) == False and v.immovable==False]
        s = sqr[:]
        for e in ents:
            mvs = e.legal_moves()
            if mvs == [] or e.save_check('psyche', mod = -3)=='Pass':
                pass
            else:
                loc = reduce(lambda a,b : a if dist(a,s)<dist(b,s) else b, mvs)
                lock(Bot.do_move, e, loc)
        root.after(1666, lambda  name = "Siren's_Call" : self.cleanup_spell(name = name))
        
        
        
        
    def mass_grave(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Mass_Grave' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mass_grave(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Mass Grave', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mass_grave(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mass_grave(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        for card in self.in_hand:
            if card in app.arcane_dict.keys():
                break
        else:
            return
        amt = self.summon_cap - self.summon_count
        if amt < 1:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Mass_Grave'].cost
        spell = self.arcane_dict['Mass_Grave']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Mass_Grave'] = Vis(name = 'Mass_Grave', loc = sqr)
        # page hand/spls
        spls = [c for c in self.in_hand if c in app.arcane_dict.keys()]
        self.page_mass_grave(hand = spls, loc = sqr[:])
        
        
    def page_mass_grave(self, event = None, hand = None, index = 0, all = (), loc = None):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(hand[index:index+9]):
            i += 1
            p = partial(self.choose_mass_grave, card = card, all = all, loc = loc)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9, all = all, loc = loc : self.page_mass_grave(hand = hand, index = i, all = all, loc = loc))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9, all = all, loc = loc : self.page_mass_grave(hand = hand, index = i, all = all, loc = loc))
            app.context_buttons.append(b4)
        if len(hand) > len(hand[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9, all = all, loc = loc : self.page_mass_grave(hand = hand, index = i, all = all, loc = loc))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9, all = all, loc = loc : self.page_mass_grave(hand = hand, index = i, all = all, loc = loc))
        # add 'done' button
        b4 = tk.Button(app.context_menu, text = 'Done', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda all = all, loc = loc : self.finish_mass_grave(all = all, loc = loc))
        b4.pack(side = 'top', pady = 2)
        app.context_buttons.append(b4)
#         root.bind('<e>', lambda e, hand = hand, i = index+5, ent = ent : self.page_giant_growth(hand = hand, index = i, ent = ent))
        
    def choose_mass_grave(self,event = None, card = None, all = None, loc = None):
        all = (card,*all) #all is tuple, unpack/update all
        self.in_hand.remove(card)
        self.discard.append(card)
        if self.in_hand == [] or len(all) == self.summon_cap-self.summon_count:
            self.finish_mass_grave(all, loc)
        else:
            hand = [c for c in self.in_hand if c not in app.summons_list]
            self.page_mass_grave(hand = hand[:], all = all, loc = loc)
        
    def finish_mass_grave(self, all, loc):
        app.depop_context(event = None)
        for t in all:
            cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
            sqr = reduce(lambda a,b : a if dist(a,loc)<dist(b,loc) else b,cs)
            spell = self.arcane_dict[t]
            self.arcane_dict[t] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint+1,spell.times_cast)
            if self.owner == 'p1':
                prefix = 'a'
            else:
                prefix = 'b'
            id = prefix + str(self.summon_ids)
            self.summon_ids += 1
            def cleanup_twin(name):
                del app.vis_dict[name]
                app.canvas.delete(name)
            n = 'Mass_Grave'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Grave_Twin', loc = sqr[:])
            root.after(1666, lambda n = n : cleanup_twin(n))
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
            app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level, imprint = t)
            app.grid[sqr[0]][sqr[1]] = id
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = t.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = t.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(2666, lambda  name = 'Mass_Grave' : self.cleanup_spell(name = name))
        
        
        
        
        
    def living_death(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Living_Death' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_living_death(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Living Death', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_living_death(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_living_death(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Living_Death'].cost
        spell = self.arcane_dict['Living_Death']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Living_Death'] = Vis(name = 'Living_Death', loc = sqr)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Living Death', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Living Death', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
        root.after(1666, lambda s = sqr : self.finish_living_death(s))
        root.after(1999, lambda name = 'Living_Death' : self.cleanup_spell(name = name))
        
    def finish_living_death(self, sqr):
        amt = self.summon_cap - self.summon_count
        for x in range(amt):
            locs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
            if locs == []:
                break
            else:
                s = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b, locs)
                num = self.summon_ids
                self.summon_ids += 1
                if self.owner == 'p1':
                    prefix = 'a'
                else:
                    prefix = 'b'
                id = prefix + str(num)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Cadaver.png'))
                app.ent_dict[id] = Cadaver(name = 'Cadaver', id = id, img = img, loc = s[:], owner = self.owner, level = self.level)
                app.grid[s[0]][s[1]] = id
        
    # target summon may move again this turn
    def energize(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Energize' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_energize(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Energize', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_energize(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_energize(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Energize' in [v.name for k,v in ent.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Energize'].cost
        spell = self.arcane_dict['Energize']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Energize', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Energize', justify = 'center', font = ('chalkduster', 13), fill = 'cyan2', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '+1 moves', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '+1 moves', justify = 'center', font = ('chalkduster', 13), fill = 'cyan2', tags = 'text')
        def energize_efct(stat):
            return stat+1
        p = partial(energize_efct)
        ent.mvs_effects.append(p)
        ent.mvs += 1
        def undo(ent, p, lockname = None):
            ent.mvs_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        app.vis_dict['Energize'] = Vis(name = 'Energize', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Energize'].img, tags = 'Energize')
        n = 'Energize' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Energize', undo_func = u, duration = 2, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Energize' : self.cleanup_spell(name = name))
    
    
    
    
    def cloudkill(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Cloudkill' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_cloudkill(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Cloudkill', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_cloudkill(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cloudkill(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Cloudkill'].cost
        spell = self.arcane_dict['Cloudkill']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        locs = [c for c in app.coords if dist(c,sqr)<=2]
        for loc in locs:
            if 'Cloudkill' not in [v.name for k,v in app.loc_dict[tuple(loc)].effects_dict.items()]:
                un = 'cloudkill' + str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Cloudkill', loc = loc[:])
                def give_take_2(sqr = None, lockname = None):
                    id =  app.grid[sqr[0]][sqr[1]]
                    if id in app.all_ents().keys():
                        ent = app.ent_dict[id]
                        def take_2(ent, lockname = None):
                            app.get_focus(ent.id)
                            lock(apply_damage, self, ent, -2, 'poison', 'Cloudkill', 'eot')
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        p = partial(take_2, ent)
                        def undo(lockname = None):
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo)
                        n = 'cloudpoison'+str(app.count)
                        ent.effects_dict[n] = Effect(name = 'Cloud_Poison', eot_func = p, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                eot = partial(give_take_2, sqr = loc)
                def undo(un, lockname = None):
                    del app.vis_dict[un]
                    app.canvas.delete(un)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, un)
                app.loc_dict[tuple(loc)].effects_dict[un] = Local_Effect(name = 'Cloudkill', undo_func = u, eot_func = eot, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = loc[:], avoid = 7)
        root.after(2333, lambda  name = 'Cloudkill' : self.cleanup_spell(name = name))
    
    
    
    def dessicate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Dessicate' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dessicate(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Dessicate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dessicate(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dessicate(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Dessicate'].cost
        spell = self.arcane_dict['Dessicate']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        ents = [v for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 1]
        def cleanup_dessicate(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for e in ents:
            n = 'dess'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Dessicate', loc = e.loc[:])
            sqr = e.loc[:]
            if to_hit(self.get_abl('wis'),e.get_abl('wis'))==True:
                root.after(1666, lambda n = n : cleanup_dessicate(n))
                app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Weak fire', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Weak fire', justify = 'center', font = ('chalkduster', 13), fill = 'green', tags = 'text')
                def compr_efct(ts):
                    return ts + ['fire']
                p = partial(compr_efct)
                e.weak_effects.append(p)
                def un(ent, p, lockname = None):
                    ent.weak_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, e, p)
                un = 'dessicate' + str(app.count)
                e.effects_dict[un] = Effect(name = 'Dessicate', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            else:
                miss(e.loc)
                root.after(1666, lambda n = n : cleanup_dessicate(n))
        root.after(2333, lambda  name = 'Dessicate' : self.cleanup_spell(name = name))
    
    # the star- play a spell on a tomb in discard (exile?) if you have that tomb in-hand, -4
    def the_star(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'The_Star' : self.cleanup_spell(name = name))
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_star(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Star', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_star(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_star(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        discard_spls = [c for c in self.discard[:] if c in self.arcane_dict.keys()]
        if discard_spls == []:
            return
        hand_spls = [c for c in self.in_hand[:] if c in self.arcane_dict.keys()]
        both = [c for c in discard_spls if c in hand_spls]
        if both == []:
            return
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        # choose tomb in both
        self.page_the_star(cards = both)
        
        
    def page_the_star(self, event = None, cards = None, index = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+9]):
            i += 1
            p = partial(self.choose_the_star, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9 : self.page_the_star(hand = hand, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9 : self.page_the_star(hand = hand, index = i))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9 : self.page_the_star(hand = hand, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9 : self.page_the_star(hand = hand, index = i))
        
    def choose_the_star(self,event = None, card = None):
        # exile tomb from discard, pay for the star cost, cast spell object
        self.discard.remove(card)
        self.exile.append(card)
        self.magick -= self.arcane_dict['The_Star'].cost
        spell = self.arcane_dict['The_Star']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        spell_obj = self.arcane_dict[card]
        self.magick += spell_obj.cost
        sqr = self.loc[:]
        app.vis_dict['The_Star'] = Vis(name = 'The_Star', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'The Star, cast '+card, justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'The Star, cast '+card, justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        root.after(1666, lambda  name = 'The_Star' : self.cleanup_spell(name = name))
        root.after(1777, lambda spell_obj = spell_obj : self.cont_the_star(spell_obj))
        
    def cont_the_star(self, spell_obj):
        spell_obj.func()
    
    # any spell target tomb in range rsn which has an imprint with spell costing less than or equal to this spell cost, is immediately cast by fork caster
    def fork(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Fork' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fork(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Fork', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fork(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fork(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Tomb)==False:
            return
        if ent.imprint=='':
            return
        spell_obj = self.arcane_dict[ent.imprint]
        if spell_obj.cost > self.arcane_dict['Fork'].cost:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        # INSERT cast here, pay for fork? pay for imprint spell?
        # hack to account for spell.func handling costs paid
        self.magick += spell_obj.cost
        # make sure to exit on spell_obj.func
        # bug spell_obj.func has hotkeys/buttons that allow for cancel, which will exit before costs are paid for spell,
        # how to / if? disallow cancel?
        # wrap/call func
        self.magick -= self.arcane_dict['Fork'].cost
        spell = self.arcane_dict['Fork']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Fork'] = Vis(name = 'Fork', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Fork', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Fork', justify = 'center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        root.after(1666, lambda  name = 'Fork' : self.cleanup_spell(name = name))
        root.after(1777, lambda spell_obj = spell_obj : self.cont_fork(spell_obj))
        
    def cont_fork(self, spell_obj):
        spell_obj.func()
    
    
    def compromised_immunity(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Compromised Immunity' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_compromised_immunity(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Compromised Immunity', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_compromised_immunity(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_compromised_immunity(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Compromised_Immunity'].cost
        spell = self.arcane_dict['Compromised_Immunity']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Compromised_Immunity'] = Vis(name = 'Compromised_Immunity', loc = sqr[:])
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Weak poison', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Weak poison', justify = 'center', font = ('chalkduster', 13), fill = 'green', tags = 'text')
            def compr_efct(ts):
                return ts + ['poison']
            p = partial(compr_efct)
            ent.weak_effects.append(p)
            def un(ent, p, lockname = None):
                ent.weak_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, ent, p)
            n = 'Compromised_Immunity' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Compromised_Immunity', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(2111, lambda  name = 'Compromised_Immunity' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1777, lambda t = 'text': app.canvas.delete(t))
            root.after(1888, lambda  name = 'Compromised_Immunity' : self.cleanup_spell(name = name))
    
    
    def minervas_gift(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = "Minerva's_Gift" : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_minervas_gift(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Gift', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_minervas_gift(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_minervas_gift(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if "Minerva's_Gift" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict["Minerva's_Gift"].cost
        spell = self.arcane_dict["Minerva's_Gift"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict["Minerva's_Gift"] = Vis(name = "Minerva's_Gift", loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict["Minerva's_Gift"].img, tags = "Minerva's_Gift")
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = '+1 agl, init\n+1 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = '+1 agl, init\n+1 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        apply_heal(self, app.ent_dict[id], 1)
        def minervas_gift_effect(stat):
            stat += 1
            return stat
        f = minervas_gift_effect
        app.ent_dict[id].agl_effects.append(f)
        app.ent_dict[id].init_effects.append(f)
        def un(i, lockname = None):
            app.ent_dict[i].agl_effects.remove(minervas_gift_effect)
            app.ent_dict[i].init_effects.remove(minervas_gift_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = "Minerva's_Gift" + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = "Minerva's_Gift", undo_func = p, duration = 2, level = self.get_abl('wis'))
        root.after(2999, lambda  name = "Minerva's_Gift" : self.cleanup_spell(name = name))

    # target gains psyshield (friendly or foe, non-witch) 2 turns (cannot target with most spells, anything that checks app.spell_target_ents())
    def bewitch(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Bewitch' : self.cleanup_spell(name = name))
        # test visual lag from 'blinking' whole map?
        # alternatively only blink the sqrs with legal targets?
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_bewitch(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Bewitch', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_bewitch(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bewitch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if id not in app.spell_target_ents().keys():
            return
        if 'Bewitch' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Bewitch'].cost
        spell = self.arcane_dict['Bewitch']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Bewitch'] = Vis(name = 'Bewitch', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Bewitch'].img, tags = 'Bewitch')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        def bewitch_effect(types):
            return types+['psyshield']
        p = partial(bewitch_effect)
        app.ent_dict[id].type_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].type_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Bewitch' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Bewitch', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Bewitch' : self.cleanup_spell(name = name))
        
        
    def read_the_stars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_rts(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Read the Stars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_rts(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rts(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Read_the_Stars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/read_the_stars.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Read_the_Stars'].cost
        spell = self.arcane_dict['Read_the_Stars']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        ent = app.ent_dict[id]
        app.vis_dict['Read_the_Stars'] = Vis(name = 'Read_the_Stars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Read_the_Stars'].img, tags = 'Read_the_Stars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Read the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Read the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+2 cold, elec dmg', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+2 cold, elec dmg', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def rts_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (type == 'cold' or type == 'elec') and (st == 'melee' or st == 'ranged' or st == 'spell'):
                amt -= 2
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+84-app.moved_down, text = '+2 Read the Stars', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+85-app.moved_down, text = '+2 Read the Stars', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(rts_atk)
        ent.attack_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.attack_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        un = partial(undo, ent, p)
        n = 'Read_the_Stars' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Read_the_Stars', undo_func = un, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Read_the_Stars' : self.cleanup_spell(name = name))
        
        
    def psi_blades(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Psi_Blades' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_psi_blades(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Psi Blades', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_psi_blades(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psi_blades(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Psi_Blades' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Psi_Blades'].cost
        spell = self.arcane_dict['Psi_Blades']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Psi_Blades'] = Vis(name = 'Psi_Blades', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psi Blades', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psi Blades', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        def psi_slash(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [s for s in app.coords if dist(s,obj.loc) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Psi Slash', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id == '' or id == 'block':
                    return
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/psi_slash.ogg')
#                 effect1.set_volume(app.effects_volume.get())
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Psi_Slash'] = Vis(name = 'Psi_Slash', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Psi_Slash'].img, tags = 'Psi_Slash')
                def cleanup_vis():
                    app.canvas.delete('text')
                    try:
                        del app.vis_dict['Psi_Slash']
                        app.canvas.delete('Psi_Slash')
                    except: pass
                my_agl = obj.get_abl('agl')
                target_agl = app.ent_dict[id].get_abl('agl')
                if to_hit(my_agl, target_agl) == True:
                    my_psyche = obj.get_abl('psyche')
                    target_psyche = app.ent_dict[id].get_abl('psyche')
                    d = damage(my_psyche, target_psyche)
                    root.after(1666, cleanup_vis)
                    lock(apply_damage, obj, app.ent_dict[id], -d, 'elec', 'Psi Slash', 'melee')
                    root.after(333, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1999, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Psi_Slash']
                    app.canvas.delete('Psi_Slash')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(psi_slash, obj = app.ent_dict[id])
        def add_psi_slash(actions = None, func = None):
            actions['Psi Slash'] = func
            return actions
        p2 = partial(add_psi_slash, func = p)
        app.ent_dict[id].action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id, p2)
        n = 'Psi_Blades' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Psi_Blades', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = "Psi_Blades" : self.cleanup_spell(name = name))
        
    def foul_familiar(self, event = None):
        names = [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]
        if 'Familiar_Imp' in names or 'Familiar_Homunculus' in names or 'Familiar_Pseudodragon' in names:
            return
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Foul_Familiar' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_foul_familiar(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_foul_familiar(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_foul_familiar(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        loc = sqr[:]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/foul_familiar.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Foul_Familiar'].cost
        spell = self.arcane_dict['Foul_Familiar']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Foul_Familiar'] = Vis(name = 'Foul_Familiar', loc = sqr)
        # summon familiar based on witch
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        if self.name == 'Agnes_Sampson':
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Familiar_Imp.png'))
            app.ent_dict[id] = Familiar_Imp(name = 'Familiar_Imp', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
            app.grid[sqr[0]][sqr[1]] = id
        elif self.name == 'Fakir_Ali':
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Familiar_Homunculus.png'))
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = img, tags = id)
            app.ent_dict[id] = Familiar_Homunculus(name = 'Familiar_Homunculus', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
            app.grid[sqr[0]][sqr[1]] = id
        root.after(666, lambda  name = 'Foul_Familiar' : self.cleanup_spell(name = name))
    
    def entomb(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.finish_entomb)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_entomb(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_entomb(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        if self.spell_entomb_used == True and self.summon_entomb_used == True:
            b.config(state = 'disabled')
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_entomb(self, event, sqr, sqrs):
        if self.spell_entomb_used == True and self.summon_entomb_used == True:
            return
        if sqr not in sqrs:
            return
        loc = app.grid[sqr[0]][sqr[1]]
        if loc != '':
            return
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        smns = app.summons_list[:]
        spells_for_turn = [k for k in self.in_hand if k not in smns]
        summons = [k for k in self.in_hand if k in app.summon_dict.keys()]
        summons = [app.summon_dict[k] for k in summons]
        spls = [self.arcane_dict[k] for k in spells_for_turn if k not in smns]
        spells = sorted(list(spls),key=lambda s : s.cost)
        spells += summons
        self.page_imprint(tup_list = spells, index = 0, sqr = sqr[:])
        
    def page_imprint(self, event = None, tup_list = None, index = None, sqr = None):
        app.depop_context(event = None)
        choose = tk.Label(root, text = 'Choose Arcana to Imprint', fg = 'tan3', bg = 'black', font = ('chalkduster', 20))
        choose.pack()
        smns = app.summons_list[:]
        app.context_buttons.append(choose)
        for i, spell in enumerate(tup_list[index:index+7]):
            state = 'enabled'
            if spell[0] in smns:# IS SUMMON
                name = spell[0].replace('_',' ')
                cost = 0
                com = partial(self.continue_entomb_summon, name = name, sqr = sqr[:])
                color = 'black'
                if self.summon_entomb_used == True or self.summon_count >= self.summon_cap:
                    state = 'disabled'
            else:# IS SPEll
                name = spell.name.replace('_', ' ')
                com = partial(self.continue_entomb_spell, name = spell.name, sqr = sqr[:])
                cost = spell.cost
                color = 'indianred'
                if self.spell_entomb_used == True:
                    state = 'disabled'
            i += 1
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name + ' •'+str(cost), font = ('chalkduster', 18), fg=color, highlightbackground = 'tan3', command = com)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
            if state == 'disabled':
                b1.config(state='disabled')
            else:
                root.bind(str(i), com)
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-7 : self.page_imprint(tup_list = t, index = i, sqr = sqr[:]))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, t = tup_list, i = index-7, sqr = sqr : self.page_imprint(tup_list = t, index = i, sqr = sqr))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+7 : self.page_imprint(tup_list = t, index = i, sqr = sqr[:]))
            b3.pack(side = 'top', pady = 2)
            root.bind('<e>', lambda e, t = tup_list, i = index+7, sqr = sqr : self.page_imprint(tup_list = t, index = i, sqr = sqr))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = self.cleanup_spell)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        root.bind('<q>', self.finish_entomb)
        
    def continue_entomb_spell(self, event = None, name = None, sqr = None):
        app.depop_context(event=None)
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.entomb_used = True
        self.spell_entomb_used = True
#         self.acts -= 1
        spell = self.arcane_dict[name]
        self.arcane_dict[name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint+1,spell.times_cast)
        app.vis_dict['Entomb'] = Vis(name = 'Entomb', loc = sqr[:])
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(self.summon_ids)
        self.summon_ids += 1
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
        app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level, imprint = name)
        app.grid[sqr[0]][sqr[1]] = id
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        for i,spl in enumerate(self.in_hand[:]):
            if spl == name:
                if spl == 'Magick_Missle':
                    self.exile.append(self.in_hand[i])
                    self.in_hand.remove(self.in_hand[i])
                    break
                else:
                    self.discard.append(self.in_hand[i])
                    self.in_hand.remove(self.in_hand[i])
                    break
        root.after(1666, self.finish_entomb)
        
        
    def continue_entomb_summon(self, event = None, name = None, sqr = None):
        app.depop_context(event=None)
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.acts -= 1
        self.summon_entomb_used = True
        if name not in self.available_summons:
            self.available_summons.append(name)
        app.vis_dict['Summon_Tomb'] = Vis(name = 'Summon_Tomb', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Entomb '+str(name), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Entomb '+str(name), justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        for i,spl in enumerate(self.in_hand[:]):
            if spl.replace('_',' ') == name:
                self.discard.append(self.in_hand[i])
                self.in_hand.remove(self.in_hand[i])
                break
#         root.after(1666, self.finish_entomb)
        root.after(1777, lambda t = 'text' : app.canvas.delete(t))
        self.place_summon(type = name.replace(' ','_'), sqr = sqr[:])
        
        
    def finish_entomb(self, event = None):
        try:
            del app.vis_dict['Entomb']
            app.canvas.delete('Entomb')
        except:
            pass
#         try:
#             del app.vis_dict['Summon_Tomb']
#             app.canvas.delete('Summon_Tomb')
#         except:
#             pass
        app.canvas.delete('text')
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.get_focus(self.id)
        app.rebind_all()
        
        
    def magick_missle(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Magick_Missle' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_magick_missle(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Magick Missle', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_magick_missle(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_magick_missle(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        amt = len([k for k,v in app.all_ents().items() if v.owner == self.owner and isinstance(v,Tomb)])
        if amt < 1:
            return
        ent = app.ent_dict[id]
#         self.init_cast_anims()
        self.magick -= self.arcane_dict['Magick_Missle'].cost
        spell = self.arcane_dict['Magick_Missle']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Magick Missle', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Magick Missle', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        lock(self.ranged_attack, sqr, 'Magick_Missle')
        lock(apply_damage, self, ent, -amt, 'magick', 'Magick Missle', 'spell')
        root.after(666, lambda  name = 'Magick_Missle' : self.cleanup_spell(name = name))
        
        
    def defile(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Defile' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_defile(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Defile', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_defile(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_defile(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Tomb) == False:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Defile'].cost
        spell = self.arcane_dict['Defile']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Defile', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Defile', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Defile'] = Vis(name = 'Defile', loc = sqr)
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            lock(apply_damage, self, ent, -4, 'slashing', 'Defile', 'spell')
            root.after(222, lambda  name = 'Defile' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1777, lambda  name = 'Defile' : self.cleanup_spell(name = name))
        
        
        
    def judgment(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Judgment' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_judgment(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Judgment', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_judgment(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_judgment(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if app.num_players == 1:
            return
        my_amt = len([k for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == self.owner])
        op_amt = len([k for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner != self.owner])
        if my_amt <= op_amt:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Tomb) == False:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Judgment'].cost
        spell = self.arcane_dict['Judgment']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Judgment', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Judgment', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Judgment'] = Vis(name = 'Judgment', loc = sqr)
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            lock(app.kill, ent.id)
            root.after(999, lambda  name = 'Judgment' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1777, lambda  name = 'Judgment' : self.cleanup_spell(name = name))
        
        
    # add def efct to smn, on non-sot/eot dmg, add +1 ablts 
    def vengeance(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Vengeance' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_vengeance(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Vengeance', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_vengeance(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_vengeance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Vengeance' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/vengeance.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Vengeance'].cost
        spell = self.arcane_dict['Vengeance']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Vengeance', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Vengeance', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Vengeance'] = Vis(name = 'Vengeance', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Vengeance'].img, tags = 'Vengeance')
        def vengeance_efct(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged') and len([v for k,v in dfndr.effects_dict.items() if v.name == 'Vengeance_Boost']) <= 3:
                def vngnc_tmp(stat):
                    return stat+1
                p = partial(vngnc_tmp)
                dfndr.str_effects.append(p)
                dfndr.agl_effects.append(p)
                dfndr.end_effects.append(p)
                dfndr.psyche_effects.append(p)
                dfndr.wis_effects.append(p)
                dfndr.rsn_effects.append(p)
                def undo(dfndr, func, lockname = None):
                    dfndr.str_effects.remove(p)
                    dfndr.agl_effects.remove(p)
                    dfndr.end_effects.remove(p)
                    dfndr.psyche_effects.remove(p)
                    dfndr.wis_effects.remove(p)
                    dfndr.rsn_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, dfndr, p)
                n = 'Vengeance_Boost'+str(app.count)
                dfndr.effects_dict[n] = Effect(name = 'Vengeance_Boost', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Vengeance\n+1 str, agl, end, psy, wis, rsn', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Vengeance\n+1 str, agl, end, psy, wis, rsn', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(vengeance_efct)
        ent.defense_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].defense_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Vengeance'+str(app.count)
        ent.effects_dict[n] = Effect(name = 'Vengeance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Vengeance' : self.cleanup_spell(name = name))
      
      
    def wreathed_in_flame(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_wreathed_in_flame(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Wreathed in Flame', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_wreathed_in_flame(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wreathed_in_flame(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Wreathed_in_Flame' in effs:
            return
        self.magick -= self.arcane_dict['Wreathed_in_Flame'].cost
        spell = self.arcane_dict['Wreathed_in_Flame']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/hatred.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Wreathed_in_Flame'] = Vis(name = 'Wreathed_in_Flame', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Wreathed in Flame', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Wreathed in Flame', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick', tags = 'text')
        ent = app.ent_dict[id]
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Resist Fire, 6 fire dmg attacker', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Resist Fire, 6 fire dmg attacker', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick', tags = 'text')
        def wreathed_resist(types):
            return types+['fire']
        p = partial(wreathed_resist)
        ent.resist_effects.append(p)
        def wreathed_def(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                lock(apply_damage, dfndr, atkr, -6, 'fire', 'Flame Shield', 'redirect')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p2 = partial(wreathed_def)
        ent.defense_effects.append(p2)
        def wreathed_weak(types):
            return [t for t in types if t != 'fire']
        p3 = partial(wreathed_weak)
        ent.weak_effects.append(p3)
        def undo(ent, p, p2, p3, lockname = None):
            ent.resist_effects.remove(p)
            ent.defense_effects.remove(p2)
            ent.weak_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p, p2, p3)
        n = 'Wreathed_in_Flame' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Wreathed_in_Flame', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), vis = 'Wreathed_in_Flame_Effect')
        root.after(2666, lambda  name = 'Wreathed_in_Flame' : self.cleanup_spell(name = name))
      
      
    def fists_of_stone(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fists_of_stone(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Fists of Stone', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fists_of_stone(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fists_of_stone(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Fists_of_Stone' in effs:
            return
        self.magick -= self.arcane_dict['Fists_of_Stone'].cost
        spell = self.arcane_dict['Fists_of_Stone']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/hatred.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Fists_of_Stone'] = Vis(name = 'Fists_of_Stone', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Fists of Stone', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Fists of Stone', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        ent = app.ent_dict[id]
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Crushing attack', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Crushing attack', justify = 'center', font = ('chalkduster', 14), fill = 'green', tags = 'text')
        def crush_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'crushing'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(crush_atk)
        ent.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'fists_of_stone' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Fists_of_Stone', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, lambda  name = 'Fists_of_Stone' : self.cleanup_spell(name = name))
      
    def fangs_of_apophis(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fangs_of_apophis(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Fangs of Apophis', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fangs_of_apophis(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fangs_of_apophis(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Fangs_of_Apophis' in effs:
            return
        self.magick -= self.arcane_dict['Fangs_of_Apophis'].cost
        spell = self.arcane_dict['Fangs_of_Apophis']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/hatred.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Fangs_of_Apophis'] = Vis(name = 'Fangs_of_Apophis', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Fangs of Apophis', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Fangs of Apophis', justify = 'center', font = ('chalkduster', 14), fill = 'green', tags = 'text')
        ent = app.ent_dict[id]
        def fangs_effect(stat):
            return stat+1
        p = partial(fangs_effect)
        ent.str_effects.append(p)
        ent.agl_effects.append(p)
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 str, agl, poison attack', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 str, agl, poison attack', justify = 'center', font = ('chalkduster', 14), fill = 'green', tags = 'text')
        def fangs_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'poison'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p2 = partial(fangs_atk)
        ent.attack_effects.append(p2)
        def undo(ent, p, p2, lockname = None):
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.attack_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p, p2)
        n = 'Fangs_of_Apophis' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Fangs_of_Apophis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Fangs_of_Apophis' : self.cleanup_spell(name = name))
      
      
    def hatred(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hatred(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Hatred', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hatred(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hatred(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Hatred' in effs:
            return
        self.magick -= self.arcane_dict['Hatred'].cost
        spell = self.arcane_dict['Hatred']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hatred.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Hatred'] = Vis(name = 'Hatred', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Hatred'].img, tags = 'Hatred')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Hatred', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Hatred', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick1', tags = 'text')
        ent = app.ent_dict[id]
        def hatred_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' and len([v for k,v in atkr.effects_dict.items() if v.name == 'Hatred_Strength']) <= 4:
                def hatred_effect(stat):
                    return stat+2
                p = partial(hatred_effect)
                atkr.str_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.str_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, atkr, p)
                n = 'Hatred_Strength' + str(app.count)
                atkr.effects_dict[n] = Effect(name = 'Hatred_Strength', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+84-app.moved_down, text = 'Hatred, +1 str', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+85-app.moved_down, text = 'Hatred, +1 str', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick1', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(hatred_atk)
        ent.attack_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.attack_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Hatred' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Hatred', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Hatred' : self.cleanup_spell(name = name))
        
        
    # target gets -2 psyche for 4 turns (does not stack), takes psyche versus end damage on cast
    def torment(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Torment' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_torment(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Torment', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_torment(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_torment(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/torment.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Torment'].cost
        spell = self.arcane_dict['Torment']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Torment'] = Vis(name = 'Torment', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Torment'].img, tags = 'Torment')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Torment', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Torment', justify = 'center', font = ('chalkduster', 14), fill = 'thistle1', tags = 'text')
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Torment' not in effs:
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+24-app.moved_down, text = '-2 psyche', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+25-app.moved_down, text = '-2 psyche', justify = 'center', font = ('chalkduster', 14), fill = 'thistle1', tags = 'text')
            def torment_effect(stat):
                return max(1,stat-2)
            p = partial(torment_effect)
            ent.psyche_effects.append(p)
            def un(id, func, lockname = None):
                app.ent_dict[id].psyche_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Torment' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Torment', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        my_psyche = self.get_abl('psyche')
        tar_end = ent.get_abl('end')
        d = damage(my_psyche, tar_end)
        lock(apply_damage, self, ent, -d, 'magick', 'Torment', 'spell')
        root.after(333, lambda  name = 'Torment' : self.cleanup_spell(name = name))

    # destroy a summon you own to deal dmg to adj ents
    def pain(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Pain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pain(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Pain', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pain(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pain(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if app.ent_dict[id].owner != self.owner or not isinstance(app.ent_dict[id], Summon):
            return
        effect1 = mixer.Sound('Sound_Effects/pain.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Pain'].cost
        spell = self.arcane_dict['Pain']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Pain'] = Vis(name = 'Pain', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Pain'].img, tags = 'Pain')
        def cleanup_pain():
            del app.vis_dict['Pain']
            app.canvas.delete('Pain')
        root.after(1999, cleanup_pain)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Pain', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Pain', font = ('chalkduster', 14), fill = 'firebrick2', tags = 'text')
#         self.init_cast_anims()
        # kill here and handle death triggers, then make explosion
        loc = app.ent_dict[id].loc[:]
        name = 'dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(333, lambda id = id, name = name : app.kill(id, name))
        root.wait_variable(app.dethloks[name])
        self.continue_pain(loc)
        
    def continue_pain(self, loc):
        adj_ents = [k for k,v in app.all_ents().items() if dist(v.loc,loc)==1]
        all_targets = adj_ents
        for id in all_targets:
            n = 'Pain' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            loc = app.ent_dict[id].loc[:]
            app.vis_dict[n] = Vis(name = 'Pain_Explode', loc = loc)
            def cleanup_vis(name):
                del app.vis_dict[name]
                app.canvas.delete(name)
            root.after(2222, lambda n = n : cleanup_vis(n))
            rand_start_anim = randrange(1,7)
            for i in range(rand_start_anim):
                app.vis_dict[n].rotate_image()
            app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
            # Damage
            my_psyche = self.get_abl('psyche')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_psyche, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'explosive', 'Pain', 'ranged')
        root.after(2333, lambda  name = 'Pain' : self.cleanup_spell(name = name))
        
    # destroy an animal type ent you own, another ent you own gets +1 mental stats (psy, wis, rsn, san)
    def offering(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Offering' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_offering(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Offering Destruction', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_offering(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_offering(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if 'animal' not in ent.get_types():
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.rebind_arrows()
        root.bind('<q>', lambda name = 'Offering' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs, ent1 = ent : self.cont_offering(event = e, sqr = s, sqrs = sqrs, ent1 = ent1))
        b = tk.Button(app.context_menu, text = 'Choose Target For Offering Effect', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs, ent1 = ent : self.cont_offering(e, s, sqrs, ent1))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
            
    def cont_offering(self, event, sqr, sqrs, ent1):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Offering'].cost
        spell = self.arcane_dict['Offering']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Offering', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Offering', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        def cleanup_offering(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        for e in [ent,ent1]:
            n = 'offering'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Offering', loc = e.loc)
            root.after(1666, lambda n = n : cleanup_offering(n))
        lock(app.kill, ent1.id)
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '+1 psy,wis,rsn,san', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '+1 psy,wis,rsn,san', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        def offering_stat(stat):
            return stat+1
        p = partial(offering_stat)
        ent.psyche_effects.append(p)
        ent.wis_effects.append(p)
        ent.rsn_effects.append(p)
        ent.san_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.psyche_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.rsn_effects.remove(p)
            ent.san_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'offering'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Offering', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, lambda  name = 'Offering' : self.cleanup_spell(name = name))
        
    def aftershock(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Aftershock' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_aftershock(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Aftershock', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_aftershock(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aftershock(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Tomb)==False:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Aftershock'].cost
        spell = self.arcane_dict['Aftershock']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Aftershock', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Aftershock', font = ('chalkduster', 14), fill = 'indianred', tags = 'text')
        visited = [ent]
        ents = [ent]
        def cleanup_vis(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def aftershock_loop(ents, visited):
            if ents == []:
                self.cleanup_spell(name = 'Aftershock')
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                loc = ent.loc
                u = 'aftershock'+str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Aftershock', loc = loc)
                lock(apply_damage, self, ent, -4, 'crushing', 'Aftershock', 'spell')
                # get adj
                adj = [v for k,v in app.all_ents().items() if dist(v.loc, loc) == 1 and v not in visited and isinstance(v,Tomb)]
                ents += adj
                visited += adj
                root.after(555, lambda u = u : cleanup_vis(u))
                root.after(555, lambda t = 'text' : app.canvas.delete(t))
                root.after(666, lambda ents = ents, v = visited : aftershock_loop(ents, v))
        aftershock_loop(ents, visited)
        

    def scour(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Scour' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_scour(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Scour', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_scour(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scour(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Tomb)==False or ent.owner != self.owner:
            return
        if ent.imprint == '':
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Scour'].cost
        spell = self.arcane_dict['Scour']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Scour, draw 2', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Scour, draw 2', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        app.vis_dict['Scour'] = Vis(name = 'Scour', loc = ent.loc)
        # rmv imprint
        spl = ent.imprint
        ent.imprint = ''
        if ent.owner == 'p1':
            witch = app.ent_dict[app.p1_witch]
        else:
            witch = app.ent_dict[app.p2_witch]
        spell = witch.arcane_dict[spl]
        witch.arcane_dict[spl] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
        drawn = 0
        for card in self.library[:]:
            self.in_hand.append(card)
            self.library = self.library[1:]
            drawn += 1
            if drawn == 2:
                break
        root.after(1999, lambda n = 'Scour' : self.cleanup_spell(name = n))



    def pillage(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Pillage' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pillage(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Pillage', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pillage(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pillage(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Tomb)==False or ent.owner != self.owner:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Pillage'].cost
        spell = self.arcane_dict['Pillage']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Pillage, +3 magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Pillage, +3 magick', font = ('chalkduster', 14), fill = 'indianred', tags = 'text')
        app.vis_dict['Pillage'] = Vis(name = 'Pillage', loc = ent.loc)
        lock(app.kill, ent.id)
        self.magick += 3
        root.after(1999, lambda n = 'Pillage' : self.cleanup_spell(name = n))
        
    # change to -4 random attr, affect every adj recursively
    def plague(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Plague' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_plague(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Plague', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_plague(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_plague(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        # PLAGUE CANNOT BE STACKED WITH OTHER PLAGUES
        if 'Plague' in app.ent_dict[id].effects_dict.keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Plague'].cost
        spell = self.arcane_dict['Plague']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Plague', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Plague', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        visited = [app.ent_dict[id].id]
        ents = [app.ent_dict[id].id]
        def cleanup_vis(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def plague_loop(ents, visited):
            if ents == []:
                self.cleanup_spell(name = 'Plague')
            else:
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                loc = app.ent_dict[id].loc
                u = 'Plague'+str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Plague', loc = loc)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                def plague_effect(stat):
                    return max(1,stat-4)
                f = plague_effect
                any = choice(range(1,11))
                if any == 1:
                    app.ent_dict[id].str_effects.append(f)
                    ef_type = 'str'
                elif any == 2:
                    app.ent_dict[id].end_effects.append(f)
                    ef_type = 'end'
                elif any == 3:
                    app.ent_dict[id].agl_effects.append(f)
                    ef_type = 'agl'
                elif any == 4:
                    app.ent_dict[id].dodge_effects.append(f)
                    ef_type = 'dodge'
                elif any == 5:
                    app.ent_dict[id].psyche_effects.append(f)
                    ef_type = 'psyche'
                elif any == 6:
                    app.ent_dict[id].rsn_effects.append(f)
                    ef_type = 'rsn'
                elif any == 7:
                    app.ent_dict[id].wis_effects.append(f)
                    ef_type = 'wis'
                elif any == 8:
                    app.ent_dict[id].san_effects.append(f)
                    ef_type = 'san'
                elif any == 9:
                    app.ent_dict[id].init_effects.append(f)
                    ef_type = 'init'
                elif any == 10:
                    app.ent_dict[id].mm_effects.append(f)
                    ef_type = 'mm'
                app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-4 '+ef_type, font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-4 '+ef_type, font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                def un(i, ef_type, lockname = None):
                    if ef_type == 'str':
                        app.ent_dict[i].str_effects.remove(plague_effect)
                    elif ef_type == 'end':
                        app.ent_dict[i].end_effects.remove(plague_effect)
                    elif ef_type == 'agl':
                        app.ent_dict[i].agl_effects.remove(plague_effect)
                    elif ef_type == 'dodge':
                        app.ent_dict[i].dodge_effects.remove(plague_effect)
                    elif ef_type == 'psyche':
                        app.ent_dict[i].psyche_effects.remove(plague_effect)
                    elif ef_type == 'wis':
                        app.ent_dict[i].wis_effects.remove(plague_effect)
                    elif ef_type == 'rsn':
                        app.ent_dict[i].rsn_effects.remove(plague_effect)
                    elif ef_type == 'san':
                        app.ent_dict[i].san_effects.remove(plague_effect)
                    elif ef_type == 'init':
                        app.ent_dict[i].init_effects.remove(plague_effect)
                    elif ef_type == 'mm':
                        app.ent_dict[i].mm_effects.remove(plague_effect)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p_undo = partial(un, id, ef_type)
                n = 'Plague' + str(app.count)
                app.ent_dict[id].effects_dict['Plague'] = Effect(name = 'Plague', undo_func = p_undo, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                # get adj
                adj = [k for k,v in app.all_ents().items() if dist(v.loc, loc) == 1 and k not in visited]
                adj = [id for id in adj if 'Plague' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]]
                ents += adj
                visited += adj
                root.after(1999, lambda u = u : cleanup_vis(u))
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ents = ents, v = visited : plague_loop(ents, v))
        plague_loop(ents, visited)

    def hallowed_ground(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Hallowed_Ground' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hallowed_ground(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Hallowed Ground', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hallowed_ground(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hallowed_ground(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/plague.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Hallowed_Ground'].cost
        spell = self.arcane_dict['Hallowed_Ground']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Hallowed Ground', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Hallowed Ground', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        def cleanup_enmesh(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        locs = [c for c in app.coords if dist(c,sqr) <= 2]
        ents = [v for k,v in app.all_ents().items() if v.loc in locs and isinstance(v,Tomb) and 'Hallowed_Ground' not in [j.name for i,j in v.effects_dict.items()]]
        def hallowed_loop(ents):
            if ents == []:
                self.cleanup_spell(name = 'Hallowed_Ground')
            else:
                ent = ents[0]
                ents = ents[1:]
                un = 'Hallowed_Ground'+str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Hallowed_Ground', loc = ent.loc[:])
                root.after(1777, lambda un = un : cleanup_enmesh(un))
                app.get_focus(ent.id)
                def hallowed_types(ts):
                    return ts+['psyshield','invisibility']
                p = partial(hallowed_types)
                ent.type_effects.append(p)
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Psyshield, invisibility', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Psyshield, invisibility', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
                def un(ent, p, lockname = None):
                    ent.type_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, ent, p)
                n = 'hallowed' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Hallowed_Ground', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ents = ents : hallowed_loop(ents))
        hallowed_loop(ents)

    def enmeshing_coils(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Enmeshing_Coils' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_enmeshing_coils(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Enmeshing Coils', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_enmeshing_coils(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enmeshing_coils(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/plague.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Enmeshing_Coils'].cost
        spell = self.arcane_dict['Enmeshing_Coils']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Enmeshing Coils', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Enmeshing Coils', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        def cleanup_enmesh(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        locs = [c for c in app.coords if dist(c,sqr) <= 1]
        for s in locs:
            name = 'Enmeshing_Coils'+str(app.count)
            app.count += 1
            app.vis_dict[name] = Vis(name = 'Enmeshing_Coils', loc = s[:])
            root.after(1777, lambda n = name : cleanup_enmesh(n))
        def enmesh_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Enmeshing_Coils')
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                ent = app.ent_dict[id]
                def enmesh_efct(stat):
                    return max(1,stat-3)
                p = partial(enmesh_efct)
                ent.agl_effects.append(p)
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-3 agility', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-3 agility', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                def un(ent, p, lockname = None):
                    ent.agl_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, ent, p)
                n = 'Enmeshing_Coils' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Enmeshing_Coils', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ids = ids : enmesh_loop(ids))
        ids = [k for k,v in app.all_ents().items() if v.loc in locs and 'Enmeshing_Coils' not in [j.name for i,j in v.effects_dict.items()]]
        enmesh_loop(ids)

            
    # PSIONIC PUSH
    def psionic_push(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Psionic_Push' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_psionic_push(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Psionic Push', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_psionic_push(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psionic_push(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        # cannot target immovable
        if app.ent_dict[id].immovable == True:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Psionic_Push'].cost
        spell = self.arcane_dict['Psionic_Push']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        loc = app.ent_dict[id].loc[:]
        ps = []
        ps.append(loc)
        for c in app.coords:
            if c[0] == (loc[0] + 1) and c[1] == loc[1] and app.grid[c[0]][c[1]] == '':
                ps.append(c)
                n = [loc[0]+2, loc[1]]
                if n in app.coords:
                    if n[0] == (loc[0] + 2) and n[1] == loc[1] and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == (loc[0] - 1) and c[1] == loc[1] and app.grid[c[0]][c[1]] == '':
                n = [loc[0]-2, loc[1]]
                ps.append(c)
                if n in app.coords:
                    if n[0] == (loc[0] - 2) and n[1] == loc[1] and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == loc[0] and c[1] == (loc[1] + 1) and app.grid[c[0]][c[1]] == '':
                n = [loc[0], loc[1]+2]
                ps.append(c)
                if n in app.coords:
                    if n[0] == loc[0] and n[1] == (loc[1] + 2) and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == loc[0] and c[1] == (loc[1] - 1) and app.grid[c[0]][c[1]] == '':
                n = [loc[0], loc[1]-2]
                ps.append(c)
                if n in app.coords:
                    if n[0] == loc[0] and n[1] == (loc[1] - 2) and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
        app.animate_squares(ps)
        root.bind('<a>', lambda e, id = id, s = grid_pos, sqrs = ps : self.choose_psi_square(event = e, id = id, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Square to Push', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, id = id, s = grid_pos, sqrs = ps : self.choose_psi_square(e, id, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
            
    def choose_psi_square(self, event, id, sqr, sqrs):
        global selected, selected_vis
        if sqr not in sqrs:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/psionic_push.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        start_loc = app.ent_dict[id].loc[:]
        app.vis_dict['Psionic_Push'] = Vis(name = 'Psionic_Push', loc = start_loc)
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Psionic_Push'].img, tags = 'Psionic_Push')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Psionic Push', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Psionic Push', font = ('chalkduster', 14), fill = 'lightgreen', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        if start_loc != sqr:
            selected = [id]
            selected_vis = ['Psionic_Push']
        def psi_move_loop(vis, ent, x, y, endx, endy, sqr, start_sqr):
            app.vis_dict[vis].rotate_image()
            app.canvas.delete(vis)
            app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = 'Psionic_Push')
            if x % 25 == 0 and y % 25 == 0:
                app.ent_dict[ent].rotate_image()
                app.canvas.delete(ent)
                app.canvas.create_image(x, y, image = app.ent_dict[ent].img, tags = app.ent_dict[ent].tags)
            if x > endx:
                x -= 10
                app.canvas.move(vis, -10, 0)
                app.canvas.move(ent, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(vis, 10, 0)
                app.canvas.move(ent, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(vis, 0, -10)
                app.canvas.move(ent, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(vis, 0, 10)
                app.canvas.move(ent, 0, 10)
            app.canvas.tag_raise(vis)
            try: app.canvas.tag_lower(app.ent_dict[ent].tags, 'large')
            except: pass
            app.canvas.tag_lower(app.ent_dict[ent].tags, 'maptop')
            if x == endx and y == endy:
                root.after(666, lambda e = ent, s = sqr, ss = start_sqr : self.finish_psionic_push(tar = e, end_loc = s, start_loc = ss))
            else:
                root.after(50, lambda p = 'Psionic_Push', id = id, x = x, y = y, endx = endx, endy = endy, s = sqr, s2 = start_sqr : psi_move_loop(p, id, x, y, endx, endy, s, s2))
        if sqr == start_loc:
            self.finish_psionic_push(id, sqr, start_loc)
        else:
            psi_move_loop('Psionic_Push', id, x, y, endx, endy, sqr, start_loc)
        
    def finish_psionic_push(self, tar, end_loc, start_loc):
        global selected, selected_vis
        ent1 = app.ent_dict[tar]
        tar_str = ent1.get_abl('str')
        ent1.loc = end_loc[:]
        app.grid[start_loc[0]][start_loc[1]] = ''
        app.grid[end_loc[0]][end_loc[1]] = ent1.id
        ents = [v for k,v in app.all_ents().items() if dist(ent1.loc,v.loc)<=1]
        def psi_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Psionic_Push')
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                if ent.save_check('agl', mod = 1) == 'Fail':
                    d = damage(tar_str, ent.get_abl('end'))
                    lock(apply_damage, ent1, ent, -d, 'crushing', 'Psionic Push', 'melee')
                    root.after(111, lambda ids = ids : psi_loop(ids))
                else:# Miss
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : psi_loop(ids))
        adj_ids = [k for k,v in app.all_ents().items() if dist(v.loc,ent1.loc)==1]
        if adj_ids == []:
            self.cleanup_spell(name = 'Psionic_Push')
        else:
            psi_loop([e.id for e in ents])
        
    # deal dmg to targ and w/i r3 of targ, decr dmg with distance, main targ gets death_trigger pass this death_trigger EOT 1 spirit
    def pestilence(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pestilence(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Area For Pestilence', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pestilence(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pestilence(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         id = app.grid[sqr[0]][sqr[1]]
#         if id == '' or id == 'block':
#             return
        loc = sqr[:]
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/pestilence.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Pestilence'].cost
        spell = self.arcane_dict['Pestilence']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         self.init_cast_anims()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 16), fill = 'gray75', tags = 'text')
        # do all vis now, staggered
        def pestil_vis_loop(index):
            for sqr in [s for s in app.coords if dist(s, loc) == index]:
                n = 'Pestilence' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Pestilence', loc = sqr[:])
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1666, lambda n = n : cleanup_vis(n))
            if index == 3:
                ents = [k for k,v in app.all_ents().items() if dist(v.loc, loc) <= 3]
                self.continue_pestilence(ents, loc)
            else:
                root.after(666, lambda j = index+1 : pestil_vis_loop(j))
        pestil_vis_loop(0)
        
    # dmg ents based on dist from sqr (main target)
    def continue_pestilence(self, ents, sqr):
        def pestil_loop(ents):
            if ents == []:
                self.cleanup_spell(name = 'Pestilence')
            else:
                id = ents[0]
                ents = ents[1:]
                loc = app.ent_dict[id].loc[:]
                app.focus_square(loc)
                # DAMAGE
                my_psyche = self.get_abl('psyche')
                tar_psyche = app.ent_dict[id].get_abl('psyche')
                d = damage(my_psyche, tar_psyche)
                d -= dist(loc, sqr)*2
                if d < 1:
                    d = 1
                lock(apply_damage, self, app.ent_dict[id], -d, 'poison', 'Pestilence', 'spell')
                if id in app.all_ents().keys() and app.ent_dict[id].loc == sqr and 'Pestilence' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    def pestil_death_trigger(obj = None, lockname = None):
                        adj = [k for k,v in app.all_ents().items() if dist(v.loc, obj.loc) == 1 and 'Pestilence' not in [j.name for i,j in v.effects_dict.items()]]
                        for id,s in [(k,v.loc) for k,v in app.all_ents().items() if k in adj]:
                            # INNER effect given by death trigger of original target
                            n = 'Pestilence' + str(app.count) # not an effect, just need unique int
                            app.count += 1 # that is why this is incr manually here, no Effect init
                            app.vis_dict[n] = Vis(name = 'Pestilence', loc = s[:])
                            app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+74-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                            app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+75-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
                            def cleanup_vis(name):
                                del app.vis_dict[name]
                                app.canvas.delete(name)
                                app.canvas.delete('text')
                            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                            root.after(888, lambda n = n : cleanup_vis(n))
                            p_inner = partial(pestil_death_trigger, app.ent_dict[id])
                            def dt_undo(lockname = None):
                                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            dt = Death_Trigger(name = 'Pestilence', level = self.get_abl('wis'), undo_func = dt_undo, dt = p_inner)
                            app.ent_dict[id].death_triggers.append(dt)
                            def un(id, ts, lockname = None):
                                for dt in app.ent_dict[id].death_triggers[:]:
                                    if dt.ts == ts:
                                        app.ent_dict[id].death_triggers.remove(dt)
                                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            u = partial(un, id, dt.ts)
                            def take_3(tar, lockname = None):
                                app.get_focus(tar)
                                lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pestilence', 'eot')
                                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            eot = partial(take_3, id)
                            n = 'Pestilence' + str(app.count)
                            app.ent_dict[id].effects_dict[n] = Effect(name = 'Pestilence', eot_func = eot, undo_func = u, duration = self.get_abl('rsn')*2, level = self.get_abl('wis'))
                        root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
                    # END inner effect passed on death trigger
                    p_death = partial(pestil_death_trigger, app.ent_dict[id])
                    def dt_undo(lockname = None):
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    dt = Death_Trigger(name = 'Pestilence', level = self.get_abl('wis'), undo_func = dt_undo, dt = p_death)
                    app.ent_dict[id].death_triggers.append(dt)
                    def un(id, ts, lockname = None):
                        for dt in app.ent_dict[id].death_triggers[:]:
                            if dt.ts == ts:
                                app.ent_dict[id].death_triggers.remove(dt)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, dt.ts)
                    # EOT FUNC
                    def take_3(tar, lockname = None):
                        app.get_focus(tar)
                        lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pestilence', 'eot')
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    eot = partial(take_3, id)
                    n = 'Pestilence' + str(app.count)
                    app.ent_dict[id].effects_dict[n] = Effect(name = 'Pestilence', eot_func = eot, undo_func = u, duration = self.get_abl('rsn')*2, level = self.get_abl('wis'))
                root.after(555, lambda t = 'text' : app.canvas.delete(t))
                root.after(666, lambda ents = ents : pestil_loop(ents))
        app.canvas.delete('text')
        pestil_loop(ents)
    
    # CURSE OF ORIAX
    def curse_of_oriax(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_curse_of_oriax(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Curse of Oriax', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_curse_of_oriax(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_curse_of_oriax(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Curse_of_Oriax' in effs:
            return
        self.magick -= self.arcane_dict['Curse_of_Oriax'].cost
        spell = self.arcane_dict['Curse_of_Oriax']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/curse_of_oriax.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+19-app.moved_down, text = 'Curse\nof\nOriax', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+20-app.moved_down, text = 'Curse\nof\nOriax', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Curse_of_Oriax'].img, tags = 'Curse_of_Oriax')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+99-app.moved_down, text = '-1 psy,wis,rsn,san,init', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+100-app.moved_down, text = '-1 psy,wis,rsn,san,init', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # DO Curse_of_Oriax EFFECTS
        def curse_of_oriax_effect(stat):
            stat -= 1
            if stat < 1:
                return 1
            else:
                return stat
        f = curse_of_oriax_effect
        app.ent_dict[id].psyche_effects.append(f)
        app.ent_dict[id].wis_effects.append(f)
        app.ent_dict[id].rsn_effects.append(f)
        app.ent_dict[id].san_effects.append(f)
        app.ent_dict[id].init_effects.append(f)
        def un(i, lockname = None):
            app.ent_dict[i].psyche_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].wis_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].rsn_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].san_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].init_effects.remove(curse_of_oriax_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        # EOT FUNC
        def take_2(tar, lockname = None):
            app.get_focus(tar)
            lock(apply_damage, self, app.ent_dict[tar], -2, 'magick', 'Curse of Oriax', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(take_2, id)
        n = 'Curse_of_Oriax' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Curse_of_Oriax', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3666, lambda  name = 'Curse_of_Oriax' : self.cleanup_spell(name = name))
        


    def dampening_emanation(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dampening_emanation(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dampening Emanation', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dampening_emanation(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dampening_emanation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if 'Dampening_Emanation' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Dampening_Emanation'].cost
        spell = self.arcane_dict['Dampening_Emanation']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Dampening_Emanation'] = Vis(name = 'Dampening_Emanation', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Dampening Emanation', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Dampening Emanation', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def damp_ef(stat):
            return max(0,stat-3)
        p = partial(damp_ef)
        prox_ef = Proximity_Effect(name = 'Dampening_Emanation', ent = ent, range = (1,2), abls = ['move_range'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys()]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Dampening_Emanation'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Dampening_Emanation' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Dampening_Emanation', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Dampening Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Dampening Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Dampening_Emanation' : self.cleanup_spell(name = name))


        
    def aura_of_agony(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_aura_of_agony(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Aura of Agony', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_aura_of_agony(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aura_of_agony(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if 'Aura_of_Agony' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Aura_of_Agony'].cost
        spell = self.arcane_dict['Aura_of_Agony']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Aura_of_Agony'] = Vis(name = 'Aura_of_Agony', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Aura of Agony', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Aura of Agony', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def aura_ag_ef(stat):
            return max(1,stat-3)
        p = partial(aura_ag_ef)
        prox_ef = Proximity_Effect(name = 'Aura_of_Agony', ent = ent, range = (1,2), abls = ['san'], abl_func = p)
        
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        
        prx_name = 'Aura_of_Agony'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Aura_of_Agony' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Aura_of_Agony', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Agonizing Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Agonizing Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Aura_of_Agony' : self.cleanup_spell(name = name))
        
        
    def molecular_subversion(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_molecular_subversion(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Molecular Subversion', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_molecular_subversion(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_molecular_subversion(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Molecular_Subversion' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Molecular_Subversion'].cost
        spell = self.arcane_dict['Molecular_Subversion']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Molecular_Subversion'] = Vis(name = 'Molecular_Subversion', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Molecular_Subversion'].img, tags = 'Molecular_Subversion')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Molecular Subversion', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Molecular Subversion', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def molsub_resist_effect(rs):
            return [r for r in rs if r != 'acid' and r != 'explosive']
        app.ent_dict[id].resist_effects.append(molsub_resist_effect)
        def molsub_wkns_effect(ws):
            return ws + ['acid', 'explosive']
        app.ent_dict[id].weak_effects.append(molsub_wkns_effect)
        def un(i, lockname = None):
            app.ent_dict[i].resist_effects.remove(molsub_resist_effect)
            app.ent_dict[i].weak_effects.remove(molsub_wkns_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = 'Molecular_Subversion' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Molecular_Subversion', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = 'Weak explsv and acid', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = 'Weak explsv and acid', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Molecular_Subversion' : self.cleanup_spell(name = name))
        
        
    def lift(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_lift(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Lift', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_lift(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_lift(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.magick -= self.arcane_dict['Lift'].cost
        spell = self.arcane_dict['Lift']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Lift'] = Vis(name = 'Lift', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Lift', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Lift', justify = 'center', font = ('chalkduster', 16), fill = 'olivedrab2', tags = 'text')
        def lift_ef(move_type):
            return 'flying'
        p = partial(lift_ef)
        ent.move_type_effects.append(p)
        def un(ent, p, lockname = None):
            ent.move_type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Lift' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Lift', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = 'Flying', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = 'Flying', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Lift' : self.cleanup_spell(name = name))
        
        
    def cloister(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_cloister(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Cloister', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_cloister(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cloister(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        self.magick -= self.arcane_dict['Cloister'].cost
        spell = self.arcane_dict['Cloister']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/lift.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Cloister'] = Vis(name = 'Cloister', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Cloister', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Cloister', justify = 'center', font = ('chalkduster', 16), fill = 'olivedrab2', tags = 'text')
        for k,v in ent.effects_dict.items():
            v.level += 6
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = 'Effects level +6', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = 'Effects level +6', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Cloister' : self.cleanup_spell(name = name))
        
        
    def plutonian_cloak(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_plutonian_cloak(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Plutonian Cloak', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_plutonian_cloak(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_plutonian_cloak(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Plutonian_Cloak' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Plutonian_Cloak'].cost
        spell = self.arcane_dict['Plutonian_Cloak']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Plutonian_Cloak'] = Vis(name = 'Plutonian_Cloak', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Plutonian_Cloak'].img, tags = 'Plutonian_Cloak')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Plutonian Cloak', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Plutonian Cloak', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
        def plut_cloak_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (type == 'slashing' or type == 'crushing' or type == 'piercing') and (st == 'melee' or st == 'ranged'):
                if 'Plutonian_Invisibility' in [v.name for k,v in dfndr.effects_dict.items()]:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
                else:
                    app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Plutonian invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Plutonian invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
                    def plu_invis(types):
                        return types+['invisibility']
                    p = partial(plu_invis)
                    dfndr.type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, dfndr.id, p)
                    n = 'Plutonian_Cloak' + str(app.count)
                    dfndr.effects_dict[n] = Effect(name = 'Plutonian_Invisibility', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            elif st == 'spell':
                if 'Plutonian_Psyshield' in [v.name for k,v in dfndr.effects_dict.items()]:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
                else:
                    def plu_psysh(types):
                        return types+['psyshield']
                    p = partial(plu_psysh)
                    dfndr.type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, dfndr.id, p)
                    n = 'Plutonian_Cloak' + str(app.count)
                    dfndr.effects_dict[n] = Effect(name = 'Plutonian_Psyshield', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Plutonian psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Plutonian psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        app.ent_dict[id].defense_effects.append(plut_cloak_effect)
        def undo(id, lockname = None):
            app.ent_dict[id].defense_effects.remove(plut_cloak_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(undo, id)
        n = 'Plutonian_Cloak' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Plutonian_Cloak', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Plutonian_Cloak' : self.cleanup_spell(name = name))
        
        
        
        
    def mirror_armor(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mirror_armor(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mirror Armor', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mirror_armor(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mirror_armor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Mirror_Armor' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Mirror_Armor'].cost
        spell = self.arcane_dict['Mirror_Armor']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mirror_Armor'] = Vis(name = 'Mirror_Armor', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+54-app.moved_down, text = 'Mirror Armor', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+55-app.moved_down, text = 'Mirror Armor', justify = 'center', font = ('chalkduster', 16), fill = 'cyan3', tags = 'text')
        def mirror_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'spell' and to_hit(atkr.get_abl('wis'),dfndr.get_abl('dodge') == False):
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Mirror Armor reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Mirror Armor reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                ids = [k for k,v in app.all_ents().items() if 1 <= dist(v.loc,dfndr.loc)<=3]
                if ids == []:
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
                else:
                    id = choice(ids)
                    app.get_focus(id)
                    ent = app.ent_dict[id]
                    n = 'Mirror_Armor'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Mirror_Armor', loc = ent.loc[:])
                    def clean_mir(n):
                        del app.vis_dict[n]
                        app.canvas.delete(n)
                    root.after(1666, lambda n = n : clean_mir(n))
                    lock(apply_damage, atkr, ent, amt, type, 'Mirror Redirect', 'redirect')
                    app.get_focus(dfndr.id)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
            else:
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Pierce Mirror Armor', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Pierce Mirror Armor', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                return(amt, type)
        p = partial(mirror_effect)
        ent.defense_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Mirror_Armor' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Mirror_Armor', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Mirror_Armor' : self.cleanup_spell(name = name))
        
    def forcefield(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_forcefield(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Forcefield', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_forcefield(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_forcefield(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Forcefield' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Forcefield'].cost
        spell = self.arcane_dict['Forcefield']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Forcefield'] = Vis(name = 'Forcefield', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+54-app.moved_down, text = 'Forcefield', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+55-app.moved_down, text = 'Forcefield', justify = 'center', font = ('chalkduster', 16), fill = 'cyan3', tags = 'text')
        def mirror_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'ranged' and to_hit(atkr.get_abl('mm'),dfndr.get_abl('dodge') == False):
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Forcefield reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Forcefield reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                ids = [k for k,v in app.all_ents().items() if 1 <= dist(v.loc,dfndr.loc)<=3]
                if ids == []:
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
                else:
                    id = choice(ids)
                    app.get_focus(id)
                    ent = app.ent_dict[id]
                    n = 'Mirror_Armor'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Forcefield', loc = ent.loc[:])
                    def clean_mir(n):
                        del app.vis_dict[n]
                        app.canvas.delete(n)
                    root.after(1666, lambda n = n : clean_mir(n))
                    lock(apply_damage, atkr, ent, amt, type, 'Forcefield Redirect', 'redirect')
                    app.get_focus(dfndr.id)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
            else:
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Pierce Forcefield', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Pierce Forcefield', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                return(amt, type)
        p = partial(mirror_effect)
        ent.defense_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Forcefield' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Forcefield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Forcefield' : self.cleanup_spell(name = name))
        
        
    def genjutsushi(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_genjutsushi(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Genjutsushi', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_genjutsushi(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_genjutsushi(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Genjutsushi' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Genjutsushi'].cost
        spell = self.arcane_dict['Genjutsushi']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Genjutsushi'] = Vis(name = 'Genjutsushi', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+54-app.moved_down, text = 'Genjutsushi', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+55-app.moved_down, text = 'Genjutsushi', justify = 'center', font = ('chalkduster', 16), fill = 'cyan3', tags = 'text')
        def genju_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged') and 'Genju_Invisibility' not in [v.name for k,v in atkr.effects_dict.items()]:
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+74-app.moved_down, text = 'Genjutsushi invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+75-app.moved_down, text = 'Genjutsushi invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                def genju_invis(types):
                    return types+['invisibility']
                p = partial(genju_invis)
                atkr.type_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, atkr, p)
                n = 'Genjutsushi' + str(app.count)
                atkr.effects_dict[n] = Effect(name = 'Genju_Invisibility', undo_func = u, duration = 1, level = atkr.get_abl('agl'))
                root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return(amt, type)
        p = partial(genju_effect)
        ent.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Genjutsushi' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Genjutsushi', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Genjutsushi' : self.cleanup_spell(name = name))
        
        
        
        
    def gift_of_mars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gift_of_mars(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose target for Gift of Mars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gift_of_mars(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gift_of_mars(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Gift_of_Mars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Gift_of_Mars'].cost
        spell = self.arcane_dict['Gift_of_Mars']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gift_of_mars.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Gift_of_Mars'] = Vis(name = 'Gift_of_Mars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Gift_of_Mars'].img, tags = 'Gift_of_Mars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Gift of Mars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Gift of Mars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Msl, MM, Psy', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Msl, MM, Psy', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def gift_of_mars_stat_effect(stat):
            return stat+1
        p = partial(gift_of_mars_stat_effect)
        ent.msl_effects.append(p)
        ent.mm_effects.append(p)
        ent.psyche_effects.append(p)
        def un(ent, p, lockname = None):
            ent.msl_effects.remove(p)
            ent.mm_effects.remove(p)
            ent.psyche_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Gift_of_Mars' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Gift_of_Mars', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Gift_of_Mars' : self.cleanup_spell(name = name))
        
        
        
    def mercurys_blessing(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mercurys_blessing(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose target for Mercury's Blessing", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mercurys_blessing(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mercurys_blessing(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if "Mercury's_Blessing" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict["Mercury's_Blessing"].cost
        spell = self.arcane_dict["Mercury's_Blessing"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/mercurys_blessing.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict["Mercury's_Blessing"] = Vis(name = "Mercury's_Blessing", loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict["Mercury's_Blessing"].img, tags = "Mercury's_Blessing")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = "Mercury's Blessing", justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = "Mercury's Blessing", justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Agl, Dod, Move range', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Agl, Dod, Move range', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def merc_blessing_stat_effect(stat):
            return stat+1
        p = partial(merc_blessing_stat_effect)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        ent.move_range_effects.append(p)
        def un(ent, p, lockname = None):
            ent.agl_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.move_range_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Mercurys_Blessing' + str(app.count)
        ent.effects_dict[n] = Effect(name = "Mercury's_Blessing", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = "Mercury's_Blessing" : self.cleanup_spell(name = name))
        
        
    def iron_spirit(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_iron_spirit(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Iron Spirit', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_iron_spirit(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_iron_spirit(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Iron_Spirit' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Iron_Spirit'].cost
        spell = self.arcane_dict['Iron_Spirit']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/iron_spirit.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Iron_Spirit'] = Vis(name = 'Iron_Spirit', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Iron_Spirit'].img, tags = 'Iron_Spirit')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Iron Spirit', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Iron Spirit', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Str, End, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Str, End, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def iron_spirit_stat_effect(stat):
            return stat+1
        p = partial(iron_spirit_stat_effect)
        ent.str_effects.append(p)
        ent.end_effects.append(p)
        ent.wis_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.end_effects.remove(p)
            ent.wis_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Iron_Spirit' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Iron_Spirit', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Iron_Spirit' : self.cleanup_spell(name = name))
        
    def strength_of_the_void(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_sotv(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Strength of the Void', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_sotv(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_sotv(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Strength_of_the_Void' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Strength_of_the_Void'].cost
        spell = self.arcane_dict['Strength_of_the_Void']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/strength_of_the_void.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Strength_of_the_Void'] = Vis(name = 'Strength_of_the_Void', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Strength_of_the_Void'].img, tags = 'Strength_of_the_Void')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Strength of the Void', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Strength of the Void', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Str, Psy, End', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Str, Psy, End', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def sotv_stat_effect(stat):
            return stat+1
        p = partial(sotv_stat_effect)
        ent.str_effects.append(p)
        ent.psyche_effects.append(p)
        ent.end_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.end_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Sotv' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Strength_of_the_Void', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Strength_of_the_Void' : self.cleanup_spell(name = name))
        
    def quicksilver(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_quicksilver(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Quicksilver', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_quicksilver(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_quicksilver(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'Quicksilver' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Quicksilver'].cost
        spell = self.arcane_dict['Quicksilver']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Quicksilver'] = Vis(name = 'Quicksilver', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Quicksilver', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Quicksilver', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+3 init', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+3 init', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def quicksilver_effect(stat):
            return stat+3
        p = partial(quicksilver_effect)
        ent.init_effects.append(p)
        def un(ent, p, lockname = None):
            ent.init_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'qsilver' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Quicksilver', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Quicksilver' : self.cleanup_spell(name = name))
        
        
    def calm(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_calm(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Calm', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_calm(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_calm(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'Calm' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Calm'].cost
        spell = self.arcane_dict['Calm']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Calm'] = Vis(name = 'Calm', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Calm', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Calm', justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+3 sanity', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+3 sanity', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        def calm_effect(stat):
            return stat+3
        p = partial(calm_effect)
        ent.san_effects.append(p)
        def un(ent, p, lockname = None):
            ent.san_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'calm' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Calm', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Calm' : self.cleanup_spell(name = name))
        
        
    def the_moon(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_moon(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Moon', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_moon(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_moon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.name not in app.summons_list:
            return
        self.magick -= self.arcane_dict['The_Moon'].cost
        spell = self.arcane_dict['The_Moon']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Moon'] = Vis(name = 'The_Moon', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Moon', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Moon', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Create Illusion...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Create Illusion...', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        smn = ent.name
        cs =  [c for c in app.coords if app.grid[c[0]][c[1]]=='']
        if cs == []:
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = 'No available area', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = 'No available area', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, lambda  name = 'The_Moon' : self.cleanup_spell(name = name))
        else:
            loc = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b, cs)
            app.vis_dict['Legerdemain'] = Vis(name = 'Legerdemain', loc = loc[:])
            def cleanup_mn():
                del app.vis_dict['Legerdemain']
                app.canvas.delete('Legerdemain')
            root.after(1666, cleanup_mn)
            img = ImageTk.PhotoImage(Image.open('summon_imgs/'+smn+'.png'))
            if self.owner == 'p1':
                id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
                app.ent_dict[app.p1_witch].summon_ids += 1
            else:
                id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
                app.ent_dict[app.p2_witch].summon_ids += 1
            app.ent_dict[id] =  eval(smn)(name = smn, id = id, img = img, loc = loc[:], owner = self.owner, level = self.level)
#             app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
            app.grid[loc[0]][loc[1]] = id
            app.ent_dict[id].spirit = 1
            clone = app.ent_dict[id]
            clone.str = ent.get_abl('str')
            clone.agl = ent.get_abl('agl')
            clone.end = ent.get_abl('end')
            clone.dodge = ent.get_abl('dodge')
            clone.bls = ent.get_abl('bls')
            clone.mm = ent.get_abl('mm')
            clone.msl = ent.get_abl('msl')
            clone.wis = ent.get_abl('wis')
            clone.psyche = ent.get_abl('psyche')
            clone.rsn = ent.get_abl('rsn')
            clone.san = ent.get_abl('san')
            clone.init = ent.get_abl('init')
            clone.move_range = ent.get_abl('move_range')
            root.after(2111, lambda  name = 'The_Moon' : self.cleanup_spell(name = name))
        
        
    def hidden_from_the_stars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hfts(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Hidden From the Stars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hfts(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hfts(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Hidden_From_the_Stars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Hidden_From_the_Stars'].cost
        spell = self.arcane_dict['Hidden_From_the_Stars']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Hidden_From_the_Stars'] = Vis(name = 'Hidden_From_the_Stars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Hidden_From_the_Stars'].img, tags = 'Hidden_From_the_Stars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Hidden From the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Hidden From the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Agl, Dod, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Agl, Dod, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def hfts_stat_effect(stat):
            return stat+1
        p = partial(hfts_stat_effect)
        ent.wis_effects.append(p)
        ent.dodge_effects.append(p)
        ent.agl_effects.append(p)
        def un(ent, p, lockname = None):
            ent.wis_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.agl_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Hfts' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Hidden_From_the_Stars', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Hidden_From_the_Stars' : self.cleanup_spell(name = name))
        
        
        
    # discard hand, spl tar ent gets +3 phys/ment stats
    def the_devil(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_devil(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Devil', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_devil(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_devil(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'The_Devil' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Devil'].cost
        spell = self.arcane_dict['The_Devil']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['The_Devil'] = Vis(name = 'The_Devil', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Devil, Discard Hand', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Devil, Discard Hand', justify = 'center', font = ('chalkduster', 14), fill = 'indianred', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+3 physical, mental stats', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+3 physical, mental stats', justify = 'center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        self.discard += self.in_hand[:]
        self.in_hand = []
        def devil_stat(stat):
            return stat+3
        p = partial(devil_stat)
        ent.str_effects.append(p)
        ent.agl_effects.append(p)
        ent.end_effects.append(p)
        ent.dodge_effects.append(p)
        ent.wis_effects.append(p)
        ent.psyche_effects.append(p)
        ent.rsn_effects.append(p)
        ent.san_effects.append(p)
        ent.init_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.end_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.rsn_effects.remove(p)
            ent.san_effects.remove(p)
            ent.init_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'the_devil' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'The_Devil', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Devil' : self.cleanup_spell(name = name))
        
        
    def the_high_priestess(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= 3]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_high_priestess(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The High Priestess', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_high_priestess(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_high_priestess(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_High_Priestess'].cost
        spell = self.arcane_dict['The_High_Priestess']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_High_Priestess'] = Vis(name = 'The_High_Priestess', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The High Priestess', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The High Priestess', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        locs = [c for c in app.coords if 1<=dist(c,sqr)<=3]
        ents = [v for k,v in app.all_ents().items() if v.get_abl('wis')>v.get_abl('str') and v.loc in locs and v.owner==self.owner and isinstance(v,Tomb)==False]
        def cleanup_priestess(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def priestess_loop(ents):
            if ents == []:
               root.after(2111, lambda  name = 'The_High_Priestess' : self.cleanup_spell(name = name))
            else:
                ent = ents[0]
                ents = ents[1:]
                n = 'priestess'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'The_High_Priestess', loc = ent.loc)
                root.after(1555, lambda n = n : cleanup_priestess(n))
                amt = 3*len([k for k,v in ent.effects_dict.items()])
                apply_heal(self, ent, amt)
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Heal '+str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Heal '+str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ents = ents : priestess_loop(ents))
        priestess_loop(ents)
        
        
    def justice(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_justice(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Justice', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_justice(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_justice(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if app.num_players == 1:
            return
        if self.owner == 'p1':
            opnt = app.ent_dict[app.p2_witch]
        else:
            opnt = app.ent_dict[app.p1_witch]
        amt = self.summon_cap - opnt.summon_cap
        if amt < 1:
            return
        self.magick -= self.arcane_dict['Justice'].cost
        spell = self.arcane_dict['Justice']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Justice'] = Vis(name = 'Justice', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Justice', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Justice', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        if self.owner == 'p1':
            opnt = app.ent_dict[app.p2_witch]
        else:
            opnt = app.ent_dict[app.p1_witch]
        amt = self.summon_cap - opnt.summon_cap
        amt *= 3
        ents = [v for k,v in app.all_ents().items() if v.name in app.summons_list and v.owner != self.owner]
        def justice_loop(ents):
            if ents == []:
                root.after(111, lambda  name = 'Justice' : self.cleanup_spell(name = name))
            else:
                ent = ents[0]
                ents = ents[1:]
                lock(apply_damage, self, ent, -amt, 'magick', 'Justice', 'spell')
                justice_loop(ents)
        justice_loop(ents)
            
        
        
        
    def the_empress(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= 2]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_empress(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Empress', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_empress(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_empress(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_Empress'].cost
        spell = self.arcane_dict['The_Empress']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Empress'] = Vis(name = 'The_Empress', loc = sqr[:])
        locs = [c for c in app.coords if dist(c,sqr)<=2]
        ents = [v for k,v in app.all_ents().items() if v.get_abl('wis')>v.get_abl('str') and v.loc in locs and v.owner==self.owner and isinstance(v,Tomb)==False]
        count = len(ents)
        while self.library != [] and count > 0:
            self.in_hand.append(self.library[0])
            self.library = self.library[1:]
            count -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Empress, draw '+str(len(ents)), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Empress, draw '+str(len(ents)), justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(2111, lambda  name = 'The_Empress' : self.cleanup_spell(name = name))
        
        
        
    def the_emperor(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_emperor(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Emperor', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_emperor(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_the_emperor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_Emperor'].cost
        spell = self.arcane_dict['The_Emperor']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Emperor'] = Vis(name = 'The_Emperor', loc = sqr[:])
        locs = [c for c in app.coords if 1<=dist(c,sqr)<=2]
        ents = [v for k,v in app.all_ents().items() if v.get_abl('str')>v.get_abl('wis') and v.loc in locs and v.owner==self.owner]
        def cleanup_emperor(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def emperor_loop(ents):
            if ents == []:
                root.after(2111, lambda  name = 'The_Emperor' : self.cleanup_spell(name = name))
            else:
                ent = ents[0]
                ents = ents[1:]
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '+1 acts', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '+1 acts', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
                n = 'emperor'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'The_Emperor', loc = ent.loc)
                root.after(1555, lambda n = n : cleanup_emperor(n))
                def emperor_acts(stat):
                    return stat+1
                p = partial(emperor_acts)
                ent.acts_effects.append(p)
                def undo(ent, p, lockname = None):
                    ent.acts_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                un = 'emperor'+str(app.count)
                ent.effects_dict[un] = Effect(name = 'The_Emperor', undo_func = u, duration = 1, level = self.get_abl('wis'))
                root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                root.after(1777, lambda ents = ents : emperor_loop(ents))
        emperor_loop(ents)
        
        
    def the_tower(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_tower(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Tower', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_tower(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_tower(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_Tower'].cost
        spell = self.arcane_dict['The_Tower']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Tower'] = Vis(name = 'The_Tower', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Tower', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Tower', justify = 'center', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = '-1 stats, draw 2 on undo psy save', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = '-1 stats, draw 2 on undo psy save', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
        def tower_effect(stat):
            return max(1,stat-1)
        p = partial(tower_effect)
        self.str_effects.append(p)
        self.agl_effects.append(p)
        self.end_effects.append(p)
        self.dodge_effects.append(p)
        self.psyche_effects.append(p)
        self.wis_effects.append(p)
        self.rsn_effects.append(p)
        self.san_effects.append(p)
        self.init_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.end_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.rsn_effects.remove(p)
            ent.san_effects.remove(p)
            ent.init_effects.remove(p)
            if isinstance(ent,Witch) and ent.save_check('psyche')=='Pass':
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Draw 2', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Draw 2', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
                count = 0
                while ent.library != []:
                    ent.in_hand.append(ent.library[0])
                    ent.library = ent.library[1:]
                    count += 1
                    if count == 2:
                        break
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1777, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'The Tower psyche fail...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'The Tower psyche fail...', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1777, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p)
        n = 'tower' + str(app.count)
        self.effects_dict[n] = Effect(name = 'The_Tower', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Tower' : self.cleanup_spell(name = name))
        
    # self gets undead, +1 end
    def death(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_death(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Death', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_death(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_death(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Death' in [v.name for k,v in self.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Death'].cost
        spell = self.arcane_dict['Death']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Death'] = Vis(name = 'Death', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Death', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Death', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Undead, +1 end', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Undead +1 end', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def death_effect(stat):
            return stat+1
        p = partial(death_effect)
        self.end_effects.append(p)
        def death_type(ts):
            return ts+['undead']
        p2 = partial(death_type)
        self.type_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.end_effects.remove(p)
            ent.type_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p, p2)
        n = 'death' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Death', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Death' : self.cleanup_spell(name = name))
        
        
    def the_chariot(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_chariot(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Chariot', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_chariot(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_chariot(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'The_Chariot' in [v.name for k,v in self.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Chariot'].cost
        spell = self.arcane_dict['The_Chariot']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Chariot'] = Vis(name = 'The_Chariot', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Chariot', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Chariot', justify = 'center', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = '+1 move range, ethereal', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = '+1 move range, ethereal', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
        def chariot_move(stat):
            return stat+1
        p = partial(chariot_move)
        self.move_range_effects.append(p)
        def chariot_move_type(type):
            return 'ethereal'
        p2 = partial(chariot_move_type)
        self.move_type_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.move_range_effects.remove(p)
            ent.move_type_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p, p2)
        n = 'chariot' + str(app.count)
        self.effects_dict[n] = Effect(name = 'The_Chariot', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Chariot' : self.cleanup_spell(name = name))
        
        
    # all undead type range 0-3 have all efcts displ mod+6
    def the_sun(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_sun(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm The Sun', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_sun(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_sun(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_Sun'].cost
        spell = self.arcane_dict['The_Sun']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Sun'] = Vis(name = 'The_Sun', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Sun', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Sun', justify = 'center', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        locs = [c for c in app.coords if dist(c,sqr)<=3]
        ents = [v for k,v in app.all_ents().items() if v.loc in locs and 'undead' in v.get_types()]
        def cleanup_sun(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def sun_loop(ents):
            if ents == []:
                root.after(111, lambda  name = 'The_Sun' : self.cleanup_spell(name = name))
            else:
                ent = ents[0]
                ents = ents[1:]
                n = 'sun'+str(app.count)
                app.vis_dict[n] = Vis(name = 'The_Sun', loc = ent.loc)
                root.after(1555, lambda n = n : cleanup_sun(n))
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')+6) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                root.after(1777, lambda ents = ents : sun_loop(ents))
        sun_loop(ents)
        
        
        
        
    def iron_skins(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_iron_skins(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Iron Skins', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_iron_skins(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_iron_skins(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        tombs = [v for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner==self.owner and v.imprint == 'Iron_Skins']
        if tombs == []:
            return
        self.magick -= self.arcane_dict['Iron_Skins'].cost
        spell = self.arcane_dict['Iron_Skins']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        tomb = choice(tombs)
        lock(app.kill, tomb.id)
        app.vis_dict['Iron_Skins'] = Vis(name = 'Iron_Skins', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Iron Skins', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Iron Skins', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Defense effect\n reduce non-crushing damage to 1 and -1 duration', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Defense effect\n reduce non-crushing damage to 1 and -1 duration', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def iron_skin(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged' or st == 'spell') and type != 'crushing':
                if amt < 0:
                    amt = -1
                # -1 Duration
                to_remove = []
                for k,v in dfndr.effects_dict.items():
                    if v.name == 'Iron_Skin':
                        v.duration -= 1
                        if v.duration == 0:
                            to_remove.append((k,v))
                        break
                if to_remove != []:
                    lock(to_remove[0][1].undo_func)
                    del dfndr.effects_dict[to_remove[0][0]]
                # remove 1 iron skin
#                 to_remove = []
#                 for k,ef in dfndr.effects_dict.items():
#                     if ef.name == 'Iron_Skins':
#                         to_remove.append((k,ef))
#                         break
#                 lock(ef.undo_func)
#                 del dfndr.effects_dict[k]
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Reduce damage\n -1 Iron Skins Duration', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Reduce damage\n -1 Iron Skins Duration', justify ='center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(iron_skin)
        self.defense_effects.append(p)
        def un(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p)
        n = 'ironskin' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Iron_Skin', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), vis = 'Iron_Skin')
#         n = 'ironskin' + str(app.count)
#         app.count += 1
#         self.effects_dict[n] = Effect(name = 'Iron_Skin', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), vis = 'Iron_Skin')
#         n = 'ironskin' + str(app.count)
#         app.count += 1
#         self.effects_dict[n] = Effect(name = 'Iron_Skin', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), vis = 'Iron_Skin')
        root.after(2111, lambda  name = 'Iron_Skins' : self.cleanup_spell(name = name))
        
        
    # redirect crushing dmg to each adj
    def inertia(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_inertia(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Inertia', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_inertia(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_inertia(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'Inertia' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Inertia'].cost
        spell = self.arcane_dict['Inertia']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Inertia'] = Vis(name = 'Inertia', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Inertia', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Inertia', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Redirect crushing...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Redirect crushing...', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def inertia_def(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged' or st == 'spell') and type == 'crushing':
                if amt < 0:
                    ents = [v for k,v in app.all_ents().items() if dist(dfndr.loc,v.loc)==1]
                    def inertia_loop(ents):
                        if ents == []:
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            return (0, type)
                        else:
                            ent = ents[0]
                            ents = ents[1:]
                            app.get_focus(ent.id)
                            lock(apply_damage, dfndr, ent, amt, 'crushing', 'Inertia', 'redirect')
                            inertia_loop(ents)
                    inertia_loop(ents)
                    # function execution of inertia_loop() is returned as 'amount,type' in apply_damage()...here
                    # last exit of caller is exe of inertia_loop, which returns None?
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(inertia_def)
        ent.defense_effects.append(p)
        def un(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'inertia' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Inertia', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Inertia' : self.cleanup_spell(name = name))
        
        
        
        
    def the_fool(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_fool(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Fool', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_fool(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_fool(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if ent.owner != self.owner:
            return
        if 'The_Fool' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Fool'].cost
        spell = self.arcane_dict['The_Fool']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Fool'] = Vis(name = 'The_Fool', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Fool', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Fool', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '1 wis, attacks incr wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '1 wis, attacks incr wis', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def fool_wis(stat):
            return 1
        p = partial(fool_wis)
        ent.wis_effects.append(p)
        def fool_def(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                if amt < 0:
                    wis = dfndr.get_abl('wis')
                    amt = max(-wis,amt)
                def fool_wis_def(stat):
                    return stat+1
                p = partial(fool_wis_def)
                dfndr.wis_effects.append(p)
                def undo(ent, p, lockname = None):
                    ent.wis_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, dfndr, p)
                n = 'fool_wis'+str(app.count)
                app.count += 1
                dfndr.effects_dict[n] = Effect(name = 'Fool_wisdom', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = '+1 wisdom, damage reduced', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = '+1 wisdom, damage reduced', justify ='center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p2 = partial(fool_def)
        ent.defense_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.wis_effects.remove(p)
            ent.defense_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'fool' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'The_Fool', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Fool' : self.cleanup_spell(name = name))
        
        
    def the_hermit(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_hermit(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Hermit', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_hermit(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_hermit(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if ent.owner != self.owner:
            return
        if 'The_Hermit' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Hermit'].cost
        spell = self.arcane_dict['The_Hermit']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Hermit'] = Vis(name = 'The_Hermit', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Hermit', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Hermit', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-2 phys stats, invisibility, psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-2 phys stats, invisibility, psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def hermit_stats(stat):
            return max(1,stat-2)
        p = partial(hermit_stats)
        ent.str_effects.append(p)
        ent.end_effects.append(p)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        def hermit_types(ts):
            return ts+['psyshield','invisibility']
        p2 = partial(hermit_types)
        ent.type_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.str_effects.remove(p)
            ent.end_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.type_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'hermit' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'The_Hermit', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Hermit' : self.cleanup_spell(name = name))
        
        
        
    def the_hanged_man(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s)==1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_hanged_man(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Hanged Man', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_hanged_man(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_hanged_man(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'The_Hanged_Man' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Hanged_Man'].cost
        spell = self.arcane_dict['The_Hanged_Man']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Hanged_Man'] = Vis(name = 'The_Hanged_Man', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Hanged Man', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Hanged Man', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Move range reduce to 2, +2 wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Move range reduce to 2, +2 wis', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def hanged_move(stat):
            return min(2,stat)
        p = partial(hanged_move)
        ent.move_range_effects.append(p)
        def hanged_stat(stat):
            return stat+2
        p2 = partial(hanged_stat)
        ent.wis_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.move_range_effects.remove(p)
            ent.wis_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'hanged' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'The_Hanged_Man', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Hanged_Man' : self.cleanup_spell(name = name))
        
        
        
    # tar gets def efct, on wis save check, recalc dmg amt using dfndr str and end
    def strength(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_strength(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Strength', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_strength(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_strength(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'Strength' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Strength'].cost
        spell = self.arcane_dict['Strength']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Strength'] = Vis(name = 'Strength', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Strength', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Strength', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Def efct, wis save recalc dmg', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Def efct, wis save recalc dmg', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def strength_def(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged' or st == 'spell') and dfndr.save_check('wis')=='Pass':
                if amt < 0:
                    amt = damage(dfndr.get_abl('str'),dfndr.get_abl('end'))
                    amt = 0-amt
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Strength, recalc damage', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Strength, recalc damage', justify ='center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Strength wisdom save fail', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Strength wisdom save fail', justify ='center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(strength_def)
        ent.defense_effects.append(p)
        def un(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'strength' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Strength', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Strength' : self.cleanup_spell(name = name))
        
        
    def the_lovers(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_lovers(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For The Lovers', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_lovers(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_lovers(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        if 'The_Lovers' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['The_Lovers'].cost
        spell = self.arcane_dict['The_Lovers']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['The_Lovers'] = Vis(name = 'The_Lovers', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'The Lovers', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'The Lovers', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Melee, ranged, and spell atk and def reduced max 2', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Melee, ranged, and spell atk and def reduced max 2', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        def lovers_def(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                amt = max(-2,amt)
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'The Lovers, reduce damage', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'The Lovers, reduce damage', justify ='center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(lovers_def)
        ent.defense_effects.append(p)
        def lovers_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                amt = max(-2,amt)
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'The Lovers, reduce damage', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'The Lovers, reduce damage', justify ='center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p2 = partial(lovers_atk)
        ent.attack_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.defense_effects.remove(p)
            ent.attack_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'lovers' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'The_Lovers', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'The_Lovers' : self.cleanup_spell(name = name))
        
        
    def animate_tomb(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_animate_tomb(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Animate Tomb', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_animate_tomb(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_animate_tomb(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if not isinstance(ent, Tomb):
            return
        if 'Animate_Tomb' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Animate_Tomb'].cost
        spell = self.arcane_dict['Animate_Tomb']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Animate_Tomb'] = Vis(name = 'Animate_Tomb', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Animate Tomb', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Animate Tomb', justify = 'center', font = ('chalkduster', 14), fill = 'wheat2', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Move, crushing atk', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Move, crushing atk', justify = 'center', font = ('chalkduster', 13), fill = 'wheat2', tags = 'text')
        # ADD MOVE
        def add_move(actions = None, ent = None):
            actions['Move'] = ent.move
            return actions
        p = partial(add_move, ent = ent)
        ent.action_effects.append(p)
        # +4 str, agl, mv rng
        def animate_stat(stat):
            return stat+4
        p2 = partial(animate_stat)
        ent.str_effects.append(p2)
        ent.agl_effects.append(p2)
        ent.move_range_effects.append(p2)
        # Melee crsh atk
        def tomb_bash(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [s for s in app.coords if dist(s,obj.loc) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Choose target for Bash', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/psi_slash.ogg')
#                 effect1.set_volume(app.effects_volume.get())
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = ent.loc[:]
                app.vis_dict['Tomb_Bash'] = Vis(name = 'Tomb_Bash', loc = visloc)
                def cleanup_vis():
                    app.canvas.delete('text')
                    try:
                        del app.vis_dict['Tomb_Bash']
                        app.canvas.delete('Tomb_Bash')
                    except: pass
                my_agl = obj.get_abl('agl')
                target_agl = ent.get_abl('agl')
                if to_hit(my_agl, target_agl) == True:
                    my_str = obj.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    root.after(1666, cleanup_vis)
                    lock(apply_damage, obj, ent, -d, 'crushing', 'Tomb Bash', 'melee')
                    root.after(333, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
                else:
                    miss(ent.loc)
                    root.after(1999, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Tomb_Bash']
                    app.canvas.delete('Tomb_Bash')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p3 = partial(tomb_bash, obj = ent)
        def add_tomb_bash(actions = None, func = None):
            actions['Tomb Bash'] = func
            return actions
        p4 = partial(add_tomb_bash, func = p3)
        ent.action_effects.append(p4)
        # +1 mvs
        def animate_mvs(stat):
            return stat+1
        p5 = partial(animate_mvs)
        ent.mvs_effects.append(p5)
        # ADD ACTIONS
        def add_acts(stat):
            return stat+1
        p6 = partial(add_acts)
        ent.acts_effects.append(p6)
        # INERT
        def add_inert(inert_bool):
            return True
        p7 = partial(add_inert)
        ent.inert_effects.append(p7)
        # UNDO
        def undo(ent, p, p2, p4, p5, p6, p7, lockname = None):
            ent.action_effects.remove(p)
            ent.str_effects.remove(p2)
            ent.agl_effects.remove(p2)
            ent.move_range_effects.remove(p2)
            ent.action_effects.remove(p4)
            ent.mvs_effects.remove(p5)
            ent.acts_effects.remove(p6)
            ent.inert_effects.remove(p7)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p, p2, p4, p5, p6, p7)
        n = 'Animate_Tomb' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Animate_Tomb', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Animate_Tomb' : self.cleanup_spell(name = name))
        
        
    def cosmic_sight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= 3]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_cosmic_sight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Cosmic Sight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_cosmic_sight(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cosmic_sight(self, event, sqr, sqrs):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Cosmic_Sight'].cost
        spell = self.arcane_dict['Cosmic_Sight']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Cosmic_Sight'] = Vis(name = 'Cosmic_Sight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Cosmic_Sight'].img, tags = 'Cosmic_Sight')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Cosmic Sight', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Cosmic Sight', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        # all enemy w/i range 3 make psy save(-1) or lose psyshield
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        if ids == []:
            root.after(1666, lambda  name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
        else:
            root.after(1666, lambda ids = ids : self.continue_cosmic_sight(ids))
    
    def continue_cosmic_sight(self, ids):
        def cosmic_loop(ids):
            if ids == []:
                root.after(1666, lambda  name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                if app.ent_dict[id].save_check('wis',mod = -2) == 'Fail':
                    un = 'Cosmic_Sight'+str(app.count)
                    app.count += 1
                    def clean_cosmic_sight(name):
                        app.canvas.delete(name)
                        del app.vis_dict[name]
                        app.canvas.delete('text')
                    sqr = app.ent_dict[id].loc[:]
                    app.vis_dict[un] = Vis(name = 'Cosmic_Sight', loc = sqr[:])
                    app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                    app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psyshield Removed', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psyshield Removed', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                    def cosmic_effect(types):
                        return [t for t in types if t != 'psyshield']
                    p = partial(cosmic_effect)
                    app.ent_dict[id].type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p)
                    n = 'Cosmic_Sight' + str(app.count)
                    app.ent_dict[id].effects_dict[n] = Effect(name = 'Cosmic_Sight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1555, lambda un = un : clean_cosmic_sight(un))
                    root.after(1666, lambda ids = ids : cosmic_loop(ids))
                else:
                    sqr = app.ent_dict[id].loc[:]
                    app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Wisdom Save', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Wisdom Save', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : cosmic_loop(ids))
        cosmic_loop(ids)
        
        
    def demonic_sight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_demonic_sight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Demonic Sight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_demonic_sight(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_demonic_sight(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Demonic_Sight'].cost
        spell = self.arcane_dict['Demonic_Sight']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Demonic_Sight'] = Vis(name = 'Demonic_Sight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Demonic_Sight'].img, tags = 'Demonic_Sight')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Demonic Sight', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Demonic Sight', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        my_psy = self.get_abl('psyche')
        tar_psy = app.ent_dict[id].get_abl('psyche')
        if to_hit(my_psy, tar_psy) == True:
            ent = app.ent_dict[id]
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Lose invisibility...', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Lose invisibility...', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
            def demonic_invis(types):
                return [t for t in types if t != 'invisibility']
            p = partial(demonic_invis)
            app.ent_dict[id].type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Demonic_Sight' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Demonic_Sight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(app.ent_dict[id].loc)
        root.after(2666, lambda  name = 'Demonic_Sight' : self.cleanup_spell(name = name))
        
        
    def reaping_of_saturnus(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Reaping_of_Saturnus' : self.cleanup_spell(name = name))
        sqrs = [v.loc for k,v in app.all_ents().items() if v.owner == self.owner and v.name in app.summons_list]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_reaping_of_saturnus(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Reaping of Saturnus', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_reaping_of_saturnus(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_reaping_of_saturnus(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner or ent.name not in app.summons_list:
            return
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Reaping_of_Saturnus'].cost
        spell = self.arcane_dict['Reaping_of_Saturnus']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Reaping_of_Saturnus'] = Vis(name = 'Reaping_of_Saturnus', loc = sqr)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Reaping of Saturnus, draw 1', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Reaping of Saturnus, draw 1', justify = 'center', font = ('chalkduster', 16), fill = 'firebrick', tags = 'text')
        self.in_hand += self.library[:1]
        self.library = self.library[1:]
        self.summon_count = max(0,self.summon_count-1)
        name = 'dethlok'+str(app.death_count)
        lock(app.kill,ent.id)
        root.after(666, lambda name = 'Reaping_of_Saturnus' : self.cleanup_spell(name = name))
        
        
    def mass_hysteria(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        root.bind('<a>', self.do_mass_hysteria)
        b = tk.Button(app.context_menu, text = 'Confirm Mass Hysteria', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_mass_hysteria(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mass_hysteria(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Mass_Hysteria'].cost
        spell = self.arcane_dict['Mass_Hysteria']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Mass Hysteria', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Mass Hysteria', justify = 'center', font = ('chalkduster', 16), fill = 'green3', tags = 'text')
        def cleanup_hysteria(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def hysteria_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Mass_Hysteria')
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                name = 'Mass_Hysteria'+str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Mass_Hysteria', loc = ent.loc[:])
                if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = '-5 sanity', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = '-5 sanity', justify = 'center', font = ('chalkduster', 16), fill = 'green3', tags = 'text')
                    def hys_ef(stat):
                        return max(1,stat-5)
                    p = partial(hys_ef)
                    ent.san_effects.append(p)
                    def undo(ent, p, lockname = None):
                        ent.san_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    n = 'Mass_Hysteria' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Mass_Hysteria', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda n = name : cleanup_hysteria(n))
                    root.after(1999, lambda ids = ids : hysteria_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda n = name : cleanup_hysteria(n))
                    root.after(1999, lambda ids = ids : hysteria_loop(ids))
        ids = app.init_q[:5]
        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
        root.after(1444, lambda ids = ids : hysteria_loop(ids))
        
        
    def carrion_wyrm(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_carrion_wyrm(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Carrion Wyrm', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_carrion_wyrm(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_carrion_wyrm(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        cards = list(set(self.discard[:]))
        if cards == []:
            return
        self.magick -= self.arcane_dict['Carrion_Wyrm'].cost
        spell = self.arcane_dict['Carrion_Wyrm']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Carrion_Wyrm'] = Vis(name = 'Carrion_Wyrm', loc = sqr[:])
        # debug custom vis
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Carrion Wyrm', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Carrion Wyrm', justify = 'center', font = ('chalkduster', 14), fill = 'gray', tags = 'text')
        self.page_carrion_wyrm(cards = cards, loc = sqr[:])


    def page_carrion_wyrm(self, event = None, cards = None, index = 0, amt = 0, loc = None):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+9]):
            i += 1
            p = partial(self.discard_carrion_wyrm, card = card, cards = cards, amt = amt, loc = loc)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-9, amt = amt, loc = loc : self.page_carrion_wyrm(cards = cards, index = i, amt = amt, loc = loc))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-9, amt = amt, loc = loc : self.page_carrion_wyrm(cards = cards, index = i, amt = amt, loc = loc))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+9, amt = amt, loc = loc : self.page_carrion_wyrm(cards = cards, index = i, amt = amt, loc = loc))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+9, amt = amt : self.page_carrion_wyrm(cards = cards, index = i, amt = amt))
        # add 'done' button
        b4 = tk.Button(app.context_menu, text = 'Done', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda amt = amt, loc = loc : self.finish_carrion_wyrm(amt = amt, loc = loc))
        b4.pack(side = 'top', pady = 2)
        app.context_buttons.append(b4)
#         root.bind('<e>', lambda e, hand = hand, i = index+5, ent = ent : self.page_giant_growth(hand = hand, index = i, ent = ent))
            
            
    def discard_carrion_wyrm(self, event = None, card = None, cards = None, amt = None, loc = None):
        app.depop_context(event = None)
        self.discard.remove(card)
        self.exile.append(card)
        cards.remove(card)
        amt += 1
        if cards == []:
            self.finish_carrion_wyrm(amt = amt, loc = loc)
        else:
            self.page_carrion_wyrm(cards = cards, amt = amt, loc = loc)
        
    def finish_carrion_wyrm(self, amt = None, loc = None):
        app.depop_context(event = None)
        # smn wyrm
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Carrion_Wyrm.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Carrion_Wyrm(name = 'Carrion_Wyrm', id = id, img = img, loc = loc[:], owner = self.owner, level = self.level, j = amt)
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[loc[0]][loc[1]] = id
        root.after(2333, lambda  name = 'Carrion_Wyrm' : self.cleanup_spell(name = name))
        
        
        
    def giant_growth(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_giant_growth(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Giant Growth', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_giant_growth(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_giant_growth(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Giant_Growth' in effs:
            return
        self.magick -= self.arcane_dict['Giant_Growth'].cost
        spell = self.arcane_dict['Giant_Growth']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Giant_Growth'] = Vis(name = 'Giant_Growth', loc = sqr[:])
        # debug custom vis
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Giant Growth', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Giant Growth', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        if self.in_hand == []:
            root.after(1999, lambda  name = 'Giant_Growth' : self.cleanup_spell(name = name))
        else:
            self.page_giant_growth(hand = self.in_hand[:], ent = ent)


    def page_giant_growth(self, event = None, hand = None, index = 0, ent = None, amt = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(hand[index:index+9]):
            i += 1
            p = partial(self.discard_giant_growth, card = card, ent = ent, amt = amt)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9, ent = ent, amt = amt : self.page_giant_growth(hand = hand, index = i, ent = ent, amt = amt))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9, ent = ent, amt = amt : self.page_giant_growth(hand = hand, index = i, ent = ent, amt = amt))
            app.context_buttons.append(b4)
        if len(hand) > len(hand[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9, ent = ent, amt = amt : self.page_giant_growth(hand = hand, index = i, ent = ent, amt = amt))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9, ent = ent, amt = amt : self.page_giant_growth(hand = hand, index = i, ent = ent, amt = amt))
        # add 'done' button
        b4 = tk.Button(app.context_menu, text = 'Done', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda amt = amt, ent = ent : self.finish_giant_growth(amt = amt, ent = ent))
        b4.pack(side = 'top', pady = 2)
        app.context_buttons.append(b4)
#         root.bind('<e>', lambda e, hand = hand, i = index+5, ent = ent : self.page_giant_growth(hand = hand, index = i, ent = ent))
            
            
    def discard_giant_growth(self, event = None, card = None, ent = None, amt = None):
        app.depop_context(event = None)
        # rmv from hand, put discard, incrs amt, call page_gia...
        self.in_hand.remove(card)
        self.discard.append(card)
        amt += 1
        if self.in_hand == []:
            self.finish_giant_growth(amt = amt, ent = ent)
        else:
            self.page_giant_growth(hand = self.in_hand[:], ent = ent, amt = amt)
        
    def finish_giant_growth(self, amt = None, ent = None):
        app.depop_context(event = None)
        loc = ent.loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+64-app.moved_down, text = '+'+str(amt)+' str, end, agl, spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+65-app.moved_down, text = '+'+str(amt)+' str, end, agl, spirit', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        def gg_efct(stat, amt = None):
            return stat + amt
        p = partial(gg_efct, amt = amt)
        ent.str_effects.append(p)
        ent.agl_effects.append(p)
        ent.end_effects.append(p)
        apply_heal(self, ent, amt)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.end_effects.remove(p)
            ent.agl_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Giant_Growth' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Giant_Growth', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, lambda  name = 'Giant_Growth' : self.cleanup_spell(name = name))
        
        
    def quest_hermit(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_quest_hermit(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Quest of the Hermit Druid', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_quest_hermit(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_quest_hermit(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if self.library == []:
            return
        self.magick -= self.arcane_dict['Quest_of_the_Hermit_Druid'].cost
        spell = self.arcane_dict['Quest_of_the_Hermit_Druid']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Quest_of_the_Hermit_Druid'] = Vis(name = 'Quest_of_the_Hermit_Druid', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Quest of the Hermit Druid', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Quest of the Hermit Druid', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
        discard = []
        for card in self.library[:]:
            if card in app.summons_list:
                self.finish_quest_hermit(card = card, discard = discard[:])
                break
            else:
                discard.append(card)
        else:
            self.finish_quest_hermit(card = None, discard = discard[:])
        
    def finish_quest_hermit(self, card, discard):
        if card != None:
            self.in_hand.append(card)
            self.library.remove(card)
            app.canvas.create_text((self.loc[0]-1)*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Reveal\n'+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text((self.loc[0]-1)*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Reveal\n'+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
        step = 10
        app.canvas.create_text((self.loc[0]+1)*100+49-app.moved_right, self.loc[1]*100-app.moved_down-1, text = 'Discard', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text((self.loc[0]+1)*100+50-app.moved_right, self.loc[1]*100-app.moved_down, text = 'Discard', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
        for c in discard:
            self.library.remove(c)
            self.discard.append(c)
            app.canvas.create_text((self.loc[0]+1)*100+49-app.moved_right, self.loc[1]*100+step-app.moved_down-1, text = str(c).replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text((self.loc[0]+1)*100+50-app.moved_right, self.loc[1]*100+step-app.moved_down, text = str(c).replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
            step += 15
        root.after(2999, lambda  name = 'Quest_of_the_Hermit_Druid' : self.cleanup_spell(name = name))
        
        
    def foretell(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_foretell(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Witch', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_foretell(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_foretell(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if app.num_players == 1:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch) == False:
            return
        if ent.library == []:
            return
        self.magick -= self.arcane_dict['Foretell'].cost
        spell = self.arcane_dict['Foretell']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Foretell'] = Vis(name = 'Foretell', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Foretell', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Foretell', justify = 'center', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
        
        cards = ent.library[:2]
        self.page_foretell(cards = cards)
        
    def page_foretell(self, event = None, cards = None):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards):
            i += 1
            p = partial(self.put_foretell, card = card, cards = cards)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
            
            
    def put_foretell(self, event = None, card = None, cards = None):
        app.depop_context(event = None)
        # two btns, discard, btm of library
        def discard(card):
            if self.owner == 'p1':
                ent = app.ent_dict[app.p2_witch]
            else:
                ent = app.ent_dict[app.p1_witch]
            ent.library.remove(card)
            ent.discard.append(card)
            cards.remove(card)
            if cards == []:
                app.depop_context(event = None)
                root.after(1999, lambda  name = 'Foretell' : self.cleanup_spell(name = name))
            else:
                self.page_foretell(cards = cards)
        p = partial(discard, card)
        def bottom(card):
            if self.owner == 'p1':
                ent = app.ent_dict[app.p2_witch]
            else:
                ent = app.ent_dict[app.p1_witch]
            ent.library.remove(card)
            ent.library[-1] = card
            cards.remove(card)
            if cards == []:
                app.depop_context(event = None)
                root.after(1999, lambda  name = 'Foretell' : self.cleanup_spell(name = name))
            else:
                self.page_foretell(cards = cards)
        p2 = partial(bottom, card)
        b1 = tk.Button(app.context_menu, wraplength = 190, text = 'Discard', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
        b1.pack(side = 'top', pady = 2)
        app.context_buttons.append(b1)
        b2 = tk.Button(app.context_menu, wraplength = 190, text = 'Bottom of Library', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p2)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        
        
    def coercion(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_coercion(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Witch', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_coercion(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_coercion(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if app.num_players == 1:
            return
        if self.in_hand == []:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch) == False:
            return
        self.magick -= self.arcane_dict['Coercion'].cost
        spell = self.arcane_dict['Coercion']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Coercion'] = Vis(name = 'Coercion', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Coercion', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Coercion', justify = 'center', font = ('chalkduster', 14), fill = 'gray', tags = 'text')
        self.page_coercion(hand = self.in_hand[:], player = 'caster')


    def page_coercion(self, event = None, hand = None, index = 0, player = None):
        app.unbind_all()
        app.depop_context(event = None)
        if player == 'caster':
            tmp = tk.Label(app.context_menu, text = 'Choose own Discard', bg = 'black', fg = 'indianred')
            tmp.pack(side = 'top', pady = 2)
        else:
            tmp = tk.Label(app.context_menu, text = 'Choose opponent Discard', bg = 'black', fg = 'indianred')
            tmp.pack(side = 'top', pady = 2)
        app.context_buttons.append(tmp)
        for i, card in enumerate(hand[index:index+9]):
            i += 1
            if player == 'caster':
                p = partial(self.discard_coercion, card = card)
            else:
                p = partial(self.finish_coercion, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9, player = player : self.page_coercion(hand = hand, index = i, player = player))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9, player = player : self.page_coercion(hand = hand, index = i, player = player))
            app.context_buttons.append(b4)
        if len(hand) > len(hand[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9, player = player : self.page_coercion(hand = hand, index = i, player = player))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9, player = player : self.page_coercion(hand = hand, index = i, player = player))
            
            
    def discard_coercion(self, event = None, card = None):
        app.depop_context(event = None)
        # rmv from hand, put discard, incrs amt, call page_gia...
        self.in_hand.remove(card)
        self.discard.append(card)
        if self.owner == 'p1':
            ent = app.ent_dict[app.p2_witch]
        else:
            ent = app.ent_dict[app.p1_witch]
        if ent.in_hand == []:
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+64-app.moved_down, text = 'None in hand...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+65-app.moved_down, text = 'None in hand...', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
            root.after(1999, lambda  name = 'Coercion' : self.cleanup_spell(name = name))
        else:
            self.page_coercion(hand = ent.in_hand[:], player = 'target')
        
    def finish_coercion(self, event = None, card = None):
        app.depop_context(event = None)
        if self.owner == 'p1':
            ent = app.ent_dict[app.p2_witch]
        else:
            ent = app.ent_dict[app.p1_witch]
        ent.in_hand.remove(card)
        ent.discard.append(card)
        root.after(1999, lambda  name = 'Coercion' : self.cleanup_spell(name = name))
        
        
    def survival_of_the_fittest(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_survival_of_the_fittest(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Survival of the Fittest', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_survival_of_the_fittest(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_survival_of_the_fittest(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        cards = list(filter(lambda x : x in app.summons_list, self.in_hand[:]))
        if cards == []:
            return
        self.magick -= self.arcane_dict['Survival_of_the_Fittest'].cost
        spell = self.arcane_dict['Survival_of_the_Fittest']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Survival_of_the_Fittest'] = Vis(name = 'Survival_of_the_Fittest', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Survival of the Fittest', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Survival of the Fittest', justify = 'center', font = ('chalkduster', 14), fill = 'gray', tags = 'text')
        self.page_survival_otf(hand = cards)


    def page_survival_otf(self, event = None, hand = None, index = 0):
        app.unbind_all()
        app.depop_context(event = None)
        tmp = tk.Label(app.context_menu, text = 'Choose Discard', bg = 'black', fg = 'indianred')
        tmp.pack(side = 'top', pady = 2)
        app.context_buttons.append(tmp)
        for i, card in enumerate(hand[index:index+9]):
            i += 1
            p = partial(self.discard_survival_otf, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9 : self.page_survival_otf(hand = hand, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9 : self.page_survival_otf(hand = hand, index = i))
            app.context_buttons.append(b4)
        if len(hand) > len(hand[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9 : self.page_survival_otf(hand = hand, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9 : self.page_survival_otf(hand = hand, index = i))
            
            
    def discard_survival_otf(self, event = None, card = None):
        app.depop_context(event = None)
        # discard, then search library if exists
        self.in_hand.remove(card)
        self.discard.append(card)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Discard '+str(card), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Discard '+str(card), justify = 'center', font = ('chalkduster', 14), fill = 'green', tags = 'text')
        cards = list(filter(lambda x : x in app.summons_list, self.library[:]))
        if cards != []:
            self.page_surv_library(cards = cards)
        else:
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'No summons to fetch...', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'No summons to fetch...', justify = 'center', font = ('chalkduster', 14), fill = 'green', tags = 'text')
            root.after(1666, lambda  name = 'Survival_of_the_Fittest' : self.cleanup_spell(name = name))

    def page_surv_library(self, event = None, cards = None, index = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+9]):
            i += 1
            p = partial(self.survival_fetch, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-9 : self.page_surv_library(cards = cards, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-9 : self.page_surv_library(cards = cards, index = i))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+9 : self.page_surv_library(cards = cards, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+9 : self.page_surv_library(cards = cards, index = i))
            
    def survival_fetch(self, event = None, card = None):
        app.depop_context(event = None)
        self.in_hand.append(card)
        self.library.remove(card)
        shuffle(self.library)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        root.after(1666, lambda  name = 'Survival_of_the_Fittest' : self.cleanup_spell(name = name))
        
        
    def myopic_neuroticism(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_myopic_neuroticism(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Myopic Neuroticism', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_myopic_neuroticism(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_myopic_neuroticism(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['Myopic_Neuroticism'].cost
        spell = self.arcane_dict['Myopic_Neuroticism']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Myopic_Neuroticism'] = Vis(name = 'Myopic_Neuroticism', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Myopic Neuroticism', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Myopic Neuroticism', justify = 'center', font = ('chalkduster', 14), fill = 'coral1', tags = 'text')
        if self.in_hand == []:
            self.magick += 1
            root.after(1999, lambda  name = 'Myopic_Neuroticism' : self.cleanup_spell(name = name))
        else:
            self.page_myopic(hand = self.in_hand[:])


    def page_myopic(self, event = None, hand = None, index = 0, amt = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(hand[index:index+9]):
            i += 1
            p = partial(self.discard_myopic, card = card, amt = amt)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index-9, amt = amt : self.page_myopic(hand = hand, index = i, amt = amt))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hand = hand, i = index-9, amt = amt : self.page_myopic(hand = hand, index = i, amt = amt))
            app.context_buttons.append(b4)
        if len(hand) > len(hand[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hand = hand, i = index+9, amt = amt : self.page_myopic(hand = hand, index = i, amt = amt))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hand = hand, i = index+9, amt = amt : self.page_myopic(hand = hand, index = i, amt = amt))
        # add 'done' button
        b4 = tk.Button(app.context_menu, text = 'Done', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda amt = amt : self.finish_myopic(amt = amt))
        b4.pack(side = 'top', pady = 2)
        app.context_buttons.append(b4)
#         root.bind('<e>', lambda e, hand = hand, i = index+5, ent = ent : self.page_giant_growth(hand = hand, index = i, ent = ent))
            
            
    def discard_myopic(self, event = None, card = None, amt = None):
        app.depop_context(event = None)
        # rmv from hand, put discard, incrs amt, call page_gia...
        self.in_hand.remove(card)
        self.discard.append(card)
        amt += 1
        if self.in_hand == []:
            self.finish_myopic(amt = amt)
        else:
            self.page_myopic(hand = self.in_hand[:], amt = amt)
        
    def finish_myopic(self, amt = None):
        app.depop_context(event = None)
        loc = self.loc[:]
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+64-app.moved_down, text = '+'+str(amt)+' magick', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+65-app.moved_down, text = '+'+str(amt)+' magick', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        self.magick += amt
        root.after(1999, lambda  name = 'Myopic_Neuroticism' : self.cleanup_spell(name = name))
        
    # spell target witch, on to-hit wis vs wis, discard a card at random
    def stupor(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_stupor(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Stupor', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_stupor(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stupor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch)==False:
            return
        if ent.in_hand == []:
            return
        self.magick -= self.arcane_dict['Stupor'].cost
        spell = self.arcane_dict['Stupor']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Stupor'] = Vis(name = 'Stupor', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Stupor', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Stupor', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
            card = choice(ent.in_hand[:])
            ent.in_hand.remove(card)
            ent.discard.append(card)
            loc = ent.loc
            app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = 'Discard '+card, justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = 'Discard '+card, justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
            root.after(1999, lambda  name = 'Stupor' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, lambda  name = 'Stupor' : self.cleanup_spell(name = name))
        
    def blind(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_blind(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Blind', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_blind(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_blind(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Blind' in effs:
            return
        self.magick -= self.arcane_dict['Blind'].cost
        spell = self.arcane_dict['Blind']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Blind'] = Vis(name = 'Blind', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Blind'].img, tags = 'Blind')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Blind', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Blind', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def blind_efct(stat):
            return max(1, stat-3)
        p = partial(blind_efct)
        ent.rsn_effects.append(p)
        ent.bls_effects.append(p)
        def un(ent, p, lockname = None):
            ent.rsn_effects.remove(p)
            ent.bls_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Blind' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Blind', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = ent.loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-3 ballistics, reason', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-3 ballistics, reason', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Blind' : self.cleanup_spell(name = name))
        
        
        
        
    def astrological_guidance(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_astrological_guidance(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Astrological Guidance', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_astrological_guidance(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_astrological_guidance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.immovable == True:
            return
        if isinstance(ent, Witch):
            return
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         app.unbind_all()
        app.unbind_nonarrows()
        app.depop_context(event = None)
        app.cleanup_squares()
        sqrs = ent.legal_moves()
        app.animate_squares(sqrs)
        root.bind('<q>', self.cleanup_spell)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs, id = id : self.cont_astrological_guidance(event = e, sqr = s, sqrs = sqrs, id = id))
        b = tk.Button(app.context_menu, text = 'Choose Location to Move', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs, id = id : self.cont_astrological_guidance(e, s, sqrs, id = id))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def cont_astrological_guidance(self, event = None, sqr = None, sqrs = None, id = None):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['Astrological_Guidance'].cost
        spell = self.arcane_dict['Astrological_Guidance']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.depop_context(event = None)
        app.unbind_nonarrows()
        app.cleanup_squares()
        app.vis_dict['Astrological_Guidance'] = Vis(name = 'Astrological_Guidance', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Astrological_Guidance'].img, tags = 'Astrological_Guidance')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Astrological Guidance', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Astrological Guidance', justify = 'center', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
        ent = app.ent_dict[id]
        def astro_mvs(stat):
            return stat-1
        p = partial(astro_mvs)
        ent.mvs_effects.append(p)
        ent.mvs -= 1
        def undo(ent, p, lockname = None):
            ent.mvs_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Astrological_Guidance' + str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Astrological_Guidance', undo_func = u, duration = 1, level = self.get_abl('wis'))
        app.focus_square(sqr)
        mt = ent.get_move_type()
        if mt == 'normal' or mt == 'charge':
            lock(Bot.ai_normal_move, ent, sqr)
        elif mt == 'teleport':
            lock(Bot.ai_teleport_move, ent, sqr)
        else:
            lock(Bot.ai_flying_move, ent, sqr)
        root.after(666, lambda  name = 'Astrological_Guidance' : self.cleanup_spell(name = name))
        
    # teleport caster to location in range rsn, on wis save
    def the_magician(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn') and app.grid[s[0]][s[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_the_magician(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_the_magician(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_the_magician(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.magick -= self.arcane_dict['The_Magician'].cost
        spell = self.arcane_dict['The_Magician']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.depop_context(event = None)
        app.unbind_nonarrows()
        app.cleanup_squares()
        app.vis_dict['The_Magician'] = Vis(name = 'The_Magician', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'The Magician', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'The Magician', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        if self.save_check('wis')=='Pass':
            app.focus_square(sqr)
            lock(Bot.ai_teleport_move, self, sqr)
            root.after(222, lambda  name = 'The_Magician' : self.cleanup_spell(name = name))
        else:
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Wisdom save fail...', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Wisdom save fail...', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, lambda  name = 'The_Magician' : self.cleanup_spell(name = name))
        
        
    def spectral_pillory(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_spectral_pillory(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Spectral Pillory', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_spectral_pillory(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spectral_pillory(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if 'Spectral_Pillory' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if ent.immovable == True:
            return
        self.magick -= self.arcane_dict['Spectral_Pillory'].cost
        spell = self.arcane_dict['Spectral_Pillory']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Spectral_Pillory'] = Vis(name = 'Spectral_Pillory', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Spectral Pillory', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Spectral Pillory', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            def pillory_minus2(stat):
                return max(0, stat-2)
            p = partial(pillory_minus2)
            ent.move_range_effects.append(p)
            def take_2(ent, lockname = None):
                app.get_focus(ent.id)
                lock(apply_damage, self, ent, -2, 'magick', 'Spectral Pillory', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, ent)
            def un(ent, p, lockname = None):
                ent.move_range_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, ent, p)
            n = 'Spectral_Pillory' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Spectral_Pillory', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            loc = ent.loc
            app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-2 move range, end of turn 2 mgk dmg', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-2 move range, end of turn 2 mgk dmg', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
            root.after(1999, lambda  name = 'Spectral_Pillory' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1777, lambda  name = 'Spectral_Pillory' : self.cleanup_spell(name = name))
        
        
        
    def gravity(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gravity(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Gravity', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gravity(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gravity(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        if 'Gravity' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if ent.immovable == True:
            return
        self.magick -= self.arcane_dict['Gravity'].cost
        spell = self.arcane_dict['Gravity']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Gravity'] = Vis(name = 'Gravity', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Gravity'].img, tags = 'Gravity')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Gravity', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Gravity', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        # DO gravity EFFECTS
        def grav_minus2(stat):
            return max(1, stat-2)
        p = partial(grav_minus2)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        def gravity_move(move_range):
            return max(0,move_range-2)
        p2 = partial(gravity_move)
        ent.move_range_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.agl_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.move_range_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'Gravity' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Gravity', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-2 move range, agl, dod', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-2 move range, agl, dod', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Gravity' : self.cleanup_spell(name = name))
        
    # change to: must choose ranged tar, rang2-6, lightning strike main tar, still do adj fire
    def beleths_command(self, event = None):
        app.depop_context(event = None)
        sqrs = [c for c in app.coords if 2 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<q>', self.cleanup_spell)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_beleths_command(sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Beleth's Command Target", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda sqr = grid_pos, sqrs = sqrs : self.do_beleths_command(sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_beleths_command(self, event = None, sqr = None, sqrs = None):
        global selected_vis
        if self.mvs < 1:
            return
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent,Witch):
            return
        self.magick -= self.arcane_dict["Beleth's_Command"].cost
        spell = self.arcane_dict["Beleth's_Command"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/beleths_command.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.mvs -= 1
        app.focus_square(self.loc)
        app.vis_dict["Beleth's_Command"] = Vis(name = "Beleth's_Command", loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict["Beleth's_Command"].img, tags = "Beleth's_Command")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+9-app.moved_down, text = "Beleth's Command", justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+10-app.moved_down, text = "Beleth's Command", justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
        # LIGHTNING VIS
        selected_vis.append("Beleth's_Lightning")
        loc = app.ent_dict[id].loc[:]
        def cleanup_lightning():
            app.canvas.delete("Beleth's_Lightning")
            del app.vis_dict["Beleth's_Lightning"]
        app.vis_dict["Beleth's_Lightning"] = Vis(name = "Beleth's_Lightning", loc = loc)
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict["Beleth's_Lightning"].img, tags = "Beleth's_Lightning")
        x2 = loc[0]*100+50-app.moved_right
        y2 = loc[1]*100+50-app.moved_down
        def beleths_lightning(timeout):
            if timeout > 0:
                app.vis_dict["Beleth's_Lightning"].rotate_image()
                app.canvas.delete("Beleth's_Lightning")
                app.canvas.create_image(x2, y2, image = app.vis_dict["Beleth's_Lightning"].img, tags = "Beleth's_Lightning")
                timeout -= 1
                root.after(60, lambda t = timeout : beleths_lightning(t))
            else:
                cleanup_lightning()
        app.get_focus(id)
        beleths_lightning(8)
        # BURN AT STAKE LOOP
        selected_vis = ["Beleth's_Command"]
        def cleanup_beleths_fire():
            app.canvas.delete("Beleth's_Command")
            del app.vis_dict["Beleth's_Command"]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        def beleths_loop(timeout):
            if timeout > 0:
                app.vis_dict["Beleth's_Command"].rotate_image()
                app.canvas.delete("Beleth's_Command")
                app.canvas.create_image(x, y, image = app.vis_dict["Beleth's_Command"].img, tags = "Beleth's_Command")
                app.canvas.tag_lower("Beleth's_Command", (self.tags))
                timeout -= 1
                root.after(99, lambda t = timeout : beleths_loop(t))
            else:
                cleanup_beleths_fire()
        beleths_loop(30)
        # LIGHTNING EFFECTS ranged target, dmg, stun chance
        my_psyche = self.get_abl('psyche')
        tar_psyche = app.ent_dict[id].get_abl('psyche')
        d1 = damage(my_psyche, tar_psyche)
        s1 = app.ent_dict[id].loc[:]
        lock(apply_damage, self, app.ent_dict[id], -d1, 'elec', 'Lightning Strike', 'spell')
        # if tar still alive, stun chance
        if id in app.all_ents().keys() and to_hit(self.get_abl('psyche'),app.ent_dict[id].get_abl('str')) and 'Beleth_Stun' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]: # Fail Save
            app.canvas.create_text(s1[0]*100-app.moved_right+49, s1[1]*100-app.moved_down+84, text = 'Stun, -1 mvs', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(s1[0]*100-app.moved_right+50, s1[1]*100-app.moved_down+85, text = 'Stun, -1 mvs', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def beleths_stun_effect(amt):
                return max(0,amt-1)
            p_stun = partial(beleths_stun_effect)
            app.ent_dict[id].mvs_effects.append(p_stun)
            app.ent_dict[id].mvs -= 1
            def un(i, func, lockname = None):
                app.ent_dict[i].mvs_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id, p_stun)
            n = 'Beleth_Stun' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Beleth_Stun', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1]
        root.after(2555, lambda t = 'text' : app.canvas.delete(t))
        root.after(2666, lambda ents = ents : self.finish_beleths(ents))
        
    def finish_beleths(self, ents):
        for e in ents:
            s = app.ent_dict[e].loc[:]
            app.focus_square(s)
#             app.canvas.delete('text')
            uniq_name = 'Immolate'+str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Immolate', loc = s) # using Immolate animations
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = "Beleth's_Command")
            d = damage(self.get_abl('psyche'),app.ent_dict[e].get_abl('psyche'))
            lock(apply_damage, self, app.ent_dict[e], -d, 'fire', 'Witchfire', 'spell')
            def clean_beleths_command(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(3666, lambda n = uniq_name : clean_beleths_command(n))
        # DO Beleth's Command EFFECTS ON CASTER
        effs = [v.name for k,v in self.effects_dict.items()]
        if "Beleth's_Command" not in effs:
            def beleths_command_effect(stat):
                stat += 1
                return stat
            f = beleths_command_effect
            self.end_effects.append(f)
            self.psyche_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].end_effects.remove(beleths_command_effect)
                app.ent_dict[i].psyche_effects.remove(beleths_command_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, self.id)
            self.effects_dict["Beleth's_Command"] = Effect(name = "Beleth's_Command", undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3666, lambda  name = "Beleth's_Command" : self.cleanup_spell(name = name))
        
        
        
        
# FAKIR ALI SPELLS
        # Ali's spells center around Heat/Fire/Resistance/Mummification
    def legerdemain(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Legerdemain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_legerdemain(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose First Target', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_legerdemain(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_legerdemain(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        app.cleanup_squares()
        root.bind('<q>', lambda name = 'Legerdemain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs, id = id : self.cont_legerdemain(event = e, sqr = s, sqrs = sqrs, id1 = id))
        b = tk.Button(app.context_menu, text = 'Choose Second Target', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs, id = id : self.cont_legerdemain(e, s, sqrs, id))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def cont_legerdemain(self, event, sqr, sqrs, id1):
        if sqr not in sqrs:
            return
        if id1 not in app.spell_target_ents().keys():
            return
        id2 = app.grid[sqr[0]][sqr[1]]
        if id2 not in app.spell_target_ents().keys():
            return
        if id1 == id2:
            return
        if self.save_check('wis', mod=-3)=='Pass':
            ent1 = app.ent_dict[id1]
            ent2 = app.ent_dict[id2]
            if isinstance(ent1, Witch) or isinstance(ent2, Witch):
                return
            self.magick -= self.arcane_dict['Legerdemain'].cost
            spell = self.arcane_dict['Legerdemain']
            self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
            app.depop_context(event = None)
            app.unbind_nonarrows()
            app.cleanup_squares()
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Legerdemain', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Legerdemain', justify = 'center', font = ('chalkduster', 13), fill = 'darkorchid1', tags = 'text')
            # have each call teleport move, same time, no need to avoid ent or vis loc collision
            loc1 = app.ent_dict[id1].loc[:]
            loc2 = app.ent_dict[id2].loc[:]
            app.ent_dict[id1].leger_move(loc2)
            app.ent_dict[id2].leger_move(loc1)
            def assign_loc(id, loc):
                app.grid[loc[0]][loc[1]] = id
    #         root.after(666, lambda id2 = id2, loc1 = loc1 : app.ent_dict[id2].leger_move(loc1))
            root.after(1777, lambda loc1 = loc1, id2 = id2 : assign_loc(id2, loc1))
            root.after(1888, lambda loc2 = loc2, id1 = id1 : assign_loc(id1, loc2))
            root.after(2111, lambda  name = 'Legerdemain' : self.cleanup_spell(name = name))
        else:
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Wisdom Fail...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Wisdom Fail...', justify = 'center', font = ('chalkduster', 13), fill = 'darkorchid1', tags = 'text')
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(2111, lambda  name = 'Legerdemain' : self.cleanup_spell(name = name))


    # add magick for each adj friendly ent and do 2 magick spell dmg to it
    def dark_ritual(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Dark_Ritual' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_dark_ritual)
        b = tk.Button(app.context_menu, text = 'Confirm Dark Ritual', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_dark_ritual(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dark_ritual(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Dark_Ritual'].cost
        spell = self.arcane_dict['Dark_Ritual']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Dark_Ritual'] = Vis(name = 'Dark_Ritual', loc = sqr[:])
        ents = [v for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc)==1 and v.owner == self.owner and isinstance(v,Tomb)==False]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Dark Ritual, add '+str(len(ents)+1)+' magick', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Dark Ritual, add '+str(len(ents)+1)+' magick', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        self.magick += int(len(ents)+1)# magic number debug spell.cost instead
        for e in ents:
            lock(apply_damage, self, e, -3, 'magick', 'Dark Ritual', 'spell')
        root.after(111, lambda  name = 'Dark_Ritual' : self.cleanup_spell(name = name))
        
        
    def witchs_blood(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = "Witch's_Blood" : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_witchs_blood)
        b = tk.Button(app.context_menu, text = "Confirm Witch's Blood", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_witchs_blood(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_witchs_blood(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict["Witch's_Blood"].cost
        spell = self.arcane_dict["Witch's_Blood"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict["Witch's_Blood"] = Vis(name = "Witch's_Blood", loc = sqr[:])
        lock(apply_damage, self, self, -4, 'magick', "Witch's Blood", 'spell')
        ents = [v for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc)==1 and v.owner == self.owner]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = "Witch's Blood, +4 magick", justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = "Witch's Blood, +4 magick", justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        self.magick += 4
        for e in ents:
            e.magick += 4
            app.canvas.create_text(e.loc[0]*100+49-app.moved_right, e.loc[1]*100+84-app.moved_down, text = "+4 magick", justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(e.loc[0]*100+50-app.moved_right, e.loc[1]*100+85-app.moved_down, text = "+4 magick", justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        root.after(1999, lambda  name = "Witch's_Blood" : self.cleanup_spell(name = name))
        
        
    def rite_of_spring(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Rite_of_Spring' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_rite_of_spring)
        b = tk.Button(app.context_menu, text = 'Confirm Rite of Spring', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_rite_of_spring(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rite_of_spring(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Rite_of_Spring'].cost
        spell = self.arcane_dict['Rite_of_Spring']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Rite_of_Spring'] = Vis(name = 'Rite_of_Spring', loc = sqr[:])
        amt = self.summon_cap-self.summon_count
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Rite of Spring, draw '+str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Rite of Spring, draw '+str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        self.in_hand += self.library[:amt]
        self.library = self.library[amt:]
        root.after(2333, lambda  name = 'Rite_of_Spring' : self.cleanup_spell(name = name))
        
        
    def grave_twin(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Grave Twin' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_grave_twin)
        b = tk.Button(app.context_menu, text = 'Confirm Grave Twin', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_grave_twin(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_grave_twin(self, event):
        if self.spell_entomb_used == True:
            return
        spls = list(filter(lambda x : x not in app.summons_list, self.in_hand[:]))
        for s in spls:
            if spls.count(s)>1:# is at least one duplicate in list, that is not smn
                break
        else:
            return
        if len([c for c in app.coords if dist(c,self.loc)==1 and app.grid[c[0]][c[1]] == '']) < 2:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Grave_Twin'].cost
        spell = self.arcane_dict['Grave_Twin']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Grave Twin', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Grave Twin', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # choose tombs from hand
        twins = list(set(filter(lambda x : spls.count(x) > 1, spls)))
        self.page_twin(twins = twins)
        
        
    def page_twin(self, event = None, twins = None, index = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(twins[index:index+5]):
            i += 1
            p = partial(self.place_twin, card = card, times = 1)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda card = card : action_description(card))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda ts = twins, i = index-5 : self.page_twin(twins = ts, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, ts = twins, i = index-5 : self.page_twin(twins = ts, index = i))
            app.context_buttons.append(b4)
        if len(twins) > len(twins[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda ts = twins, i = index+5 : self.page_twins(twins = ts, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, ts = twins, i = index+5 : self.page_twin(twins = ts, index = i))
                    
                    
            
    def place_twin(self, event = None, card = None, times = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.rebind_arrows()
        # choose two locs, place two of named card from hand
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, n = card, s = grid_pos, sqrs = sqrs, times = times: self.grave_spell(event = e, name = n, sqr = s, sqrs = sqrs, times = times))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, n = card, s = grid_pos, sqrs = sqrs, t = times : self.grave_spell(name=n, sqr=s, sqrs=sqrs, times=t))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
#         b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
#         b2.pack(side = 'top')
#         app.context_buttons.append(b2)
        
        
    def grave_spell(self, event = None, name = None, sqr = None, sqrs = None, times = None):
        if sqr not in sqrs:
            return
        app.depop_context(event=None)
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.entomb_used = True
        self.spell_entomb_used = True
#         self.acts -= 1
        spell = self.arcane_dict[name]
        self.arcane_dict[name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint+1,spell.times_cast)
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(self.summon_ids)
        self.summon_ids += 1
        def cleanup_twin(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        n = 'Grave_Twin'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Grave_Twin', loc = sqr[:])
        root.after(1666, lambda n = n : cleanup_twin(n))
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
        app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level, imprint = name)
        app.grid[sqr[0]][sqr[1]] = id
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        for i,spl in enumerate(self.in_hand[:]):
            if spl == name:
                self.discard.append(self.in_hand[i])
                self.in_hand.remove(self.in_hand[i])
                break
        if times == 1:
            root.after(1666, lambda n = name, t =2 : self.place_twin(card = n, times = t))
        else:
            root.after(1777, lambda  name = 'Grave_Twin' : self.cleanup_spell(name = name))
            
            
            
    def temperance(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Temperance' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_temperance)
        b = tk.Button(app.context_menu, text = 'Confirm Temperance', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_temperance(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_temperance(self, event):
        mine = len([k for k,v in app.all_ents().items() if v.owner == self.owner and isinstance(v,Tomb)])
        opnt = len([k for k,v in app.all_ents().items() if v.owner != self.owner and isinstance(v,Tomb)])
        if mine >= opnt-1:
            return
        cards = [k for k in self.in_hand[:]+self.discard[:] if k in self.arcane_dict.keys()]
        if cards == []:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Temperance'].cost
        spell = self.arcane_dict['Temperance']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Temperance', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Temperance', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
        # choose hand or discard...
        b1 = tk.Button(app.context_menu, wraplength = 190, text = 'In Hand', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda cards = self.in_hand[:], place = 'Hand' : self.page_temperance(cards = cards, place = place)) 
        b1.pack(side = 'top', pady = 2)
        app.context_buttons.append(b1)
        b2 = tk.Button(app.context_menu, text = 'In Discard', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = self.discard[:], place = 'Discard' : self.page_temperance(cards = cards, place = place))
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        
        
    def page_temperance(self, event = None, cards = None, index = 0, place = None):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+5]):
            i += 1
            p = partial(self.place_temperance, card = card, place = place)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda card = card : action_description(card))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-5, place = place : self.page_temperance(cards = cards, index = i, place = place))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-5, place = place : self.page_temperance(cards = cards, index = i, place = place))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+5, place = place : self.page_temperance(cards = cards, index = i, place = place))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+5, place = place : self.page_temperance(cards = cards, index = i, place = place))
        if place == 'Hand':
            b5 = tk.Button(app.context_menu, text = 'In Discard', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = self.discard[:], place = 'Discard' : self.page_temperance(cards = cards, place = place))
            b5.pack(side = 'top', pady = 2)
            app.context_buttons.append(b5)
        if place == 'Discard':
            b6 = tk.Button(app.context_menu, text = 'In Hand', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = self.in_hand[:], place = 'Hand' : self.page_temperance(cards = cards, place = place))
            b6.pack(side = 'top', pady = 2)
            app.context_buttons.append(b6)
                    
            
    def place_temperance(self, event = None, card = None, place = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.unbind_all()
        # place the chosen card and remove from place
        cs = [c for c in app.coords if app.grid[c[0]][c[1]]=='']
        if cs == []:
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'No available area...', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'No available area...', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1777, lambda  name = 'Temperance' : self.cleanup_spell(name = name))
        else:
            loc = reduce(lambda a,b : a if dist(self.loc,a)<dist(self.loc,b) else b, cs)
            app.vis_dict['Temperance'] = Vis(name = 'Temperance', loc = loc)
            spell = self.arcane_dict[card]
            self.arcane_dict[card] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint+1,spell.times_cast)
            if self.owner == 'p1':
                prefix = 'a'
            else:
                prefix = 'b'
            id = prefix + str(self.summon_ids)
            self.summon_ids += 1
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
            app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = loc[:], owner = self.owner, level = self.level, imprint = card)
            app.grid[loc[0]][loc[1]] = id
            # remove from place
            if place == 'Hand':
                self.in_hand.remove(card)
                self.exile.append(card)
                root.after(111, lambda  name = 'Temperance' : self.cleanup_spell(name = name))
            elif place == 'Discard':
                self.discard.remove(card)
                self.exile.append(card)
                root.after(111, lambda  name = 'Temperance' : self.cleanup_spell(name = name))
            else:
                print('unknown place in temperance, should not reach')
                root.after(111, lambda  name = 'Temperance' : self.cleanup_spell(name = name))
            
        
    def foresight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Foresight' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_foresight)
        b = tk.Button(app.context_menu, text = 'Confirm Foresight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_foresight(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_foresight(self, event):
        if self.library == []:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Foresight'].cost
        spell = self.arcane_dict['Foresight']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Foresight'] = Vis(name = 'Foresight', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Foresight', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Foresight', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        cards = self.library[:]
        self.page_foresight(cards = cards)
        
    def page_foresight(self, event = None, cards = None, index = 0, times = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+9]):
            i += 1
            p = partial(self.foresight_fetch, card = card, times = times)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-9, times = times : self.page_foresight(cards = cards, index = i, times = times))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-9, times = times : self.page_foresight(cards = cards, index = i, times = times))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+9, times = times : self.page_foresight(cards = cards, index = i, times = times))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+9, times = times : self.page_foresight(cards = cards, index = i, times = times))
        b4 = tk.Button(app.context_menu, text = 'DONE', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda name = 'Foresight' : self.cleanup_spell(name = name))
        b4.pack(side = 'top', pady = 2)
        app.context_buttons.append(b4)
            
            
    def foresight_fetch(self, event = None, card = None, times = None):
        app.depop_context(event = None)
        self.exile.append(card)
        self.library.remove(card)
        shuffle(self.library)
        times += 1
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down+(times*15), text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down+(times*15), text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        if self.library == [] or times == 3:
            root.after(1999, lambda  name = 'Foresight' : self.cleanup_spell(name = name))
        else:
            self.page_foresight(cards = self.library[:], times = times)
        
        
    def styxian_guide(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Styxian_Guide' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_styxian_guide)
        b = tk.Button(app.context_menu, text = 'Confirm Styxian Guide', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_styxian_guide(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_styxian_guide(self, event):
        if self.spell_entomb_used == True:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Styxian_Guide'].cost
        spell = self.arcane_dict['Styxian_Guide']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Styxian_Guide'] = Vis(name = 'Styxian_Guide', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Styxian Guide', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Styxian Guide', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        # set spell_ento, page_library if library exists, chosen card in_hand, remove from library
        self.spell_entomb_used = True
        if self.library == []:
            root.after(1999, lambda  name = 'Styxian_Guide' : self.cleanup_spell(name = name))
        else:
            self.page_styxian(lib = self.library[:])
        
    def page_styxian(self, event = None, lib = None, index = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(lib[index:index+9]):
            i += 1
            p = partial(self.styxian_fetch, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda lib = lib, i = index-9 : self.page_styxian(lib = lib, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, lib = lib, i = index-9 : self.page_styxian(lib = lib, index = i))
            app.context_buttons.append(b4)
        if len(lib) > len(lib[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda lib = lib, i = index+9 : self.page_styxian(lib = lib, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, lib = lib, i = index+9 : self.page_styxian(lib = lib, index = i))
            
    def styxian_fetch(self, event = None, card = None):
        app.depop_context(event = None)
        self.in_hand.append(card)
        self.library.remove(card)
        shuffle(self.library)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Fetch '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        root.after(1999, lambda  name = 'Styxian_Guide' : self.cleanup_spell(name = name))
        
        
    def wrath_of_samael(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Wrath_of_Samael' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_wrath_of_samael)
        b = tk.Button(app.context_menu, text = 'Confirm Wrath of Samael', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_wrath_of_samael(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wrath_of_samael(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Wrath_of_Samael'].cost
        spell = self.arcane_dict['Wrath_of_Samael']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Wrath_of_Samael'] = Vis(name = 'Wrath_of_Samael', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Wrath of Samael', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Wrath of Samael', justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        
        # +/- buttons linked to Label
        app.tmp = tk.IntVar()
        app.tmp.set(0)
        def plus():
            cur = app.tmp.get()
            if self.magick > cur:
                app.tmp.set(cur+1)
        p = partial(plus)
        b = tk.Button(app.context_menu, text = '+', wraplength = 190, font = ('chalkduster', 22), fg = 'indianred', highlightbackground = 'tan3', command = p)
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        def minus():
            cur = app.tmp.get()
            if cur > 0:
                app.tmp.set(cur-1)
        p2 = partial(minus)
        b2 = tk.Button(app.context_menu, text = '-', wraplength = 190, font = ('chalkduster', 22), fg = 'indianred', highlightbackground = 'tan3', command = p2)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        total_label = tk.Label(app.context_menu, textvariable = app.tmp, bg = 'black', fg = 'indianred')
        total_label.pack(side = 'top', pady = 2)
        app.context_buttons.append(total_label)
        def okay():
            cur = app.tmp.get()
            self.magick -= cur
            self.cont_wrath(cur)
        p3 = partial(okay)
        b3 = tk.Button(app.context_menu, text = 'DONE', wraplength = 190, font = ('chalkduster', 22), fg = 'indianred', highlightbackground = 'tan3', command = p3)
        b3.pack(side = 'top', pady = 2)
        app.context_buttons.append(b3)
        

        
    
    def cont_wrath(self, amt):
        app.depop_context(event = None)
        ents = [v for k,v in app.all_ents().items() if v.get_inert()==False and isinstance(v,Witch)==False]
        def cleanup_fire(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def cleanup_elec(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def wrath_loop(ents):
            if ents == []:
                self.finish_wrath()
            else:
                ent = ents[0]
                ents = ents[1:]
                app.get_focus(ent.id)
                n = 'wrath'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Wrath_Lightning', loc = ent.loc)
                root.after(1333, lambda n = n : cleanup_elec(n))
                lock(apply_damage, self, ent, -amt, 'elec', 'Wrath Lightning', 'ranged')
                if ent.id in app.all_ents().keys():# ent still exists
                    app.get_focus(ent.id)
                    n = 'wrath'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Wrath_Fire', loc = ent.loc)
                    root.after(1999, lambda n = n : cleanup_fire(n))
                    lock(apply_damage, self, ent, -amt, 'fire', 'Wrath Fire', 'spell')
                    wrath_loop(ents)
                else:# ent killed in first dmg
                    wrath_loop(ents)
        wrath_loop(ents)
        
    def finish_wrath(self):
        # remove imprint
        tombs = [v for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == self.owner]
        for t in tombs:
            if t.imprint == 'Wrath_of_Samael':
                t.imprint = ''
                break
        spell = self.arcane_dict['Wrath_of_Samael']
        self.arcane_dict['Wrath_of_Samael'] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
        self.cleanup_spell(name = 'Wrath_of_Samael')
        
        
    def pull_from_the_aether(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Pull_from_the_Aether' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_pull_from_the_aether)
        b = tk.Button(app.context_menu, text = 'Confirm Pull from the Aether', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_pull_from_the_aether(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pull_from_the_aether(self, event):
        if self.exile == []:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Pull_from_the_Aether'].cost
        spell = self.arcane_dict['Pull_from_the_Aether']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Pull_from_the_Aether'] = Vis(name = 'Pull_from_the_Aether', loc = sqr[:])
        cards = self.exile[:]
        self.page_pull_aether(cards = cards)
        
    def page_pull_aether(self, event = None, cards = None, index = 0):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(cards[index:index+9]):
            i += 1
            p = partial(self.pull_aether_fetch, card = card)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda n = card : action_description(n))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index-9 : self.page_pull_aether(cards = cards, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, cards = cards, i = index-9 : self.page_pull_aether(cards = cards, index = i))
            app.context_buttons.append(b4)
        if len(cards) > len(cards[:index+9]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda cards = cards, i = index+9 : self.page_pull_aether(cards = cards, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, cards = cards, i = index+9 : self.page_pull_aether(cards = cards, index = i))
            
    def pull_aether_fetch(self, event = None, card = None):
        app.depop_context(event = None)
        self.in_hand.append(card)
        self.exile.remove(card)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Return '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Return '+str(card).replace('_',' '), justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        root.after(1999, lambda  name = 'Pull_from_the_Aether' : self.cleanup_spell(name = name))
        
        
    def the_hierophant(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'The_Hierophant' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_the_hierophant)
        b = tk.Button(app.context_menu, text = 'Confirm The Hierophant', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_the_hierophant(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)

    def do_the_hierophant(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['The_Hierophant'].cost
        spell = self.arcane_dict['The_Hierophant']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'The Hierophant', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'The Hierophant', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        # Prox Efct +2 phys stats frndly rng 1
        def hiero_ef(stat):
            return stat+2
        p = partial(hiero_ef)
        prox_ef = Proximity_Effect(name = 'The_Hierophant', ent = self, range = (0,1), abls = ['str','agl','end','dodge','init'], abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner==self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'hierophant'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'hierophant' + str(app.count)
        self.effects_dict[n] = Effect(name = 'The_Hierophant', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, lambda  name = 'The_Hierophant' : self.cleanup_spell(name = name))
        
        
    def the_wheel(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'The_Wheel' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_the_wheel)
        b = tk.Button(app.context_menu, text = 'Confirm The Wheel', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_the_wheel(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_the_wheel(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['The_Wheel'].cost
        spell = self.arcane_dict['The_Wheel']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['The_Wheel'] = Vis(name = 'The_Wheel', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'The Wheel...\n shuffle exile, discard, library, draw 1', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'The Wheel...\n shuffle exile, discard, library, draw 1', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        # shuffle exile and discard into library, draw a card
        self.library += self.exile[:]
        self.library += self.discard[:]
        self.exile = []
        self.discard = []
        shuffle(self.library)
        if self.library != []:
            self.in_hand.append(self.library[0])
            self.library = self.library[1:]
            root.after(1999, lambda  name = 'The_Wheel' : self.cleanup_spell(name = name))
        else:
            root.after(1999, lambda  name = 'The_Wheel' : self.cleanup_spell(name = name))
            
            
            
    def the_world(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'The_World' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_the_world)
        b = tk.Button(app.context_menu, text = 'Confirm The World', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_the_world(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_the_world(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['The_World'].cost
        spell = self.arcane_dict['The_World']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['The_World'] = Vis(name = 'The_World', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'The World...\n Each player draws for each tomb', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'The World...\n Each player draws for each tomb', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        amt = len([k for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == self.owner])
        while amt > 0 and self.library != []:
            self.in_hand.append(self.library[0])
            self.library = self.library[1:]
            amt -= 1
        if app.num_players == 2:
            if self.owner == 'p1':
                witch = app.ent_dict[app.p2_witch]
            else:
                witch = app.ent_dict[app.p1_witch]
            amt = len([k for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == witch.owner])
            while amt > 0 and witch.library != []:
                witch.in_hand.append(witch.library[0])
                witch.library = witch.library[1:]
                amt -= 1
        root.after(2333, lambda  name = 'The_World' : self.cleanup_spell(name = name))
        
        
    def scrye(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Scrye' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_scrye)
        b = tk.Button(app.context_menu, text = 'Confirm Scrye', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_scrye(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scrye(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Scrye'].cost
        spell = self.arcane_dict['Scrye']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Scrye'] = Vis(name = 'Scrye', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Scrye, draw 1', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Scrye, draw 1', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        self.in_hand += self.library[0:1]
        self.library = self.library[1:]
        root.after(2333, lambda  name = 'Scrye' : self.cleanup_spell(name = name))
        
        
    def frantic_search(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Frantic_Search' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_frantic_search)
        b = tk.Button(app.context_menu, text = 'Confirm Frantic Search', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_frantic_search(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_frantic_search(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Frantic_Search'].cost
        spell = self.arcane_dict['Frantic_Search']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        sqr = self.loc[:]
        app.vis_dict['Frantic_Search'] = Vis(name = 'Frantic_Search', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Frantic Search, draw 2, discard 3', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Frantic Search, draw 2, discard 3', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        self.in_hand += self.library[0:2]
        self.library = self.library[2:]
        if len(self.in_hand) < 2:
            self.discard += self.in_hand
            self.in_hand = []
            root.after(2333, lambda  name = 'Frantic_Search' : self.cleanup_spell(name = name))
        else:
            self.page_frantic_search(hand_list = self.in_hand[:])
        
        # discard 2 like page regrowth
    def page_frantic_search(self, event = None, hand_list = None, index = 0, times = 1):
        app.unbind_all()
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        for i, card in enumerate(hand_list[index:index+5]):
            i += 1
            p = partial(self.frantic_discard, card = card, times = times)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(card.replace('_', ' ')), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda name = card : action_description(name))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hl = hand_list, i = index-5, t = times : self.page_frantic_search(hand_list = hl, index = i, times = t))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, hl = hand_list, i = index-5, t = times : self.page_frantic_search(hand_list = hl, index = i, times = t))
            app.context_buttons.append(b4)
        if len(hand_list) > len(hand_list[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda hl = hand_list, i = index+5, t = times : self.page_frantic_search(hand_list = hl, index = i, times = t))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, hl = hand_list, i = index+5, t = times : self.page_frantic_search(hand_list = hl, index = i, times = t))
                    
                    
            
    def frantic_discard(self, event = None, card = None, times = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        # discard the card, if times is 1 page again with times set to 2, if times is 2 exit
        self.in_hand.remove(card)
        self.discard.append(card)
        if times < 3:
            times += 1
            self.page_frantic_search(hand_list = self.in_hand[:], index = 0, times = times)
        else:
            self.cleanup_spell(name = 'Frantic_Search')
        
        
    def upheaval(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Upheaval' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_upheaval)
        b = tk.Button(app.context_menu, text = 'Confirm Upheaval', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_upheaval(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_upheaval(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Upheaval'].cost
        spell = self.arcane_dict['Upheaval']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Upheaval'] = Vis(name = 'Upheaval', loc = self.loc[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Upheaval', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Upheaval', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # for each ent, if it is in smns list, destroy it and decrement summon_count for owner and its owner draws a card
        # for each tomb, destroy it and decr imprint for owner and its owner draws a card
        ents = [v for k,v in app.all_ents().items() if v.name in app.summons_list or isinstance(v,Tomb)]
        for e in ents:
            if e.owner == 'p1':
                witch = app.ent_dict[app.p1_witch]
            else:
                witch = app.ent_dict[app.p2_witch]
            witch.summon_count = max(0,witch.summon_count-1)
            if witch.library != []:
                witch.in_hand.append(witch.library[0])
                witch.library = witch.library[1:]
            lock(app.kill, e.id)
        root.after(666, lambda  name = 'Upheaval' : self.cleanup_spell(name = name))
        
    # add action to witch, on agl v agl to-hit, +1 psy self, -1 psy tar
    def profane_pshent(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Profane_Pshent' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_profane_pshent)
        b = tk.Button(app.context_menu, text = 'Confirm Profane Pshent', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_profane_pshent(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_profane_pshent(self, event):
        if 'Profane_Pshent' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Profane_Pshent'].cost
        spell = self.arcane_dict['Profane_Pshent']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Profane_Pshent'] = Vis(name = 'Profane_Pshent', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Devour Intellect', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Devour Intellect', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
        # add devour intellect action
        def devour_intellect(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Devour Intellect', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                if ent.get_abl('psyche') < 2:
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Devour_Intellect'] = Vis(name = 'Devour_Intellect', loc = visloc)
                my_agl = obj.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl) == True:
                    # add efcts
                    def devour_minus(stat):
                        return max(1,stat-1)
                    p = partial(devour_minus)
                    ent.psyche_effects.append(p)
                    def devour_plus(stat):
                        return stat+1
                    p2 = partial(devour_plus)
                    obj.psyche_effects.append(p2)
                    def undo(ent, p, lockname = None):
                        ent.psyche_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    u2 = partial(undo, obj, p2)
                    n = 'devour'+str(app.count)
                    app.count += 1
                    n2 = 'devour'+str(app.count)
                    app.count += 1
                    ent.effects_dict[n] = Effect(name = 'Devour_Intellect', undo_func = u, duration = obj.get_abl('rsn'), level = obj.get_abl('wis'))
                    obj.effects_dict[n2] = Effect(name = 'Devour_Intellect', undo_func = u2, duration = obj.get_abl('rsn'), level = obj.get_abl('wis'))
                    app.canvas.create_text(obj.loc[0]*100+49-app.moved_right, obj.loc[1]*100+84-app.moved_down, text = '+1 Psyche', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(obj.loc[0]*100+50-app.moved_right, obj.loc[1]*100+85-app.moved_down, text = '+1 Psyche', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-1 Psyche', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-1 Psyche', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
                    root.after(1999, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(ent.loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Devour_Intellect']
                    app.canvas.delete('Devour_Intellect')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(devour_intellect, obj = self)
        def add_devour(actions = None, func = None):
            actions['Devour Intellect'] = func
            return actions
        p2 = partial(add_devour, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'devour' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Profane_Pshent', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        
        root.after(2333, lambda  name = 'Profane_Pshent' : self.cleanup_spell(name = name))



    def imbue_thrall(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Imbue_Thrall' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_imbue_thrall)
        b = tk.Button(app.context_menu, text = 'Confirm Imbue Thrall', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_imbue_thrall(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_imbue_thrall(self, event):
        if 'Imbue_Thrall' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Imbue_Thrall'].cost
        spell = self.arcane_dict['Imbue_Thrall']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Imbue_Thrall'] = Vis(name = 'Imbue_Thrall', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Imbue', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Imbue', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
        # add imbue action
        def imbue(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Imbue', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.all_ents().keys():
                    return
                ent = app.ent_dict[id]
                if isinstance(ent,Witch):
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Imbue'] = Vis(name = 'Imbue', loc = visloc)
                # choose abl
                abls = ['strength', 'agility', 'endurance', 'dodge', 'psyche', 'wisdom', 'reason', 'sanity', 'initiative']
                for abl in abls:
                    b = tk.Button(app.context_menu, text = abl, wraplength = 190, font = ('chalkduster', 16), fg = 'tan3', highlightbackground = 'tan3', command = lambda obj = obj, ent = ent, abl = abl : choose_imbue(obj = obj, ent = ent, abl = abl))
                    b.pack(side = 'top')
                    app.context_buttons.append(b)
            def choose_imbue(event = None, obj = None, ent = None, abl = None):
                app.depop_context(event = None)
#                 app.canvas.delete('text')
                if abl == 'strength':
                    amt = obj.get_abl('str')
                elif abl == 'agility':
                    amt = obj.get_abl('agl')
                elif abl == 'endurance':
                    amt = obj.get_abl('end')
                elif abl == 'dodge':
                    amt = obj.get_abl('dodge')
                elif abl == 'psyche':
                    amt = obj.get_abl('psyche')
                elif abl == 'wisdom':
                    amt = obj.get_abl('wis')
                elif abl == 'reason':
                    amt = obj.get_abl('rsn')
                elif abl == 'sanity':
                    amt = obj.get_abl('san')
                elif abl == 'initiative':
                    amt = obj.get_abl('init')
                def imbue_efct(stat, amt = None):
                    return max(1,amt)
                p = partial(imbue_efct, amt = amt)
                if abl == 'strength':
                    ent.str_effects.append(p)
                elif abl == 'agility':
                    ent.agl_effects.append(p)
                elif abl == 'endurance':
                    ent.end_effects.append(p)
                elif abl == 'dodge':
                    ent.dodge_effects.append(p)
                elif abl == 'psyche':
                    ent.psyche_effects.append(p)
                elif abl == 'wisdom':
                    ent.wis_effects.append(p)
                elif abl == 'reason':
                    ent.rsn_effects.append(p)
                elif abl == 'sanity':
                    ent.san_effects.append(p)
                elif abl == 'initiative':
                    ent.init_effects.append(p)
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Set '+abl+' to '+str(amt), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Set '+abl+' to '+str(amt), justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                def undo(ent, abl, func, lockname = None):
                    if abl == 'strength':
                        ent.str_effects.remove(func)
                    elif abl == 'agility':
                        ent.agl_effects.remove(func)
                    elif abl == 'endurance':
                        ent.end_effects.remove(func)
                    elif abl == 'dodge':
                        ent.dodge_effects.remove(func)
                    elif abl == 'psyche':
                        ent.psyche_effects.remove(func)
                    elif abl == 'wisdom':
                        ent.wis_effects.remove(func)
                    elif abl == 'reason':
                        ent.rsn_effects.remove(func)
                    elif abl == 'sanity':
                        ent.san_effects.remove(func)
                    elif abl == 'initiative':
                        ent.init_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, abl, p)
                n = 'imbue'+str(app.count)
                ent.effects_dict[n] = Effect(name = 'Imbue', undo_func = u, duration = 1, level = self.get_abl('wis'))
                root.after(1999, lambda obj = obj : cancel_attack(obj = obj))
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Imbue']
                    app.canvas.delete('Imbue')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(imbue, obj = self)
        def add_imbue(actions = None, func = None):
            actions['Imbue'] = func
            return actions
        p2 = partial(add_imbue, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'imbue' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Imbue_Thrall', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, lambda  name = 'Imbue_Thrall' : self.cleanup_spell(name = name))


        
    # b blade of disaster- adds black blade strike- adj agl v agl, str v end amt -amt to rndm stat
    def black_blade_of_disaster(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Black_Blade_of_Disaster' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_b_blade)
        b = tk.Button(app.context_menu, text = 'Confirm Black Blade of Disaster', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_b_blade(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_b_blade(self, event):
        if 'Black_Blade_of_Disaster' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Black_Blade_of_Disaster'].cost
        spell = self.arcane_dict['Black_Blade_of_Disaster']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Black_Blade_of_Disaster'] = Vis(name = 'Black_Blade_of_Disaster', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Black Blade of Disaster', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Black Blade of Disaster', justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
        # add b blade action
        def b_blade_strike(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Black Blade of Disaster', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Black_Blade_Strike'] = Vis(name = 'Black_Blade_Strike', loc = visloc)
                my_agl = obj.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl) == True:
                    # get amt (damage) and apply as neg efct to rand abl
                    amt = damage(obj.get_abl('str'),ent.get_abl('end'))
                    abl = choice(['str','end','agl','dodge','wis','psyche','rsn','init','san'])
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '- '+str(amt)+' '+str(abl), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '- '+str(amt)+' '+str(abl), justify = 'center', font = ('chalkduster', 13), fill = 'magenta', tags = 'text')
                    # add neg efct
                    def b_blade_efct(stat, amt = None):
                        return max(1,stat-amt)
                    p = partial(b_blade_efct, amt = amt)
                    if abl == 'str':
                        ent.str_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.str_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'agl':
                        ent.agl_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.agl_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'end':
                        ent.end_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.end_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'dodge':
                        ent.dodge_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.dodge_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'psyche':
                        ent.psyche_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.psyche_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'wis':
                        ent.wis_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.wis_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'rsn':
                        ent.rsn_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.rsn_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'san':
                        ent.san_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.san_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    elif abl == 'init':
                        ent.init_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.init_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                    n = 'b_blade' + str(app.count)
                    self.effects_dict[n] = Effect(name = 'Disaster', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1888, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(ent.loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Black_Blade_Strike']
                    app.canvas.delete('Black_Blade_Strike')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(b_blade_strike, obj = self)
        def add_b_blade(actions = None, func = None):
            actions['Black Blade Strike'] = func
            return actions
        p2 = partial(add_b_blade, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'b_blade' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Black_Blade_of_Disaster', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Black_Blade_of_Disaster' : self.cleanup_spell(name = name))
        
        
    # add vorpal_strike to self, on agl vs agl, str vs end slsh mle dmg, auto-kill animal type
    def vorpal_blade(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Vorpal_Blade' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_vorpal_blade)
        b = tk.Button(app.context_menu, text = 'Confirm Vorpal Blade', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_vorpal_blade(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vorpal_blade(self, event):
        if 'Vorpal_Blade' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Vorpal_Blade'].cost
        spell = self.arcane_dict['Vorpal_Blade']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Vorpal_Blade'] = Vis(name = 'Vorpal_Blade', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Vorpal Blade', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Vorpal Blade', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        # add vorpal strike action
        def vorpal_strike(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Vorpal Strike', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Vorpal_Strike'] = Vis(name = 'Vorpal_Strike', loc = visloc)
                my_agl = obj.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl) == True:
                    if 'animal' in ent.get_types():
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Auto kill animal', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Auto kill animal', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                        lock(app.kill, ent.id)
                        root.after(666, lambda e = None, obj = obj : cancel_attack(e, obj))
                    else:
                        d = damage(obj.get_abl('str'),ent.get_abl('end'))
                        lock(apply_damage, obj, ent, -d, 'slashing', 'Vorpal Strike', 'melee')
                        root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(ent.loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Vorpal_Strike']
                    app.canvas.delete('Vorpal_Strike')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(vorpal_strike, obj = self)
        def add_vorpal_blade(actions = None, func = None):
            actions['Vorpal Blade'] = func
            return actions
        p2 = partial(add_vorpal_blade, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'vorp' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Vorpal_Blade', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Vorpal_Blade' : self.cleanup_spell(name = name))
        
        
    def burning_hands(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Burning_Hands' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_burning_hands)
        b = tk.Button(app.context_menu, text = 'Confirm Burning Hands', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_burning_hands(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_burning_hands(self, event):
        if 'Burning_Hands' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Burning_Hands'].cost
        spell = self.arcane_dict['Burning_Hands']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Burning_Hands'] = Vis(name = 'Burning_Hands', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Burning Hands', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Burning Hands', justify = 'center', font = ('chalkduster', 13), fill = 'indianred', tags = 'text')
        # add flame fan action
        def flame_fan(event = None, obj = None):
            if obj.acts < 1:
                return
            if obj.magick < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Flame Fan', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.spell_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
                obj.magick -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/flare.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Flame_Fan'] = Vis(name = 'Flame_Fan', loc = visloc)
                my_wis = obj.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis) == True:
                    d = damage(obj.get_abl('psyche'),ent.get_abl('psyche'))
                    lock(apply_damage, obj, ent, -d, 'fire', 'Flame Fan', 'spell')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(ent.loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Flame_Fan']
                    app.canvas.delete('Flame_Fan')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(flame_fan, obj = self)
        def add_flame_fan(actions = None, func = None):
            actions['Flame Fan'] = func
            return actions
        p2 = partial(add_flame_fan, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'flamefan' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Burning_Hands', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Burning_Hands' : self.cleanup_spell(name = name))
        
        
        
    def acid_arrow(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Acid_Arrow' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_acid_arrow)
        b = tk.Button(app.context_menu, text = 'Confirm Acid Arrow', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_acid_arrow(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_acid_arrow(self, event):
        if 'Acid_Arrow' in [v.name for k,v in self.effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Acid_Arrow'].cost
        spell = self.arcane_dict['Acid_Arrow']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Acid_Arrow'] = Vis(name = 'Acid_Arrow', loc = sqr[:])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Acid Arrow', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Acid Arrow', justify = 'center', font = ('chalkduster', 13), fill = 'limegreen', tags = 'text')
        # add Acid Bolt action
        def acid_bolt(event = None, obj = None):
            if obj.acts < 1:
                return
            if obj.magick < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(obj.loc,c) <= obj.get_abl('rsn')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Acid Bolt', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.spell_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
                obj.magick -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/plague.ogg')
                effect1.set_volume(app.effects_volume.get())
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                lock(Entity.ranged_attack, obj, ent.loc, 'Acid_Bolt')
                my_wis = obj.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis) == True:
                    d = damage(obj.get_abl('psyche'),ent.get_abl('psyche'))
                    lock(apply_damage, obj, ent, -d, 'acid', 'Acid Bolt', 'spell')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(ent.loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Acid_Bolt']
                    app.canvas.delete('Acid_Bolt')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
                app.exists_check(app.active_ent)
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(acid_bolt, obj = self)
        def add_acid_bolt(actions = None, func = None):
            actions['Acid Bolt'] = func
            return actions
        p2 = partial(add_acid_bolt, func = p)
        self.action_effects.append(p2)
        def un(ent, func, lockname = None):
            ent.action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, self, p2)
        n = 'acidbolt' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Acid_Arrow', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Acid_Arrow' : self.cleanup_spell(name = name))
        
        
    def meditate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Meditate' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_meditate)
        b = tk.Button(app.context_menu, text = 'Confirm Meditate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_meditate(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_meditate(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Meditate'].cost
        spell = self.arcane_dict['Meditate']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Meditate'] = Vis(name = 'Meditate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Meditate'].img, tags = 'Meditate')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Meditate', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Meditate', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # DO Meditate EFFECTS
        def meditate_effect(stat):
            stat += 1
            return stat
        f = meditate_effect
        app.ent_dict[id].psyche_effects.append(f)
############################################
        def meditate_move(move_range):
            return move_range + 2
        app.ent_dict[id].move_range_effects.append(meditate_move)
        def un(i, lockname = None):
            app.ent_dict[i].psyche_effects.remove(meditate_effect)
            app.ent_dict[i].move_range_effects.remove(meditate_move)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = 'Meditate' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Meditate', undo_func = p, duration = 1, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Meditate' : self.cleanup_spell(name = name))
        
        
    def mind_rot(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= max(1,self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mind_rot(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mind Rot', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mind_rot(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mind_rot(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Mind_Rot' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        ent = app.ent_dict[id]
        if isinstance(id, Witch):
            return
        self.magick -= self.arcane_dict['Mind_Rot'].cost
        spell = self.arcane_dict['Mind_Rot']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/disintegrate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mind_Rot'] = Vis(name = 'Mind_Rot', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mind_Rot'].img, tags = 'Mind_Rot')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Mind Rot', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Mind Rot', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def mind_rot_effect(stat):
            return max(1, stat-3)
        p = partial(mind_rot_effect)
        def mind_rot_wis(stat):
            return max(1, stat-2)
        p2 = partial(mind_rot_wis)
        def mind_rot_rsn(stat):
            return max(1, stat-1)
        p3 = partial(mind_rot_rsn)
        ent.san_effects.append(p)
        ent.wis_effects.append(p2)
        ent.rsn_effects.append(p3)
        def un(id, p, p2, p3, lockname = None):
            app.ent_dict[id].san_effects.remove(p)
            app.ent_dict[id].wis_effects.remove(p2)
            app.ent_dict[id].rsn_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p, p2, p3)
        n = 'Mind_Rot' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Mind_Rot', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = ent.loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-1 rsn, -2 wis, -3 san', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-1 rsn, -2 wis, -3 san', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Mind_Rot' : self.cleanup_spell(name = name))
        
    def horrid_wilting(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Horrid_Wilting' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_horrid_wilting(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Horrid Wilting', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_horrid_wilting(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_horrid_wilting(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/horrid_wilting.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Horrid_Wilting'].cost
        spell = self.arcane_dict['Horrid_Wilting']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2]
        def horrid_loop(ents):
            if ents == []:
                root.after(666, lambda  name = 'Horrid_Wilting' : self.cleanup_spell(name = name))
            else:
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                n = 'Horrid_Wilting' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                loc = app.ent_dict[id].loc[:]
                app.vis_dict[n] = Vis(name = 'Horrid_Wilting', loc = loc)
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                    app.canvas.delete('text')
                rand_start_anim = randrange(1,7)
                for i in range(rand_start_anim):
                    app.vis_dict[n].rotate_image()
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                # tohit?
                if to_hit(self.get_abl('wis'),app.ent_dict[id].get_abl('wis')):
                    my_psyche = self.get_abl('psyche')
                    tar_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_psyche, tar_end)
                    root.after(1555, lambda n = n : cleanup_vis(n))
                    lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Horrid Wilting', 'spell')
                    root.after(111, lambda ents = ents : horrid_loop(ents))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1555, lambda n = n : cleanup_vis(n))
                    root.after(1666, lambda ents = ents : horrid_loop(ents))
        horrid_loop(ents)
        
        
    def grasp_of_the_old_ones(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_grasp(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Grasp', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_grasp(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/grasp_of_the_old_ones.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Grasp_of_the_Old_Ones'].cost
        spell = self.arcane_dict['Grasp_of_the_Old_Ones']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        ent = app.ent_dict[id]
        app.vis_dict['Grasp_of_the_Old_Ones'] = Vis(name = 'Grasp_of_the_Old_Ones', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Grasp_of_the_Old_Ones'].img, tags = 'Grasp_of_the_Old_Ones')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Grasp of the Old Ones', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Grasp of the Old Ones', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        my_psy = self.get_abl('psyche')
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Lose psyshield, invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Lose psyshield, invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
            def grasp_effect(types):
                return [t for t in types if t != 'psyshield' or t != 'invisibility']
            p = partial(grasp_effect)
            ent.type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Grasp_of_the_Old_Ones' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Grasp_of_the_Old_Ones', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        

        root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        
    def boiling_blood(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Boiling_Blood' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_boiling_blood(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Boiling Blood', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_boiling_blood(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_boiling_blood(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Boiling_Blood' in effs:
            return
        effect1 = mixer.Sound('Sound_Effects/boiling_blood.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Boiling_Blood'].cost
        spell = self.arcane_dict['Boiling_Blood']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.vis_dict['Boiling_Blood'] = Vis(name = 'Boiling_Blood', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Boiling_Blood'].img, tags = 'Boiling_Blood')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Boiling\nBlood', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        # DO Boiling_Blood EFFECTS
        def boiling_blood_str_effect(stat):
            stat += 4
            return stat
        def boiling_blood_end_effect(stat):
            return max(1, stat-4)
        ent.str_effects.append(boiling_blood_str_effect)
        ent.end_effects.append(boiling_blood_end_effect)
        def un(i, lockname = None):
            app.ent_dict[i].str_effects.remove(boiling_blood_str_effect)
            app.ent_dict[i].end_effects.remove(boiling_blood_end_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        # EOT FUNC
        def take_2(tar, lockname = None):
            app.get_focus(tar)
            lock(apply_damage, self, app.ent_dict[tar], -2, 'fire', 'Boiling Blood', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(take_2, id)
        n = 'Boiling_Blood' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Boiling_Blood', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, lambda  name = 'Boiling_Blood' : self.cleanup_spell(name = name))
        
    
        
    def dark_sun(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Dark_Sun' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dark_sun(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dark Sun', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dark_sun(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dark_sun(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Dark_Sun' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        self.magick -= self.arcane_dict['Dark_Sun'].cost
        spell = self.arcane_dict['Dark_Sun']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.cleanup_squares()
        app.vis_dict['Dark_Sun'] = Vis(name = 'Dark_Sun', loc = sqr[:]) #[sqr[0],sqr[1]-1])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Dark_Sun'].img, tags = 'Dark_Sun')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down+14, text = 'Dark Sun', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down+15, text = 'Dark Sun', justify ='center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        selected_vis = ['Dark_Sun']
        def dark_sun_loop(starty, endy, x):
            if starty > endy:
                app.vis_dict['Dark_Sun'].rotate_image()
                app.canvas.delete('Dark_Sun')
                app.canvas.create_image(x, starty, image = app.vis_dict['Dark_Sun'].img, tags = 'Dark_Sun')
                starty -= 10
                app.canvas.move('Dark_Sun', 0, -10)
                app.canvas.tag_raise('Dark_Sun')
            if starty == endy:
                root.after(1333, lambda  name = 'Dark_Sun' : self.cleanup_spell(name = name))
            else:
                root.after(299, lambda sy = starty, ey = endy, x = x : dark_sun_loop(sy, ey, x))
        locy = sqr[1]*100+70-app.moved_down
        locx = sqr[0]*100+50-app.moved_right
        # Effect
        if app.ent_dict[id].save_check('wis') == 'Pass':
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+74, text = '+1 actions', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+75, text = '+1 actions', justify ='center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            def dark_acts(acts):
                return acts+1
            p = partial(dark_acts)
            app.ent_dict[id].acts_effects.append(p)
            app.ent_dict[id].acts += 1
            def undo(id, func, lockname = None):
                app.ent_dict[id].acts_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Dark_Sun' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Dark_Sun', undo_func = u, duration = 1, level = self.get_abl('wis'))
        else:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+74, text = 'Save fail...', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+75, text = 'Save fail...', justify ='center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        dark_sun_loop(locy, locy-90, locx)

        
    # change mummify, too good with leap still make useful combo, disable leap
    def mummify(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mummify(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mummify', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mummify(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mummify(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Mummify' in effs:
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        effect1 = mixer.Sound('Sound_Effects/mummify.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Mummify'].cost
        spell = self.arcane_dict['Mummify']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mummify'] = Vis(name = 'Mummify', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Mummify', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Mummify', justify = 'center', font = ('chalkduster', 14), fill = 'darkgoldenrod', tags = 'text')
        # DO Mummify EFFECTS
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = '+4 end, move reduced to 1', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = '+4 end, move reduced to 1', justify = 'center', font = ('chalkduster', 14), fill = 'darkgoldenrod', tags = 'text')
        def mummify_effect(stat):
            stat += 4
            return stat
        f = mummify_effect
        ent.end_effects.append(f)
        def mummy_moves(move_range):
            if move_range < 2:
                return move_range
            else:
                return 1
        ent.move_range_effects.append(mummy_moves)
        if isinstance(ent, Berserker):
            ent.leap_used = True
        def sot(ent, lockname = None):
            if isinstance(ent, Berserker):
                ent.leap_used = True
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p_sot = partial(sot, ent)
        def un(ent, lockname = None):
            ent.end_effects.remove(mummify_effect)
            ent.move_range_effects.remove(mummy_moves)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent)
        n = 'Mummify' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Mummify', undo_func = u, sot_func = p_sot, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Mummify' : self.cleanup_spell(name = name))
        
        
    def dust_devil(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dust_devil(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dust Devil', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dust_devil(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dust_devil(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        self.magick -= self.arcane_dict['Dust_Devil'].cost
        spell = self.arcane_dict['Dust_Devil']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Dust Devil', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Dust Devil', justify = 'center', font = ('chalkduster', 14), fill = 'goldenrod', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        n = 'Dust_Devil'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Dust_Devil', loc = sqr[:])
        def cleanup_dustd(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_dustd(n))
        if to_hit(my_wis, tar_wis):
            my_psyche = self.get_abl('psyche')
            tar_psyche = ent.get_abl('psyche')
            d = damage(my_psyche, tar_psyche)
            locs = [c for c in app.coords if dist(c,ent.loc) <= self.get_abl('psyche') and app.grid[c[0]][c[1]] == '']
            if locs != []:
                newloc = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, locs)
                lock(ent.throw_move, newloc)
                app.canvas.delete('text')
                app.get_focus(id)
            lock(apply_damage, self, ent, -d, 'explosive', 'Dust Devil', 'spell')
            root.after(333, lambda  name = 'Dust_Devil' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1666, lambda  name = 'Dust_Devil' : self.cleanup_spell(name = name))
        
        
    def dispel(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dispel(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dispel', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dispel(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dispel(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Dispel'].cost
        spell = self.arcane_dict['Dispel']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         effect1 = mixer.Sound('Sound_Effects/dispel.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Dispel'] = Vis(name = 'Dispel', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Dispel'].img, tags = 'Dispel')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Dispel', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Dispel', justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        misswatch = 0
        if to_hit(my_wis, tar_wis):
            misswatch += 1
            spacer = 30
            to_remove = []
            for k,v in ent.effects_dict.items():
                if v.dispel(self.get_abl('wis')) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                    spacer += 15
            for k in to_remove:
                del app.ent_dict[id].effects_dict[k]
        if to_hit(my_wis, tar_wis):
            misswatch += 1 
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
            def dispel_effect(types):
                return [t for t in types if t != 'psyshield']
            p = partial(dispel_effect)
            ent.type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Dispel' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Dispel', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        if misswatch == 0:
            miss(ent.loc)
        root.after(2666, lambda  name = 'Dispel' : self.cleanup_spell(name = name))
        
    def immolate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= max(1,self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_immolate(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Immolate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_immolate(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_immolate(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Immolate'].cost
        spell = self.arcane_dict['Immolate']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Immolate'] = Vis(name = 'Immolate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Immolate'].img, tags = 'Immolate')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Immolate', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Immolate', justify = 'center', font = ('chalkduster', 14), fill = 'indianred3', tags = 'text')
        my_psyche = self.get_abl('psyche')
        tar_psyche = app.ent_dict[id].get_abl('psyche')
        d = damage(my_psyche, tar_psyche)
        lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Immolate', 'spell')
        root.after(333, lambda  name = 'Immolate' : self.cleanup_spell(name = name))
        
        
    def disintegrate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_disintegrate(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Disintegrate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_disintegrate(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_disintegrate(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Disintegrate' in effs:
            return
        ent = app.ent_dict[id]
        if isinstance(ent, Witch):
            return
        self.magick -= self.arcane_dict['Disintegrate'].cost
        spell = self.arcane_dict['Disintegrate']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        effect1 = mixer.Sound('Sound_Effects/disintegrate.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Disintegrate'] = Vis(name = 'Disintegrate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Disintegrate'].img, tags = 'Disintegrate')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Disintegrate', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Disintegrate', justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        # DO Disintegrate EFFECTS
        def disintegrate_effect(stat):
            return max(1,stat-1)
        f = disintegrate_effect
        rnd = choice(['str','end','agl','rsn','san'])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '-1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '-1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        if rnd == 'str':
            app.ent_dict[id].str_effects.append(f)
        elif rnd == 'end':
            app.ent_dict[id].end_effects.append(f)
        elif rnd == 'agl':
            app.ent_dict[id].agl_effects.append(f)
        elif rnd == 'rsn':
            app.ent_dict[id].rsn_effects.append(f)
        elif rnd == 'san':
            app.ent_dict[id].san_effects.append(f)
        def un(i, f, lockname = None):
            if f in app.ent_dict[i].str_effects:
                app.ent_dict[i].str_effects.remove(f)
            elif f in app.ent_dict[i].end_effects:
                app.ent_dict[i].end_effects.remove(f)
            elif f in app.ent_dict[i].agl_effects:
                app.ent_dict[i].agl_effects.remove(f)
            elif f in app.ent_dict[i].rsn_effects:
                app.ent_dict[i].rsn_effects.remove(f)
            elif f in app.ent_dict[i].san_effects:
                app.ent_dict[i].san_effects.remove(f)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, f)
        # EOT FUNC
        def disint(tar, lockname = None):
            def disintegrate_effect(stat):
                return max(1,stat-1)
            f = disintegrate_effect
            rnd = choice(['str','end','agl','rsn','san'])
            ent = app.ent_dict[tar]
            app.get_focus(tar)
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Disintegrate, -1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Disintegrate, -1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
            if rnd == 'str':
                app.ent_dict[tar].str_effects.append(f)
            elif rnd == 'end':
                app.ent_dict[tar].end_effects.append(f)
            elif rnd == 'agl':
                app.ent_dict[tar].agl_effects.append(f)
            elif rnd == 'rsn':
                app.ent_dict[tar].rsn_effects.append(f)
            elif rnd == 'san':
                app.ent_dict[tar].san_effects.append(f)
            def un(prev_undo, i, f, lockname = None):
                if f in app.ent_dict[i].str_effects:
                    app.ent_dict[i].str_effects.remove(f)
                elif f in app.ent_dict[i].end_effects:
                    app.ent_dict[i].end_effects.remove(f)
                elif f in app.ent_dict[i].agl_effects:
                    app.ent_dict[i].agl_effects.remove(f)
                elif f in app.ent_dict[i].rsn_effects:
                    app.ent_dict[i].rsn_effects.remove(f)
                elif f in app.ent_dict[i].san_effects:
                    app.ent_dict[i].san_effects.remove(f)
                prev_undo(lockname)
            for k,v in app.ent_dict[tar].effects_dict.items():
                if v.name == 'Disintegrate':
                    key = k
            app.ent_dict[tar].effects_dict[k].undo_func = partial(un, app.ent_dict[tar].effects_dict[k].undo_func, tar, f)
            lock(apply_damage, self, app.ent_dict[tar], -1, 'acid', 'Disintegrate', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(disint, id)
        n = 'Disintegrate' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Disintegrate', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Disintegrate' : self.cleanup_spell(name = name))
        
        
        
    # all friendly ents within range 3 get +1 all attrs and heals 1 spirit, all enemy ents get -1 all attrs and loses 1 spirit, lasts 3 turns, does not stack
    def command_of_osiris(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= max(1, self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqrs = sqrs : self.do_command_of_osiris(event = e, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Command of Osiris', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_command_of_osiris(e, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_command_of_osiris(self, event, sqrs):
        self.magick -= self.arcane_dict['Command_of_Osiris'].cost
        spell = self.arcane_dict['Command_of_Osiris']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        friendly_ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and v.loc in sqrs]
        enemy_ents = [k for k,v in app.all_ents().items() if v.owner != self.owner and v.loc in sqrs]
        # SUN VIS
        app.vis_dict['Osiris_Sun'] = Vis(name = 'Osiris_Sun', loc = [self.loc[0],self.loc[1]-4])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, (self.loc[1]-4)*100+50-app.moved_down, image = app.vis_dict['Osiris_Sun'].img, tags = 'Command_of_Osiris')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, (self.loc[1]-3)*100+14-app.moved_down, text = 'Command of Osiris', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, (self.loc[1]-3)*100+15-app.moved_down, text = 'Command of Osiris', justify = 'center', font = ('chalkduster', 14), fill = 'tan3', tags = 'text')
        def cleanup_sun():
            del app.vis_dict['Osiris_Sun']
            app.canvas.delete('Osiris_Sun')
        root.after(2666, cleanup_sun)
        # FRIENDLY ENTS
        for id in friendly_ents:
            effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
            if 'Osiris_Blessing' in effs:
                continue
            sqr = app.ent_dict[id].loc[:]
            uniq_name = 'Command_of_Osiris' + str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Command_of_Osiris', loc = sqr)
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = 'Command_of_Osiris')
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '+1 Str,End +1 Spirit', justify = 'center', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '+1 Str,End +1 Spirit', justify = 'center', font = ('chalkduster', 12), fill = 'tan3', tags = 'text')
            # CLEANUP UNIQUE VIS
            def cleanup_osiris(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(2666, lambda n = uniq_name : cleanup_osiris(n))
            # SPIRIT
            apply_heal(self, app.ent_dict[id], 1)
            # DO Command of Osiris EFFECTS
            def osiris_effect(stat):
                return stat+1
            p = partial(osiris_effect)
            app.ent_dict[id].str_effects.append(p)
            app.ent_dict[id].end_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Command_of_Osiris' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Osiris_Blessing', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        #  ENEMY ENTS
        for id in enemy_ents:
            effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
            if 'Osiris_Curse' in effs:
                continue
            sqr = app.ent_dict[id].loc[:]
            uniq_name = 'Command_of_Osiris' + str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Command_of_Osiris', loc = sqr)
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = 'Command_of_Osiris')
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '-1 Str,End', justify = 'center', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '-1 Str,End', justify = 'center', font = ('chalkduster', 12), fill = 'tan3', tags = 'text')
            # CLEANUP UNIQUE VIS
            def cleanup_osiris(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(2666, lambda n = uniq_name : cleanup_osiris(n))
            # DO Command of Osiris EFFECTS
            def osiris_effect(stat):
                return max(1,stat-1)
            p = partial(osiris_effect)
            app.ent_dict[id].str_effects.append(p)
            app.ent_dict[id].end_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Command_of_Osiris' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Osiris_Curse', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, lambda  name = 'Command_of_Osiris' : self.cleanup_spell(name = name))
        
# MORGAN SPELLS
        # Morgan's spells center around Nature/Earth/Weather/Illusion
        
    def fleet_of_paw(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Fleet_of_Paw' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_fleet_of_paw)
        b = tk.Button(app.context_menu, text = 'Confirm Fleet of Paw', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_fleet_of_paw(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fleet_of_paw(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        id = self.name
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Fleet of Paw', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Fleet of Paw', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        def cleanup_fop(un):
            app.canvas.delete(un)
            del app.vis_dict[un]
            app.canvas.delete('text')
        def fop_loop(ents):
            if ents == []:
                self.cleanup_spell('Fleet_of_Paw')
            else:
                id = ents[0]
                ents = ents[1:]
                if 'Fleet_of_Paw' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    app.get_focus(id)
                    s = app.ent_dict[id].loc[:]
                    un = 'FOP' + str(app.count)
                    app.vis_dict['Fleet_of_Paw'] = Vis(name = 'Fleet_of_Paw', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                    def fop_move(r):
                        return r + 1
                    p = partial(fop_move)
                    app.ent_dict[id].move_range_effects.append(p)
                    def un(id, f, lockname = None):
                        app.ent_dict[id].move_range_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p)
                    app.ent_dict[id].effects_dict[un] = Effect(name = 'Fleet_of_Paw', undo_func = u, duration = 1, level = self.get_abl('psyche'))
                    root.after(1555, lambda un = un : cleanup_fop(un))
                    root.after(1666, lambda ents = ents : fop_loop(ents))
                else:
                    fop_loop(ents)
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        ents = [k for k,v in app.ent_dict.items() if v.owner == self.owner and isinstance(v, (Thaumaturge, Illusionist, Umbrae_Wolf, Berserker, Murrain_Wolf))]
        root.after(1666, lambda ents = ents : fop_loop(ents))
                    
                    
    def hypnotic_spectre(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_hypnotic_spectre(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Hypnotic Spectre', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e, sqr = grid_pos, sqrs = sqrs : self.do_hypnotic_spectre(e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_hypnotic_spectre(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Hypnotic_Spectre' in [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/hunting_hawk.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Hypnotic_Spectre'].cost
        spell = self.arcane_dict['Hypnotic_Spectre']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        def clean_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1555, clean_summon)
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Hypnotic Spectre', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Hypnotic Spectre', justify = 'center', font = ('chalkduster', 14), fill = 'gray', tags = 'text')
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Hypnotic_Spectre.png'))
        app.ent_dict[id] = Hypnotic_Spectre(name = 'Hypnotic_Spectre', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        root.after(1666, lambda  name = 'Hypnotic_Spectre' : self.cleanup_spell(name = name))
                    
                    
    def barrow_wight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_barrow_wight(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Barrow Wight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e, sqr = grid_pos, sqrs = sqrs : self.do_barrow_wight(e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_barrow_wight(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Barrow_Wight' in [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/hunting_hawk.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Barrow_Wight'].cost
        spell = self.arcane_dict['Barrow_Wight']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        def clean_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1555, clean_summon)
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Barrow Wight', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Barrow Wight', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Barrow_Wight.png'))
        app.ent_dict[id] = Barrow_Wight(name = 'Barrow_Wight', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        root.after(1666, lambda  name = 'Barrow_Wight' : self.cleanup_spell(name = name))
                    
    def deaths_head_moth(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = "Death's_Head_Moth" : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(s,self.loc) <= self.get_abl('rsn') and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_deaths_head_moth(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Cofirm Death's Head Moth", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_deaths_head_moth(e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_deaths_head_moth(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Deaths_Head_Moth' in [v.name for k,v in app.all_ents().items() if v.owner == self.owner]:
            return
        tombs = [v for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner==self.owner and v.imprint == "Death's_Head_Moth"]
        if tombs == []:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/hunting_hawk.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict["Death's_Head_Moth"].cost
        spell = self.arcane_dict["Death's_Head_Moth"]
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        tomb = choice(tombs)
        lock(app.kill, tomb.id)
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        def clean_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1555, clean_summon)
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = "Death's Head Moth", justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = "Death's Head Moth", justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Deaths_Head_Moth.png'))
        app.ent_dict[id] = Deaths_Head_Moth(name = 'Deaths_Head_Moth', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        root.after(1666, lambda  name = "Death's_Head_Moth" : self.cleanup_spell(name = name))
                    
                    
    def hunting_hawk(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Hunting_Hawk' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if s == self.loc]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_hunting_hawk(event = e))
        b = tk.Button(app.context_menu, text = 'Confirm Hunting Hawk', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_hunting_hawk(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_hunting_hawk(self, event = None):
        if 'Hunting_Hawk' in [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/hunting_hawk.ogg')
#         effect1.set_volume(app.effects_volume.get())
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Hunting_Hawk'].cost
        spell = self.arcane_dict['Hunting_Hawk']
        self.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,spell.times_cast+1)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        sqrs = [s for s in app.coords if app.grid[s[0]][s[1]] == '']
        sqr = choice(sqrs)
        app.focus_square(sqr)
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        def clean_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1555, clean_summon)
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Hunting Hawk', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Hunting Hawk', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Hunting_Hawk.png'))
        app.ent_dict[id] = Hunting_Hawk(name = 'Hunting_Hawk', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        root.after(1666, lambda  name = 'Hunting_Hawk' : self.cleanup_spell(name = name))
    
    
    
    def entangle():
        pass
        
    def enchant(self, event = None):
            # any summon within range 4 has attrs (str, agl, end, dodge, psyche) set to 5 until 3 opp turns have passed, prevents further modification while active
        print('enchant')
        
    def wild_hunt(self, event = None):
            # Creates 3 summons within range 2 of caster or up to 3 if not enough squares available, first is Boar (stats 3,3,3,2,2,4,0) movement range 2 attack any adjacent, second is wolf (2,3,2,4,2,3,0) movement range 3 attack any adjacent, third is hawk (2,4,2,4,3,2,0) movement range 4 not impeded by other units/obstacles attack any adjacent
        print('wild_hunt')
        
    def ceridwens_command(self, event = None):
            # Command rules apply, caster cannot move, all squares within range 2 of caster become 'water' (impassable terrain) any ents currently occupying these squares are moved to a random square 'at edge' (closest available square to edge of water squares or first unoccupied square if all 'edge' squares are occupied), at end of turn caster heals 4 spirit, lasts until caster has 3 turns end (healing happens first)
        print('ceridwens_command')
        
    def natures_wrath(self, event = None):
            # Choose a square within range 5, all ents within range 2 of square must 'to hit' their inverted agl versus dodge at the end of every caster's turn, those that 'hit' suffer 3 spirit damage, lasts 3 caster's turns (effect happens 'before' end turn, effects happen 3 times)
        print('natures_wrath')
        
    def counterspell(self, event = None):
            # Choose a spell effect 'in play', make 'to hit' psyche versus effect's owner's psyche, on success cancel all effects from the spell (call its cleanup function) and effect's owner takes magick damage psyche versus psyche
        print('counterspell')
        
    
    
class VerticalScrolledFrame(tk.Frame): 
    '''
    * Use the 'interior' attribute to place widgets inside the scrollable frame
    * Construct and pack/place/grid normally
    * This frame only allows vertical scrolling
    '''
    def __init__(self, parent, *args, **kw):
        tk.Frame.__init__(self, parent, *args, **kw)
        # create a canvas object and a vertical scrollbar for scrolling it
        vscrollbar = tk.Scrollbar(self, orient=tk.VERTICAL, relief = 'raised', troughcolor = 'black', highlightbackground = 'black', width = 13)
        vscrollbar.pack(fill=tk.Y, side=tk.RIGHT, expand=tk.FALSE)
        canvas = tk.Canvas(self, bd=0, highlightthickness=0, bg = 'black',
                        yscrollcommand=vscrollbar.set)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=tk.TRUE)
        vscrollbar.config(command=canvas.yview)
        # reset the view
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        # create a frame inside the canvas which will be scrolled with it
        self.interior = interior = tk.Frame(canvas)
        interior_id = canvas.create_window(0, 0, window = interior, anchor = 'nw')
        # track changes to the canvas and frame width and sync them,
        # also updating the scrollbar
        def _configure_interior(event):
            # update the scrollbars to match the size of the inner frame
            size = (interior.winfo_reqwidth(), interior.winfo_reqheight())
            canvas.config(scrollregion="0 0 %s %s" % size)
            if interior.winfo_reqwidth() != canvas.winfo_width():
                # update the canvas's width to fit the inner frame
                canvas.config(width=interior.winfo_reqwidth())
        interior.bind('<Configure>', _configure_interior)

        def _configure_canvas(event):
            if interior.winfo_reqwidth() != canvas.winfo_width():
                # update the inner frame's width to fill the canvas
                canvas.itemconfigure(interior_id, width=canvas.winfo_width())
        canvas.bind('<Configure>', _configure_canvas)

# static class / interface used by computer controlled entities
class Ai_man():
    # handles computer or user controlled berserk ent
    # exits back to app.handle_action()
    def handle_berserk_ent_action(ent):
        def flail_loop(ent):# LOOPING in here or not exiting properly, focus stays on berserk ent
            if (ent.acts < 1 and ent.mvs < 1) or (ent.mvs < 1 and [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) == 1] == []):
                root.after(111, app.handle_action)
            else:
                if ent.acts > 0 and choice((0,1)):# rand choose, acts and mvs until they are exhausted
                    if ids := [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) == 1]:
                        if ent.acts > 0:
                            ent.acts -= 1
                            id = choice(ids)
                            app.get_focus(id)
                            my_agl = ent.get_abl('agl')
                            tar_agl = app.ent_dict[id].get_abl('agl')
                            if to_hit(my_agl, tar_agl) == True:
                                my_str = ent.get_abl('str')
                                tar_end = app.ent_dict[id].get_abl('end')
                                d = damage(my_str, tar_end)
                                lock(apply_damage, ent, app.ent_dict[id], -d, 'crushing', 'Flail', 'melee')
                                if ent in app.ent_dict.values():
                                    flail_loop(ent)
                                else:
                                    app.handle_action()
                            else:
                                miss(app.ent_dict[id].loc)
                                root.after(1111, lambda t = 'text' : app.canvas.delete(t))
                                root.after(1333, lambda e = ent : flail_loop(e))
                        else:##
                            if ent.legal_moves() == []:
                                app.handle_action()
                            else:
                                flail_loop(ent)
                    else:
                        flail_loop(ent)
                elif ent.mvs > 0:
                    if ent.legal_moves() != []:
                        mvs = ent.legal_moves()
                        mv = choice(mvs)
                        # DEBUG debug here, ethereal/flying/unobstructed moves may have no path...
                        app.focus_square(mv)
                        ent.mvs -= 1
                        name = 'dethlok'+str(app.death_count)
                        app.death_count += 1
                        app.dethloks[name] = tk.IntVar(0)
                        if ent.get_move_type() == 'normal' or ent.get_move_type() == 'charge':
                            Bot.ai_normal_move(ent, mv, name)
                        elif ent.get_move_type() == 'teleport':
                            Bot.ai_teleport_move(ent, mv, name)
                        else:
                            Bot.ai_flying_move(ent, mv, name)
                        app.wait_variable(app.dethloks[name])
#                         lock(ent.do_move, mv)
                        app.unbind_all()
                        flail_loop(ent)
                    else:## 
                        if ent.acts > 0 and [v for k,v in app.all_ents().items() if dist(v.loc,ent.loc) == 1] != []:
                            flail_loop(ent)
                        else:
                            app.handle_action()
                else:
                    flail_loop(ent)
        flail_loop(ent)
            
            
    # dispatches to other pursue functions
    # no dumb ranged pursue yet...
    def pursue(ent, target_type, smart_dumb, move_type, ideal_range):
        if ideal_range == 1:
            if smart_dumb == 'smart':
                if move_type == 'normal' or move_type == 'charge':
                    Ai_man.melee_pursue(ent, target_type)
                else:
                    Ai_man.ranged_flying_pursue(ent, ideal_range, target_type)
            else:
                Ai_man.melee_dumb_pursue(ent, target_type)
        else:
            if move_type == 'normal' or move_type == 'charge':
                Ai_man.ranged_pursue(ent, ideal_range, target_type)
            else:
                Ai_man.ranged_flying_pursue(ent, ideal_range, target_type)
            

    def ranged_flying_pursue(ent, ideal_range, target_type):
        ir = ideal_range
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('ranged_flying_pursue unknown target_type')
            gs1 = unique([g for g in app.coords for el in els if dist(el,g) <= ir and app.grid[g[0]][g[1]] == ''])
            # strip of all not closest to self
            gs1 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs1]), gs1))
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(30,60)]
            mvs = ent.legal_moves()
            # 'flee' to maxim dist among legal_moves if already inside range of atk, already atked
            if target_type == 'spell':
                close_ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'action':
                close_ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'all':
                close_ents = [k for k,v in app.all_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            else:
                print('ranged_flying_pursue unknown target_type')
            if close_ents and ent.acts <= 0: # FLEE
                ms = intersect(mvs,cs)
                if ms == []:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                else:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, ms)
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, app.handle_action)
            elif mvs != []: #
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, gs1)
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs))
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            else:
                root.after(666, app.handle_action)
            
    # pursue for normal move_type, ranged attack at ideal_range while avoiding detrimental local/map effects, with 'flee' behavior
    def ranged_pursue(ent, ideal_range, target_type):
        ir = ideal_range
        if ent.mvs < 1 or ent.normal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('ranged_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            gs1 = [g for g in app.coords for el in els if dist(el,g) <= ir and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in app.coords for el in els if dist(el,g) <= ir and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            # strip of all not closest to self
            gs1 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs1]), gs1))
            gs2 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs2]), gs2))
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(30,60)]
            # 
            cs1 = cs + gs1
            cs2 = cs + gs2
            mvs = ent.legal_moves()
            # 'flee' to maxim dist among legal_moves if already inside range of atk, already atked
            if target_type == 'spell':
                close_ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'action':
                close_ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'all':
                close_ents = [k for k,v in app.all_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            else:
                print('ranged_pursue unknown target_type')
            if close_ents and ent.acts <= 0:
                ms = intersect(mvs,cs)
                if ms == []:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                else:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, ms)
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, app.handle_action)
            elif path := bfs(ent.loc[:], gs1, app.grid[:]):
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs1))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                if mvs := intersect(path,mvs):
                    g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                    if intersect(mvs,cs) == []:
                        mv = g
                    else:
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs2))
                    ent.mvs -= 1
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                root.after(666, app.handle_action)
            
    # Purse while avoiding detrimental local effects (based on rand val compared to cumulative 'avoid' val of efcts at location)
    # change to prefer paths that stagger axis moved
    def melee_pursue(ent, target_type):
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('melee_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            mvs = ent.legal_moves()
            gs1 = [g for g in app.coords for el in els if dist(el,g) == 1 and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in app.coords for el in els if dist(el,g) == 1 and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(40,60)]
            cs1 = cs + gs1
            cs2 = cs + gs2
            if path := bfs(ent.loc[:], gs1, app.grid[:]):
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs1))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                if mvs := intersect(path,mvs):
                    g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                    if intersect(mvs,cs) == []:
                        mv = g
                    else:
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs2))
                    ent.mvs -= 1
#                     root.after(444, lambda mv = mv : app.focus_square(mv))
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                root.after(666, app.handle_action)
                
    # do not avoid loc_effects, move towards any sqr adj to an enemy, if none exist find a path by removing friendly ents and move on that path until blocked by friendly ent
    def melee_dumb_pursue(ent, target_type):
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('melee_dumb_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            cs = [c for c in app.coords]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            gs1 = [g for g in cs for el in els if dist(el,g) == 1 and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in cs for el in els if dist(el,g) == 1 and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            if path := bfs(ent.loc[:], gs1, app.grid[:]):
                mv = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,ent.legal_moves()))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                mvs = intersect(path, ent.legal_moves())
                if mvs:
                    mv = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, mvs)
                    ent.mvs -= 1
#                     root.after(444, lambda mv = mv : app.focus_square(mv))
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                print('no paths grid or egrid, should not be here unless levels altered')
                root.after(666, app.handle_action)
            
            
class App(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        self.pack()
        self.grimoire_name_tmp = tk.StringVar()
        self.grimoire_p1 = {}
        self.grimoire_p2 = {}
        self.music_volume = tk.DoubleVar()
        self.music_volume.set(1)
        self.effects_volume = tk.DoubleVar()
        self.effects_volume.set(1)
        self.ent_dict = {}
        self.sqr_dict = {}
        self.vis_dict = {}
        self.arcane_dict = {}
        self.image_holder = []
        self.global_effects_dict = {}
        self.init_q = []
        self.num_players = 1
        self.moved_right = 0
        self.moved_down = 0
        self.context_buttons = []
        self.help_buttons = []
        self.dethloks = {}
        self.death_count = 0
        self.cycle_q = []
        self.enemy_cycle_q = []
        self.current_ent = ''
        self.active_ent = None
        self.count = 0 # used for uniquely naming Effects with the same prefix/name
        self.p1_witch = ''
        self.p2_witch = ''
        self.two_player_map_num = 0
        self.turn_counter = 0
        self.proximity_effects_dict = {}
        self.enemy_color_img = ImageTk.PhotoImage(Image.open('animations/Enemy_Color_Img/0.png'))
        self.bot_minimap_img = ImageTk.PhotoImage(Image.open('animations/Bot_Minimap_Img/0.png').resize((10,10)))
        self.block_minimap_img = ImageTk.PhotoImage(Image.open('minimap_block.png').resize((10,10)))
        self.arcane_dict["Minerva's_Gift"] = Spell("Minerva's_Gift",Witch.minervas_gift, 1, 0, 0)
        self.arcane_dict['Psionic_Push'] = Spell('Psionic_Push',Witch.psionic_push, 1, 0, 0)
        self.arcane_dict['Foretell'] = Spell('Foretell',Witch.foretell, 1, 0, 0)
        self.arcane_dict['Defile'] = Spell('Defile',Witch.defile, 1, 0, 0)
        self.arcane_dict['Death'] = Spell('Death',Witch.death, 1, 0, 0)
        self.arcane_dict['The_Tower'] = Spell('The_Tower',Witch.the_tower, 1, 0, 0)
        self.arcane_dict['Pillage'] = Spell('Pillage',Witch.pillage, 1, 0, 0)
        self.arcane_dict["Death's_Head_Moth"] = Spell("Death's_Head_Moth",Witch.deaths_head_moth, 1, 0, 0)
        self.arcane_dict['Compromised_Immunity'] = Spell('Compromised_Immunity',Witch.compromised_immunity, 1, 0, 0)
        self.arcane_dict['Frantic_Search'] = Spell('Frantic_Search',Witch.frantic_search, 1,0,0)
        self.arcane_dict['Boiling_Blood'] = Spell('Boiling_Blood',Witch.boiling_blood, 1,0,0)
        self.arcane_dict['Meditate'] = Spell('Meditate',Witch.meditate, 1,0,0)
        self.arcane_dict['Temperance'] = Spell('Temperance',Witch.temperance, 1,0,0)
        self.arcane_dict['Wrath_of_Samael'] = Spell('Wrath_of_Samael',Witch.wrath_of_samael, 1, 0, 0)
        self.arcane_dict['Legerdemain'] = Spell('Legerdemain',Witch.legerdemain, 1,0,0)
        self.arcane_dict['Read_the_Stars'] = Spell('Read_the_Stars',Witch.read_the_stars, 1, 0, 0)
        self.arcane_dict['Cosmic_Sight'] = Spell('Cosmic_Sight',Witch.cosmic_sight, 1, 0, 0)
        self.arcane_dict['Bewitch'] = Spell('Bewitch',Witch.bewitch, 1, 0, 0)
        self.arcane_dict['Dark_Ritual'] = Spell('Dark_Ritual',Witch.dark_ritual, 1,0,0)
        self.arcane_dict['Quicksilver'] = Spell('Quicksilver',Witch.quicksilver, 1, 0, 0)
        self.arcane_dict['Offering'] = Spell('Offering',Witch.offering, 1, 0, 0)
        self.arcane_dict['Calm'] = Spell('Calm',Witch.calm, 1, 0, 0)
        self.arcane_dict['Fists_of_Stone'] = Spell('Fists_of_Stone',Witch.fists_of_stone, 1, 0, 0)
        self.arcane_dict['Pull_from_the_Aether'] = Spell('Pull_from_the_Aether',Witch.pull_from_the_aether, 1, 0, 0)
        self.arcane_dict['Survival_of_the_Fittest'] = Spell('Survival_of_the_Fittest',Witch.survival_of_the_fittest, 1, 0, 0)
        self.arcane_dict['Scrye'] = Spell('Scrye',Witch.scrye, 2,0,0)
        self.arcane_dict['Magick_Missle'] = Spell('Magick_Missle',Witch.magick_missle, 2, 0, 0)
        self.arcane_dict['Cloister'] = Spell('Cloister',Witch.cloister, 2, 0, 0)
        self.arcane_dict['The_Magician'] = Spell('The_Magician',Witch.the_magician, 2, 0, 0)
        self.arcane_dict['Coercion'] = Spell('Coercion',Witch.coercion, 2, 0, 0)
        self.arcane_dict['Grave_Twin'] = Spell('Grave_Twin',Witch.grave_twin, 2, 0, 0)
        self.arcane_dict['Foresight'] = Spell('Foresight',Witch.foresight, 2, 0, 0)
        self.arcane_dict['Dessicate'] = Spell('Dessicate',Witch.dessicate, 2, 0, 0)
        self.arcane_dict['The_Chariot'] = Spell('The_Chariot',Witch.the_chariot, 2, 0, 0)
        self.arcane_dict["Siren's_Call"] = Spell("Siren's_Call",Witch.sirens_call, 2, 0, 0)
        self.arcane_dict['The_Fool'] = Spell('The_Fool',Witch.the_fool, 2, 0, 0)
        self.arcane_dict['Scour'] = Spell('Scour',Witch.scour, 2, 0, 0)
        self.arcane_dict['Molecular_Subversion'] = Spell('Molecular_Subversion',Witch.molecular_subversion, 2, 0, 0)
        self.arcane_dict['Demonic_Sight'] = Spell('Demonic_Sight',Witch.demonic_sight, 2, 0, 0)
        self.arcane_dict['Lift'] = Spell('Lift',Witch.lift, 2, 0, 0)
        self.arcane_dict['Mummify'] = Spell('Mummify',Witch.mummify, 2,0,0)
        self.arcane_dict['Inertia'] = Spell('Inertia',Witch.inertia, 2,0,0)
        self.arcane_dict['Hunting_Hawk'] = Spell('Hunting_Hawk',Witch.hunting_hawk, 2, 0, 0)
        self.arcane_dict['Psi_Blades'] = Spell('Psi_Blades',Witch.psi_blades, 2, 0, 0)
        self.arcane_dict['The_Hermit'] = Spell('The_Hermit',Witch.the_hermit, 2, 0, 0)
        self.arcane_dict['Genjutsushi'] = Spell('Genjutsushi',Witch.genjutsushi, 2, 0, 0)
        self.arcane_dict['The_Hanged_Man'] = Spell('The_Hanged_Man',Witch.the_hanged_man, 2, 0, 0)
        self.arcane_dict['Quest_of_the_Hermit_Druid'] = Spell('Quest_of_the_Hermit_Druid',Witch.quest_hermit, 2, 0, 0)
        self.arcane_dict['Energize'] = Spell('Energize',Witch.energize, 2, 0, 0)
        self.arcane_dict['Myopic_Neuroticism'] = Spell('Myopic_Neuroticism',Witch.myopic_neuroticism, 2,0,0)
        self.arcane_dict['Iron_Spirit'] = Spell('Iron_Spirit',Witch.iron_spirit, 2, 0, 0)
        self.arcane_dict['Fangs_of_Apophis'] = Spell('Fangs_of_Apophis',Witch.fangs_of_apophis, 2, 0, 0)
        self.arcane_dict["Mercury's_Blessing"] = Spell("Mercury's_Blessing",Witch.mercurys_blessing, 2, 0, 0)
        self.arcane_dict['Hidden_From_the_Stars'] = Spell('Hidden_From_the_Stars',Witch.hidden_from_the_stars, 2, 0, 0)
        self.arcane_dict['Strength_of_the_Void'] = Spell('Strength_of_the_Void',Witch.strength_of_the_void, 2, 0, 0)
        self.arcane_dict['Gift_of_Mars'] = Spell('Gift_of_Mars',Witch.gift_of_mars, 2, 0, 0)
        self.arcane_dict["Witch's_Blood"] = Spell("Witch's_Blood",Witch.witchs_blood, 2,0,0)
        self.arcane_dict['Hallowed_Ground'] = Spell('Hallowed_Ground',Witch.hallowed_ground, 2, 0, 0)
        self.arcane_dict['Grasp_of_the_Old_Ones'] = Spell('Grasp_of_the_Old_Ones',Witch.grasp_of_the_old_ones, 2,0,0)
        self.arcane_dict['Dark_Sun'] = Spell('Dark_Sun',Witch.dark_sun, 3,0,0)
        self.arcane_dict['Spectral_Pillory'] = Spell('Spectral_Pillory',Witch.spectral_pillory, 3, 0, 0)
        self.arcane_dict['The_Sun'] = Spell('The_Sun',Witch.the_sun, 3, 0, 0)
        self.arcane_dict['Fork'] = Spell('Fork',Witch.fork, 3,0,0)
        self.arcane_dict['Voodoo_Doll'] = Spell('Voodoo_Doll',Witch.voodoo_doll, 3,0,0)
        self.arcane_dict['Aftershock'] = Spell('Aftershock',Witch.aftershock, 3,0,0)
        self.arcane_dict['The_Lovers'] = Spell('The_Lovers',Witch.the_lovers, 3,0,0)
        self.arcane_dict['Hypnotic_Spectre'] = Spell('Hypnotic_Spectre',Witch.hypnotic_spectre, 3,0,0)
        self.arcane_dict['Vorpal_Blade'] = Spell('Vorpal_Blade',Witch.vorpal_blade, 3,0,0)
        self.arcane_dict['Burning_Hands'] = Spell('Burning_Hands',Witch.burning_hands, 3,0,0)
        self.arcane_dict['Acid_Arrow'] = Spell('Acid_Arrow',Witch.acid_arrow, 3,0,0)
        self.arcane_dict['Carrion_Wyrm'] = Spell('Carrion_Wyrm',Witch.carrion_wyrm, 3,0,0)
        self.arcane_dict['Foul_Familiar'] = Spell('Foul_Familiar',Witch.foul_familiar, 3, 0, 0)
        self.arcane_dict['Astrological_Guidance'] = Spell('Astrological_Guidance',Witch.astrological_guidance, 3, 0, 0)
        self.arcane_dict['Profane_Pshent'] = Spell('Profane_Pshent',Witch.profane_pshent, 3, 0, 0)
        self.arcane_dict['Wreathed_in_Flame'] = Spell('Wreathed_in_Flame',Witch.wreathed_in_flame, 3, 0, 0)
        self.arcane_dict['Giant_Growth'] = Spell('Giant_Growth',Witch.giant_growth, 3, 0, 0)
        self.arcane_dict['Strength'] = Spell('Strength',Witch.strength, 3, 0, 0)
        self.arcane_dict['Animate_Tomb'] = Spell('Animate_Tomb',Witch.animate_tomb, 3, 0, 0)
        self.arcane_dict['Plutonian_Cloak'] = Spell('Plutonian_Cloak',Witch.plutonian_cloak, 3, 0, 0)
        self.arcane_dict['The_Wheel'] = Spell('The_Wheel',Witch.the_wheel, 3, 0, 0)
        self.arcane_dict['Stupor'] = Spell('Stupor',Witch.stupor, 3, 0, 0)
        self.arcane_dict['Styxian_Guide'] = Spell('Styxian_Guide',Witch.styxian_guide, 3, 0, 0)
        self.arcane_dict['Plague'] = Spell('Plague',Witch.plague, 3, 0, 0)
        self.arcane_dict['Iron_Skins'] = Spell('Iron_Skins',Witch.iron_skins, 3, 0, 0)
        self.arcane_dict['Curse_of_Oriax'] = Spell('Curse_of_Oriax',Witch.curse_of_oriax, 3, 0, 0)
        self.arcane_dict['Pain'] = Spell('Pain',Witch.pain, 3, 0, 0)
        self.arcane_dict['Dust_Devil'] = Spell('Dust_Devil',Witch.dust_devil, 4,0,0)
        self.arcane_dict['Imbue_Thrall'] = Spell('Imbue_Thrall',Witch.imbue_thrall, 4,0,0)
        self.arcane_dict['Forcefield'] = Spell('Forcefield',Witch.forcefield, 4, 0, 0)
        self.arcane_dict['The_Hierophant'] = Spell('The_Hierophant',Witch.the_hierophant, 4, 0, 0)
        self.arcane_dict['Judgment'] = Spell('Judgment',Witch.judgment, 4, 0, 0)
        self.arcane_dict['Disintegrate'] = Spell('Disintegrate',Witch.disintegrate, 4,0,0)
        self.arcane_dict['The_Star'] = Spell('The_Star',Witch.the_star, 4,0,0)
        self.arcane_dict['The_Devil'] = Spell('The_Devil',Witch.the_devil, 4,0,0)
        self.arcane_dict['Mass_Hysteria'] = Spell('Mass_Hysteria',Witch.mass_hysteria, 4, 0, 0)
        self.arcane_dict['Aura_of_Agony'] = Spell('Aura_of_Agony',Witch.aura_of_agony, 4, 0, 0)
        self.arcane_dict['The_High_Priestess'] = Spell('The_High_Priestess',Witch.the_high_priestess, 4, 0, 0)
        self.arcane_dict['Barrow_Wight'] = Spell('Barrow_Wight',Witch.barrow_wight, 4, 0, 0)
        self.arcane_dict['Reaping_of_Saturnus'] = Spell('Reaping_of_Saturnus',Witch.reaping_of_saturnus, 4, 0, 0)
        self.arcane_dict['Gravity'] = Spell('Gravity',Witch.gravity, 4, 0, 0)
        self.arcane_dict['The_Empress'] = Spell('The_Empress',Witch.the_empress, 5, 0, 0)
        self.arcane_dict['Rite_of_Spring'] = Spell('Rite_of_Spring',Witch.rite_of_spring, 5, 0, 0)
        self.arcane_dict['Living_Death'] = Spell('Living_Death',Witch.living_death, 5, 0, 0)
        self.arcane_dict['Mass_Grave'] = Spell('Mass_Grave',Witch.mass_grave, 5, 0, 0)
        self.arcane_dict['The_Moon'] = Spell('The_Moon',Witch.the_moon, 5, 0, 0)
        self.arcane_dict['Mirror_Armor'] = Spell('Mirror_Armor',Witch.mirror_armor, 5, 0, 0)
        self.arcane_dict['Black_Blade_of_Disaster'] = Spell('Black_Blade_of_Disaster',Witch.black_blade_of_disaster, 5, 0, 0)
        self.arcane_dict['The_Emperor'] = Spell('The_Emperor',Witch.the_emperor, 5, 0, 0)
        self.arcane_dict['Hatred'] = Spell('Hatred',Witch.hatred, 5, 0, 0)
        self.arcane_dict['Cloudkill'] = Spell('Cloudkill',Witch.cloudkill, 5, 0, 0)
        self.arcane_dict['Blind'] = Spell('Blind',Witch.blind, 5, 0, 0)
        self.arcane_dict['Horrid_Wilting'] = Spell('Horrid_Wilting',Witch.horrid_wilting, 5,0,0)
        self.arcane_dict['Dispel'] = Spell('Dispel',Witch.dispel, 5,0,0)
        self.arcane_dict["Beleth's_Command"] = Spell("Beleth's_Command",Witch.beleths_command, 5, 0, 0)
        self.arcane_dict['Dampening_Emanation'] = Spell('Dampening_Emanation',Witch.dampening_emanation, 5, 0, 0)
        self.arcane_dict['The_World'] = Spell('The_World',Witch.the_world, 5, 0, 0)
        self.arcane_dict['Enmeshing_Coils'] = Spell('Enmeshing_Coils',Witch.enmeshing_coils, 5, 0, 0)
        self.arcane_dict['Mind_Rot'] = Spell('Mind_Rot',Witch.mind_rot, 5,0,0)
        self.arcane_dict['Immolate'] = Spell('Immolate',Witch.immolate, 5,0,0)
        self.arcane_dict['Command_of_Osiris'] = Spell('Command_of_Osiris',Witch.command_of_osiris, 6,0,0)
        self.arcane_dict['Justice'] = Spell('Justice',Witch.justice, 6,0,0)
        self.arcane_dict['Vengeance'] = Spell('Vengeance',Witch.vengeance, 6, 0, 0)
        self.arcane_dict['Torment'] = Spell('Torment',Witch.torment, 6, 0, 0)
        self.arcane_dict['Pestilence'] = Spell('Pestilence',Witch.pestilence, 6, 0, 0)
        self.arcane_dict['Haunted_Cairn'] = Spell('Haunted_Cairn',Witch.haunted_cairn, 7, 0, 0)
        self.arcane_dict['Summon_Lesser_Demon'] = Spell('Summon_Lesser_Demon',Witch.summon_lesser_demon, 7, 0, 0)
        self.arcane_dict['Summon_Cenobite'] = Spell('Summon_Cenobite',Witch.summon_cenobite, 7, 0, 0)
        self.arcane_dict['Upheaval'] = Spell('Upheaval',Witch.upheaval, 8, 0, 0)
        self.summon_dict = {}
        # costs for summons not used
        self.summon_dict['Berserker'] = ('Berserker',0)
        self.summon_dict['Illusionist'] = ('Illusionist',0)
        self.summon_dict['Umbrae_Wolf'] = ('Umbrae_Wolf',0)
        self.summon_dict['Thaumaturge'] = ('Thaumaturge',0)
        self.summon_dict['Murrain_Wolf'] = ('Murrain_Wolf',0)
        self.summon_dict['Fiend'] = ('Fiend',0)
        self.summon_dict['Wurdulak'] = ('Wurdulak',0)
        self.summon_dict['Chirurgeon'] = ('Chirurgeon',0)
        self.summon_dict['Hexmage'] = ('Hexmage',0)
        self.summon_dict['Fell_Evolver'] = ('Fell_Evolver',0)
        self.summon_dict['Drake'] = ('Drake',0)
        self.summon_dict['Inquisitor'] = ('Inquisitor',0)
        self.summon_dict['Pixie'] = ('Pixie',0)
        self.summon_dict['Chronomancer'] = ('Chronomancer',0)
        self.summon_dict['Enchantress'] = ('Enchantress',0)
        self.summon_dict['Diabolist'] = ('Diabolist',0)
        self.summon_dict['Artificer'] = ('Artificer',0)
        self.summon_dict['Yellow_Priest'] = ('Yellow_Priest',0)
        self.summon_dict['Goblin_Shaman'] = ('Goblin_Shaman',0)
        self.summon_dict['Beastmaster'] = ('Beastmaster',0)
        self.summon_dict['Ogre'] = ('Ogre',0)
        self.summons_list = ['Berserker','Illusionist','Umbrae_Wolf','Thaumaturge','Murrain_Wolf','Fiend','Wurdulak','Chirurgeon','Hexmage','Fell_Evolver','Drake','Inquisitor','Pixie','Chronomancer','Enchantress', 'Diabolist', 'Artificer', 'Yellow_Priest', 'Goblin_Shaman', 'Beastmaster', 'Ogre']
        # the following few anim dicts are for testing 'load images on game start, instead of as needed'
        # results in faster response for image loading in game, longer load time (as would be expected)
        self.sqr_anims = {}
        anims = [a for r,d,a in walk('animations/move/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/move/' + anim))
            self.sqr_anims[i] = a
        
        self.aura_anims = {}
        anims = [a for r,d,a in walk('animations/Aura/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Aura/' + anim))
            self.aura_anims[i] = a
        
        self.mortar_anims = {}
        anims = [a for r,d,a in walk('animations/Mortar/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Mortar/' + anim))
            self.mortar_anims[i] = a
        
        self.pestilence_anims = {}
        anims = [a for r,d,a in walk('animations/Pestilence/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Pestilence/' + anim))
            self.pestilence_anims[i] = a
            
        self.plague_anims = {}
        anims = [a for r,d,a in walk('animations/Plague/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Plague/' + anim))
            self.plague_anims[i] = a
            
        self.toxic_miasma_anims = {}
        anims = [a for r,d,a in walk('animations/Toxic_Miasma/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Toxic_Miasma/' + anim))
            self.toxic_miasma_anims[i] = a
            
        self.leap_anims = {}
        anims = [a for r,d,a in walk('./animations/Leap/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Leap/' + anim))
            self.leap_anims[i] = a
            
            
        self.boar_anims = {}
        anims = [a for r,d,a in walk('./animations/Goblin_Shaman_Boar/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Goblin_Shaman_Boar/' + anim))
            self.boar_anims[i] = a
            
        self.eyegaunt_anims = {}
        anims = [a for r,d,a in walk('./animations/Goblin_Shaman_Eyegaunt/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Goblin_Shaman_Eyegaunt/' + anim))
            self.eyegaunt_anims[i] = a
            
        self.pounce_anims = {}
        anims = [a for r,d,a in walk('./animations/Pounce/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Pounce/' + anim))
            self.pounce_anims[i] = a
            
        self.cleanse_with_fire_anims = {}
        anims = [a for r,d,a in walk('animations/Cleanse_with_Fire/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Cleanse_with_Fire/' + anim))
            self.cleanse_with_fire_anims[i] = a
            
        self.choose_num_players()
        
        
    # testing func for 'check for ent existence after action, if removed then go to next round'
    def exists_check(self, id):
        if id not in self.all_ents().keys():
            self.handle_action()
        else:
            self.get_focus(id)
        
        
        # Luminari 280
        # Herculanum 240
        # Papyrus 240
    def choose_num_players(self):
#         background_music.music.load('Ove Melaa - Dead, Buried and Cold.ogg')
        sound1 = mixer.Sound('Music/Ove Melaa - Dead, Buried and Cold.ogg')
        background_music.play(sound1, -1)
        sound1.set_volume(self.music_volume.get())
        self.title_screen = ImageTk.PhotoImage(Image.open('titleScreen999.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.game_title = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.game_title.create_image(0,0, image =self.title_screen, anchor = 'nw')
        self.game_title.pack(side = 'top')
        
        self.grim_edit = tk.Button(root, text = 'Grimoire Editor', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.grimoire_editor)
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-170, anchor='s', window = self.grim_edit)
        
        self.one_player = tk.Button(root, text = 'Campaign', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda num = 1 : self.num_chose(num))
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-120, anchor='s', window = self.one_player)
        
        self.two_player = tk.Button(root, text = 'Duel', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda num = 2 : self.num_chose(num))
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-70, anchor='s', window = self.two_player)
        
        self.load_button = tk.Button(root, text = 'Load Campaign', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.try_load)
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-20, anchor='s', window = self.load_button)
        
        
    # should destroy old windows/buttons, open new window that, in addition to editor/builder, allows actions:
    # save grimoire, load grimoire, and back to title screen
    # grimoire is chosen from saved after choosing either campaign or duel
    def grimoire_editor(self, mode = None, lockname = None):
        # cleanup title screen stuff
        if mode != 'select':
            self.game_title.destroy()
            self.grim_edit.destroy()
            self.one_player.destroy()
            self.two_player.destroy()
            del self.title_screen
            del self.game_title
            del self.grim_edit
            del self.one_player
            del self.two_player
        # BG IMAGE AND 1ST BORDER IMG
        self.bg_img = ImageTk.PhotoImage(Image.open('grimoire_editor_bg.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.bg_canvas = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.bg_canvas.create_image(0,0, image =self.bg_img, anchor = 'nw')
        self.bg_canvas.pack(side = 'top')
        self.bd_img = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-180, root.winfo_screenheight()//3-46)))
        self.bg_canvas.create_image(root.winfo_screenwidth()//2, 200, image =self.bd_img)
        # 3 FRAMES
        self.lr_frame = tk.Frame(root, width = 100, height = 100)
        self.addremove_frame = tk.Frame(root, width = 100, height = 100)
        self.spell_frame = tk.Frame(root, width = 800, height = 100)
        self.spell_frame.pack_propagate(False)
        self.summon_frame = tk.Frame(root, width = 800, height = 100)
        self.summon_frame.pack_propagate(False)
        # SPELL BUTTONS, keep refs to only spell buttons
        self.spell_buttons = []
        self.summon_buttons = []
        # STRUCT THAT HOLDS SPELLS ADDED TO GRIMOIRE, in bottom listbox
        self.grimoire = {}
        # SPELL OBJECTS from arcane dict, holds order?
        self.spell_list = [v for v in self.arcane_dict.values()]
        self.summon_list = [v for v in self.summon_dict.values()]
        # SPELL BUTTON HIGHLIGHTER (WHEN BUTTON DEPRESSED)
        def depress(event = None, btn = None):
            if app.selected_btn == []:
                btn.config(fg = 'black')
                app.selected_btn.append(btn)
            elif app.selected_btn[0] == btn:
                btn.config(fg = 'indianred')
                app.selected_btn = []
            else:
                app.selected_btn[0].config(fg = 'indianred')
                btn.config(fg = 'black')
                app.selected_btn = []
                app.selected_btn.append(btn)
        # PAGE BACK remakes all top frame spell buttons
        def deselect():
            if app.selected_btn != []:
                app.selected_btn[0].config(fg = 'indianred')
                app.selected_btn = []
        def page_back():
            deselect()
            for btn in self.spell_buttons:
                btn.destroy()
            self.spell_list = [self.spell_list[-1]]+self.spell_list[:-1]
            for spell in self.spell_list[0:5]:
                func = partial(depress)
                b1 = tk.Button(self.spell_frame, text = spell.name.replace('_',' ') + ' •'+str(spell.cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                b1.config(command = lambda btn = b1 : func(btn=btn))
                b1.pack(side = 'left', fill = 'both', expand = True)
                b1.bind('<Button-2>', lambda event, b = b1, n = spell.name.replace('_',' ') : app.action_info(event, name = n, button = b))
                self.spell_buttons.append(b1)
        prev = partial(page_back)
        def page_back2():
            deselect()
            for btn in self.summon_buttons:
                btn.destroy()
            self.summon_list = [self.summon_list[-1]]+self.summon_list[:-1]
            for smn in self.summon_list[0:5]:
                name = smn[0]
                cost = smn[1]
                func = partial(depress)
                b1 = tk.Button(self.summon_frame, text = name.replace('_',' ') + ' •'+str(cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                b1.config(command = lambda btn = b1 : func(btn=btn))
                b1.pack(side = 'left', fill = 'both', expand = True)
                b1.bind('<Button-2>', lambda event, b = b1, n = name.replace('_',' ') : app.action_info(event, name = n, button = b))
                self.summon_buttons.append(b1)
        prev2 = partial(page_back2)
        # next moves spells in frame 'forward'
        def page_forward():
            deselect()
            for btn in self.spell_buttons:
                btn.destroy()
            self.spell_list = self.spell_list[1:]+[self.spell_list[0]]
            col = 0
            for spell in self.spell_list[0:5]:
                func = partial(depress)
                b1 = tk.Button(self.spell_frame, text = spell.name.replace('_',' ') + ' •'+str(spell.cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                b1.config(command = lambda btn = b1 : func(btn=btn))
                b1.pack(side = 'left', fill = 'both', expand = True)
                b1.bind('<Button-2>', lambda event, b = b1, n = spell.name.replace('_',' ') : app.action_info(event, name = n, button = b))
                self.spell_buttons.append(b1)
        next = partial(page_forward)
        def page_forward2():
            deselect()
            for btn in self.summon_buttons:
                btn.destroy()
            self.summon_list = self.summon_list[1:]+[self.summon_list[0]]
            col = 0
            for smn in self.summon_list[0:5]:
                name = smn[0]
                cost = smn[1]
                func = partial(depress)
                b1 = tk.Button(self.summon_frame, text = name.replace('_',' ') + ' •'+str(cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                b1.config(command = lambda btn = b1 : func(btn=btn))
                b1.pack(side = 'left', fill = 'both', expand = True)
                b1.bind('<Button-2>', lambda event, b = b1, n = name.replace('_',' ') : app.action_info(event, name = n, button = b))
                self.summon_buttons.append(b1)
        next2 = partial(page_forward2)
        # LEFT ARROW TOP
        self.l_arrow = tk.Button(self.lr_frame, text = '<', height = 2, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = prev)
        self.l_arrow.grid(row = 0, column = 0)
        # LEFT ARROW BTM
        self.l_arrow2 = tk.Button(self.lr_frame, text = '<', height = 2, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = prev2)
        self.l_arrow2.grid(row = 1, column = 0)
        # RIGHT ARROW TOP
        self.r_arrow = tk.Button(self.lr_frame, text = '>', height = 2, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = next)
        self.r_arrow.grid(row = 0, column = 1)
        # RIGHT ARROW BTM
        self.r_arrow2 = tk.Button(self.lr_frame, text = '>', height = 2, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = next2)
        self.r_arrow2.grid(row = 1, column = 1)
        # WINDOW FOR FRAME 1 LR BUTTONS
        self.bg_canvas.create_window(200, 200, window = self.lr_frame)
        # ADD REMOVE SPELL BUTTONS
        def add():
            if self.selected_btn == []:
                return
            else:
                btn = self.selected_btn[0]
                name = btn.cget('text').replace('_',' ')
                ix = name.find('•')
                name = name[:ix]
                name = name.rstrip(' ')
                if name in self.grimoire.keys():# INCR COUNT
                    count = self.grimoire[name]
                    if count == 4:
                        return
                    else:
                        all = self.grim_lbox.get(0,'end')
                        ix = all.index(name+' '+str(count))
                        self.grim_lbox.delete(ix)
                        self.grimoire[name] += 1
                        count = self.grimoire[name]
                        self.grim_lbox.insert(ix, name+' '+str(count))
                        self.grim_lbox.selection_clear(0,'end')
                        self.grim_lbox.selection_set(ix)
                        self.grim_lbox.see(ix)
                else:# ADD TO GRIMOIRE
                    self.grimoire[name] = 1
                    self.grim_lbox.insert('end',name.replace('_',' ')+' '+'1')
                    self.grim_lbox.selection_clear(0,'end')
                    self.grim_lbox.selection_set('end')
                    self.grim_lbox.see(ix)
                j = self.spell_total.get()
                self.spell_total.set(j+1)
        adder = partial(add)
        self.add_button = tk.Button(self.addremove_frame, text = '+', height = 4, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = adder)
        # REMOVE
        def remove():
            if self.selected_btn == []:
                return
            else:
                btn = self.selected_btn[0]
                name = btn.cget('text').replace('_',' ')
                ix = name.find('•')
                name = name[:ix]
                name = name.rstrip(' ')
                if name in self.grimoire.keys():
                    j = self.spell_total.get()
                    self.spell_total.set(j-1)
                    count = self.grimoire[name]
                    if count == 1:#REMOVE FROM struct and lbox
                        all = self.grim_lbox.get(0,'end')
                        ix = all.index(name+' '+str(count))
                        self.grim_lbox.selection_clear(0,'end')
                        self.grim_lbox.selection_set(ix)
                        self.grim_lbox.see(ix)
                        self.grim_lbox.delete(ix)
                        del self.grimoire[name]
                    else:# DECR COUNT
                        all = self.grim_lbox.get(0,'end')
                        ix = all.index(name+' '+str(count))
                        self.grim_lbox.delete(ix)
                        self.grimoire[name] -= 1
                        count = self.grimoire[name]
                        self.grim_lbox.insert(ix, name+' '+str(count))
                        self.grim_lbox.selection_clear(0,'end')
                        self.grim_lbox.selection_set(ix)
                        self.grim_lbox.see(ix)
                else:
                    pass
        rmv = partial(remove) 
        self.rmv_button = tk.Button(self.addremove_frame, text = '-', height = 4, width = 1, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 38), relief = 'raised', command = rmv)
        self.add_button.pack(side = 'left', fill = 'y', expand = 1)
        self.rmv_button.pack(side = 'left', fill = 'y', expand = 1)
        # WINDOW FOR FRAME 2 ADD REMOVE BUTTONS
        self.bg_canvas.create_window(root.winfo_screenwidth()-200, 200, window = self.addremove_frame)
#         SELECTED BTN LOCK
        self.selected_btn = []
        # INITIAL SPELL BTNS
        for spell in self.spell_list[:5]:
            func = partial(depress)
            b1 = tk.Button(self.spell_frame, text = spell.name.replace('_',' ') + ' •'+str(spell.cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
            b1.config(command = lambda btn = b1 : func(btn=btn))
            b1.pack(side = 'left', fill = 'both', expand = True)
            b1.bind('<Button-2>', lambda event, b = b1, n = spell.name.replace('_',' ') : app.action_info(event, name = n, button = b))
            self.spell_buttons.append(b1)
        # INITIAL SUMMONS BTNS
        for smn in self.summon_list[:5]:
            func = partial(depress)
            name = smn[0]
            cost = smn[1]
            b1 = tk.Button(self.summon_frame, text = name.replace('_',' ') + ' •'+str(cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
            b1.config(command = lambda btn = b1 : func(btn=btn))
            b1.pack(side = 'left', fill = 'both', expand = True)
            b1.bind('<Button-2>', lambda event, b = b1, n = name.replace('_',' ') : app.action_info(event, name = n, button = b))
            self.summon_buttons.append(b1)
#         WINDOW FOR FRAME 3 SPELL BUTTONS
        self.bg_canvas.create_window(root.winfo_screenwidth()//2, 150, window = self.spell_frame)
        # BIG PAGE SPELLS ABOVE SPELL FRAME (PAGE 5-10 at a time)
        self.pg_left_btn = tk.Button(self.bg_canvas, text = '<PAGE', font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
        def big_page_left():
            page_back()
            page_back()
            page_back()
            page_back()
            page_back()
        self.pg_left_btn.config(command = big_page_left)
        self.bg_canvas.create_window(root.winfo_screenwidth()//2-50, 50, window = self.pg_left_btn)
        
        self.pg_rt_btn = tk.Button(self.bg_canvas, text = 'PAGE>', font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
        def big_page_rt():
            page_forward()
            page_forward()
            page_forward()
            page_forward()
            page_forward()
        self.pg_rt_btn.config(command = big_page_rt)
        self.bg_canvas.create_window(root.winfo_screenwidth()//2+50, 50, window = self.pg_rt_btn)
        
        # WINDOW FOR FRAME SUMMON BUTTONS
        self.bg_canvas.create_window(root.winfo_screenwidth()//2, 250, window = self.summon_frame)
        # SAVE / LOAD / MAIN MENU BUTTONS between frames
        def save_grim():
            # constrain save size
            if self.spell_total.get() < 60:
                self.save_grim_var.set('grimoire minimum 60 spells')
                return
            fname = self.save_grim_var.get()
            saves = [s for r,d,s in walk('./Grimoires')][0]
            saves = [s for s in saves[:] if s[0] != '.']
#             if fname in saves:
#                 self.save_grim_var.set('filename already exists')
#                 return
            with open('Grimoires/'+fname, 'w+') as f:
                self.save_grim_var.set('Grimoire Saved...')
                f.write(str(self.grimoire))
        # SAVE BTN ENTRY
        self.save_btn = tk.Button(self.bg_canvas, text = 'SAVE', wraplength = 190, font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=save_grim)
        self.bg_canvas.create_window(root.winfo_screenwidth()//3-200, 350, window = self.save_btn)
        self.save_grim_var = tk.StringVar()
        self.save_grim_var.set('name')
        self.entry = tk.Entry(self.bg_canvas, textvariable = self.save_grim_var, font = ('chalkduster', 15), highlightbackground = 'black')
        self.bg_canvas.create_window(root.winfo_screenwidth()//3-40, 365, anchor='s', window = self.entry)
        # LOAD
        def load_grim():
            grims = [s for r,d,s in walk('Grimoires/')][0]
            grims = [s for s in grims[:] if s[0] != '.']
            self.scroll_frame = VerticalScrolledFrame(root)
            self.bg_canvas.create_window(root.winfo_screenwidth()/2 + root.winfo_screenwidth()/8, root.winfo_screenheight()-220, anchor = 'nw', window = self.scroll_frame)
            self.grimoire_save_btns = []
            def load_grimoire(grim_dict, filename):
                app.grimoire_name_tmp.set(filename)
                # clear grimoire struct and lbox, populate both with clicked grimoire
                self.grimoire = grim_dict
                self.grim_lbox.delete(0,'end')
                i = 0
                ttl = 0
                for k,v in self.grimoire.items():
                    self.grim_lbox.insert(i,k+' '+str(v))
                    ttl += v
                    i += 1
                self.spell_total.set(ttl)
            for g in grims:
                # expand filename into readable
                with open('Grimoires/'+g, 'r') as f:
                    grim_dict = eval(f.readline().strip('\n'))
                    cmd = partial(load_grimoire, grim_dict, g)
                    b = tk.Button(self.scroll_frame.interior, text = g, width = 13, wraplength = 190, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = cmd)
                    b.pack() 
                    self.grimoire_save_btns.append(b)
            cancel_b = tk.Button(self.scroll_frame.interior, text = 'Cancel', bg = 'black', fg = 'black', width = 13, highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = self.scroll_frame.destroy)
            cancel_b.pack(side = 'bottom')
            self.grimoire_save_btns.append(cancel_b)
        self.load_btn = tk.Button(self.bg_canvas, text = 'LOAD', wraplength = 190, font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=load_grim)
        self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.666)-200, 350, window = self.load_btn)
        # MAIN MENU
        def back_main():
            for b in self.spell_buttons:
                b.destroy()
            for child in root.winfo_children():
                if child._name != '!app':
                    child.destroy()
            self.selected_btn = []
            self.choose_num_players()
        self.main_menu_btn = tk.Button(self.bg_canvas, text = 'MAIN MENU', wraplength = 190, font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=back_main)
        self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.999)-200, 350, window = self.main_menu_btn)
        # SELECT FUNC
        if mode == 'select':
            def select():
                if self.spell_total.get() >= 60:
                    app.grimoire_p1 = deepcopy(app.grimoire)
                    self.name_label1.config(fg='indianred')
                    # sets lockvar called from create_map_curs_context
                    if app.num_players == 1:
                        app.dethloks[lockname].set(1)
                    elif app.num_players == 2 and app.grimoire_p2 != {}:
                        app.dethloks[lockname].set(1)
            def select2():
                if self.spell_total.get() >= 60:
                    app.grimoire_p2 = deepcopy(app.grimoire)
                    self.name_label2.config(fg='indianred')
                    # sets lockvar called from create_map_curs_context
                    if app.grimoire_p1 != {}:
                        app.dethloks[lockname].set(1)
            # GRIMOIRE LABEL NAME P1
            self.name_label1 = tk.Label(self.bg_canvas, text = 'P1 grimoire', bg='black')
            self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.999)-490, 365, window = self.name_label1)
            # SELECT BUTTON PLAYER 1
            self.select_btn = tk.Button(self.bg_canvas, text = 'SELECT P1', wraplength = 190, font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=select)
            self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.999)-380, 365, window = self.select_btn)
            # GRIMOIRE LABEL NAME P2
            self.name_label2 = tk.Label(self.bg_canvas, text = 'P2 grimoire', bg='black')
            self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.999)-490, 325, window = self.name_label2)
            # SELECT BTN PLAYER 2
            if app.num_players == 2:
                self.select_btn2 = tk.Button(self.bg_canvas, text = 'SELECT P2', wraplength = 190, font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=select2)
                self.bg_canvas.create_window(int(root.winfo_screenwidth()*0.999)-380, 325, window = self.select_btn2)
        # SPELL COUNT TOTAL LABEL
        self.spell_total = tk.IntVar()
        self.spell_total.set(0)
        self.spell_total_label = tk.Label(self.bg_canvas, textvariable = self.spell_total, bg = 'black', fg = 'indianred')
        self.bg_canvas.create_window(100, 350, window = self.spell_total_label)
        # SECOND BD IMG BOTTOM SCREEN
        self.bd_img2 = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-130, root.winfo_screenheight()//3+104)))
        self.bg_canvas.create_image(root.winfo_screenwidth()//2, root.winfo_screenheight()//3+300, image =self.bd_img2)
        # BOTTOM FRAME
        self.frame2 = tk.Frame(root)
        # LB SCROLLBAR
        self.sb = tk.Scrollbar(self.frame2)
        # LISTBOX
        self.grim_lbox = tk.Listbox(self.frame2, height = 12, width = 158, yscrollcommand = self.sb.set, selectmode = 'single', font = 'kokonor',bg = 'black', fg = 'indianred', relief = 'sunken', borderwidth = 6)
        # CLICK ON LISTBOX JUMP TO SPELL
        def clickEvent(event):
            selection = event.widget.curselection()
            if selection:
                deselect()
                index = selection[0]
                row = event.widget.get(index)
                ix = row.find('•')
                name = row[:ix].rstrip(' ')
                ix2 = 0
                if name.replace(' ','_') in app.summon_dict.keys():# IS SUMMON
                    for i,s in enumerate(self.summon_list[:]):
                        n = s[0]
                        if n.replace('_',' ') == name:
                            ix2 = i
                    for btn in self.summon_buttons:
                        btn.destroy()
                    self.summon_list = list(self.summon_list[ix2:])+list(self.summon_list[:ix2])
                    for smn in self.summon_list[0:5]:
                        name = smn[0]
                        cost = smn[1]
                        func = partial(depress)
                        b1 = tk.Button(self.summon_frame, text = name.replace('_',' ') + ' •'+str(cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                        b1.config(command = lambda btn = b1 : func(btn=btn))
                        b1.pack(side = 'left', fill = 'both', expand = True)
                        b1.bind('<Button-2>', lambda event, b = b1, n = name.replace('_',' ') : app.action_info(event, name = n, button = b))
                        self.summon_buttons.append(b1)
                else:# IS SPELL
                    for i,s in enumerate(self.spell_list[:]):
                        if s.name.replace('_',' ') == name:
                            ix2 = i
                    app.selected_btn = []
                    for btn in self.spell_buttons:
                        btn.destroy()
                    self.spell_list = list(self.spell_list[ix2:])+list(self.spell_list[:ix2])
                    for spell in self.spell_list[0:5]:
                        func = partial(depress)
                        b1 = tk.Button(self.spell_frame, text = spell.name.replace('_',' ') + ' •'+str(spell.cost), wraplength = 190, font = ('chalkduster', 17), fg='indianred', highlightbackground = 'tan3')
                        b1.config(command = lambda btn = b1 : func(btn=btn))
                        b1.pack(side = 'left', fill = 'both', expand = True)
                        b1.bind('<Button-2>', lambda event, b = b1, n = spell.name.replace('_',' ') : app.action_info(event, name = n, button = b))
                        self.spell_buttons.append(b1)
        self.grim_lbox.bind('<<ListboxSelect>>', clickEvent)
        self.sb.config(command = self.grim_lbox.yview)
        self.grim_lbox.pack(side = 'left', fill = 'y', expand = 1)
        self.sb.pack(side = 'right', fill = 'y')
        self.bg_canvas.create_window(root.winfo_screenwidth()//2, root.winfo_screenheight()//3+300, window = self.frame2)
        
        
    def page_grimoire_spells(self, event = None, tup_list = None, index = None):
        app.depop_context(event = None)
        for i,spell in enumerate(tup_list[index:index+7]):
            name = spell.name.replace('_', ' ')
            func = spell.func
            cost = spell.cost
            i += 1
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name + ' •'+str(cost), font = ('chalkduster', 18), fg='tan3', highlightbackground = 'tan3', command = func)
            b1.pack(side = 'top', pady = 2)
            if cost > self.magick or spell.times_cast >= spell.times_imprint:
                b1.config(state = 'disabled')
            else:
                root.bind(str(i), func)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            b3.pack(side = 'top', pady = 2)
            root.bind('<e>', lambda e, t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = self.cleanup_spell)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        
    def try_load(self):
        saves = [s for r,d,s in walk('save_games/')][0]
        saves = [s for s in saves[:] if s[0] != '.']
        # create a button for each save and a cancel button
        self.scroll_frame = VerticalScrolledFrame(root)
        self.game_title.create_window(root.winfo_screenwidth()/2 + root.winfo_screenwidth()/8, root.winfo_screenheight()-220, anchor = 'nw', window = self.scroll_frame)
        self.game_title.saves_buttons = []
        for s in saves:
            # expand filename into readable
            with open('save_games/'+s, 'r') as f:
#                 obj = load(f)
                name = f.readline().strip('\n')
                level = f.readline().strip('\n')
                arcane = eval(f.readline().strip('\n'))
                sum_cap = int(f.readline().strip('\n'))
                str = int(f.readline().strip('\n'))
                agl = int(f.readline().strip('\n'))
                end = int(f.readline().strip('\n'))
                mm = int(f.readline().strip('\n'))
                msl = int(f.readline().strip('\n'))
                bls = int(f.readline().strip('\n'))
                dodge = int(f.readline().strip('\n'))
                psyche = int(f.readline().strip('\n'))
                rsn = int(f.readline().strip('\n'))
                wis = int(f.readline().strip('\n'))
                san = int(f.readline().strip('\n'))
                init = int(f.readline().strip('\n'))
                b_acts = int(f.readline().strip('\n'))
                b_mvs = int(f.readline().strip('\n'))
                b_smns = int(f.readline().strip('\n'))
                b_spirit = int(f.readline().strip('\n'))
                move_range = int(f.readline().strip('\n'))
                area = int(f.readline().strip('\n'))
                entomb_deck = eval(f.readline().strip('\n'))
                if name == 'Agnes_Sampson':
                    img = ImageTk.PhotoImage(Image.open('avatars/Agnes_Sampson.png'))
                    obj = Witch(name = 'Agnes_Sampson', img = img, loc = [0,0], owner = 'p1', level = int(level), entomb_deck = entomb_deck)
                elif name == 'Fakir_Ali':
                    img = ImageTk.PhotoImage(Image.open('avatars/Fakir_Ali.png'))
                    obj = Witch(name = 'Fakir_Ali', img = img, loc = [0,0], owner = 'p1', level = int(level), entomb_deck = entomb_deck)
                obj.summon_cap = sum_cap
                obj.str = str
                obj.agl = agl
                obj.end = end
                obj.mm = mm
                obj.msl = msl
                obj.bls = bls
                obj.dodge = dodge
                obj.psyche = psyche
                obj.rsn = rsn
                obj.wis = wis
                obj.san = san
                obj.init = init
                obj.base_acts = b_acts
                obj.base_mvs = b_mvs
                obj.base_smns = b_smns
                obj.smns = b_smns
                obj.base_spirit = b_spirit
                obj.spirit = b_spirit
                obj.magick = 0
                obj.current_area = area
                obj.move_range = move_range
                cmd = lambda obj = obj : self.load_game(obj)
                b = tk.Button(self.scroll_frame.interior, text = s, width = 13, wraplength = 190, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = cmd)
                b.pack() 
                self.game_title.saves_buttons.append(b)
        cancel_b = tk.Button(self.scroll_frame.interior, text = 'Cancel', bg = 'black', fg = 'black', width = 13, highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = self.scroll_frame.destroy)
        cancel_b.pack(side = 'bottom')
        self.game_title.saves_buttons.append(cancel_b)
                
    def load_game(self, obj):
        self.game_title.destroy()
        self.load_map_triggers(map_number = obj.current_area, protaganist_object = obj)
        
    def num_chose(self, num):
        self.num_players = num
        self.game_title.destroy()
        self.grim_edit.destroy()
        self.one_player.destroy()
        self.two_player.destroy()
        del self.title_screen
        del self.game_title
        del self.grim_edit
        del self.one_player
        del self.two_player
        if self.num_players == 2:
            self.choose_map()
        else:
        # first choose_witch() here
            self.choose_witch(player_num = 1)
#             self.load_map_triggers(map_number = 0)
            
    # make each branch load the intro scene for level, with 'continue' button when done reading/displaying to call create_map_curs_context
    def load_map_triggers(self, map_number, witch = None, protaganist_object = None):
        background_music.stop()
        if map_number == 0: # FIRST AREA, NO 'CONTINUATION from previous level' BY PASSING PROTAG OBJECT
            self.map_triggers = []
            # CLEANUP FROM CHOOSE_WITCH
            try:
                self.avatar_popup.destroy()
                del self.wrapped_funcs
            except:
                pass
            self.p1_witch = witch
            sound1 = mixer.Sound('Music/heroic_demise.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            if protaganist_object:
                self.load_intro_scene(map_number, protaganist_object = protaganist_object)
            else:
                self.load_intro_scene(map_number)# DONT NEED PROTAG OBJECT ON FIRST AREA
    # SECOND LEVEL
        elif map_number == 1:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/Caves of sorrow.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # THRID LEVEL 
        elif map_number == 2:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/arabesque.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            # tag both knights as 'stairway' or 'doorway'
            def tag_knights():
                knights = [v for k,v in app.all_ents().items() if v.name == 'Undead_Knight']
                for v in knights:
                    if v.loc == [19,13]:
                        v.stairway = True
                        v.doorway = False
                    elif v.loc == [28,17]:
                        v.doorway = True
                        v.stairway = False
                self.map_triggers.remove(tag_knights)
            self.map_triggers.append(tag_knights)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # LIBRARY
        elif map_number == 121:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/field_of_dreams.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
        # LABYRINTH 
        elif map_number == 21:
            sound1 = mixer.Sound('Music/Blackmoor_Colossus.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.map_triggers = []
            def ghost_kickoff():
                app.ghost_dead = False
                app.map_triggers.remove(ghost_kickoff)
            self.map_triggers.append(ghost_kickoff)
            self.revenant_rate = 0
            self.top2 = Image.open('1_player_map_fog/map21/2_top.png')
            self.bot2 = Image.open('1_player_map_fog/map21/2.png')
            def area_sixteen():
                if app.ent_dict[app.p1_witch].loc in [[13,16],[13,17],[13,18],[13,19],[13,20]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[14,16],[14,17],[15,16],[15,17],[16, 16], [17, 16], [18, 16], [19, 16], [20, 16], [21, 16], [22, 16], [23, 16], [24, 16], [25, 16], [26, 16], [27, 16],[27,17],[27,18],[27,19],[27,20],[27,21],[26,21],[25,21],[25,20],[25,19],[17, 19], [18, 19], [19, 19], [20, 19], [21, 19], [22, 19], [23, 19], [24, 19],[14, 20], [15, 20], [16, 20], [17, 20], [18, 20], [19, 20]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/16_top.png')
                    bot = Image.open('1_player_map_fog/map21/16.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    app.rebind_all()
                    self.map_triggers.remove(area_sixteen)
            # Ghost place 1, add ghost to coord 35,35
            # when ghost below N hp, move to final spot at 2,2 in area 9 which should only be revealed after area 8
            # add revenants or revenant generation...
            # 29,26 and 31,30 add trig to summon revs on turn 2
            # certain areas, once revealed, generate revenants every N turns, area 1 (start area), area 4 at 30,8, area 15 at 30, 34 and 32, 24, other revs are only placed and not generated/summoned
            def area_fifteen():
                if app.ent_dict[app.p1_witch].loc in [[5,37],[4,37]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[6, 37], [7, 37], [8, 37], [9, 37], [10, 37], [11, 37], [12, 37], [13, 37], [14, 37], [15, 37], [16, 37], [17, 37], [18, 37], [19, 37], [20, 37], [21, 37], [22, 37], [23, 37], [24, 37], [25, 37], [26, 37], [27, 37], [28, 37], [29, 37], [30, 37], [31, 37], [32, 37],[24, 36], [25, 36], [26, 36], [27, 36], [28, 36], [29, 36], [30, 36], [31, 36], [32, 36], [33, 36], [34, 36], [35, 36], [36, 36], [37, 36], [38, 36],[24, 35], [25, 35], [26, 35], [27, 35], [28, 35], [29, 35], [30, 35], [31, 35], [32, 35], [33, 35], [34, 35], [34, 34], [34, 37], [35, 34], [36, 34], [36, 37], [35, 37], [38, 34], [38, 37], [35, 35], [36, 35], [37, 35], [38, 35],[24, 34], [25, 34], [26, 34], [27, 34], [28, 34], [29, 34], [30, 34], [31, 34], [32, 34]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/15_top.png')
                    bot = Image.open('1_player_map_fog/map21/15.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_fifteen)
                    # PLACE GHOST
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Ghost.png'))
                    ent = Ghost(name = 'Ghost', img = img, loc = [35,35], owner = 'p2')
                    app.grid[35][35] = ent.id
                    app.ent_dict[ent.id] = ent
                    app.canvas.create_image(3550-app.moved_right, 3550-app.moved_down, image = ent.img, tags = ent.tags)
                    def ghost_check():
                        if 'Ghost' not in [v.name for k,v in app.all_ents().items()]:
                            app.ghost_dead = True
                            app.map_triggers.remove(ghost_check)
                    app.map_triggers.append(ghost_check)
                    app.rebind_all()
            def area_fourteen():
                if app.ent_dict[app.p1_witch].loc in [[7,24],[6,24]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[7,25],[7, 26], [7, 27], [7, 28], [7, 29], [7, 30], [7, 31],[8, 30], [9, 30], [10, 30], [11, 30], [12, 30], [13, 30], [14, 30], [15, 30], [16, 30], [17, 30], [18, 30], [19, 30], [20, 30], [21, 30], [22, 30], [23, 30], [24, 30],[8, 31], [9, 31], [10, 31], [11, 31], [12, 31], [13, 31], [14, 31], [15, 31], [16, 31], [17, 31], [18, 31], [19, 31], [20, 31], [21, 31], [22, 31], [23, 31], [24, 31],[22,32],[22,33],[7, 34], [8, 34], [9, 34], [10, 34], [11, 34], [12, 34], [13, 34], [14, 34], [15, 34], [16, 34], [17, 34], [18, 34], [19, 34], [20, 34], [21, 34], [22, 34]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/14_top.png')
                    bot = Image.open('1_player_map_fog/map21/14.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    app.rebind_all()
                    self.map_triggers.remove(area_fourteen)
            def area_thirteen():
                if app.ent_dict[app.p1_witch].loc in [[1,24],[1,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_fifteen)
                    coords = [[1,25],[1,26],[1,27],[1,28],[2,27],[2,28],[3,27],[3,28],[4,27],[4,28],[5,27],[5,28],[5, 29], [5, 30], [5, 31], [5, 32], [5, 33], [5, 34], [5, 35], [5, 36], [5, 37],[4, 33], [4, 34], [4, 35], [4, 36], [4, 37],[3, 31], [3, 32], [3, 33], [3, 34], [3, 35], [3, 36], [3, 37],[2, 31], [2, 32], [2, 33], [2, 34], [2, 35], [2, 36], [2, 37],[1, 31], [1, 32], [1, 33], [1, 34], [1, 35], [1, 36], [1, 37]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/13_top.png')
                    bot = Image.open('1_player_map_fog/map21/13.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_thirteen)
                    app.rebind_all()
            self.map_triggers.append(area_thirteen)
            def area_twelve():
                if app.ent_dict[app.p1_witch].loc in [[12,20],[11,20],[4,19],[5,19],[6,19],[5,13],[5,12]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_fourteen)
                    coords = [[4,13],[3,13],[2,13],[1,13],[1, 14], [1, 15], [1, 16], [1, 17], [1, 18], [1, 19], [1, 20], [1, 21], [1, 22], [1, 23], [1, 24],[3, 13], [3, 14], [3, 15], [3, 16], [3, 17], [3, 18], [3, 19], [3, 20], [3, 21], [3, 22], [3, 23], [3, 24],[4,24],[5,24],[5,23],[5,22],[6,22],[6,23],[6,24],[7,22],[7,23],[7,24],[8,23],[8,22],[9,23],[9,22],[10,23],[10,22],[11,23],[11,22],[12,23],[12,22],[11,21],[12,21]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/12_top.png')
                    bot = Image.open('1_player_map_fog/map21/12.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_twelve)
                    # when revealing 12, if 11 not revealed then reveal it
                    if area_eleven in self.map_triggers:
                        area_eleven(alt = True)
                    app.rebind_all()
            self.map_triggers.append(area_twelve)
            def area_eleven(alt = False):
                if app.ent_dict[app.p1_witch].loc in [[14,11],[14,12],[14,13]] or alt == True:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_sixteen)
                    coords = [[13,11],[13,12],[13,13],[12,11],[12,12],[12,13],[11,11],[11,12],[11,13],[11, 14], [11, 15], [11, 16], [11, 17], [11, 18], [11, 19], [11, 20],[12,18],[12,19],[12,20],[13,16],[13,17],[13,18],[13,19],[13,20],[10,15],[9,15],[9,16],[9,17],[9,18],[9,19],[8,19],[7,19],[6,19],[5,19],[10,11],[10,12],[9,11],[9,12],[8,11],[8,12],[7,11],[7,12],[7,13],[7,14],[7,15],[7,16],[6,16],[5,16],[4,19]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/11_top.png')
                    bot = Image.open('1_player_map_fog/map21/11.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_eleven)
                    app.rebind_all()
            self.map_triggers.append(area_eleven)
            def area_ten():
                if app.ent_dict[app.p1_witch].loc in [[16,9],[16,10],[4,13],[3,13]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[5, 8], [6, 8], [7, 8], [8, 8], [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8], [15, 8], [16, 8],[5,9],[5,10],[5,11],[5,12],[5,13]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/10_top.png')
                    bot = Image.open('1_player_map_fog/map21/10.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_ten)
                    app.rebind_all()
            self.map_triggers.append(area_ten)
            def area_nine():
                if app.ent_dict[app.p1_witch].loc in [[3,5],[4,5]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[3,6],[3,7],[3,8],[3,9],[3,10],[2,10],[1,10],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[2,2],[3,2],[4,2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/9_top.png')
                    bot = Image.open('1_player_map_fog/map21/9.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_nine)
                    app.rebind_all()
            def area_eight():
                if app.ent_dict[app.p1_witch].loc in [[24,9],[24,10]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_nine)
                    coords = [[18, 8], [19, 8], [20, 8], [21, 8], [22, 8], [23, 8], [24, 8],[18,7],[18,6],[18,5],[3, 5], [4, 5], [5, 5], [6, 5], [7, 5], [8, 5], [9, 5], [10, 5], [11, 5], [12, 5], [13, 5], [14, 5], [15, 5], [16, 5],[17,5]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/8_top.png')
                    bot = Image.open('1_player_map_fog/map21/8.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_eight)
                    app.rebind_all()
            def area_seven():
                if app.ent_dict[app.p1_witch].loc in [[26,9],[26,10]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[26,8],[26,7],[26,6],[26,5],[25,5],[24,5],[23,5],[22,5],[21,5],[20,5]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/7_top.png')
                    bot = Image.open('1_player_map_fog/map21/7.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_seven)
                    app.rebind_all()
            def area_six():
                if app.ent_dict[app.p1_witch].loc in [[38,2],[37,2]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[7, 2], [8, 2], [9, 2], [10, 2], [11, 2], [12, 2], [13, 2], [14, 2], [15, 2], [16, 2], [17, 2], [18, 2], [19, 2], [20, 2], [21, 2], [22, 2], [23, 2], [24, 2], [25, 2], [26, 2], [27, 2], [28, 2], [29, 2], [30, 2], [31, 2], [32, 2], [33, 2], [34, 2], [35, 2], [36, 2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/6_top.png')
                    bot = Image.open('1_player_map_fog/map21/6.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_six)
                    app.rebind_all()
            def area_five():
                if app.ent_dict[app.p1_witch].loc in [[38,22],[38,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_six)
                    coords = [[38, 2], [38, 3], [38, 4], [38, 5], [38, 6], [38, 7], [38, 8], [38, 9], [38, 10], [38, 11], [38, 12], [38, 13], [38, 14], [38, 15], [38, 16], [38, 17], [38, 18], [38, 19], [38, 20], [38, 21],[37,2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/5_top.png')
                    bot = Image.open('1_player_map_fog/map21/5.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_five)
                    app.rebind_all()
            self.map_triggers.append(area_five)
            def area_four():
                if app.ent_dict[app.p1_witch].loc in [[35,22],[35,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[35, 7], [35, 8], [35, 9], [35, 10], [35, 11], [35, 12], [35, 13], [35, 14], [35, 15], [35, 16], [35, 17], [35, 18], [35, 19], [35, 20], [35, 21],[29,7],[30,7],[31,7],[32,7],[33,7],[34,7],[29,8],[30,8],[31,8],[32,8],[33,8],[34,8]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/4_top.png')
                    bot = Image.open('1_player_map_fog/map21/4.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_four)
                    app.rebind_all()
            self.map_triggers.append(area_four)
            def area_three():
                if app.ent_dict[app.p1_witch].loc in [[33,22],[33,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[33,21],[33,20],[33,19],[33,18],[33,17],[33,16],[33,15],[33,14],[33,13],[33,12]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/3_top.png')
                    bot = Image.open('1_player_map_fog/map21/3.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_three)
                    app.rebind_all()
            self.map_triggers.append(area_three)
            def area_two():
                if app.ent_dict[app.p1_witch].loc in [[29,22],[30,22],[31,22]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_seven)
                    self.map_triggers.append(area_eight)
                    coords = [[29,21],[30,21],[31,21],[29,20],[30,20],[31,20],[29,19],[30,19],[31,19],[29,18],[30,18],[31,18],[29,17],[30,17],[31,17],[29,16],[30,16],[31,16],[29,15],[30,15],[31,15],[29,14],[30,14],[31,14],[29,13],[30,13],[31,13],[29,12],[30,12],[31,12],[28,12],[28,13],[27,12],[27,13],[26,12],[26,13],[25,12],[25,13],[24,12],[24,13],[23,12],[23,13],[22,12],[22,13],[21,12],[21,13],[20,12],[20,13],[19,12],[19,13],[18,12],[18,13],[17,12],[17,13],[16,12],[16,13],[15,12],[15,13],[14,12],[14,13],[16,11],[17,11],[18,11],[19,11],[20,11],[21,11],[22,11],[16,10],[16,9],[14,11],[24,11],[24,10],[24,9],[26,11],[26,10],[26,9]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = self.top2
                    bot = self.bot2
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_two)
                    app.rebind_all()
            self.map_triggers.append(area_two)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # WHITE DRAGON
        elif map_number == 22:
            sound1 = mixer.Sound('Music/Dark_Amulet.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # WARLOCK
        elif map_number == 122:
            sound1 = mixer.Sound('Music/Dark_Descent.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # LEVEL 3 SANCTUM ENTRYWAY
        elif map_number == 3:
            sound1 = mixer.Sound('Music/radakan - old crypt.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # RITUAL CIRCLE
        elif map_number == 4:
            sound1 = mixer.Sound('Music/The Peculiar Habits of the Cave Hermits.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(app.music_volume.get())
            self.map_triggers = []
            app.mages_placed = False
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # END OF GAME
        else:
            print('add gorgon level...map number 5')
        
    def load_intro_scene(self, map_number = None, protaganist_object = None):
        filename = 'intro_scene_texts/intro_scene_text'+str(map_number)+'.txt'
        with open(filename) as f:
            text = f.read()
        self.intro_scene = ImageTk.PhotoImage(Image.open('intro_scenes/intro_scene'+str(map_number)+'.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.intro_canvas = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.intro_canvas.create_image(0,0, image =self.intro_scene, anchor = 'nw')
        self.intro_canvas.pack(side = 'top')

        self.bd_img = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-180, root.winfo_screenheight()//3-11)))
        self.intro_canvas.create_image(root.winfo_screenwidth()//2, root.winfo_screenheight()-192, anchor='s', image =self.bd_img)
        
        self.frame = tk.Frame(root)#, width = root.winfo_screenwidth()-180, height = root.winfo_screenheight()//4)
        self.sb = tk.Scrollbar(self.frame)
        
        self.intro_text = tk.Text(self.frame, height = 7, width = 118, wrap = 'word', bg = 'black', relief = 'raised', highlightthickness = 0, borderwidth = 0, fg = 'indianred', font = ('kokonor', 16))
        self.intro_text.insert('end', text)
        self.intro_text.configure(state = 'disabled')
        
        self.intro_canvas.create_window(root.winfo_screenwidth()//2, root.winfo_screenheight()-320, window = self.frame)
        self.intro_text.pack(side = 'left')
        self.sb.pack(side = 'right', fill = 'y')
        self.intro_text.configure(yscrollcommand = self.sb.set)
        self.sb.config(command = self.intro_text.yview)

# # CONT OR SAVE BUTTONS        
        self.start_area_button = tk.Button(root, text = 'Start Area', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = map_number, po = protaganist_object : self.create_map_curs_context(n,po))
        self.intro_canvas.create_window(root.winfo_screenwidth()//2-100, root.winfo_screenheight()-80, anchor='s', window = self.start_area_button)
        
    # ONLY CALLED IN 2 PLAYER MODE
    def choose_map(self):
        self.choosemap = tk.Label(root, text = 'Choose Map', fg = 'tan3', bg = 'black', font = ('chalkduster', 38))
        self.choosemap.pack()
        # CHOOSE MAPS
        maps = [m for r,d,m in walk('./2_player_map_portraits')][0]
        maps = [m for m in maps[:] if m[0] != '.']
        self.tmp_list = []
        self.page_maps(maps = maps)
        
    def page_maps(self, event = None, maps = None, index = 0):
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        if index > 0:
            b4 = tk.Button(root, text = 'W : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda maps = maps, i = index-4 : self.page_maps(maps = maps, index = i))
            b4.pack(side = 'top', pady = 2)
            app.context_buttons.append(b4)
        if len(maps) > len(maps[:index+4]):
            b3 = tk.Button(root, text = 'E : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda maps = maps, i = index+4 : self.page_maps(maps = maps, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
        for map in maps[index:index+4]:
            photo = ImageTk.PhotoImage(Image.open('./2_player_map_portraits/' + map).reduce((1)))
            self.tmp_list.append(photo)
            map_num = map.rstrip('.png')
            cmd = lambda indx = map_num : self.map_choice_cleanup(indx)
            b = tk.Button(root, image = photo, bg = 'black', highlightbackground = 'tan3', command = cmd)
    #             self.tmp_mapimg_dict['map'+map_num] = photo
    #             b.config(image = self.tmp_mapimg_dict['map'+map_num], bg = 'black', highlightbackground = 'tan3', command = cmd)
            # DEBUG packing will have to be fixed here for different screen sizes
            b.pack(side = 'left', padx = 10, pady = 10)
            self.context_buttons.append(b)
            
            
            
    def map_choice_cleanup(self, map_number):
        self.two_player_map_num = int(map_number)
        self.choosemap.destroy()
        for b in self.context_buttons:
            b.destroy()
        del self.tmp_list
        self.choose_witch(player_num = 1)
#         self.create_map_curs_context(map_number)
        
        
        # IF PROTAG, LOAD PROTAG AND DO NOT RE-INIT WITCH
    def create_map_curs_context(self, map_number, protaganist_object = None):
        global curs_pos, grid_pos, map_pos
        for child in root.winfo_children():
            if child._name != '!app':
                child.destroy()
        # SELECT GRIMOIRE FOR START CAMPAIGN, translate grimoire editor object to Witch usable obj (with count, as 'cards')
        if protaganist_object == None:
            # use wait_var to pause exec
            name = 'dethlok'+str(app.death_count)
            app.death_count += 1
            app.dethloks[name] = tk.IntVar(0)
            self.grimoire_editor(mode = 'select', lockname = name)
            app.wait_variable(app.dethloks[name])
            entomb_deck_p1 = []
            for k,v in self.grimoire_p1.items():
                for x in range(v):
                    entomb_deck_p1.append(k.replace(' ','_'))
            if self.num_players == 2:
                app.entomb_deck_p2 = []
                for k,v in self.grimoire_p2.items():
                    for x in range(v):
                        app.entomb_deck_p2.append(k.replace(' ','_'))
            for child in root.winfo_children():
                if child._name != '!app':
                    child.destroy()
        self.map_number = map_number
        try: self.intro_canvas.destroy()
        except: pass
        # GET MAP DIMENSIONS
        if self.num_players == 1:
            filename = '1_player_map_info/map' + str(map_number) + '.txt'
        else:
            filename = '2_player_map_info/map' + str(map_number) + '.txt'
        with open(filename) as f:
            self.map_info = f.read().splitlines()
        self.map = 'map' + str(map_number)
        self.map_width = int(self.map_info[0])
        self.map_height = int(self.map_info[1])
        # CREATE GRID FROM MAP DIMENSIONS
        col = self.map_width//100
        row = self.map_height//100
        self.grid = [[''] * row for i in range(col)]
        self.coords = [[x,y] for x in range(self.map_width//100) for y in range(self.map_height//100)]
        self.loc_dict = dict([(tuple(c), Loc(c)) for c in app.coords])
        # START LOC
        if self.num_players == 1:
            self.start_loc = eval(self.map_info[2])
        else:
            self.start_loc = eval(self.map_info[2])[0]
            self.p2_start_loc = eval(self.map_info[2])[1]
        # LOAD MAP / GRID INFO / IMPASSABLE TERRAIN
        terrain = eval(self.map_info[3])
        for coord in terrain:
            self.grid[coord[0]][coord[1]] = 'block'
        # CONTEXT MENU
        self.con_bg = ImageTk.PhotoImage(Image.open('context_menu_bg.png').resize(( 200, root.winfo_screenheight())))
        self.context_menu = tk.Canvas(root, bg = 'black', bd=0, highlightthickness=0, relief='raised', height = root.winfo_screenheight(), width = 200)
        self.context_menu.pack_propagate(0)
        self.context_menu.pack(side = 'left', fill = 'both', expand = 'false')
        self.context_menu.create_image(0, 0, anchor = 'nw', image = self.con_bg)
        # CANVAS
        width = root.winfo_screenwidth()
        height = root.winfo_screenheight()
        if self.map_width < width:
            width = self.map_width
        if self.map_height < height:
            height = self.map_height
        self.canvas = tk.Canvas(root, width = width, bg = 'black', height = height, bd=2, highlightthickness=0, relief='sunken')
        self.canvas.pack()
        # MAP
        if self.num_players == 1:
            fname = '1_player_maps/'
            topfname = '1_player_map_tops/'
        else:
            fname = '2_player_maps/'
            topfname = '2_player_map_tops/'
        self.map_bottom_image = Image.open(fname + 'map'+str(map_number)+'.png')
        self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
#         self.map_bottom = ImageTk.PhotoImage(Image.open(fname + 'map'+str(map_number)+'.png'))
#         self.image_holder.append(map_bottom)
        self.map_top_image = Image.open(topfname + 'map_top'+str(map_number)+'.png')
        self.map_top = ImageTk.PhotoImage(self.map_top_image)
        self.canvas.create_image(0, 0, anchor='nw', image= self.map_bottom, tags=('mapbottom','map'))
        self.canvas.create_image(0, 0, anchor='nw', image= self.map_top, tags = ('maptop','map'))
        # CURSOR
        self.cursor_img = ImageTk.PhotoImage(Image.open("cursor.png").resize((100,100)))
        self.vis_dict['cursor'] = Vis(name = 'cursor', loc = [0,0])
        curs_pos = [0,0]
        grid_pos = [0,0]
        map_pos = [0,0]
        self.canvas.create_image(0, 0, image=self.cursor_img, tags='cursor')
        # MINI MAP
        w = self.map_width//10
        h = self.map_height//10
        self.minimap = ImageTk.PhotoImage(Image.open('minimap.png').resize((w,h)))
        w2 = root.winfo_screenwidth()//10-10
        h2 = root.winfo_screenheight()//10
        self.minimap_screen = ImageTk.PhotoImage(Image.open('minimap_screen.png').resize((w2,h2)))
        # CHOOSE WITCH IF 2 PLAYER OR FIRST LEVEL
        if protaganist_object:
            self.load_witch(witch = protaganist_object.name, player_num = 1, protaganist_object = protaganist_object)
        else:# LOADING FIRST LEVEL, NOT SAVE GAME
            # load/select grimoire here, that func should exit to load_witch
            self.load_witch(witch = self.p1_witch, player_num = 1, protaganist_object = None, entomb_deck = entomb_deck_p1[:])
#             self.choose_witch()
        
    # Called twice for 2player mode, first call defaults to first player choice, second call passes player_num = 2
    def choose_witch(self, player_num = 1):
        self.avatar_popup = tk.Toplevel(root)
        self.avatar_popup.attributes('-topmost', 'true')
        self.avatar_popup.attributes("-fullscreen", True)
        self.avatar_popup.config(bg = 'black')
#         self.avatar_popup.grab_set()
        label = tk.Label(self.avatar_popup, text = 'Choose Player ' + str(player_num) + ' Witch', font = ('chalkduster', 36), fg = 'indianred', bg = 'black')
        label.pack(side = 'top')
        if player_num == 1:
            witches = [w for r,d,w in walk('./portraits/')][0]
            witches = [w for w in witches[:] if w[0] != '.']
        elif player_num == 2:
            witches = [w for r,d,w in walk('./portraits')][0]
            witches = [w for w in witches[:] if w[0] != '.']
            p1_w_fname = self.p1_witch + '.png'
            witches.remove(p1_w_fname)
        self.avatar_popup.witch_widgets = []
        self.avatar_popup.img_dict = {}
        self.wrapped_funcs = []
        for i,witch in enumerate(witches):
            f = tk.Frame(self.avatar_popup, bg = 'black')
            f.pack(side = 'left')
            self.avatar_popup.witch_widgets.append(f)
            b = tk.Button(f)
            # change below to call load_map_trigger(witchname)
            if player_num == 1 and self.num_players == 2:
                def wrap(somePartial, witch_name):
                    self.p1_witch = witch_name
                    somePartial()
                p1 = partial(self.choose_witch, player_num = 2)
                p = partial(wrap, p1, witch[:-4])
            elif player_num == 2 and self.num_players == 2:
                def wrap(somePartial, witch_name):
                    self.p2_witch = witch_name
                    somePartial()
                p1 = partial(self.create_map_curs_context, map_number = self.two_player_map_num)
                p = partial(wrap, p1, witch[:-4])
            else:
                p = partial(self.load_map_triggers, map_number = 0, witch = witch[:-4])
#             p = partial(self.load_witch, witch[:-4], player_num)
            cmd = lambda win = self.avatar_popup, p = p : self.release_wrapper(win, p)
            self.wrapped_funcs.append(p)
            photo = ImageTk.PhotoImage(Image.open('./portraits/' + witch))
            self.avatar_popup.img_dict[witch] = photo
            # DETERMINE HORIZONTAL PADDING BY SCREENSIZE
            # DEBUG ASSUMES 3 WITCHES, ASSUMES MINIMUM SCREEN WIDTH 900
            width = root.winfo_screenwidth()
            remainder_screen = width - (300 * len(witches))
            horz_pad = (remainder_screen//len(witches))//2
            b.config(image = self.avatar_popup.img_dict[witch],highlightbackground='tan3', font = ('chalkduster', 22), highlightthickness = 1, command = cmd)
            b.pack(side = 'top', padx = horz_pad)
            info = lambda w = witch[:-4] : self.show_avatar_info(w)
            b2 = tk.Button(f)
            whtspc_txt = witch[:-4].replace('_', ' ')
            b2.config(text = whtspc_txt, highlightbackground='tan3', highlightthickness= 1, fg = 'tan3', font = ('chalkduster', 22), command = info)
            b2.pack(side = 'bottom')
            self.avatar_popup.witch_widgets.append(b2)
            self.avatar_popup.witch_widgets.append(b)
        
    def load_witch(self, witch = None, player_num = None, protaganist_object = None, entomb_deck = None):
        if player_num == 1:
            self.p1_witch = witch
            if self.num_players == 2:
                loc = self.start_loc
            else:
                loc = self.start_loc
        elif player_num == 2:
            self.p2_witch = witch
            loc = self.p2_start_loc
        # if protaganist_object, instead load its data, RE-INIT IMAGES THAT CANNOT BE SERIALIZED BY PICKLE DUMP
        # changed from pickle to 'write attrs to encoded text file'... DEBUG
        # works but is ugly esp on load game...
        if protaganist_object:
            protaganist_object.loc = loc[:]
            witch_img = ImageTk.PhotoImage(Image.open('avatars/' + witch +'.png'))
            protaganist_object.img = witch_img
            self.ent_dict[witch] = protaganist_object
        else:# NEED TO ATTACH CHOOSE GRIMOIRE HERE
            witch_img = ImageTk.PhotoImage(Image.open('avatars/' + witch +'.png'))
            self.ent_dict[witch] = Witch(name = witch, img = witch_img, loc = loc, owner = 'p' + str(player_num), level = 2, entomb_deck = entomb_deck[:])
        self.canvas.create_image(self.ent_dict[witch].loc[0]*100+50-self.moved_right, self.ent_dict[witch].loc[1]*100+50-self.moved_down, image = self.ent_dict[witch].img, tags = self.ent_dict[witch].tags)
        self.grid[self.ent_dict[witch].loc[0]][self.ent_dict[witch].loc[1]] = witch
        # EXIT FOR 1 PLAYER
        if self.num_players == 1:
            # DEBUG LOAD BOT ENEMIES FOR PLAYER 1 HERE
            # LOAD 1 PLAYER MAP BOT UNITS
            lst = self.map_info[4:]
            c1 = 0
            end = len(lst)
            itlst = iter(lst)
            for x in itlst:
                img = eval(x)
                ent = eval(next(itlst))
                self.ent_dict[ent.id] = ent
                self.canvas.create_image(ent.loc[0]*100+50, ent.loc[1]*100+50, image = ent.img, tags = ent.tags)
                self.grid[ent.loc[0]][ent.loc[1]] = ent.id
                c1 += 1
                if c1 == end:
                    break
            self.animate()
            self.start_level_popup()
            self.map_trigger_loop()
        # CHOOSE SECOND PLAYER WITCH
        elif self.num_players == 2 and player_num == 1:# and self.p2_witch == '':
            self.load_witch(witch = self.p2_witch, player_num = 2, entomb_deck = app.entomb_deck_p2[:])
#             self.choose_witch(player_num = 2)
        # EXIT CHOOSING IF BOTH FINISHED AND START TURN
        else: #self.num_players == 2 and self.p2_witch != '':
#             self.start_turn()
            if self.map_number == 0:
                sound1 = mixer.Sound('Music/heroic_demise.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 1:
                sound1 = mixer.Sound('Music/Caves of sorrow.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 2:
                sound1 = mixer.Sound('Music/arabesque.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 121:
                sound1 = mixer.Sound('Music/field_of_dreams.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 21:
                sound1 = mixer.Sound('Music/Blackmoor_Colossus.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 22:
                sound1 = mixer.Sound('Music/Dark_Amulet.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 122:
                sound1 = mixer.Sound('Music/Dark_Descent.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 3:
                sound1 = mixer.Sound('Music/radakan - old crypt.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            elif self.map_number == 4:
                sound1 = mixer.Sound('Music/The Peculiar Habits of the Cave Hermits.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(app.music_volume.get())
            self.animate()
            self.start_level_popup()
            # change below to use 2-player map triggers (if necessary), will need at least some kind of trigger to detect player death
#             self.map_trigger_loop()
        
    def start_level_popup(self):
        if app.num_players == 2:
            start_text = '''
        Defeat the opposing Witch...
            '''
        elif app.map_number == 2:
            start_text = '''
        Defeat either Undead Knight...
        '''
        elif app.map_number == 121:
            start_text = '''
        Defeat the Ghost...
        '''
        elif app.map_number == 122:
            start_text = '''
        Defeat the Warlock...
        '''
        elif app.map_number == 21:
            start_text = '''
        Find and Defeat the Ghost...
        '''
        elif app.map_number == 22:
            start_text = '''
        Defeat the White Dragon...
        '''
        elif app.map_number == 3:
            start_text = '''
        Defeat Kensai, Barbarian, and Sorceress...
        '''
        elif app.map_number == 4:
            start_text = '''
        Defeat Earth and Air mages, end the round. Then, defeat Fire and Water mages...
        '''
        else:
            start_text = '''
        Defeat all the enemies and end the turn...
        '''
        self.canvas.create_text(399, root.winfo_screenheight()//2-1, text = start_text, font = ('chalkduster', 38), fill = 'black', tags = 'start_text')
        self.canvas.create_text(400, root.winfo_screenheight()//2, text = start_text, font = ('chalkduster', 38), fill = 'indianred', tags = 'start_text')
        def starter():
            self.close_btn.destroy()
            self.canvas.delete('start_text')
            self.start_turn()
        p = partial(starter)
        self.close_btn = tk.Button(self.canvas, text = 'OK', font = ('chalkduster', 22), highlightbackground='black', fg='tan3', command = p)
        self.canvas.create_window(root.winfo_screenwidth()//2-150, self.canvas.winfo_screenheight()//2+150, window = self.close_btn)
        
            
    # handle_sot_campaign() for Campaign mode OTHERWISE generate initiative queue (app.generate_init_q)
    def start_turn(self): # AWAIT button press, start level popup
        if self.num_players == 1:
            self.handle_sot_campaign()
        else:
            self.generate_init_q()
    
    # Effects for Campaign mode
    # exit on generate_init_q()
    def handle_sot_campaign(self):
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4-1, app.canvas.winfo_screenheight()-69, text='Start-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'black', tags = 'sot_text')
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4, app.canvas.winfo_screenheight()-70, text='Start-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'indianred', tags = 'sot_text')
        if self.map_number == 21: #LABYRINTH
            self.generate_init_q()
        elif self.map_number == 22: #WHITE DRAGON
            for ent in app.all_ents().values():
                if ent.name == 'White_Dragon':
                    dragon = ent
            # SUMMON KOBOLDS
            if dragon.spirit < 100 and dragon.summoned_kobolds == False:
                empty_locs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c, dragon.loc) >= 14]
                loc1 = choice(empty_locs)
                empty_locs.remove(loc1)
                loc2 = choice(empty_locs)
                empty_locs.remove(loc2)
                loc3 = choice(empty_locs)
                empty_locs.remove(loc3)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Kobold_Shaman.png'))
                ent1 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc1[:], owner = 'p2')
                ent2 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc2[:], owner = 'p2')
                ent3 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc3[:], owner = 'p2')
                app.ent_dict[ent1.id] = ent1
                app.ent_dict[ent2.id] = ent2
                app.ent_dict[ent3.id] = ent3
                app.grid[loc1[0]][loc1[1]] = ent1.id
                app.grid[loc2[0]][loc2[1]] = ent2.id
                app.grid[loc3[0]][loc3[1]] = ent3.id
                dragon.summoned_kobolds = True
            # SUMMON ORCS
            elif dragon.spirit < 50 and dragon.summoned_orcs == False:
                empty_locs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c, dragon.loc) >= 14]
                loc1 = choice(empty_locs)
                empty_locs.remove(loc1)
                loc2 = choice(empty_locs)
                empty_locs.remove(loc2)
                loc3 = choice(empty_locs)
                empty_locs.remove(loc3)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Orc_Axeman.png'))
                ent1 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc1[:], owner = 'p2')
                ent2 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc2[:], owner = 'p2')
                ent3 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc3[:], owner = 'p2')
                app.ent_dict[ent1.id] = ent1
                app.ent_dict[ent2.id] = ent2
                app.ent_dict[ent3.id] = ent3
                app.grid[loc1[0]][loc1[1]] = ent1.id
                app.grid[loc2[0]][loc2[1]] = ent2.id
                app.grid[loc3[0]][loc3[1]] = ent3.id
                dragon.summoned_orcs = True
            self.generate_init_q()
        elif self.map_number == 4:
            mages = [v.name for k,v in app.all_ents().items()]
            # earth and air mages have been killed, but fire and water mages have not been created
            if 'Earth_Mage' not in mages and 'Air_Mage' not in mages and 'Water_Mage' not in mages and 'Fire_Mage' not in mages and app.mages_placed == False:
                    # kill earth elementals and air elementals
                    ids = [k for k,v in app.all_ents().items() if v.name == 'Earth_Elemental' or v.name == 'Air_Elemental']
                    def place_fire_water_mages():
                        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
                        loc1 = reduce(lambda a,b : a if dist(a,[22,19])<dist(b,[22,19]) else b,empty)
                        empty.remove(loc1)
                        loc2 = reduce(lambda a,b : a if dist(a,[22,15])<dist(b,[22,15]) else b,empty)
                        img = ImageTk.PhotoImage(Image.open('summon_imgs/Fire_Mage.png'))
                        img2 = ImageTk.PhotoImage(Image.open('summon_imgs/Water_Mage.png'))
                        ent = Fire_Mage(name = 'Fire_Mage', img = img, loc = loc1[:], owner = 'p2')
                        app.ent_dict[ent.id] = ent
                        app.grid[ent.loc[0]][ent.loc[1]] = ent.id
                        ent2 = Water_Mage(name = 'Water_Mage', img = img2, loc = loc2[:], owner = 'p2')
                        app.ent_dict[ent2.id] = ent2
                        app.grid[ent2.loc[0]][ent2.loc[1]] = ent2.id
                        app.mages_placed = True
                        root.after(111, lambda loc1 = loc1 : app.focus_square(loc1))
                        root.after(999, lambda loc2 = loc2 : app.focus_square(loc2))
                        root.after(1888, self.generate_init_q)
                    def kill_loop(ids):
                        if ids == []:
                            place_fire_water_mages()
                        else:
                            id = ids[0]
                            ids = ids[1:]
                            ent = app.ent_dict[id]
                            app.get_focus(ent.id)
                            name = 'dethlok'+str(app.death_count)
                            app.death_count += 1
                            app.dethloks[name] = tk.IntVar(0)
                            root.after(333, lambda id = id, name = name : app.kill(id, name))
                            root.wait_variable(app.dethloks[name])
                            kill_loop(ids)
                    kill_loop(ids)
            else:
                self.generate_init_q()
        else:
            self.generate_init_q()


        
    # Put all game objects to act for the turn in initiative queue (which may be modified later)
    # exit on handle_sot_effects()
    def generate_init_q(self):
        ids = self.ents_to_act()
        q = []
        while ids != []:
            id = ids[0]
            ids = ids[1:]
            if q == []:
                q.append(id)
            else:
                ent = app.ent_dict[id]
                for i,j in enumerate(q[:]):
                    qent = app.ent_dict[j]
                    if ent.get_abl('init') > qent.get_abl('init'):
                        q = q[0:i] + [id] + q[i:]
                        break
                    elif ent.get_abl('init') == qent.get_abl('init'):
                        if ent.get_abl('agl') > qent.get_abl('agl'):
                            q = q[0:i] + [id] + q[i:]
                            break
                        elif ent.get_abl('agl') == qent.get_abl('agl'):
                            if ent.get_abl('dodge') >= qent.get_abl('dodge'):
                                q = q[0:i] + [id] + q[i:]
                                break
                else:
                    q.append(id)
        self.init_q = q[:]
        self.generate_witch_magick()
        
    
    # ALSO SHUFFLE self.entomb_deck
    def generate_witch_magick(self):
        # p1
        witch = app.ent_dict[app.p1_witch]
#         shuffle(witch.entomb_deck)
        if app.turn_counter == 0:
            shuffle(witch.entomb_deck)
            witch.library = witch.entomb_deck[:]
            witch.in_hand += witch.library[:9]
            witch.library = witch.library[9:]
        else:
            if witch.library != []:
                witch.in_hand += [witch.library[0]]
                witch.library = witch.library[1:]
        tombs = len([k for k,v in app.all_ents().items() if v.name == 'Tomb' and v.owner == witch.owner])
        witch.magick += witch.magick_regen
        witch.magick += (tombs)
        # p2
        if app.num_players == 2:
            witch = app.ent_dict[app.p2_witch]
#             shuffle(witch.entomb_deck)
            if app.turn_counter == 0:
                shuffle(witch.entomb_deck)
                witch.library = witch.entomb_deck[:]
                witch.in_hand += witch.library[:9]
                witch.library = witch.library[9:]
            else:
                if witch.library != []:
                    witch.in_hand += [witch.library[0]]
                    witch.library = witch.library[1:]
            tombs = len([k for k,v in app.all_ents().items() if v.name == 'Tomb' and v.owner == witch.owner])
            witch.magick += witch.magick_regen
            if app.turn_counter == 0:
                witch.in_hand += witch.library[:1]
                witch.library = witch.library[1:]
            witch.magick += (tombs)
        self.handle_sot_effects()
        
    # Resolve start-of-turn effects on each entity AND loc_effects(on map)
    # exit on handle_ent_action()
    def handle_sot_effects(self):
        efs = [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]
        q = []
        while efs != []:
            ef = efs[0]
            efs = efs[1:]
            if q == []:
                q.append(ef)
            else:
                for i,j in enumerate(q[:]):
                    if ef.ts < j.ts:
                        q = q[0:i] + [ef] + q[i:]
                        break
                else:
                    q.append(ef)
        for ef in q:
            if ef.sot_func != None:
                if ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]:
                    lock(ef.sot_func) # RESOLVE / CALL effects
        root.after(1555, lambda t = 'sot_text' : app.canvas.delete(t))
        root.after(1666, self.handle_action)
        
    # Called until no more entities to act in app.init_q
    # COMPUTER entities are handled with Ai_man.handle_ent_action() (or Ai_man.handle_berserk_ent_action on sanity check fail) (whose exits must either lock or not end async expecting their async timeout to be waited for) then exits by calling this function(handle_ent_action)
    # USER controlled entities are EITHER handed the keyboard bindings with app.rebind_all() and always exit by pressing the 'end round' button which calls app.end_round() which calls this function(handle_ent_action) OR (on sanity check fail) handled by Ai_man.handle_berserk_ent_action() in the same manner as a computer controlled entity
    # EXITS on app.handle_eot_effects()
    def handle_action(self):
        app.unbind_all()
        app.active_ent = None
        if self.init_q == []:
            app.unbind_all()
            self.active_ent = None
            app.canvas.delete('active_ent')
            self.handle_vivify()
#             self.handle_eot_effects()
        else:
            id = self.init_q[0]
            self.init_q = self.init_q[1:]
            if id not in app.ent_dict.keys() or app.ent_dict[id].get_inert() == True:
                app.handle_action()
                return
            ent = app.ent_dict[id]
            ent.acts = ent.get_abl('acts')
            ent.mvs = ent.get_abl('mvs')
            if isinstance(ent, Witch):
                ent.smns = ent.get_abl('smns')
            self.get_focus(id)
            self.active_ent = id
            # SANITY CHECK
            sanity = ent.sanity_check()
            if self.num_players == 1 and ent.owner == 'p2':
                if sanity == 'Pass':
                    ent.do_round()
                else:
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(999, lambda t = 'text' : app.canvas.delete(t))
                    app.get_focus(ent.id)
                    root.after(1333, lambda e = ent : Ai_man.handle_berserk_ent_action(e))
            else:
                if sanity == 'Pass':
                    self.rebind_all()
                else:
                    self.unbind_all()
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(999, lambda t = 'text' : app.canvas.delete(t))
                    app.get_focus(ent.id)
                    root.after(1333, lambda e = ent : Ai_man.handle_berserk_ent_action(e))
                    
    # exit on handle_eot_effects
    def handle_vivify(self):
        # handle vivify, both players
        effect1 = mixer.Sound('Sound_Effects/vivify.ogg')
        effect1.set_volume(app.effects_volume.get())
        sound_effects.play(effect1, 0)
        def cleanup_vivify(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        witch = app.ent_dict[app.p1_witch]
        tombs = [v for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == witch.owner]
        def vivify_loop(tombs):
            if tombs == []:
                if app.num_players == 2:
                    witch = app.ent_dict[app.p2_witch]
                    tombs = [v for k,v in app.all_ents().items() if isinstance(v,Tomb) and v.owner == witch.owner]
                    def vivify_loop2(tombs):
                        if tombs == []:
                            root.after(666, self.handle_eot_effects)
                        else:
                            t = tombs[0]
                            tombs = tombs[1:]
                            ents = [v for k,v in app.all_ents().items() if dist(v.loc,t.loc) == 1 and isinstance(v,(Witch,Tomb))==False and v.owner == t.owner]
                            if ents == []:
                                vivify_loop2(tombs)
                            else:
                                app.get_focus(t.id)
                                for e in ents:
                                    u = 'Vivify'+str(app.count)
                                    app.count += 1
                                    amt = t.get_abl('str')
                                    app.vis_dict[u] = Vis(name = 'Vivify', loc = e.loc[:])
                                    app.canvas.create_text(e.loc[0]*100-app.moved_right+49, e.loc[1]*100-app.moved_down+44, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                                    app.canvas.create_text(e.loc[0]*100-app.moved_right+50, e.loc[1]*100-app.moved_down+45, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
                                    app.canvas.create_text(e.loc[0]*100-app.moved_right+49, e.loc[1]*100-app.moved_down+64, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                                    app.canvas.create_text(e.loc[0]*100-app.moved_right+50, e.loc[1]*100-app.moved_down+65, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'lightblue', tags = 'text')
                                    root.after(1222, lambda name = u : cleanup_vivify(name))
                                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                                    apply_heal(t, e, amt)
                                    e.magick += amt
                                    if e.magick > e.base_magick:
                                        e.magick = e.base_magick
                                root.after(1333, lambda tombs = tombs : vivify_loop2(tombs))
                    vivify_loop2(tombs)
                else:
                    root.after(666, self.handle_eot_effects)
            else:
                t = tombs[0]
                tombs = tombs[1:]
                ents = [v for k,v in app.all_ents().items() if dist(v.loc,t.loc) == 1 and isinstance(v,(Witch,Tomb))==False and v.owner == t.owner]
                if ents == []:
                    vivify_loop(tombs)
                else:
                    app.get_focus(t.id)
                    for e in ents:
                        u = 'Vivify'+str(app.count)
                        app.count += 1
                        amt = t.get_abl('str')
                        app.vis_dict[u] = Vis(name = 'Vivify', loc = e.loc[:])
                        app.canvas.create_text(e.loc[0]*100-app.moved_right+49, e.loc[1]*100-app.moved_down+44, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(e.loc[0]*100-app.moved_right+50, e.loc[1]*100-app.moved_down+45, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
                        app.canvas.create_text(e.loc[0]*100-app.moved_right+49, e.loc[1]*100-app.moved_down+64, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(e.loc[0]*100-app.moved_right+50, e.loc[1]*100-app.moved_down+65, text = str(amt), justify = 'center', font = ('chalkduster', 13), fill = 'lightblue', tags = 'text')
                        root.after(1222, lambda name = u : cleanup_vivify(name))
                        root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                        apply_heal(t, e, amt)
                        e.magick += amt
                        if e.magick > e.base_magick:
                            e.magick = e.base_magick
                    root.after(1333, lambda tombs = tombs : vivify_loop(tombs))
        vivify_loop(tombs)
        
    # End of turn effects for each entity and location
    # exit on app.handle_eot_campaign()
    def handle_eot_effects(self):
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4-1, app.canvas.winfo_screenheight()-69, text='End-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'black', tags = 'eot_text')
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4, app.canvas.winfo_screenheight()-70, text='End-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'indianred', tags = 'eot_text')
        efs = [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()] + [v for k,v in app.proximity_effects_dict.items()]
        q = []
        # put efs in init q
        while efs != []:
            ef = efs[0]
            efs = efs[1:]
            if q == []:
                q.append(ef)
            else:
                for i,j in enumerate(q[:]):
                    if ef.ts < j.ts: # SORT BY TIMESTAMP
                        q = q[0:i] + [ef] + q[i:]
                        break
                else:
                    q.append(ef)
        for ef in q:
            if ef.eot_func != None:
                if ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()] + [v for k,v in app.proximity_effects_dict.items()]:# CHECKS IF STILL EXISTS THIS LINE
                    lock(ef.eot_func) # RESOLVE / CALL effects
            # decr ef.dur
            if isinstance(ef, Proximity_Effect):
                continue
            else:
                ef.duration -= 1
                if ef.duration <= 0 and ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]: # MUST CHECK IF STILL EXISTS AGAIN, in case eot removed owner
                    lock(ef.undo_func)
                    # delete Effect from source dict
                    for efct,key,ent in [(j,i,v) for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()]:
                        if efct == ef:
                            del ent.effects_dict[key]
                    for efct,key,loc in [(j,i,k) for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]:
                        if efct == ef:
                            del app.loc_dict[loc].effects_dict[key]
        self.handle_eot_campaign()
        
        
    def handle_eot_campaign(self):
        if app.num_players == 1:
            # LABYRINTH
            if self.map_number == 21:
                # generate revenants based on app.revenant_rate, starts at 2
                total_revs = len([v for v in app.all_ents().values() if isinstance(v,Revenant)])
                if total_revs <= 4:
                    for i in range(min(2, app.revenant_rate//3)):
                        img = ImageTk.PhotoImage(Image.open('summon_imgs/Revenant.png'))
                        # get rand empty sqr
                        sqr = choice([s for s in app.coords if app.grid[s[0]][s[1]] == ''])
                        ent = Revenant(name = 'Revenant', img = img, loc = sqr[:], owner = 'p2')
                        app.ent_dict[ent.id] = ent
                        app.grid[sqr[0]][sqr[1]] = ent.id
            # LIBRARY
            elif self.map_number == 121:
                # get potential spawn sqrs
                sqrs = [s for s in [[22,3],[23,3],[24,3],[22,4],[23,4],[24,4],[22,5],[23,5],[24,5]] if app.grid[s[0]][s[1]] == '']
                if sqrs != []:
                    loc = choice(sqrs)
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Revenant.png'))
                    ent = Revenant(name = 'Revenant', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                ghost = [v for k,v in app.all_ents().items() if v.name == 'Ghost']
                if ghost:
                    ghost = ghost[0]
                if ghost and ghost.spirit < 50 and ghost.retreated_once == False:
                    ghost.retreated_once = True
                    if app.grid[7][2] != '':
                        empt_coords = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
                        sqr = choice(empt_coords)
                    else:
                        sqr = [7,2]
                    oldloc = ghost.loc[:]
                    app.grid[oldloc[0]][oldloc[1]] = ''
                    ghost.loc = sqr[:]
                    app.grid[sqr[0]][sqr[1]] = ghost.id
                    app.canvas.delete(ghost.tags)
                    app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = ghost.img, tags = ghost.tags)
        root.after(1555, lambda t = 'eot_text' : app.canvas.delete(t))
        root.after(1666, self.check_victory_cond)
        
    # takes the current map number, checks game state if ncsry to see if alt route should be taken,
    # returns int of next level map number
    def get_next_level(self, map):
        # trolls and undead knights level, check which knights are dead
        if map == 2:
            knights = [v for k,v in app.all_ents().items() if v.name == 'Undead_Knight']
            if knights == []:# KILLED BOTH LEVEL WARP to ritual circle
                return 4
            elif [v for v in knights if v.doorway == True]:
                return 21
            elif [v for v in knights if v.stairway == True]:
                return 121
        # warlock and dragon levels both lead to sanctum entryway
        elif map == 22 or map == 122:
            return 3
        else:
            return map + 1
    
    # should return 'victory' or None
    def check_victory_conditions(self, map):
        if map == 0:
            all = [k for k,v in self.ent_dict.items() if v.owner == 'p2']
            if all == []:
                return 'victory'
        elif map == 1:
            all = [k for k,v in self.ent_dict.items() if v.owner == 'p2']
            if all == []:
                return 'victory'
        elif map == 2:
            knights = [k for k,v in self.all_ents().items() if v.name == 'Undead_Knight']
            if len(knights) < 2:
                return 'victory'
        elif map == 21:# minotaur
            if app.ghost_dead == True:
                return 'victory'
        elif map == 22:# dragon
            if 'White_Dragon' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 121:# library
            if 'Ghost' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 122:# warlock
            if 'Warlock' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 3:# sanctum entryway
            names = [v.name for k,v in self.all_ents().items()]
            if 'Kensai' not in names and 'Barbarian' not in names and 'Sorceress' not in names:
                return 'victory'
        elif map == 4:# ritual circle
            mages = [v.name for k,v in app.all_ents().items()]
            if 'Earth_Mage' not in mages and 'Air_Mage' not in mages and 'Water_Mage' not in mages and 'Fire_Mage' not in mages and app.mages_placed == True:
                return 'victory'
        
    def check_victory_cond(self):
        if app.num_players == 1:
            if self.check_victory_conditions(self.map_number) == 'victory':
                next_level = self.get_next_level(self.map_number)
#                 lockname = 'victory_lock'+str(app.death_count)
#                 app.death_count += 1
                lock(self.victory_popup, next_level)
            else:
                self.end_turn()
        else:
            self.end_turn()
        
    # reset transient vars... these have changed...
    # exit on app.start_turn()
    def end_turn(self):
        ents = [v for k,v in self.all_ents().items()]
        for ent in ents:
            ent.mvs = ent.get_abl('mvs')
            ent.acts = ent.get_abl('acts')
            if isinstance(ent, Witch):
                ent.smns = ent.get_abl('smns')
#                 ent.entomb_used = False
                ent.spell_entomb_used = False
                ent.summon_entomb_used = False
                ent.magick = 0
                # reset times_cast to 0
                for spell in ent.arcane_dict.values():
                    ent.arcane_dict[spell.name] = Spell(spell.name,spell.func,spell.cost,spell.times_imprint,0)
            if isinstance(ent, Berserker):
                ent.leap_used = False
            if isinstance(ent, Wurdulak):
                ent.shift_form = 1
            if isinstance(ent, Fell_Evolver):
                ent.evolved = False
            if isinstance(ent, Troll):
                ent.regen_this_round = False
            if isinstance(ent, White_Dragon):
                ent.free_fly = False
            if isinstance(ent, Warlock):
                ent.summoned_undead = False
            if isinstance(ent, Sorceress):
                ent.teleport_used = False
            if isinstance(ent, Barbarian):
                ent.leap_used = False
            if isinstance(ent, Water_Mage):
                ent.summoned_elementals = False
                ent.purify_used = False
        app.turn_counter += 1
        self.start_turn()
        # END TURN SEQUENCE
                    
                    
    def center_focus(self, sqr):
        # find 'center'
        # center is around 4,4 4,5 5,5 5,4 UNLESS towards edges of map
        # make best effort to move_curs until sqr is equal to grid_pos AND curs_pos is as close as possible to 4,4...
        # not true... curs_pos must move 'past' the sqr in most cases
        # OPTION 2
        # first, focus_square() as normal, then 'adjust' (move cursor 
        pass
                    
    def get_focus(self, id):
        while grid_pos[0] < self.ent_dict[id].loc[0]:
            self.move_curs(dir = 'Right')
        while grid_pos[0] > self.ent_dict[id].loc[0]:
            self.move_curs(dir = 'Left')
        while grid_pos[1] < self.ent_dict[id].loc[1]:
            self.move_curs(dir = 'Down')
        while grid_pos[1] > self.ent_dict[id].loc[1]:
            self.move_curs(dir = 'Up')
            
    def focus_square(self, s):
        while grid_pos[0] < s[0]:
            self.move_curs(dir = 'Right')
        while grid_pos[0] > s[0]:
            self.move_curs(dir = 'Left')
        while grid_pos[1] < s[1]:
            self.move_curs(dir = 'Down')
        while grid_pos[1] > s[1]:
            self.move_curs(dir = 'Up')
    
    def redraw_colors(self):
        app.canvas.delete('color')
        for ent in app.all_ents().values():
            if ent.owner == 'p1':
                img = app.p1_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
            elif app.num_players == 2:
                img = app.p2_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
            else:
                img = app.enemy_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
    
    def redraw_effects_text(self):
        app.canvas.delete('effects_text')
        for ent in self.ent_dict.values():
            efs = [v for v in ent.effects_dict.values()]
            starty = 5
            for ef in efs[0:5]:
                self.canvas.create_text(ent.loc[0]*100+4-self.moved_right, ent.loc[1]*100+starty-1-self.moved_down, text=ef.name.replace('_',' ')[0:9]+'...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'black', tags = 'effects_text')
                self.canvas.create_text(ent.loc[0]*100+5-self.moved_right, ent.loc[1]*100+starty-self.moved_down, text=ef.name.replace('_',' ')[0:9]+'...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'gray66', tags = 'effects_text')
                starty += 10
            if len(efs) > 5:
                self.canvas.create_text(ent.loc[0]*100+4-self.moved_right, ent.loc[1]*100+starty-1-self.moved_down, text='...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'black', tags = 'effects_text')
                self.canvas.create_text(ent.loc[0]*100+5-self.moved_right, ent.loc[1]*100+starty-self.moved_down, text='...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'gray66', tags = 'effects_text')
        
        
    def animate(self):
        global selected, selected_vis
#         app.canvas.delete('color')
        self.redraw_colors()
        self.redraw_effects_text()
        # ENTS
        for ent in self.ent_dict.values():
            if ent.id not in selected:
                ent.rotate_image()
                self.canvas.delete(ent.id)
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = ent.img, tags = ent.tags)
                app.canvas.tag_lower((ent.tags), 'maptop')
                for k,ef in ent.effects_dict.items():
                    if ef.vis != None:
                        ef.vis.rotate_image()
                        self.canvas.delete(ef.vis.tags)
                        self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = ef.vis.img, tags = ef.vis.tags)
                        app.canvas.tag_lower((ef.vis.tags), 'maptop')
        # SQRS
        for sqr in self.sqr_dict.keys():
            self.sqr_dict[sqr].rotate_image()
            self.canvas.delete(sqr)
            self.canvas.create_image(self.sqr_dict[sqr].loc[0]*100+50-self.moved_right, self.sqr_dict[sqr].loc[1]*100+50-self.moved_down, image = self.sqr_dict[sqr].img, tags = sqr)
        try: app.canvas.tag_raise('large')
        except: pass
#         app.canvas.tag_raise('maptop')
        app.canvas.tag_raise('cursor')
        # VISUALS
        for vis in self.vis_dict.keys():
            if vis not in selected_vis:
                self.vis_dict[vis].rotate_image()
                self.canvas.delete(vis)
                if vis == 'cursor':
                    self.canvas.create_image(self.vis_dict[vis].loc[0]*100+50, self.vis_dict[vis].loc[1]*100+50, image = self.vis_dict[vis].img, tags = vis)
                else:
                    self.canvas.create_image(self.vis_dict[vis].loc[0]*100+50-self.moved_right, self.vis_dict[vis].loc[1]*100+50-self.moved_down, image = self.vis_dict[vis].img, tags = vis)
                app.canvas.tag_raise(vis)
        # PROX
        app.canvas.delete('proximity_effects')
        for k,prx in self.proximity_effects_dict.items():
            if k not in selected_vis:
                prx.rotate_image()
                self.canvas.delete(k)
                for sqr in prx.get_locs():
                    self.canvas.create_image(sqr[0]*100+50-self.moved_right, sqr[1]*100+50-self.moved_down, image = prx.img, tags = (k, 'proximity_effects'))
        try: # LOWER THE CURSOR BELOW MOVING ANIMATIONS (VIS)
            app.canvas.tag_lower(('cursor'), (selected_vis))
        except: pass
        try: app.canvas.tag_raise('text')
        except: pass
        # INIT QUEUE
        self.canvas.delete('init_ents')
        if self.init_q != []:
            self.canvas.delete('init_q')
            txt = ''
            for id in self.init_q:
                ent = [v for k,v in app.ent_dict.items() if v.id == id]
                if ent:
                    ent = ent[0]# delist
                    if isinstance(ent, Witch):
                        txt += ent.id.replace('_',' ') + ' '
                    else:
                        txt += ent.name.replace('_',' ') +'-'+ ent.id + ' '
            self.canvas.create_text(14, 14, text='Initiative Queue: ', anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'black', tags = 'init_q')
            self.canvas.create_text(15, 15, text='Initiative Queue: ', anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'indianred', tags = 'init_q')
            self.canvas.create_text(174, 14, text= txt, anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'black', tags = 'init_ents')
            self.canvas.create_text(175, 15, text= txt, anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'indianred', tags = 'init_ents')
        # Show Name, Active Ent
        self.redraw_active_ent()
        # MINI MAP
        self.redraw_minimap()
        self.animate_id = root.after(200, self.animate)
        
    def redraw_minimap(self):
        self.canvas.delete('minimap')
        self.canvas.create_image(100,self.canvas.winfo_height()-100, anchor='sw', image =self.minimap, tags = 'minimap')
        col = self.map_width//100
        row = self.map_height//100
        startx = 100
        starty = self.canvas.winfo_height()-self.minimap.height()-90
        ticx = app.map_width//col
        ticy = app.map_height//row
        incrx = 0
        incry = 0
        for x in range(col):
            for y in range(row):
                if app.grid[x][y] in app.all_ents().keys():
                    ent = app.ent_dict[app.grid[x][y]]
                    if ent.owner == 'p1':
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image = app.p1_minimap_img, tags = 'minimap')
                    elif app.num_players == 2:
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image = app.p2_minimap_img, tags = 'minimap')
                    else:
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image =app.bot_minimap_img, tags = 'minimap')
#                 elif app.grid[x][y] == 'block':
#                         self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image =self.block_minimap_img, tags = 'minimap')
                incry += 10
            incrx += 10
            incry = 0
        # redraw minimap screen
        down = app.moved_down//10
        right = app.moved_right//10
        self.canvas.create_image(100+right-5,self.canvas.winfo_height()-20-self.minimap.height()+down, anchor='sw', image =self.minimap_screen, tags = 'minimap')

    def victory_popup_duel(self, winner, loser, draw = None, lockname = None):
        def end():
            self.close_btn.destroy()
            self.canvas.delete('victory_text')
            app.dethloks[lockname].set(1)
            self.reset()
        if draw == True:
            vic_text = 'Draw'
        else:
            vic_text = winner.replace('_',' ')+' is the victor'
        self.canvas.create_text(399, root.winfo_screenheight()//2-1, text = vic_text, font = ('chalkduster', 38), fill = 'black', tags = 'victory_text')
        self.canvas.create_text(400, root.winfo_screenheight()//2, text = vic_text, font = ('chalkduster', 38), fill = 'indianred', tags = 'victory_text')
        p = partial(end)
        self.close_btn = tk.Button(self.canvas, text = 'OK', font = ('chalkduster', 22), highlightbackground='black', fg='tan3', command = p)
        self.canvas.create_window(root.winfo_screenwidth()//2-150, self.canvas.winfo_screenheight()//2+150, window = self.close_btn)
        
    
    def victory_popup(self, next_level = None, lockname = None):
        def end():
            self.close_btn.destroy()
            self.canvas.delete('victory_text')
            app.dethloks[lockname].set(1)
            self.end_level(next_level = next_level)
        vic_text = '''
        Victory Achieved, for now...
        '''
        self.canvas.create_text(399, root.winfo_screenheight()//2-1, text = vic_text, font = ('chalkduster', 38), fill = 'black', tags = 'victory_text')
        self.canvas.create_text(400, root.winfo_screenheight()//2, text = vic_text, font = ('chalkduster', 38), fill = 'indianred', tags = 'victory_text')
        p = partial(end)
        self.close_btn = tk.Button(self.canvas, text = 'OK', font = ('chalkduster', 22), highlightbackground='black', fg='tan3', command = p)
        self.canvas.create_window(root.winfo_screenwidth()//2-150, self.canvas.winfo_screenheight()//2+150, window = self.close_btn)
        
        
    def map_trigger_loop(self):
        for mt in self.map_triggers:
            result = mt()
        self.map_trigger_id = root.after(1666, self.map_trigger_loop)
        
    def end_level(self, next_level = None):
        global curs_pos, selected, selected_vis, map_pos, grid_pos
#         self.canvas.destroy()
        root.after_cancel(self.animate_id)
        root.after_cancel(self.map_trigger_id)
        # for each effect in witch and global, call its undo
        protaganist_object  = app.ent_dict[self.p1_witch]
        protaganist_object.reset_transient_vars()
        prev_map_num = int(self.map[3:])
        new_map_num = next_level
        for child in root.winfo_children():
            if child._name != '!app':
                child.destroy()
        # THIS WORKS, JUST NEED TO CLEAN ALL VARS LIKE GRID, SELF.STUFF, GLOBALS
        # GLOBALS
        curs_pos = [0, 0]
        selected = []
        selected_vis = []
        map_pos = [0, 0]
        grid_pos = [0,0]
        self.ent_dict = {}
        self.sqr_dict = {}
        self.vis_dict = {}
        self.loc_dict = {}
        self.image_holder = []
        self.map_triggers = []
        self.active_player = 'p1'
        self.moved_right = 0
        self.moved_down = 0
        self.context_buttons = []
        self.help_buttons = []
        self.turn_counter = 0
        self.count = 0 # used for uniquely naming Effects with the same prefix/name
        self.death_count = 0
        self.dethloks = {}
        self.cycle_q = []
        self.enemy_cycle_q = []
        self.current_ent = ''
        self.active_ent = None
        # CALL IN-BETWEEN LEVEL SCREEN / VICTORY SCREEN
        # GIVE ANY STORYLINE RELATED TO FINISHED AND NEXT LEVEL
        # GIVE OPTION TO SAVE PROGRESS
        # WILL NEED, AT SOME POINT, TO SAVE ACTUAL WITCH OBJECT (NOT JUST STRING NAME), TO HOLD PERSISTENT CHANGES
        self.load_cutscene(prev_map_num, new_map_num, protaganist_object)
        
        
    def load_cutscene(self, prev_map_num, new_map_num, protaganist_object):
        # Make cutscene using background pictures and overlay unit models
        self.cut_scene = ImageTk.PhotoImage(Image.open('cut_scenes/cut_scene'+str(prev_map_num)+'.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.cut_canvas = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.cut_canvas.create_image(0,0, image =self.cut_scene, anchor = 'nw')
        self.cut_canvas.pack(side = 'top')
        filename = 'cut_scene_texts/cut_scene_text'+str(prev_map_num)+'.txt'
        with open(filename) as f:
            text = f.read()
            
        self.bd_img = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-180, root.winfo_screenheight()//3-11)))
        self.cut_canvas.create_image(root.winfo_screenwidth()//2, root.winfo_screenheight()-192, anchor='s', image =self.bd_img)
        self.frame = tk.Frame(root)#, width = root.winfo_screenwidth()-180, height = root.winfo_screenheight()//4)
        self.sb = tk.Scrollbar(self.frame)
        self.cut_text = tk.Text(self.frame, height = 7, width = 118, wrap = 'word', bg = 'black', relief = 'raised', highlightthickness = 0, borderwidth = 0, fg = 'indianred', font = ('kokonor', 16))
        self.cut_text.insert('end', text)
        self.cut_text.configure(state = 'disabled')
        
        self.cut_canvas.create_window(root.winfo_screenwidth()//2, root.winfo_screenheight()-320, window = self.frame)
        self.cut_text.pack(side = 'left')
        self.sb.pack(side = 'right', fill = 'y')
        self.cut_text.configure(yscrollcommand = self.sb.set)
        self.sb.config(command = self.cut_text.yview)
        # CONT OR SAVE BUTTONS        
        self.next_area_button = tk.Button(root, text = 'Next Area', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = new_map_num, po = protaganist_object : self.next_area(n,po))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2-100, root.winfo_screenheight()-80, anchor='s', window = self.next_area_button)
        self.save_game_button = tk.Button(root, text = 'Save Game', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = new_map_num, po = protaganist_object : self.save_game(n, po))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-80, anchor='s', window = self.save_game_button)
        
    def next_area(self, new_map_num, protaganist_object):
        self.cut_canvas.destroy()
        # LOAD NEXT MAP
        self.load_map_triggers(new_map_num, protaganist_object = protaganist_object)
        
    def save_game(self, new_map_num, protaganist_object):
        protaganist_object.current_area = new_map_num
        # make text input, put in cut_canvas with create_window
        self.save_game_button.destroy()
        text_var = tk.StringVar()
        text_var.set('filename')
        entry = tk.Entry(root, textvariable = text_var, font = ('chalkduster', 15), highlightbackground = 'black')
        save_b = tk.Button(root, text = 'Save', font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'black', command = lambda t = text_var, p = protaganist_object : self.do_save(t, p))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-45, anchor='s', window = save_b)
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-80, anchor='s', window = entry)
        
        
        # change from using pickle dump to write to text file, on load decode the written gibberish (make it gibberish in stored form)
    def do_save(self, text_var, protag_obj):
        fname = text_var.get()
        saves = [s for r,d,s in walk('./save_games')][0]
        saves = [s for s in saves[:] if s[0] != '.']
        if fname in saves:
            text_var.set('filename already exists')
            return
        with open('save_games/'+fname, 'w+') as f:
            text_var.set('game saved')
            # strip attrs, write all spell names to file
            f.write(str(protag_obj.name)+'\n')
            f.write(str(protag_obj.level)+'\n')
            f.write(str(list(protag_obj.arcane_dict.keys()))+'\n')
            f.write(str(protag_obj.summon_cap)+'\n')
            f.write(str(protag_obj.str)+'\n')
            f.write(str(protag_obj.agl)+'\n')
            f.write(str(protag_obj.end)+'\n')
            f.write(str(protag_obj.mm)+'\n')
            f.write(str(protag_obj.msl)+'\n')
            f.write(str(protag_obj.bls)+'\n')
            f.write(str(protag_obj.dodge)+'\n')
            f.write(str(protag_obj.psyche)+'\n')
            f.write(str(protag_obj.rsn)+'\n')
            f.write(str(protag_obj.wis)+'\n')
            f.write(str(protag_obj.san)+'\n')
            f.write(str(protag_obj.init)+'\n')
            f.write(str(protag_obj.base_acts)+'\n')
            f.write(str(protag_obj.base_mvs)+'\n')
            f.write(str(protag_obj.base_smns)+'\n')
            f.write(str(protag_obj.base_spirit)+'\n')
            f.write(str(protag_obj.move_range)+'\n')
            f.write(str(protag_obj.current_area)+'\n')
            f.write(str(protag_obj.entomb_deck)+'\n')
    
    
    def populate_context(self, event):
        e = self.current_pos()
        if e == '' or e == 'block':
            return
        if e != app.current_ent:
            app.depop_context(event = None)
        elif self.context_buttons != []:
            return
        self.repop_help_buttons()
        expanded_name = self.ent_dict[e].name.replace('_',' ')
        # DEBUG make info button into label that holds the info
        self.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png').resize((190,363)))
        bg = tk.Canvas(self.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = self.cntxt_info_bg, anchor = 'nw')
#         bg.create_text(14, 7, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'ghostwhite')
#         bg.create_text(16, 9, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'ghostwhite')
#         bg.create_text(15, 8, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'gray30')
        text = expanded_name+'\n'
        text +=  self.get_info_text(e)
        bg.create_text(14, 7, text=text, width = 180, anchor = 'nw', font = ('chalkduster', 13), fill = 'ghostwhite')
        bg.create_text(16, 9, text=text, width = 180, anchor = 'nw', font = ('chalkduster', 13), fill = 'ghostwhite')
        bg.create_text(15, 8, text=text, width = 180, anchor = 'nw', font = ('chalkduster', 13), fill = 'gray30')
        # create 'info' button as last element
        if e != self.active_ent:
            txt3 = self.get_more_info(e)
            more_info_button = tk.Button(self.context_menu, text = 'More Info', font = ('chalkduster', 16), fg='indianred', highlightbackground = 'tan3', command = lambda t = txt3 : self.more_info(t))
            more_info_button.pack(side = 'top')
            self.context_buttons.append(more_info_button)
            root.bind('<i>', lambda e, t = txt3 : self.more_info(t))
        self.context_buttons.append(bg)
        if e == self.active_ent:
            tup_list = list(self.ent_dict[e].get_actions().items())
            self.page_actions(tup_list = tup_list, index = 0)
            
    def page_actions(self, event = None, tup_list = None, index = None):
        app.unbind_numerical_hotkeys()
        # destroy old buttons
        for b in self.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        self.repop_help_buttons()
        if index == 0:
            txt3 = self.get_more_info(self.active_ent)
            more_info_button = tk.Button(self.context_menu, text = 'More Info', font = ('chalkduster', 16), fg='indianred', highlightbackground = 'tan3', command = lambda t = txt3 : self.more_info(t))
            more_info_button.pack(side = 'top')
            self.context_buttons.append(more_info_button)
            root.bind('<i>', lambda e, t = txt3 : self.more_info(t))
        for i, name_action in enumerate(tup_list[index:index+5]):
            name = name_action[0].replace('_', ' ')
            action = name_action[1]
#             def wrapper(event = None, func = None):
#                 func()
#                 app.exists_check(app.active_ent)
#             action = partial(wrapper, func = action)
            i += 1
            root.bind(str(i), action)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name, font = ('chalkduster', 18), fg='tan3', highlightbackground = 'tan3', command = action)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = 'W : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-5 : self.page_actions(tup_list = t, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind('<w>', lambda e, t = tup_list, i = index-5 : self.page_actions(tup_list = t, index = i))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+5]):
            b3 = tk.Button(app.context_menu, text = 'E : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+5 : self.page_actions(tup_list = t, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind('<e>', lambda e, t = tup_list, i = index+5 : self.page_actions(tup_list = t, index = i))
        
    def depop_context(self, event):
        # unbind any potential numeric keys bound to relative actions
        try:
            for x in range(1, 10):
                root.unbind(str(x))
        except: pass
        for b in self.context_buttons:
            b.destroy()
        self.context_buttons = []
        root.unbind('<p>')
    
    
    def move_curs(self, event = None, dir = None):
        global map_pos, grid_pos, curs_pos
        # need to either unbind arrows, or unbind as much as possible during execution without becoming rebound on ai turn
        if event == None:
            event = Dummy()
            event.keysym = None
        frame_width = self.canvas.winfo_width()
        frame_height = self.canvas.winfo_height()
        # map_pos is how much map has moved [x,y]
        # curs_pos is relative to screen (stays within around [0,0] to [9,6] relative to screen size
        # grid_pos is always absolute position of grid where cursor appears (relates to app.grid)
        if event.keysym == 'Left' or dir == 'Left':
            if curs_pos[0] > 1: # leftmost possible cursor position
                curs_pos[0] -= 1
                grid_pos[0] -= 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[0] > 0 : # leftmost possible map position, always zero
                map_pos[0] -= 1
                self.move_map('Left')
                grid_pos[0] -= 1
        elif event.keysym == 'Right' or dir == 'Right':
            if grid_pos[0] == ((self.map_width//100) - 1):
                return
            if curs_pos[0] < ((frame_width//100)-1):
                curs_pos[0] += 1
                grid_pos[0] += 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[0] < ((self.map_width//100)-(frame_width//100)-1):
                self.move_map('Right')
                map_pos[0] += 1
                grid_pos[0] += 1
        elif event.keysym == 'Up' or dir == 'Up':
            if curs_pos[1] > 1: # topmost
                curs_pos[1] -= 1
                grid_pos[1] -= 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[1] > 0: # topmost, always zero
                self.move_map('Down')
                map_pos[1] -= 1
                grid_pos[1] -= 1
        elif event.keysym == 'Down' or dir == 'Down':
            if grid_pos[1] == ((self.map_height//100)-1):
                return
            if curs_pos[1] < ((frame_height//100)-1):
                curs_pos[1] += 1
                grid_pos[1] += 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[1] < ((self.map_height//100)-(frame_height//100)-0):
                self.move_map('Up')
                map_pos[1] += 1
                grid_pos[1] += 1

    def redraw_active_ent(self):
        if self.active_ent:
            self.canvas.delete('active_ent')
            loc = app.ent_dict[self.active_ent].loc
            self.canvas.create_text(loc[0]*100+49-self.moved_right, loc[1]*100+99-self.moved_down, text=self.ent_dict[self.active_ent].name.replace('_',' '), font = ('chalkduster', 13), fill = 'black', tags = 'active_ent')
            self.canvas.create_text(loc[0]*100+50-self.moved_right, loc[1]*100+100-self.moved_down, text=self.ent_dict[self.active_ent].name.replace('_',' '), font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'active_ent')
        
        
    def move_map(self, direction):
        tmp = self.ent_dict.keys()
        ents = [x for x in tmp if x not in selected]
        pers_vis = [y for y in self.vis_dict.keys() if y not in selected_vis]
        prxs = [k for k in self.proximity_effects_dict.keys() if k not in selected_vis]
        if direction == 'Left':
            self.canvas.move('map', 100, 0)
            self.moved_right -= 100
            for ent in ents:
                for k,v in app.ent_dict[ent].effects_dict.items():
                    if v.vis != None:
                        self.canvas.move(v.vis.tags, 100, 0)
                self.canvas.move(ent, 100, 0)
            for vis in pers_vis:
                self.canvas.move(vis, 100, 0)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 100, 0)
            for prx in prxs:
                self.canvas.move(prx, 100, 0)
        elif direction == 'Right':
            self.canvas.move('map', -100, 0)
            self.moved_right += 100
            for ent in ents:
                for k,v in app.ent_dict[ent].effects_dict.items():
                    if v.vis != None:
                        self.canvas.move(v.vis.tags, -100, 0)
                self.canvas.move(ent, -100, 0)
            for vis in pers_vis:
                self.canvas.move(vis, -100, 0)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, -100, 0)
            for prx in prxs:
                self.canvas.move(prx, -100, 0)
        elif direction == 'Up':
            self.canvas.move('map', 0, -100)
            self.moved_down += 100
            for ent in ents:
                for k,v in app.ent_dict[ent].effects_dict.items():
                    if v.vis != None:
                        self.canvas.move(v.vis.tags, 0, -100)
                self.canvas.move(ent, 0, -100)
            for vis in pers_vis:
                self.canvas.move(vis, 0,-100)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 0, -100)
            for prx in prxs:
                self.canvas.move(prx, 0, -100)
        elif direction == 'Down':
            self.canvas.move('map', 0, 100)
            self.moved_down -= 100
            for ent in ents:
                self.canvas.move(ent, 0, 100)
                for k,v in app.ent_dict[ent].effects_dict.items():
                    if v.vis != None:
                        self.canvas.move(v.vis.tags, 0, 100)
            for vis in pers_vis:
                self.canvas.move(vis, 0, 100)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 0, 100)
            for prx in prxs:
                self.canvas.move(prx, 0, 100)
        self.redraw_active_ent()
        self.redraw_colors()
        self.redraw_effects_text()
        
        
    def game_options(self):
        self.options_popup = tk.Toplevel(bg = 'black')
        self.options_popup.minsize(400, 400)
        self.options_popup.grab_set()
        self.options_popup.attributes('-topmost', 'true')
        def on_close():
            pass
        self.options_popup.protocol('WM_DELETE_WINDOW', on_close)
        def update_music_volume(event = None):
            background_music.set_volume(app.music_volume.get())
        p = partial(update_music_volume)
        # BGROUND MUSIC VOLUME
        self.volume_scale = tk.Scale(self.options_popup, command=p, tickinterval=0.1, resolution=0.1, from_=0.0, to=2.0, bg='black', relief='sunken', borderwidth=3, variable=app.music_volume, label='Music Volume', fg='indianred', font=('kokonor',13), orient='horizontal')
        self.volume_scale.pack(side='top', fill='x', expand='y')
        # EFFECTS VOLUME
        self.effects_scale = tk.Scale(self.options_popup, tickinterval=0.1, resolution=0.1, from_=0.0, to=2.0, bg='black', relief='sunken', borderwidth=3, variable=app.effects_volume, label='Effects Volume', fg='indianred', font=('kokonor',13), orient='horizontal')
        self.effects_scale.pack(side='top', fill='x', expand='y')
        self.close = tk.Button(self.options_popup, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.options_popup : self.destroy_release(win))
        self.close.pack()
        # on change of variable need to change curently running music
        
        
    def help(self):
        self.help_popup = tk.Toplevel(bg = 'black')
        sb = tk.Scrollbar(self.help_popup)
        self.help_popup.grab_set()
        self.help_popup.attributes('-topmost', 'true')
#         self.help_popup.config(resize = False)
#         self.help_popup.geometry(root.winfo_screenwidth(), root.winfo_screenheight())
        def on_close():
            pass
        self.help_popup.protocol('WM_DELETE_WINDOW', on_close)
        help_text = '''
        R-click on Spell or Action buttons to see descriptions. 
        L-click on map to move cursor. 
        Arrow keys move cursor around map. 
        Press 'a' when cursor is over a unit to see info and available actions if it is 'active' (during its round in the turn).
        Effects from spells or actions may happen during the end/start-of-turn. 
        'q' is the generic cancel for most actions/selections.
        'i' is the hotkey for the 'more info' button.
        'p' is the hotkey for 'end round'. (press 'p' again to confirm 'end round')
        ',' and 'l' cycle cursor over friendly units. 
        '.' and ';' cycle cursor over enemy units. 
        The order of rounds is determined by the initiative-queue, which is displayed at the top of the screen, showing the order of units to act in this turn. The ordering happens before applying start-of-turn effects and is determined by 'initiative' ability (ties broken with 'agility', those ties broken with 'dodge', those ties randomly ordered).
        Tombs created by the Entomb ability produce magick and allow for the casting of their imprinted arcane spell.
        Arcane spells may be cast by spending magick (generated every turn) as long as the spell is imprinted.
        You may cast an arcane spell for as many times as it is imprinted, and can afford with magick.
        You may place one summon each round. It will be placed in the initiative queue next turn.
        Actions/arcane spells EITHER target as ACTIONS (and cannot target units with INVISIBILITY) OR as SPELLS (and cannot target units with PSYSHIELD).
        Some actions/spells do not target at all.
        Every unit makes a 'sanity check' before its round. A fail makes it move randomly and attempt melee attacks (using agility vs agility to-hit, and strength vs endurance damage) using the number of moves and actions available to it. A sanity check generates a random number between 0-100. If this value is higher than the unit's sanity times ten, it fails. So once sanity abilities start falling below 10, units will randomly go berserk.
        Effects applied to units are resolved in the order of 'most recent first' or 'last in, first out' AND in 'batches'.
        There are only 3 'batches' of effects: Local, Proximity, and Map; with each batch resolved 'most recent first'.
        When looking up an ability score of any unit, all Local effects are applied, then all Proximity, and finally all Map Effects. So if a unit has an older Local effect that removes all instances of 'invisibility' from its types, and it occupies a location with a Map effect (even if it is an older effect) that adds 'invisibility', then that unit will have 'invisibility' when its types are retrieved. Conversely, A unit with an older Local effect that adds 'invisibility' will have it removed when applying a newer Local effect that does so.
        Effects that are not noted as Proximity or Map are considered Local (they exist on a unit that they effect).
        Proximity effects exist on a unit, and may effect it, and also may affect other units within some distance.
        
        Ability Scores:
        *NOTE* The use of abilities is determined by the specific action/spell being used, which will always declare (in its right-click description) WHICH specific abilities are used in any to-hit, damage, save, dispel checks, etc. Abilities do have a tendency to be used by certain kinds of actions. For example, ranged attacks will often compare marksmanship vs dodge to-hit, missle vs endurance for damage, and ballistics for range/distance. In contrast, a spell-action (costing magick points) that causes damage will often use wisdom vs wisdom to-hit, psyche vs psyche for damage, reason for range. A spell/action that grants an effect often uses reason for determining the duration of the effect and wisdom for the 'level' (affects dispel/removal attempts).***
        Strength: used mostly for damage from melee actions
        Agility: mostly to-hit/miss melee actions
        Endurance: mostly used for resisting damage from physical(slashing, crushing, piercing) actions
        Marksmanship: to-hit chance, ranged, physical actions
        Missle: damage from physical(mostly piercing type) ranged actions
        Ballistics: range from physical actions
        Dodge: avoid ranged physical actions
        Psyche: damage dealt/resisted from non-phys actions/spells (usually magick type)
        Wisdom: to-hit/miss for mostly spell-based actions, also used for determining the 'level' of an effect granted
        Reason: range and duration for many spells/effects.
        Sanity: mostly just for sanity checks
        Initiative: mostly order of round performance
        The 'to hit' (chance to affect with an action/spell) formula compares one ability to another (noted by the specific action/ability). Percentage chance to hit = ((attacker ability minus defender ability) times ten) plus 50. For example, an attacker's agility score of 5 compared to a defender's agility 5 is a fifty percent chance to hit.
        Effects can be dispelled with some modifier (usually provided by some ability score of the dispelling unit). A dispel is an attempt to remove the effect, the success of which depends on the level of the effect, usually the caster's wisdom score (higher level effects are harder to dispel). The dispel formula is random-value-between-neg1-and-101 compared to spell-level minus modifier times 10. 
        Save-checks are implemented similarly except they only use one ability score times 10 (plus 50).
        Damage happens to the units 'spirit' ability and function like hit-points/health.
        The damage formula (similar to to-hit) compares some ability score against another (usually a value of the attacker compared to a value of the defender). The BASE VALUE for DAMAGE when ability scores are equal is SIX. For example, if the strength value 6 of the attacker is compared to the endurance value 6 of the defender, the damage is 6.
        Multiple effects can be applied to abilities like strength, agility, etc and also move range. Multiple changes of abilities caused by effects are resolved in the order in which they were applied (the most recently added effect is resolved last).
        '''
#         self.text = tk.List(self.help_popup, yscrollcommand = sb.set, text = help_text, wraplength = 750, font = ('chalkduster', 20), fg='indianred', bg = 'black')
        self.text = tk.Text(self.help_popup, yscrollcommand = sb.set, wrap = 'word', bg = 'black', fg = 'tan3', font = ('chalkduster', 20))
        self.text.insert('end', help_text)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(self.help_popup, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.help_popup : self.destroy_release(win))
        self.close.pack()
        self.text.pack()
        sb.pack(side = 'right', fill = 'y')
        sb.config(command = self.text.yview)
        
    def map_effect_info(self, event = None):
        # get location from cursor loc
        loc = grid_pos[:]
        # get effects from app.loc_dict
        efs = app.loc_dict[tuple(loc)].effects_dict.items()
        txt = ''
        txt += 'Location: '+str(loc)+'\n'
        txt += 'Effects:' +'\n'
        for k,ef in efs:
            txt += '  '+ef.name.replace('_',' ')+': '+loc_effect_description(ef)+'\n'
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', wrap = 'word', relief = 'sunken', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))

    def more_info(self, txt):
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', highlightthickness = 0, relief = 'sunken', wrap = 'word', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))
        
        
    def get_info_text(self, ent):
        ent = app.ent_dict[ent]
        txt = ''
        txt += 'Strength: ' + str(ent.get_abl('str')) +'/'+str(ent.str)+ '\n'
        txt += 'Agility: ' + str(ent.get_abl('agl'))  +'/'+str(ent.agl)+ '\n'
        txt += 'Endurance: ' + str(ent.get_abl('end'))  +'/'+str(ent.end)+ '\n'
        txt += 'Marksmanship: ' + str(ent.get_abl('mm'))  +'/'+str(ent.mm)+ '\n'
        txt += 'Missle: ' + str(ent.get_abl('msl'))  +'/'+str(ent.msl)+ '\n'
        txt += 'Ballistics: ' + str(ent.get_abl('bls'))  +'/'+str(ent.bls)+ '\n'
        txt += 'Dodge: ' + str(ent.get_abl('dodge'))  +'/'+str(ent.dodge)+ '\n'
        txt += 'Psyche: ' + str(ent.get_abl('psyche'))  +'/'+str(ent.psyche)+ '\n'
        txt += 'Wisdom: ' + str(ent.get_abl('wis'))  +'/'+str(ent.wis)+ '\n'
        txt += 'Reason: ' + str(ent.get_abl('rsn'))  +'/'+str(ent.rsn)+ '\n'
        txt += 'Sanity: ' + str(ent.get_abl('san'))  +'/'+str(ent.san)+ '\n'
        txt += 'Initiative: ' + str(ent.get_abl('init'))  +'/'+str(ent.init)+ '\n'
        txt += 'Move Range: ' + str(ent.get_abl('move_range'))  +'/'+str(ent.move_range)+ '\n'
        txt += 'Moves: ' + str(max(0,ent.mvs))+'/'+str(max(0,ent.get_abl('mvs')))  + '\n'
        txt += 'Actions: ' + str(max(0,ent.acts))+'/'+str(max(0,ent.get_abl('acts')))  + '\n'
        if isinstance(ent, Tomb):
            txt += 'Imprint: '+ent.imprint.replace('_',' ')+'\n'
        if isinstance(ent, Witch):
#             txt += 'Cantrips: ' + str(max(0,ent.cantrips))+'/'+str(ent.get_abl('cantrips')) + '\n'
            txt += 'Summon Cap: ' + str(ent.summon_count) + '/' + str(ent.summon_cap) + '\n'
            txt += 'Magick: ' + str(ent.magick) + '\n'
            txt += 'In Hand: ' + str(len(ent.in_hand)) + '\n'
        elif isinstance(ent,(Pyrrhic_Gnome)):
            txt += 'Tick : '+str(ent.tick)+'\n'
        else:
            txt += 'Magick: ' + str(ent.magick) + '/' + str(ent.base_magick) + '\n'
        txt += 'Spirit: ' + str(ent.spirit) + '/' + str(ent.base_spirit)
        return txt
        
    def get_more_info(self, ent):
        txt = ''
        ent = app.ent_dict[ent]
        if isinstance(ent, Witch):
            txt += 'Name: '+ent.id.replace('_',' ') + '\n'
            txt += 'Magick Regen: '+str(ent.magick_regen)+'\n' 
            txt += 'Library Remains: '+str(len(ent.library))+'\n'
            txt += 'Summon Cap: ' + str(ent.summon_cap) + '\n'
            txt += 'In Hand : ' + str(', '.join(ent.in_hand)) + '\n'
            txt += 'Discard : '+ str(', '.join(ent.discard))+'\n'
            txt += 'Exile : '+ str(', '.join(ent.exile))+'\n'
        else:
            txt += 'Name: '+ent.name.replace('_',' ') + '\n'
            txt += 'ID: ' +ent.id.replace('_',' ') + '\n'
        if ent.info_text != None:
            txt += ent.info_text + '\n'
        if isinstance(ent, Warlock):
            txt += 'Warlock is immune to all effects that alter abilities, including acts and moves.' + '\n'
        if isinstance(ent, Earth_Mage):
            txt += 'Earth Mage gets +1 to abls, besides acts and moves, for each Earth Elemental that exists.' + '\n'
            txt += 'Earthquake can still be cast even if removed from actions.' + '\n'
        txt += 'Move type: ' + ent.get_move_type() + '\n'
        # actions/atks
        txt += 'Actions:'+'\n'
        for a in ent.get_actions().keys():
            txt += '  '+a +': '+ action_description(a) +'\n'
        # types
        txt += 'Types:'+'\n'
        tmp = []
        for t in ent.get_types():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        # resist, wkns
        txt += 'Resist:'+'\n'
        tmp = []
        for t in ent.get_resist():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        txt += 'Weak:'+'\n'
        tmp = []
        for t in ent.get_weak():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        # effects
        txt += 'Effects:'+'\n'
        for ef,v in ent.effects_dict.items():
            txt += '  '+v.name.replace('_',' ') +': '+effect_description(v) +'\n'
        # death triggers...
        txt += 'Death Triggers:'+'\n'
        for dt in ent.death_triggers:
            txt += '  '+ dt.name.replace('_',' ') +': '+death_trigger_description(dt.name)+'\n'
        # INERT
        txt += 'Inert :'+str(ent.get_inert())+'\n'
        return txt

                 
    def confirm_end(self, event = None):
        self.unbind_all()
        self.depop_context(event = None)
        l = tk.Label(self.context_menu, text = 'End Round?', fg = 'indianred', bg = 'black', wraplength = 190, relief = 'raised', font = ('chalkduster', 22))
        self.context_buttons.append(l)
        root.bind('<p>', self.end_round)
        b1 = tk.Button(self.context_menu, text = 'END', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.end_round)
        b1.pack(side = 'bottom')
        self.context_buttons.append(b1)
        b2 = tk.Button(self.context_menu, text = 'Cancel', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.cancel_end_round)
        b2.pack(side = 'bottom')
        self.context_buttons.append(b2)
        l.pack(side = 'bottom')
        root.bind('<q>', lambda e : self.cancel_end_round())
        
    def end_round(self, event = None):
        app.unbind_all()
        self.depop_context(event = None)
        app.handle_action()
        
        
    def cancel_end_round(self):
        self.rebind_all()
        self.depop_context(event = None)
        
        
        # kokonor
    def show_avatar_info(self, witch):
        self.info_popup = tk.Toplevel()
        self.info_popup.grab_set()
        self.info_popup.attributes('-topmost', 'true')
        self.info_popup.title(witch)
        text = open('avatar_info/' + witch + '.txt', 'r').read()
        f = tk.Frame(self.info_popup, bg = 'black')
        f.pack()
        l = tk.Label(f, text = text, wraplength = root.winfo_screenwidth()-90, bg = 'black', fg = 'indianred', font = ('kokonor', 18))
        l.pack()
        close = tk.Button(f, text = 'close', font = ('chalkduster', 22), highlightbackground = 'black', command = lambda win = self.info_popup : self.destroy_release(win))
        close.pack()
    
    def animate_squares(self, sqrs):
        sqrs = [s for s in sqrs if app.grid[s[0]][s[1]] != 'block']
        for i, sqr in enumerate(sqrs):
            img = ImageTk.PhotoImage(Image.open('animations/move/0.png'))
            self.sqr_dict['sqr'+str(i)] = Sqr(img, sqr)
            self.canvas.create_image(sqr[0]*100+50-self.moved_right, sqr[1]*100+50-self.moved_down, image = self.sqr_dict['sqr'+str(i)].img, tags = 'sqr'+str(i))
            
    def cleanup_squares(self):
        for s in app.sqr_dict.keys():
            app.canvas.delete(s)
        app.sqr_dict = {}
    
    def current_pos(self):
        return self.grid[grid_pos[0]][grid_pos[1]]
        
    def exit_fullscreen(self, event):
        root.attributes("-fullscreen", False)
        
    def destroy_release(self, popup):
        popup.grab_release()
        popup.destroy()
        
    def release_wrapper(self, window, partial):
        window.grab_release()
        window.destroy()
        partial()
        
    def kill(self, id, lockname):
        def trigger_loop(triggers):
            if triggers == []:
                root.after(666, lambda id = id, ln = lockname : self.finish_kill(id, ln))
            else:
                t = triggers[0]
                triggers = triggers[1:]
                name = 'dethlok'+str(app.death_count)
                app.death_count += 1
                app.dethloks[name] = tk.IntVar(0)
                t.dt(lockname = name)
                root.wait_variable(app.dethloks[name])
#                 root.after(222, lambda name = name : root.wait_variable(app.dethloks[name]))
                trigger_loop(triggers)
#                 root.after(333, lambda ts = triggers : trigger_loop(ts))
        trigger_loop(app.ent_dict[id].death_triggers[:])

    def finish_kill(self, id, lockname):
        ent = app.ent_dict[id]
        self.canvas.delete(id)
        # destroy related 'top' image of large Ents
        if app.ent_dict[id].type == 'large_bottom':
            app.ent_dict[id].large_undo()
        self.grid[self.ent_dict[id].loc[0]][self.ent_dict[id].loc[1]] = ''
        if id in app.init_q:
            app.init_q.remove(id)
        if app.active_ent == id:
            app.active_ent = None
        del self.ent_dict[id]
        ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        app.cycle_q = ents[:]
        app.enemy_cycle_q = en_ents[:]
        # DEBUG handle if killing witch
        # If witch is dead, show popup with victory/defeat
        if app.num_players == 1:
            witch = app.p1_witch
            if witch not in app.all_ents().keys():
                self.reset()
        elif app.num_players == 2:# 2 PLAYER DUEL
            witch1 = app.p1_witch
            witch2 = app.p2_witch
            ids = app.all_ents().keys()
            if witch1 in ids and witch2 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch1, witch2)
            elif witch2 in ids and witch1 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch2, witch1)
            elif witch1 not in ids and witch2 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch1, witch2, draw = True)
        # if tomb, decr times_imprint (witch is alive here)
        if isinstance(ent,Tomb):
            name = ent.imprint
            if ent.owner == 'p1':
                witch_ent = app.ent_dict[app.p1_witch]
            elif ent.owner == 'p2':
                witch_ent = app.ent_dict[app.p2_witch]
            if name != '':
                spell = witch_ent.arcane_dict[ent.imprint]
                witch_ent.arcane_dict[ent.imprint] = Spell(spell.name,spell.func,spell.cost,max(0,spell.times_imprint-1),spell.times_cast)
        app.dethloks[lockname].set(1)

    def unbind_arrows(self):
        root.unbind('<Right>')
        root.unbind('<Left>')
        root.unbind('<Up>')
        root.unbind('<Down>')
        
    def rebind_arrows(self):
        root.bind('<Right>', app.move_curs)
        root.bind('<Left>', app.move_curs)
        root.bind('<Up>', app.move_curs)
        root.bind('<Down>', app.move_curs)
        app.canvas.bind('<Button-1>', app.jump_to_square)
        app.canvas.tag_bind('minimap', '<Double-Button-1>', app.jump_to_minimap)
        
    def unbind_nonarrows(self):
        root.unbind('<a>')
        root.unbind('<q>')
        root.unbind('<i>')
        root.unbind('<e>')
        root.unbind('<w>')
        root.unbind('<p>')
        try: app.canvas.unbind('<Button-2>')
        except: pass
        try: app.canvas.unbind('<Double-Button-1>')
        except: pass
#         root.unbind('<,>')
#         root.unbind('<.>')
        for x in range(10):
            root.unbind(str(x))
            
    def unbind_numerical_hotkeys(self):
        for x in range(10):
            root.unbind(str(x))
            
    def unbind_all(self):
        for x in range(10):
            root.unbind(str(x))
        root.unbind('<Right>')
        root.unbind('<Left>')
        root.unbind('<Up>')
        root.unbind('<Down>')
        root.unbind('<a>')
        root.unbind('<q>')
        root.unbind('<,>')
        root.unbind('<.>')
        root.unbind('<l>')
        root.unbind('<;>')
        root.unbind('<e>')
        root.unbind('<i>')
        root.unbind('<m>')
        root.unbind('<h>')
        root.unbind('<e>')
        root.unbind('<w>')
        root.unbind('<p>')
        try: app.canvas.unbind('<Button-1>')
        except: pass
        try: app.canvas.unbind('<Button-2>')
        except: pass
        try: app.canvas.tag_unbind('minimap')
        except: pass
#         try: app.canvas.unbind('<Double-Button-1>')
#         except: pass
#         root.unbind('<Escape>')

    def rebind_all(self):
        root.bind('<Right>', app.move_curs)
        root.bind('<Left>', app.move_curs)
        root.bind('<Up>', app.move_curs)
        root.bind('<Down>', app.move_curs)
        root.bind('<a>', app.populate_context)
        root.bind('<q>', app.depop_context)
        root.bind('<,>', app.cycle_friendly_units)
        root.bind('<l>', app.de_cycle_friendly_units)
        root.bind('<.>', app.cycle_enemy_units)
        root.bind('<;>', app.de_cycle_enemy_units)
        root.bind('<m>', app.map_effect_info)
        root.bind('<h>', app.highlight_active)
        app.canvas.tag_bind('minimap', '<Double-Button-1>', app.jump_to_minimap)
        app.canvas.bind('<Button-1>', app.jump_to_square)
        app.canvas.bind('<Button-2>', app.rclick_pop_context)
#         root.bind('<Escape>', app.exit_fullscreen)
        # DEBUG ####
#         root.bind('<d>', app.debugger)

    def jump_to_minimap(self, event):
        app.unbind_arrows()
        x = (event.x-100)
        y = (event.y-(app.canvas.winfo_height()-self.minimap.height()-90))
        # get closest in map
        x = x//10
        y = y//10
        aroundx = [x,x-1,x+1]
        aroundy = [y,y-1,y+1]
        # disallow jump to extreme borders of map...
        for x in aroundx:
            if x == 0 or x == 1 or x == app.map_width//100 or x == app.map_width//100-1:
                break
            for y in aroundy:
                if y == 0 or y == 1 or y == app.map_height//100 or y == app.map_height//100-1:
                    break
                pair = [x,y]
                if pair in app.coords:
                    app.focus_square(pair[:])
                    app.rebind_arrows()
                    return


    def rclick_pop_context(self, event = None):
        app.jump_to_square(event)
        app.populate_context(event = None)

    def confirm_quit(self):
        self.depop_context(event = None)
        self.unbind_all()
    # Instead of label just paste a bunch of intrusive text across the main canvas
    # centered around the grid_pos
        l = tk.Label(self.context_menu, text = 'Confirm Quit', relief = 'raised', fg = 'indianred', bg = 'black', font = ('chalkduster', 22))
        self.context_buttons.append(l)
        b1 = tk.Button(self.context_menu, text = 'QUIT', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = root.destroy)
        self.context_buttons.append(b1)
        b2 = tk.Button(self.context_menu, text = 'Cancel', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.cancel_quit)
        b2.pack(side = 'bottom')
        b1.pack(side = 'bottom')
        self.context_buttons.append(b2)
        l.pack(side = 'bottom')

    def cancel_quit(self):
        self.depop_context(event = None)
#         for b in self.context_buttons:
#             b.destroy()
#         self.repop_help_buttons()
        self.rebind_all()
        
    def repop_help_buttons(self):
        menu_button = tk.Button(self.context_menu, text="Menu", font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=self.open_menu)
        menu_button.pack(side = 'bottom')
        self.context_buttons.append(menu_button)
        root.bind('<p>', self.confirm_end)
        end_turn_button = tk.Button(self.context_menu, text = 'End Round', font = ('chalkduster', 22), highlightbackground = 'tan3', command = self.confirm_end)
        end_turn_button.pack(side = 'bottom')
        self.context_buttons.append(end_turn_button)
        
    def open_menu(self):
        self.depop_context(event = None)
        self.unbind_all()
        quit_button = tk.Button(self.context_menu, text="QUIT", font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=self.confirm_quit)
        quit_button.pack(side = 'bottom')
        self.context_buttons.append(quit_button)
        options_button = tk.Button(self.context_menu, text = 'Options', font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command = self.game_options)
        options_button.pack(side = 'bottom')
        self.context_buttons.append(options_button)
        help_button = tk.Button(self.context_menu, text = 'Help', font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command = self.help)
        help_button.pack(side = 'bottom')
        self.context_buttons.append(help_button)
        close_button = tk.Button(self.context_menu, text = 'Close Menu', font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command = self.cancel_quit)
        close_button.pack(side = 'bottom')
        self.context_buttons.append(close_button)
        
        
    # called when you die in 1player mode
    def reset(self):
        from sys import executable, argv
        from os import execl
        python = executable
        execl(python, python, * argv)
        
    def highlight_active(self, event = None):
        if app.active_ent:
            app.get_focus(app.active_ent)
        
    # cycle through units on your turn with SpaceBar
    def cycle_friendly_units(self, event = None):
        my_ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        for id in my_ents: # if ents has changed, reset the cycle order
            if id not in app.cycle_q:
                app.cycle_q = my_ents[:]
                break
        id = app.cycle_q[0] # after possible reset, grab first in line to focus
        app.cycle_q = app.cycle_q[1:]+[app.cycle_q[0]] # move to back of q
        app.focus_square(app.ent_dict[id].loc)

    def de_cycle_friendly_units(self, event = None):
        my_ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        for id in my_ents: # if ents has changed, reset the cycle order
            if id not in app.cycle_q:
                app.cycle_q = my_ents[:]
                break
        app.cycle_q = [app.cycle_q[-1]] + app.cycle_q[:-1] # put it back in front
        id = app.cycle_q[-1] # after possible reset, grab last in line to focus
        app.focus_square(app.ent_dict[id].loc)
        
    def cycle_enemy_units(self, event = None):
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        for id in en_ents: # if ents has changed, reset the cycle order
            if id not in app.enemy_cycle_q:
                app.enemy_cycle_q = en_ents[:]
                break
        id = app.enemy_cycle_q[0] # after possible reset, grab first in line to focus
        app.enemy_cycle_q = app.enemy_cycle_q[1:]+[app.enemy_cycle_q[0]] # move to back of q
        app.focus_square(app.ent_dict[id].loc)
        
    def de_cycle_enemy_units(self, event = None):
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        for id in en_ents: # if ents has changed, reset the cycle order
            if id not in app.enemy_cycle_q:
                app.enemy_cycle_q = en_ents[:]
                break
        app.enemy_cycle_q = [app.enemy_cycle_q[-1]] + app.enemy_cycle_q[:-1] # put it back in front
        id = app.enemy_cycle_q[-1]
        app.focus_square(app.ent_dict[id].loc)
        
        
    def jump_to_square(self, event = None):
        x = (event.x + app.moved_right)//100
        y = (event.y + app.moved_down)//100
        if (app.map_width//100)-1 <= x or (app.map_height//100)-1 <= y:
            return
        if x < 1 or y < 1:
            return
        app.focus_square([x,y])
        
    def all_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large'}
        
    def ents_to_act(self):
        ids = [k for k,v in self.ent_dict.items() if v.type != 'large']
        shuffle(ids)
        return ids
        
    def spell_target_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large' and 'psyshield' not in v.get_types()}
        
    def action_target_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large' and 'invisibility' not in v.get_types()}
        
    # create popup with description of action name
    # ADD manually lookup name for all actions and spells
#     def action_info(self, event = None, name = None, button = None):
#         def end(window):
#             self.destroy_release(window)
#         self.info_popup = tk.Toplevel()
#         self.info_popup.grab_set()
#         self.info_popup.attributes('-topmost', 'true')
#         def on_close():
#             pass
#         self.info_popup.protocol('WM_DELETE_WINDOW', on_close)
#         info_text = name + '\n' + action_description(name)
#         self.text = tk.Label(self.info_popup, text = info_text, wraplength = 400, font = ('chalkduster', 22), fg='indianred', bg = 'black')
#         self.text.pack()
#         self.close = tk.Button(self.info_popup, text = 'OK', font = ('chalkduster', 22), fg='tan3', command = lambda win = self.info_popup : end(win))
#         self.close.pack()

    def action_info(self, event = None, name = None, button = None):
        txt = name+'\n'
        txt += action_description(name)
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', highlightthickness = 0, relief = 'sunken', wrap = 'word', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))
#         self.mi_popup = tk.Toplevel(bg = 'black')
#         sb = tk.Scrollbar(self.mi_popup)
#         self.mi_popup.grab_set()
#         self.mi_popup.attributes('-topmost', 'true')
#         def on_close():
#             pass
#         self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
#         self.text = tk.Text(self.mi_popup, yscrollcommand = sb.set, bg = 'black', fg = 'tan3', font = ('chalkduster', 20))
#         self.text.insert('end', txt)
#         self.text.configure(state = 'disabled')
#         self.close = tk.Button(self.mi_popup, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
#         self.close.pack()
#         self.text.pack()
#         sb.pack(side = 'right', fill = 'y')
#         sb.config(command = self.text.yview)
#         self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))


    def generic_cancel(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def debugger(self, event):
        sqr = grid_pos
        id = app.grid[sqr[0]][sqr[1]]
        if id in app.all_ents().keys():
            ent = app.ent_dict[id]
            for k,v in ent.__dict__.items():
                print(k,v)
#         global grid_pos, curs_pos, map_pos
#         id = app.grid[grid_pos[0]][grid_pos[1]]
#         if id in app.all_ents().items():
#             ent = app.ent_dict[id]
#             print(ent.get_stat_total())
    # doesnt work since curs_pos is tied to grid_pos/map_pos
    # movement of cursor keeps all in sync
#         app.move_map('Left')

root = tk.Tk()
app = App(master=root)

root.bind('<Right>', app.move_curs)
root.bind('<Left>', app.move_curs)
root.bind('<Up>', app.move_curs)
root.bind('<Down>', app.move_curs)
root.bind('<a>', app.populate_context)
root.bind('<q>', app.depop_context)
root.bind('<l>', app.de_cycle_friendly_units)
root.bind('<,>', app.cycle_friendly_units)
root.bind('<;>', app.de_cycle_enemy_units)
root.bind('<.>', app.cycle_enemy_units)
app.unbind_all()
# root.bind('<Escape>', app.exit_fullscreen)
#### DEBUG ####
root.bind('<d>', app.debugger)


root.configure(background = 'black')

root.attributes('-transparent', True)
root.attributes("-fullscreen", True)

width = root.winfo_screenwidth()
height = root.winfo_screenheight()
root.geometry('%sx%s' % (width, height))

app.mainloop()