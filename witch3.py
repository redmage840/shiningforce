# an ent that dies during its own action that contains a loop over multiple ents...
# execution of loop continues as normal ONLY if the ent referenced itself through self (if at all)
# attempting to look up the ent (or any ent) that has been removed through kill() during the loop will throw error
# HOWEVER, execution completes and the current round still belongs to the ent that has been removed...
# may pass round as normal, but somehow should check if the ent still exists.../pass directly to next round...

# kill checks for death of witch/gameover (1 or 2 player), check_victory_cond() checks for victory at eot for 1 player campaign

# squamous carapace descr piercing?

# effect descr elemental langour, asthenia, biotranspose, moldering effluvium plague, 

# list comprehensions recalc all internal func calls?! not memoized...
# speed up animate sqrs blinks, like wing buffet

# currently map triggers are only used for labyrinth level, but maybe should keep loop for other things that can happen async (safely)

# transmuter either cast asthenia or elemental langour not both same target

# make fell evolver image change with evolutions

# fix/change/balance lesser demon, maybe cenobite

# show range hexes, in effect descr

# tombkiller...
# ghast, crushing damage, prefers tomb targets if any exist...

# wraith, perm def efct reduce melee/ranged dmg to 1, perm psyshield

# change mind rot, blind, torment,

# time mage? actions that alter initq, init, san? acts? moves?

# make gorgon class / level

# sounds: corrosive atk

# effect descriptions: splinters, noxious venom, winnow verd, nox respir

# music volume / sfx volume , and/or turn on/off

# note in help, all defense effects are applied after all attack efcts have been applied...

# mousehover popup spell/action desc?

# r-click on minimap to jump screen position...show block sqrs

# log relevant text items in background of context menu

# magick regen rate, make this use getter so it can be changed by effects

# smart bots, smart targeting, ie kobold shamans prefer targets with low psyche/wisdom

# witches use for actions...

# types ==> undead

'''
Random names/ideas
boost, major familiar, healing salve, detox, dire poison, freeze, 
bolt, mental decay, clear mind, quicken, sunbeam, trance, shocking strike

Agnes Stuff
themes- 'Psionics', movement augmentation ; 'Disease' debilitating spells affected by proximity of ents ; 'Astrology|Astronomy' ... ; 'Demonic Pantheon' (Lesser Key of Soloman), Beleth patron

Mind Leech
redirect magick dmg to target, how to do this... changing dfndr object: func that called apply_damage() still assumes it has to only check spirit of initial target...

armor of thorns
sot/eot all adj take 1 piercing, add phys resist

Force Field
reduce phys def efct

Astrological Guidance
move tar up to its move_range wo applying move effects, cannot have moved, sets move_used to true

trap in stone
replace ent w less than 40 max spirit w inert ent or 'block'

astral projection
choose a location and another spell, cast the spell as if you were located at the chosen location

illusory eclipse
transform all shadows (friendly and enemy), tar shadow gains invis

lament of the void
bard gets way to dispel invis psyshield chance

reaping of saturnus
destroy a summon to reduce summon count by 1

guardian of the chthonic gate
summon cerberus, slashing and fire atk, lasts only this turn

plutos verdict
doom-like

Ali Stuff
themes- 'Sacrifice' spells have downside/upside, sometimes useful on either friendly or enemy ents ; 'Egyptian Pantheon', Osiris Patron, Fakir Techniques

Iron Maiden
tar takes piercing dmg to get efct that reduces/resists phys

Bed of Nails
get efct that incrs phys to gain resists to poison, magick, elemental

Riddle of the Sphinx
choose among resists that a tar has, tar loses that resist on psy save fail (-2)

Fangs of Apophis
Tar gains invis and atk efct that changes type to poison

Chimeric Mutation

Wreathed in Flames
remove fire wkns, add resist fire, elec, pierc, atk efct that changes phys to fire +1 dmg

Third Eye
all wi range rsn make psy save -2 or lose invis and psyshield

Hammer of the Abyss
crushing dmg to tar

Mirage
tar gains magick resist, exchange position with enemy ent

Zombify
tar (non pb/witch) gains wkns fire. -2 agl, resist phys, add action 'gangrenous bite' agl v agl, str vs end + 3dmg with -1 end and add wkns poison

Pierce the Veil
tar gets atk efct, remove all resist (1 turn) and psyshield if tar fails psy save -3

Morgan LeFay Stuff
themes- 'woodland' summons: spells that create computer-controlled, player-owned ents; Spells that create terrain effects supporting 'woodland' types ; Range attacks and movement ; 'Arthurian/Celtic Pantheon', Ceridwen patron, 

source material - changelings, leprechaun, puca, banshee, loughleagh (lake of healing), black lamb, T'yeer-Na-N-Oge, Hy-Brasail (isle of the blessed), dullahan, far darrig, merrow, sluagh (horde,undead), fomorian (giants), bean nighe, barghest, beast of bodmin moor, black annis/anny, redcap, nuckelavee
'''

# level with 'waypoints' end/start turn on waypoint to move between areas...

# pathfinding (esp along long paths) should avoid moving entirely along one axis

# save game during level?

# get_focus/focus_square should 'center' screen on area...

# main menu / back buttons in load

# summon r-click desc

# change morgan stats, spells

# make hawk target action targets?

# visuals for eot/sot effects...

# trolls that fail sanity check skip their regen..., anything with specific behavior in do_round() would... minotaur, dragon, etc...

# show costs of actions, without disrupting the names for action_descr lookups...
# alt five is infi symbol


import tkinter as tk
# from tkinter import ttk
from os import walk
from PIL import ImageTk,Image
from random import choice, randrange, shuffle
from functools import partial, reduce
from fractions import Fraction
# from pickle import dump, load
from copy import deepcopy
from math import ceil
# filehandler = open(filename, 'r') 
# object = pickle.load(filehandler)

def unique(listoflists):
    tx = [tuple(s) for s in listoflists]
    ts = list(set(tx))
    return [list(t) for t in ts]

def round_100(x):
    prefix = x // 100
    rm = int(str(x)[-2:])
    if rm >= 50:
        prefix += 1
    return prefix

# takes a string (name of action), returns a string descr, used in populate_context=>get_info/get_more_info
def action_description(act):
    if act == 'Slash':
        return 'To-hit agility vs agility, strength vs endurance slashing melee damage, adjacent target as action.'
    elif act == 'Flying Move':
        return 'Move without being impeded by obstacles.'
    elif act == 'Pox':
        return 'Adjacent units get end-of-turn effect: 3 poison dmg. Duration is reason. Level is wisdom.'
    elif act == 'Summon':
        return 'Summon 1 wolf'
    elif act == 'Move':
        return 'Move according to move type and move range'
    elif act == 'Spell':
        return 'Cast cantrip or arcane spell'
    elif act == 'Gravity':
        return 'A unit within range equal to caster rsn gets move range reduced by 2, also -2 agility and dodge. Duration equal to caster rsn. Level equal to caster wis. Target as spell.'
    elif act == 'Curse of Oriax':
        return 'A unit within range of caster rsn gets -1 to each (psy,wis,rsn,san,init) and takes 2 magick dmg at end of turn. Duration equal to caster rsn. Level equal to caster wis. Target as spell.'
    elif act == 'Pestilence':
        return 'Range rsn, psy vs psy poison spell dmg, psy vs psy (minus distance from primary target times 2) to all within range 3 on hit. Primary target gets effect: eot 3 poison dmg and a death trigger that passes new eot effect to all adjacent (dur and level based on current caster abilities). Duration = rsn times 2, level = wis. Does not target unit. Targets location (can cast on units with psyshield).'
    elif act == 'Plague':
        return 'Target in range rsn and each unit connected by occupied adjacent sqrs (counting units without pestilence effect) gets -4 to a random ability among str, agl, end, mm, psy, wis, rsn, san, init. Duration = rsn, level = wis. Target as spell.'
    elif act == "Beleth's Command":
        return 'Costs 1 act AND 1 mv to use. A non-adjacent unit is struck by lightning, taking psyche vs psyche elec dmg. On to-hit (psyche vs strength) the unit gets -1 moves, lasting rsn at level wis. Then, all adjacent units to the caster take psy vs psy fire dmg. The caster gains +1 psyche +1 endurance effect if not already possessed, lasting rsn at level wis. Target only lightning target as spell.'
    elif act == "Minerva's Gift":
        return 'Spell target gets +1 agl, init, heal 1 spirit. Duration 2 turns at level wis.'
    elif act == 'Psionic Push':
        return 'A unit is pushed at/towards any location (including its current) within range 2 as long as the path is unobstructed. After push, if there are any adjacent units then each plus original target make agility save(+1). A failed save means the unit takes a crushing attack from the pushed unit using half strength(of pushed unit, rounded up) vs endurance(of unit receiving attack) (the pushed unit attacks itself upon a failed save after ending a push adjacent to other units, ending the push on a location with no adjacent units results in no attacks to any unit). Spell target.'
    elif act == 'Energize':
        return 'Target gets effect +1 mvs. Lasts 2 turns at level wisdom. Spell target.'
    elif act == 'Psi Blades':
        return 'Adjacent target gains a melee attack action. Aglity vs aglity to hit, psyche vs psyche electric melee damage. Duration is reason, level wisdom. Spell target, added psi slash is action target'
    elif act == 'Psi Slash':
        return 'This is the action added from Psi Blades. Attack adjacent, aglity vs aglity to hit, psyche vs psyche electric melee damage.'
    elif act == 'Pyrotechnics':
        return 'Range is ballistics. Marksmanship vs Dodge to hit. Missle vs Endurance explosive damage. Action target (ents without invis).'
    elif act == 'Molecular Subversion':
        return 'The very structure of a creature begins to dissolve... Target gains an effect that removes resistances to acid and explosive (resistances may be gained through effects cast after this spell). Also gives an effect that adds weakness to acid and explosive dmg. Duration is reason at level of caster wisdom. Spell target.'
    elif act == 'Plutonian Cloak':
        return 'Target gets a defense effect. When taking damage, if the type is slashing, piercing, or crushing melee damage, this summon gains invisibility (untargetable with non-spell actions) until the end of this turn; OR, if the damage source is a spell, the summon gains psyshield (untargetable with spells) until the end of this turn. Invisibility or psyshield are not added if the summon already has them as types added by this spell. Duration of caster reason at level wisdom. (each instance of either invisibility or psyshield last 1 turn). Spell target.'
    elif act == 'Hidden From the Stars':
        return 'A non-witch adjacent target gains +1 agility, dodge, and wisdom. Duration is reason at level of wisdom. Spell target.'
    elif act == 'Cosmic Sight':
        return 'All enemies within range 3 of caster make wisdom check (-2) or get an effect which strips all preexisting instances of psyshield (effects applied later may grant psyshield while this is still in effect). May grant effect to unit already with this effect (for the purposes of stripping later added instances of psyshield). Duration is reason at level of wisdom. No targeting.'
    elif act == 'Bewitch':
        return 'Any non-witch target, friendly or enemy, within range of reason, gains an effect granting psyshield until the end of this turn. Level is wisdom. Spell target.'
    elif act == 'Read the Stars':
        return 'Spell target summon gains attack effect that increases elec and cold type damage by 2 when the source is melee, ranged, or spell. Duration is reason at level of wisdom.'
    elif act == 'Demonic Sight':
        return 'Any target in range of reason, on to hit psyche vs psyche, gets an effect that strips invisibility. Duration is reason. Level is wisdom. (must be targetable by spells).'
    elif act == 'Mist Move':
        return 'Move without being obstructed by obstacles.'
    elif act == 'Drain Life':
        return 'range of reason, to hit wis vs wis, magick damage psyche vs psyche. Caster is healed equal to half the amount of dmg successfully dealt (rounded up). Target as spell. Costs 3 magick.'
    elif act == 'Muddle':
        return 'If to-hit psyche vs psyche, spell target gets an end of turn effect causing it to attack itself. It attempts a hit with its own agility (always 50%, unless affected by its own attack or defense effects). A successful hit causes strength vs endurance (its own) crushing dmg. Lasts 3 turns at level of wisdom. Costs 2 magick.'
    elif act == 'Tendrils of Chaos':
        return 'Two separate to-hit attempts are made against the target: the first, psyche vs agl, target gets -2 to its move range unless it already has this move range effect. The second, psyche vs str, gives -2 to a random ability among all abilities besides acts, moves, move range, ballistics, and missle, and can be given multiple times to the same unit. Both effects last equal to caster reason  at level of wisdom. Target as spell.'
    elif act == 'Warpfire':
        return 'A location which does not already have a warpfire effect has a warpfire placed on it. At the start of the turn, each unit within range 3 of the warpfire is teleported to a random square among the squares CLOSEST to the warpfire. At end-of-turn, if a unit occupies the location, it gets -2 sanity effect at reason duration and wisdom level (of original caster).'
    elif act == 'Phase Shift':
        return 'Switch between the Umbrae Wolf and Umbrae Mist forms. Counts as action.'
    elif act == 'Dark Shroud':
        return 'All friendly units within range 3 of a location within range reason heal 2 spirit and receive +1 dodge if they do not already have the effect. Duration is reason, level is wisdom. Costs one magick, does not target.'
    elif act == 'Umbrae Strike':
        return 'Action target. Range ballistic. Marksmanship versus dodge to-hit. Missle versus endurance electric ranged damage.'
    elif act == 'Stalk':
        return 'To-hit marksmanship vs dodge, unit gets an effect which causes either slashing, crushing, or piercing damage dealt to it to be increased by 2, if the type if melee or ranged. Duration is missle, level is ballistic. Targets as action.'
    elif act == 'Darkblast':
        return 'If used on a friendly unit, attempt to dispel(level = missle) any 1 effect and then heal it 3 spirit. If used on an enemy unit, a successful to-hit (marksmanship vs dodge) does piercing ranged damage: missle vs endurance. After the attack, attempts to dispel(level = missle) any 1 effect on the target. Targets as an action. Costs 2 magick.'
    elif act == 'Leap':
        return 'Move over obstacles to any square within move range. Movement effects do not affect the range of Leap unless specifically noted. Does not count as either an action or a move. Can only be used once per turn.'
    elif act == 'Rage':
        return 'Dispel(level = strength) attempt all current effects on self. Gain +3 str, end, +4 psy. Take 3 magick damage when effect ends OR is dispelled. While rage effect exists, Berserker may only use Move, Leap, and Whirlwind. Duration is reason. Level is strength.'
    elif act == 'Hurl':
        return 'Move an adjacent friendly unit to a location up to distance strength from Berserker. Target as action.'
    elif act == 'Whirlwind':
        return 'Attack each adjacent unit (does not target). To-hit: agl-3(min 1) vs agl, slashing damage: str vs end'
    elif act == 'Simulacrum':
        return 'Target, as spell, within range reason gets +4 agility. Duration is reason at level of wisdom. Costs 1 magick.'
    elif act == 'Gate':
        return 'Target, as spell, within range reason. Relocate unit to any location within range reason.'
    elif act == 'Mortar':
        return 'A unit within range (ballistics<=ballistics+2), and all units within range 2 of that location, upon failing to-hit marksmanship vs dodge, take a random amount of fire ranged damage (between missle-minus-d3 and missle). Does not target.'
    elif act == 'Tracer Grenade':
        return 'A unit within range (ballistics<=ballistics+2), and all units within range 2 of that location, upon failing to-hit marksmanship vs dodge, get -4 dodge and effect that strips instances of previously held invisibility (later effects may grant invisibility while this effect still persists). Duration is missle. Level is ballistics.'
    elif act == 'Doubling Cube':
        return 'Target unit and all friendly units within range 1 of target get double effect if they do not already have it. Effect causes any slashing, crushing, or pierced damage made against unit to force attacker to make a to-hit roll (psyche vs psyche) against defender. On fail, the attackers dmg is reduced to 1. Duration is reason, level is wisdom. Costs 3 magick. Only targets primary as spell.'
    elif act == 'Unholy Chant':
        return 'All other friendly units within range 2 of caster get +1 to all stats (str, agl, end, mm, msl, bls, dod, psy, wis, rsn, san, init, moverange) for the remainder of the turn at level wisdom. Costs 1 magick.'
    elif act == 'Arrow of Diana':
        return 'Target within range of ballistics, on fail of to-hit marksmanship vs dodge, takes missle vs endurance piercing damage. Action target'
    elif act == 'Esuna':
        return 'Target within range reason has each effect attempted to dispel(wisdom). Targets as spell. Costs 2 magick.'
    elif act == 'Moonlight':
        return 'Target within range reason is healed equal to caster psyche up to its max spirit. Target as spell. Costs 2 magick.'
    elif act == 'Aura':
        return 'Target within range reason and all friendly units within range 3 of target heal a random amount between 1 and caster psyche. Target primary as spell. Costs 2 magick.'
    elif act == 'Tranquility':
        return 'Dispel(wisdom) attempt all effects on a location.'
    elif act == 'Paralyze':
        return 'An adjacent spell target, upon failing wisdom vs wisdom to-hit, gets an effect which reduces move range by 3 to a minimum of 1, and reduces its number of actions by 1. Duration is reason. Level is wisdom. Costs 2.'
    elif act == 'Scarab Gestation':
        return 'Spell target, range reason (non-scarab/scarab swarm/familiar). Upon to hit psyche vs strength, gives a death trigger that summons a scarab under your control. Costs 2 magick. Duration is 13 turns. Level is psyche.'
    elif act == 'Bite':
        return 'Scarab bites an adjacent unit. To-hit: agl vs agl, damage: str vs end, melee.'
    elif act == 'Scarab Swarm':
        return 'Transform a scarab into a flying scarab swarm.'
    elif act == 'Spore Cloud':
        return 'Target location in range 2 gets effect: +2 dodge, -2 damage if type is slashing, piercing, or fire. Duration is reason. Level is wisdom.'
    elif act == 'Claw Rake':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg. If unit does not have effect, gets Ghoul Venom -1 str, end and end-of-turn 2 poison dmg at duration of reason and level of wisdom (of ghoul).'
    elif act == 'Bone Strike':
        return 'adjacent action target, agl vs agl, str vs end crushing dmg.'
    elif act == 'Firebolt':
        return 'spell target range reason, wis vs wis, psy vs psy fire dmg. Costs 1.'
    elif act == 'Scratch':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg.'
    elif act == 'Chop':
        return 'adjacent action target, agl vs agl, str vs end slashing dmg.'
    elif act == 'Bless':
        return 'Heal a friendly spell target within range reason equal to caster psyche.'
    elif act == 'Boiling Blood':
        return 'Adjacent spell target that you own gets +4 str, -4 end, end-of-turn 2 fire damage. Duration is reason. Level is wisdom.'
    elif act == 'Dark Sun':
        return 'Adjacent spell target gets +1 actions until the end of this turn if it passes a wisdom save check. Level is wisdom.'
    elif act == 'Meditate':
        return 'Caster gets +1 psyche and +2 move range until the end of this turn. Level is wisdom.'
    elif act == 'Horrid Wilting':
        return 'Target location, and all units within range 2, on to-hit wis vs wis, take psyche vs endurance acid damage. Does not target.'
    elif act == 'Mummify':
        return 'Spell target within range reason gets +4 endurance and move range reduced to 1. If unit is a Berserker, its leap is set to used for the turn on casting and during start-of-turn effects. Duration is reason. Level is wisdom.'
    elif act == 'Command of Osiris':
        return 'All friendly units within half range reason (rounded down, min 1) get +1 str and end. They are also healed for 1 spirit. All enemies in the same range get -1 str and end. Duration is reason. Level is wisdom. Does not target.'
    elif act == 'Immolate':
        return 'Spell target within half of reason range (rounded down, minimum 1) takes (psyche vs psyche) fire spell damage.'
    elif act == 'Disintegrate':
        return 'Spell target within range reason gets -1 to random ability among str, agl, end, rsn, san. It also gets end-of-turn effect that gives -1 among the same abilities and causes 1 acid damage. Duration is reason. Level is wisdom.'
    elif act == 'Darkness':
        return 'A location within range reason, and all within range 1 of that, get location effect causing units with normal or flying move type (which are not immovable) moving from them -2 move range. Costs 1 magick. Lasts 2 turns at level wisdom.'
    elif act == 'Foul Familiar':
        return 'Summon familiar under your control. Caster takes 5 magick damage on familiar death.'
    elif act == 'Poison Sting':
        return 'Range ballistics, marksmanship vs dodge to-hit, missle vs endurance poison damage. Hit also causes effect, -1 strength and 1 poison damage end-of-turn, stackable. Duration is missle. Level is ballistics.'
    elif act == 'Dire Charm':
        return 'All units within range reason, upon to-hit psyche vs psyche, damage themselves using their own strength vs endurance, crushing melee. Costs 3 magick. Does not target.'
    elif act == 'Baleful Stare':
        return 'Spell target within range reason, upon to-hit wisdom vs strength, that does not have this effect gets -1 psyche and end-of-turn 2 acid damage. Duration is reason. Level is wisdom.'
    elif act == 'Mind Rot':
        return 'Spell target in range reason gets -2 wisdom, -1 reason, -3 sanity. Duration is reason. Level is wisdom.'
    elif act == 'Legerdemain':
        return 'Exchange position of two spell target units.'
    elif act == 'Grasp of the Old Ones':
        return 'Any unit within range reason, upon to-hit psyche vs psyche, gets an effect that strips invisibility and psyshield. Duration is reason. Level is wisdom. Does not target.'
    elif act == 'Dust Devil':
        return 'A spell target within range reason, upon to-hit wisdom vs wisdom, takes psyche vs psyche explosive damage and is relocated to any of the locations (chosen randomly) furthest away from the caster among the locations within distance from the target equal to caster psyche.'
    elif act == 'Dispel':
        return 'An action target within range reason, upon failing to-hit wisdom vs wisdom, has all effects attempted to dispel using caster wisdom. Upon another to-hit using wisdom vs wisdom, the unit gets an effect that strips psyshield. Duration is reason. Level is wisdom.'
    elif act == 'Brambles':
        return 'Spell target within range reason, and all units within distance 2, get -1 move range if they have normal type movement and, on to-hit wisdom vs agility, take psyche vs endurance slashing spell damage. Costs 3.'
    elif act == 'Flesh Hooks':
        return 'An adjacent friendly action target, without this ability, is granted Hook Attack action. This action targets a unit within range reason that, on to-hit wisdom vs dodge, does psyche vs endurance piercing ranged damage. Action is granted for duration reason at level wisdom.'
    elif act == 'Hellfire':
        return 'Spell target within range half of reason (rounded down, min 1), on to-hit wis vs wis, does psyche vs psyche fire spell damage. If that unit fails an endurance save(-5), it gets burn effect which causes slashing, crushing, piercing, fire, and explosive damage to be increased by 2. Duration is reason. Level is wisdom.'
    elif act == 'Stregth Through Wounding':
        return 'All units within range 3 take 2 piercing damage. Friendly units get +1 psyche and endurance. Duration is reason. Level is wisdom.'
    elif act == 'Analyze':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, gets an effect that removes resistances to slashing, piercing, crushing, and explosive damage. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Smoke Bomb':
        return 'A location within range ballistics, which does not have this effect, gets effect that grants invisibility to the occupant. Duration is missle. Level is marksmanship.'
    elif act == 'Pierce Shield':
        return 'Action target within range reason, on to-hit wisdom vs wisdom, gets effect that removes psyshield and gives -1 to psyche and wisdom. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Rend Space':
        return 'Deal explosive spell damage to a unit equal to 3 times the number of map effects at that location. Costs 2.'
    elif act == 'Haste':
        return 'A spell target within range, without this effect, reason gets +4 initiative, +1 agility, dodge, and moves. Duration is reason. Level is wisdom. Costs 2 magick.'
    elif act == 'Encumber':
        return 'A spell target within range reason, without this effect, on to-hit wisdom vs wisdom, gets -4 initiative and -2 agility, marksmanship, dodge, move range, and -1 moves. Duration is reason. Level is wisdom. Costs 1.'
    elif act == 'Gaze':
        return 'Action target within range ballistics, which does not already have this effect, on to-hit marksmanship vs dodge, gets -2 psyche, strength, and move range. Duration is missle. Level is marksmanship.'
    elif act == 'Howl From Beyond':
        return 'All enemy units within range reason without this effect, on to-hit strength vs strength, get -3 sanity and -2 reason. Duration is endurance. Level is strength.'
    elif act == 'Track':
        return 'All enemy units within range reason, on to-hit agility vs agility, get an effect that removes invisibility. Duration is endurance. Level is strength.'
    elif act == 'Toxic Miasma':
        return 'All enemy units, which are not Murrain Wolves, within range reason, on to-hit psyche vs endurance, get an effect that removes invisibility. Another to-hit psyche vs endurance gives -1 wisdom and reason. Duration is reason. Level is wisdom.'
    elif act == 'Leprous Bite':
        return 'An adjacent action target unit, on to-hit agility vs agility, gets -1 str, end, agl, mm, psy, wis, rsn, san, init and takes strength vs endurance slashing melee damage.'
    elif act == 'Concerted Volley':
        return 'Each friendly unit within range 2 of caster gets +X marksmanship where X is equal to the number of friendly units within range 2 of caster without this effect, max +4 bonus to each unit. Duration is wisdom. Level is wisdom. Costs 1.'
    elif act == 'Vengeance':
        return 'Spell target gets defense effect, on receiving melee or ranged damage, adds a +1 effect to str,agl,end,psy,wis,rsn. +1 Effect may be added up to 4 times. Both +1 boosts and this effect have duration equal to caster reason and level equal to caster wisdom.'
    elif act == 'Pounce':
        return "'Jump'(move unimpeded by obstacles) to a location within move range that is adjacent to at least 1 enemy unit. After relocating, attack each adjacent enemy, to-hit agility vs agility, damage strength vs endurance, slashing melee. Does not target."
    elif act == 'Suplex':
        return "An adjacent, action target unit, that does not have the type 'immovable', on to-hit agility vs agility, is relocated to any adjacent location from the caster. Any unit occupying the location is relocated to one of the closest locations to its current location. The original target, and the other potential unit, both take damage equal to the caster strength vs their endurance, crushing melee."
    elif act == 'Anoint':
        return 'Any spell target within range reason, that does not have this effect, gets +1 wisdom. Duration is reason. Level is wisdom. Costs 1 magick.'
    elif act == 'Abeyance':
        return 'An adjacent, spell target unit, on to-hit wisdom vs wisdom, has an action of your choice removed for duration reason at level wisdom. Costs 3 magick.'
    elif act == 'Reveal':
        return 'An adjacent unit, on to-hit wisdom vs wisdom, gets an effect that strips psyshield if it has psyshield, otherwise gets an effect that strips invisibility. Duration is reason. Level is wisdom.'
    elif act == 'Nullify':
        return 'All units within range reason, that do not have either psyshield or invisibility, have each of their effects attempted to dispel using the caster wisdom. Costs 3 magick.'
    elif act == 'Roar':
        return 'All units within range reason that do not have this effect, enemy units on strength vs psyche to-hit get -2 sanity, friendly units on wisdom save check get +2 sanity. Duration is endurance. Level is srength.'
    elif act == "Devil's Mark":
        return 'A spell target unit gets +2 to any chosen ability. Costs 3 magick. Duration is reason. Level is wisdom.'
    elif act == 'Mesmerize':
        return 'Spell target within range rsn, on to hit wisdom vs wisdom, gets an effect causing a start-of-turn psyche save check(mod 0). On failure, the unit loses one action, if it has any, and is dealt crushing melee damage equal to its own strength vs endurance. Duration is reason. Level is wisdom.'
    elif act == 'Torment':
        return 'A spell target within range reason gets an effect that gives -2 psyche, if it does not already have this effect. It then takes psyche vs endurance magick spell damage.'
    elif act == 'Entrance':
        return 'A spell target in range reason, on to-hit psyche vs psyche, gets -3 sanity at duration reason and level wisdom. Costs 2 magick.'
    elif act == 'Enthrall':
        return 'A spell target within range reason without this effect, on to-hit psyche vs psyche, gets -2 strength, agility, marksmanship, dodge at duration reason and level wisdom. Costs 2 magick.'
    elif act == 'Chill Touch':
        return 'An adjacent action target, on to-hit agility vs agility, gets -1 wisdom at duration reason and level wisdom, then takes strength vs endurance cold melee damage.'
    elif act == 'Enervating Grasp':
        return 'An adjacent action target, on to-hit agility vs agility, has magick drained and given to the caster equal to psyche vs psyche damage. The caster cannot go above their base magick in this manner.'
    elif act == 'Vampiric Bite':
        return 'An adjacent action target, on to-hit agility vs agility, takes strength vs endurance piercing melee damage. Caster gets +3 psyche, if it does not have this effect, at duration reason and level wisdom.'
    elif act == 'Bat Form':
        return 'Once per round, Wurdulak may shift form into either bat or wolf form, an Effect lasting 1 turn at level wisdom. Bat form gives +5 to move range, changes move type to flying, and -3 to strength, agility, endurance.'
    elif act == 'Wolf Form':
        return 'Once per round, Wurdulak may shift form into either bat or wolf form, an Effect lasting 1 turn at level wisdom. Wolf form gives +4 agility, +3 move range, and -3 to psyche, wisdom.'
    elif act == 'Hook Attack':
        return 'To-hit wisdom vs dodge. Damage psyche vs endurance, piercing ranged.'
    elif act == 'Stitch Cadaver':
        return 'Summon a Cadaver under your control within range reason. Cadaver performs a round during the end-of-turn phase. If it can  move adjacent to an enemy by moving its move range, it will, and then perform an attack (agility vs agility to-hit, strength vs endurance crushing melee damage). Otherwise it moves randomly within its move range. Cadaver gets a normal round during the turn, but has no actions to use unless granted by the Chirurgeon (or other source).'
    elif act == 'Bone Pincers':
        return 'Action target cadaver you own. It gains an effect granting an action, which targets as action an adjacent unit and on to-hit agility vs agility does strength vs endurance slashing melee damage. This effect has duration reason and level wisdom.'
    elif act == 'Willful Perambulation':
        return 'Action target cadaver you own. It gains an effect granting an action, which allows it to move using its moves. This effect has duration reason and level wisdom.'
    elif act == 'Corrosive Glands':
        return 'Action target cadaver you own. It gains an effect granting an action, which targets as action a unit within range ballistics and on to-hit marksmanship vs dodge does missle vs endurance acid ranged damage. This effect has duration reason and level wisdom.'
    elif act == 'Bone Pincer Attack':
        return 'Action target adjacent unit. On to-hit agility vs agility, does strength vs endurance slashing melee damage.'
    elif act == 'Corrosive Attack':
        return 'Action target unit within range ballistics. On to-hit marksmanship vs dodge, does missle vs endurance acid ranged damage.'
    elif act == 'Alacrity':
        return 'Action target cadaver you own within range reason gets +5 agility, +4 move range  and strength. Costs 4 magick. Duration is reason. Level is wisdom.'
    elif act == 'Farsight':
        return 'Action target cadaver you own within range reason gets +6 marksmanship, +2 ballistics, and +4 missle. Costs 4 magick. Duration is reason. Level is wisdom.'
    elif act == 'Fuse Trap':
        return 'Add local effect to a location within reason. On undo, do 3 explosive undo damage to each unit within range 3 of the effect (damage source is caster of fuse trap). Duration is 1. Level is wisdom.'
    elif act == 'Entomb':
        return 'Teleport to an empty location within range reason, leaving a Tomb summon in your place. The tomb has no moves and one action, Vivify, that restores spirit and magick to summons based on Tomb psyche. Witch gains 3 magick at the beginning of the start-of-turn phase for each tomb controlled. Entomb may be used once per turn.'
    elif act == 'Pain':
        return 'Destroy a summon you own within range reason. All adjacent units take psyche (of caster) vs endurance explosive ranged damage.'
    elif act == 'Hatred':
        return 'A spell target unit without this effect gets an attack effect. Whenever dealing melee damage, this unit gets a +1 strength effect at the duration and level of caster reason and wisdom. Bonus is applied after damage amount calculated and can be applied up to 5 times. This effect has duration reason and level wisdom.'
    elif act == 'Terror':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage.'
    elif act == 'Fear':
        return 'Action target in range reason, and all other enemy units adjacent, on to-hit wisdom vs wisdom take psyche vs psyche cold spell damage. Then, if they do not have this effect, get -1 move range and psyche.'
    elif act == 'Slow':
        return 'Spell target in range reason, and all other enemy units adjacent, if they do not have this effect, get -2 move range and an attack effect that reduces their ranged and melee damage by half (rounded down) to a minimum of 1.'
    elif act == 'Willowisp':
        return 'Spell target in range reason takes psyche vs endurance fire spell damage and gets a burn defense effect, if it does not already possess one. Burn causes melee, ranged, and spell damage received to be increased by 2 if the type is slashing, crushing, piercing, fire, or explosive. The target is then moved to a random location within distance 4, as long as an open path exists.'
    elif act == 'Wail':
        return 'All enemy units within range reason of caster are moved to a location among those furthest from caster from the moves the unit could normally make.'
    elif act == 'Iron Spirit':
        return 'An adjacent spell target summon gets +1 strength, endurance, and wisdom. Duration is reason. Level is wisdom.'
    elif act == 'Strength of the Void':
        return 'An adjacent spell target summon gets +1 strength, endurance, and psyche. Duration is reason. Level is wisdom.'
    elif act == 'Gift of Mars':
        return 'An adjacent spell target summon gets +1 missle, marksmanship, and psyche. Duration is reason. Level is wisdom.'
    elif act == "Mercury's Blessing":
        return 'An adjacent spell target summon gets +1 agility, dodge, and move range. Duration is reason. Level is wisdom.'
    elif act == 'Duress':
        return 'Spell target within range reason that has psyche equal to or greater than its strength, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage; then, gets an effect -4 reason and -7 sanity at duration reason and level wisdom.'
    elif act == 'Summon Undead':
        return 'Summon two skeletons and one ghoul.'
    elif act == "Tourach's Hymn":
        return 'Spell target within range reason that has strength equal to or greater than its psyche, on to-hit wisdom vs wisdom, takes psyche vs psyche magick spell damage; then, gets an effect -4 strength and agility at duration reason and level wisdom.'
    elif act == 'Staff of Vecna':
        return 'A unit within range reason gets an effect that removes psyshield.'
    elif act == 'Stomp':
        return 'All units, that are not flying, ethereal, or immovable, take between 1 and 6 minus their distance from caster, electric ranged damage. They are then moved up to 2 squares closer towards the caster, if an unobstructed path exists.'
    elif act == 'Pound':
        return 'An adjacent enemy unit, on to-hit agility vs agility, takes strength vs endurance crushing melee damage.'
    elif act == 'Charge':
        return 'An enemy unit on a straight path from caster, whose location is equal to or greater than the caster move range   but less than or equal to 2 times the caster move range, is Charged. The caster is relocated adjacent, and on to-hit agility vs agility, the unit takes strength vs endurance crushing melee damage.'
    elif act == 'Rake':
        return 'An adjacent unit, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Iceblast':
        return 'A unit within range reason, and all other units within range 2, on to-hit wisdom vs wisdom, take psyche vs psyche cold spell damage.'
    elif act == 'Vivify':
        return 'Restore spirit and magick equal to caster psyche. Costs 1 magick.'
    elif act == 'Lift':
        return 'Spell target gets a move type effect that changes its move type to flying.'
    elif act == 'Fireblast':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche fire spell damage. The unit then gets a Burn effect, if it does not already have one, causing slashing, crushing, piercing, fire, or explosive damage to be increased by 2 if it is of type melee, ranged, or spell.'
    elif act == 'Teleport':
        return 'Moves a friendly unit within range reason closer to enemy units, moving within the same reason range.'
    elif act == 'Charged Bolt':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche electric spell damage.'
    elif act == 'Lacerate':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Lunge':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance piercing melee damage.'
    elif act == 'Frenzy':
        return 'All adjacent units, on to-hit agility vs agility, take strength vs endurance slashing melee damage.'
    elif act == 'Shout':
        return 'All units within range reason, on to-hit strength vs psyche, get -2 sanity.'
    elif act == 'Gale':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance electric ranged damage.'
    elif act == 'Static Storm':
        return 'All units within range reason, besides caster, have all effects attempted to dispel by caster using wisdom.'
    elif act == 'Cyclonic Rift':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche electric spell damage. Then, teleport it to a random location no further from itself than the caster psyche.'
    elif act == 'Breath of Life':
        return 'All Air Elementals are healed 10 spirit. Then, all of their effects are attempted to dispel using caster wisdom.'
    elif act == 'Summon Air Elementals':
        return 'Summon 3 Air Elementals, once, close to the caster.'
    elif act == 'Summon Earth Elementals':
        return 'Summon 3 Earth Elementals, once, close to the caster.'
    elif act == 'Earthquake':
        return 'All units within range reason that are not flying, ethereal, or immovable, take psyche vs agility crushing spell damage; And, are moved up to 4 squares among those squares that are furthest from the caster.'
    elif act == 'Summon Fire Elementals':
        return 'Summon 3 Fire Elementals, once, close to the caster.'
    elif act == 'Firewall':
        return 'All units, that are not Fire Elementals, and in lateral lines from the caster, up to range reason; take psyche vs psyche fire spell damage.'
    elif act == 'Surge':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance piercing ranged damage.'
    elif act == 'Dehydrate':
        return 'Spell target in range reason, and all enemy units range 2 from target, on to-hit wisdom vs wisdom, take psyche vs psyche acid spell damage, AND get an effect giving weakness to Fire damage.'
    elif act == 'Fog':
        return 'Spell target in range reason, and all enemy units range 2 from target, on to-hit wisdom vs wisdom, take 3 cold spell damage; AND, get an effect giving -3 to move range, if they do not already possess this effect.'
    elif act == 'Purify':
        return 'Any unit within range reason with at least 2 effects, that are not Dehydrate or Fog, has all effects attempted to dispel (besides Dehydrate or Fog) using the caster wisdom.'
    elif act == 'Summon Water Elementals':
        return 'Summon 3 Water Elementals, close to the caster. Water Elementals can only travel in one of the four cardinal directions, depending on their direction on summon. They must move forward and are destroyed on colliding with an obstacle.'
    elif act == 'Flare':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance fire ranged damage.'
    elif act == 'Rock Punch':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance crushing melee damage.'
    elif act == 'Zephyr Lance':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche slashing spell damage. Costs 2 magick.'
    elif act == 'Lift':
        return 'Spell target gets effect that changes move type to flying. Duration is reason. Level is wisdom.'
    elif act == 'Mass Hysteria':
        return 'The next five units remaining to act in initiative queue, on to-hit wisdom vs wisdom, get -5 sanity effect. Duration is reason. Level is wisdom.'
    elif act == 'Riposte':
        return 'An adjacent action target, on to-hit agility vs agility, gets an attack effect that causes its melee damage dealt to be reduced to 1 on failing an agility vs agility to-hit check vs defender. Duration is reason. Level is wisdom.'
    elif act == 'Cloister':
        return 'A spell target in range reason has all of its effects levels raised by 6.'
    elif act == 'Genjutsushi':
        return 'Spell target in range reason gets an attack effect. When dealing melee or ranged damage, this unit gets an effect granting invisibility lasting 1 turn at level of its own agility. The effect is added immediately on resolution of the attack effect (before any later attack/defense effects or damage being dealt). The spell itself has duration reason and level wisdom.'
    elif act == 'Molten Claws':
        return 'Adds attack effect to self. Changes damage type to fire and adds 2 damage if type is melee. Duration is reason. Level is wisdom.'
    elif act == 'Bane Claws':
        return 'Adds attack effect to self. Changes damage type to poison, adds end-of-turn 2 poison damage effect to hit melee targets. Duration is reason. Level is wisdom.'
    elif act == 'Aura of Agony':
        return 'Spell target within range reason gets an effect that gives all enemy units (of caster) within range 2, -3 sanity. Duration is reason. Level is wisdom.'
    elif act == 'Dampening Emanation':
        return 'Spell target within range reason gets an effect that gives all units within range 2, -3 move range. Duration is reason. Level is wisdom.'
    elif act == 'Blind':
        return 'Spell target in range reason gets -3 ballistics and reason. Duration is reason. Level is wisdom.'
    elif act == 'Assail':
        return 'Adjacent action target, on to-hit agility vs agility, takes strength vs endurance slashing melee damage.'
    elif act == 'Wooden Skin':
        return 'Evolution that adds attack effect that changes attack type to crushing and leaves splinter effect on damaged targets, causing 2 piercing end-of-turn damage with duration reason and level wisdom.'
    elif act == 'Calcify':
        return 'Evolution that gives +2 endurance, wisdom, and psyche. Attack type changed to piercing. Adds weakness to crushing. Adds resistance to magick and electric. Cannot be used with wooden skin.'
    elif act == 'Unstable Fervor':
        return 'Evolution that gives +1 acts, moves, +5 initiative, removes all resistances. Attack type change to crushing. Cannot be used with chimeric mutation. Must have wooden skin or calcify.'
    elif act == 'Chimeric Mutation':
        return 'Evolution that changes move type to flying, gives +5 move range, removes all weakness. Adds Scorch action that targets as action any within range reason, and all within range 1 of that target, on wisdom vs wisdom to-hit, does psyche vs psyche fire ranged damage. Cannot be used with unstable fervor. Must have either wooden skin or calcify.'
    elif act == 'Moldering Effluvium':
        return 'Evolution that granting end of turn effect that gives -4 endurance to all adjacent enemies at duration reason and level wisdom. Adds resistance to poison and acid. Removes weakness to poison and acid. Cannot be used with squamous carapace. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation.'
    elif act == 'Squamous Carapace':
        return 'Evolution that removes slashing, piercing, fire, and cold weakness. Gives +2 strength and agility. End of turn heal 4 to caster. Cannot be used with moldering effluvium. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation.'
    elif act == 'Winnowing Verdure':
        return 'Evolution that adds proximity effect giving all enemy within range 3 of caster -4 agility, initiative, and also weakness to fire. Cannot be used with noxious respiration. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation, and moldering effluvium or squamous carapace.'
    elif act == 'Noxious Respiration':
        return 'Evolution that adds attack effect causing damage to add -3 reason and move range effect at duration reason and level wisdom. Attack type becomes poison. Removes all weaknesses from caster and adds all resistances. Cannot be used with winnowing verdure. Must have one of each wooden skin or calcify, unstable fervor or chimeric mutation, and moldering effluvium or squamous carapace.'
    elif act == 'Nimbus of Oppression':
        return 'Proximity effect on caster giving all units in range 3 -4 psyche. Costs 2 magick. Duration is reason. Level is wisdom.'
    elif act == 'Halo of Encumberance':
        return 'Proximity effect on caster giving all units in range 3 -4 strength. Costs 2 magick. Duration is reason. Level is wisdom.'
    elif act == 'Feedback':
        return 'Deal electric melee damage to an adjacent action target unit equal to the number of effects it has.'
    elif act == 'Trenchant Lunula':
        return 'An adjacent action target unit, on to-hit agility vs agility, takes strength vs endurance slashing melee damage and gets an effect giving -2 reason at duration reason and level wisdom.'
    elif act == 'Scorch':
        return 'Action target, and each adjacent, on to-hit wisdom vs wisdom, take psyche vs psyche fire ranged damage.'
    elif act == 'Psychic Suffocation':
        return 'Proximity effect giving all enemy within range 1 of caster -1 acts (remember that acts are determined for each unit at the begin of its round).'
    elif act == 'Mirror Armor':
        return 'Spell target in range reason gets effect: on taking spell type damage, if attacker misses wisdom vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. Duration reason. Level wisdom.'
    elif act == 'Pierce the Heart':
        return 'An adjacent action target unit, on to-hit agility vs agility, takes strength vs endurance piercing melee damage and gets an effect giving -2 strength at duration reason and level wisdom.'
    elif act == 'Nix':
        return 'Any of the caster hex effects currently active are attempted to be dispelled using wisdom+10 to allow changing hexes.'
    elif act == 'Torpor Field':
        return 'All enemy in range 3 get -4 move range.'
    elif act == 'Enmeshing Coils':
        return 'Spell target in range reason, and each adjacent enemy without this effect, get -3 agility.'
    elif act == 'Cleanse with Fire':
        return 'All enemy units within range 3 of caster, on to-hit wisdom vs wisdom, take psyche vs psyche fire spell damage.'
    elif act == 'Persecute':
        return 'All enemy units within range 3 of caster, on to-hit wisdom vs wisdom, lose magick equal to caster psyche.'
    elif act == 'Prophecy':
        return 'Spell target within range reason gets +3 reason effect at duraton reason and level wisdom.'
    elif act == 'Chain Lightning':
        return 'Action target within range ballistics, on to-hit marksmanship vs dodge, takes missle vs endurance electric ranged damage. If target is hit, chain lightning attempts to hit a random unit that has not yet been hit within range 3 and is not the caster. Chain lightning continues to pass as long as it successfully hits and there is a target in range.'
    elif act == 'Overload':
        return 'If caster strength and psyche are both at least 3 greater than their base values, caster gets effect granting +1 acts (acts are granted at begin of round) at duration reason and level wisdom.'
    elif act == 'Hidden Strike':
        return 'If caster is invisible, auto-hit an adjacent action target for strength vs endurance slashing melee damage.'
    elif act == 'Spit Venom':
        return 'Action target in range ballistics, on to-hit marksmanship vs dodge, takes missle vs dodge poison ranged damage and gets an effect causing 2 end-of-turn poison damage.'
    elif act == 'Hindering Mucilage':
        return 'A location within range ballistics gets a map effect causing units with normal move type to get -3 agility, dodge, and move range when occupying the location.'
    elif act == 'Wing Buffet':
        return 'An action target in range strength, on to-hit strength vs strength, is relocated to a random location among those furthest from the caster and within range caster strength from target.'
    elif act == 'Chameleon Camouflage':
        return 'Caster gains invisibility effect. Cannot be used if caster already has this effect or Shimmering Scales.'
    elif act == 'Shimmering Scales':
        return 'Caster gains psyshield effect. Cannot be used if caster already has this effect or Chameleon Camouflage.'
    elif act == 'Elemental Langour':
        return 'Spell target in range reason, on wisdom vs wisdom to-hit, gets an effect that removes resistance and adds weakness to fire, cold, and electric damage. Costs 3 magick.'
    elif act == 'Asthenia':
        return 'Spell target in range reason, on wisdom vs wisdom to-hit, gets an effect that removes resistance and adds weakness to slashing, piercing, and crushing damage. Costs 3 magick.'
    elif act == 'Detox':
        return 'Spell target in range reason has each of its effects with an end-of-turn effect attempted to dispel using the caster wisdom. Costs 2 magick.'
    elif act == 'Geomantic Clutch':
        return 'Spell target in range reason, on to-hit wisdom vs wisdom, takes psyche vs psyche crushing spell damage and an effect that reduces its move range by 3, if it does not have this reduction already. If the unit is flying move type, then add 3 to the damage and it gets an effect that changes its move type to normal. Costs 4 magick.'
    elif act == 'Biotranspose':
        return 'A spell target in range reason without this effect, on to-hit wisdom vs wisdom, gets an effect that switches its strength and psyche.'
    elif act == 'Agony':
        return 'Spell target in range reason, on to-hit marksmanship vs dodge, takes psyche vs psyche magick spell damage. Costs 1 magick.'
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    elif act == '':
        return ''
    else:
        return 'Some description'

def loc_effect_description(ef):
    if ef.name == 'Spore_Cloud':
        return '+2 dodge, reduces piercing, slashing, fire damage by 2 (min 1).'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Warpfire':
        return 'Start-of-turn relocate all within range 3 among random locations closest to warpfire.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Darkness':
        return '-2 move range from this location.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Smoke_Bomb':
        return 'Grants invisibility.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fuse_Trap':
        return 'On undo, do 3 explosive undo damage to each unit within range 3.'+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return ''+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return ''+' Duration = '+str(ef.duration)+', level = '+str(ef.level)
    else:
        return 'Some description'

# takes an Effect instance, returns a string descr, used in populate_context=>get_info/get_more_info
def effect_description(ef):
    if ef.name == 'Curse_of_Oriax':
        return '-1 psy,wis,rsn,san,init, 2 magick dmg eot, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pox':
        return 'Eot 3 poison dmg, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pestilence':
        return '3 poison dmg eot, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plague':
        return '-4 random effect, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gravity':
        return '-2 agility, dodge, and move range, dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hidden_From_the_Stars':
        return '+1 agility, dodge, wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Cloak':
        return 'Adds defense effect. If receiving slashing, piercing, or crushing damage, add invisibility to self for the remainder of turn. If receiving magick damage, add psyshield to self for remainder of turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Invisibility':
        return 'Adds Invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Plutonian_Psyshield':
        return 'Adds Psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Cosmic_Sight':
        return 'Removes Psyshield. Targets as action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Demonic_Sight':
        return 'Removes Invisibility. Targets as spell. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Beleth_Stun':
        return '-1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Beleth's_Command":
        return '+1 psyche, endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Paralyze':
        return '-3 move range (min 1) and -1 actions. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Scarab_Gestation':
        return 'Gives death trigger that summons Scarab. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dark_Shroud':
        return '+1 Dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Muddle':
        return 'End-of-turn, unit attacks self, agl vs agl, str vs end (own abilities) crushing damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Stalk':
        return 'Increases received slashing, piercing, and crushing damage by 2, if the type is melee of ranged. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Tendrils_Move':
        return '-2 (min 1 ) move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Tendrils_Drain':
        return '-2 random ability. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Rage':
        return '+3 strength, endurance, +4 psyche. 3 magick damage on end. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Doubling_Cube':
        return 'When receiving slashing, piercing, or crushing damage, attacker must hit (psyche vs psyche) or the damage is reduced to 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Tracer_Grenade':
        return '-4 dodge, lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Simulacrum':
        return '+4 agility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Molecular_Subversion':
        return 'Removes resistances to acid and explosive. Add weaknesses acid and explosive. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Minerva's_Gift":
        return '+1 agility and initiative. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bewitch':
        return 'Adds psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Read_the_Stars':
        return '+2 when dealing cold or electric damage, if the type is melee, ranged, or spell. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Psi_Blades':
        return 'Adds Psi Slash action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Energize':
        return '+1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Ghoul_Venom':
        return '-1 str, end. End-of-turn 2 poison damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Boiling_Blood':
        return '+4 str, -4 end. End-of-turn 2 fire damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dark_Sun':
        return '+1 actions. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Meditate':
        return '+1 psyche, +2 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mummify':
        return '+4 endurance. Move range reduced to 1. Berserker leap set to used (use may be regained through later spells/effects). dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Osiris_Blessing':
        return '+1 strength and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Osiris_Curse':
        return '-1 strength and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Disintegrate':
        return '-1 to random ability among str, agl, end, rsn, san and also additional -1 randomly among same at end-of-turn. 1 acid damage end-of-turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Warp_Insane':
        return '-2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hex':
        return '-1 str,agl,end,mm,dod,psy,wis,rsn,san,init. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Poison_Sting':
        return '-1 strength. 1 poison damage end-of-turn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Unholy_Chant':
        return '+1 all abilities (not actions, moves). dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Baleful_Stare':
        return '-1 psyche, end-of-turn 2 acid damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Brambles':
        return '-1 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mind_Rot':
        return '-3 wisdom, reason, sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Grasp_of_the_Old_Ones':
        return 'Lose psyshield and invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dispel':
        return 'Lose psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Burn':
        return 'Slashing, crushing, piercing, fire, and explosive damage increased by 2. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Flesh_Hooks':
        return 'Grants Hook Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Strength_Through_Wounding':
        return '+1 psyche and endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Analyze':
        return 'Removes resistances to slashing, piercing, crushing, and explosive damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Pierce_Shield':
        return 'Remove psyshield. -1 psyche and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Haste':
        return '+4 initiative. +1 agility, dodge, and moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Encumber':
        return '-4 initiative. -2 agility, marksmanship, dodge, and move range. -1 moves. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gaze':
        return '-2 strength, psyche, and move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Howl_From_Beyond':
        return '-3 sanity, -2 reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Track':
        return 'Lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Miasma_Drain':
        return '-1 wisdom and reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Miasma_Invis':
        return 'Lose invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Leprous Bite':
        return '-1 str, end, agl, mm, psy, wis, rsn, san, init. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Concerted_Volley':
        return '+X marksmanship. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Abeyance':
        return 'Action removed. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vengeance':
        return 'adds +1 to str,agl,end,psy,wis,rsn on non-sot/eot dmg. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vengeance_Boost':
        return '+1 str,agl,end,psy,wis,rsn. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Reveal_Psyshield':
        return 'Remove psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Reveal_Invisibility':
        return 'Remove invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Abeyance':
        return 'Remove chosen action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Roar_Friendly':
        return '+2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Roar_Enemy':
        return '-2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Anoint':
        return '+1 wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Devil's_Mark":
        return '+2 to chosen ability. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hook_Attack':
        return 'Wisdom vs dodge to-hit, psyche vs endurance piercing, ranged damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Contagion':
        return '-3 strength, agility, endurance, dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mesmerize':
        return 'At start-of-turn, on psyche save check fail (mod 0), unit takes crushing melee damage equal to its own strength vs endurance AND loses one action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Entrance':
        return '-3 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Enthrall':
        return '-2 strength, agility, marksmanship, dodge. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chill_Touch':
        return '-1 wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Vampiric_Bite':
        return '+3 psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bat_Form':
        return '+5 move range, flying move type, -3 strength, agility, endurance. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wolf_Form':
        return '+4 agility, +3 move range, -3 psyche and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hatred':
        return 'Whenever dealing melee damage, this unit gets +1 strength at duration reason and level wisdom of caster of this effect. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Hatred_Strength':
        return '+1 strength. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bone_Pincer_Attack':
        return 'Grants Bone Pincer Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Willful_Move':
        return 'Grants Move. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Corrosive_Attack':
        return 'Grants Corrosive Attack. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Alacrity':
        return '+5 agility, +4 move range and strength. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Farsight':
        return '+6 marksmanship, +2 ballistics, +4 missle. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fear':
        return '-1 move range and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Slow':
        return '-2 move range. Melee and ranged damage dealt is reduced by half (rounded down) minimum 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Iron_Spirit':
        return '+1 strength, endurance, and wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Strength_of_the_Void':
        return '+1 strength, endurance, and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Gift_of_Mars':
        return '+1 missle, marksmanship, and psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Mercury's_Blessing":
        return '+1 agility, dodge, and move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Duress':
        return '-4 reason and -7 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == "Tourach's_Hymn":
        return '-4 strength and agility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Staff_of_Vecna':
        return 'Removes psyshield. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Torment':
        return '-2 psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Shout':
        return '-2 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Riposte':
        return 'Melee damage dealt reduced to 1 on failing to-hit agility vs agility check against defender. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Lift':
        return 'Changes move type to flying. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Fog':
        return '-3 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dehydrate':
        return 'Adds fire weakness. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mass_Hysteria':
        return '-5 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Genjutsushi':
        return 'When dealing melee or ranged damage, this unit gets invisibility effect. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Genju_Invisibility':
        return 'Invisibility. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Molten_Claws':
        return 'Change melee damage to fire type, add 2 damage to melee. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bane_Claws':
        return 'Change melee damage to poison, add end-of-turn 2 poison damage bane poison to hit melee targets. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Bane_Poison':
        return 'End of turn 2 poison damage. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Blind':
        return '-3 ballistics and reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Nimbus_of_Oppression':
        return '-4 psyche. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Halo_of_Encumberance':
        return '-4 strength. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Trenchant_Lunula':
        return '-2 reason. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Dampening_Emanation':
        return '-3 move range. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Wooden_Skin':
        return 'Crushing attack type that leaves splinter effect causing 2 piercing end-of-turn damage at duration reason and level wisdom. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Calcify':
        return '+2 endurance, wisdom, and psyche. Adds weakness to crushing and resistance to magick and electric. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Unstable_Fervor':
        return '+1 acts, moves, +5 initiative. Remove all resistances. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Chimeric_Mutation':
        return 'Changes move type to flying, gives +5 move range, removes all weakness. Adds scorch action. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Moldering_Effluvium':
        return 'End-of-turn -4 endurance to adjacent enemies. Add resist poison and acid. Remove weakness poison and acid. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Squamous_Carapace':
        return 'Removes slashing, piercing, fire, and cold weakness. +2 strength and agility. End-of-turn heal 4 spirit. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Winnowing_Verdure':
        return 'All enemy range 3 get -4 agility and initiative, also fire weakness. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Noxious_Respiration':
        return 'Damage causes -3 reason and attack type becomes poison. Removes all weaknesses from caster and adds all resistances. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Aura_of_Agony':
        return 'All enemy in range 2 get -3 sanity. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == 'Mirror_Armor':
        return 'On taking spell type damage, if attacker misses wisdom vs dodge to-hit, redirect the damage to a random unit within range 3, if one exists, and reduce damage to original target to 1. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    elif ef.name == '':
        return '. dur = '+str(ef.duration)+', level = '+str(ef.level)
    else:
        return 'Some description'

def death_trigger_description(name):
    if name == 'Familiar_Death':
        return 'Owner takes 4 magick damage.'
    elif name == 'Contagion':
        return 'Each adjacent unit without this effect gets -3 strength, agility, endurance, and dodge. Duration is reason. Level is wisdom.'
    else:
        return 'Some Description'

def miss(loc):
    app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Miss!', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
    app.canvas.create_text(loc[0]*100-app.moved_right+51, loc[1]*100-app.moved_down+76, text = 'Miss!', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
    app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Miss!', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')

# takes start and end coord ([x,y]), returns True if no interceding 'block' sqrs, else False
def los(start, end):
    blocked = [c for c in app.coords if app.grid[c[0]][c[1]] == 'block']
    x = start[0]*100+50-app.moved_right
    y = start[1]*100+50-app.moved_down
    endx = end[0]*100+50-app.moved_right
    endy = end[1]*100+50-app.moved_down
    if x == endx:
        xstep = 0
        ystep = 10
    elif y == endy:
        xstep = 10
        ystep = 0
    else:
        slope = Fraction(abs(x - endx), abs(y - endy))
        xstep = slope.numerator
        ystep = slope.denominator
        while xstep + ystep < 10:
            xstep *= 2
            ystep *= 2
    def los_loop(sx, sy, ex, ey, xstep, ystep):
        if abs(sx - ex) < 15 and abs(sy - ey) < 15:# close enough to goal sqr
            return True
        if sx > ex:
            sx -= xstep
        elif sx < ex:
            sx += xstep
        if sy > ey:
            sy -= ystep
        elif sy < ey:
            sy += ystep
        cx = round_100(sx)
        cy = round_100(sy)
        if [cx,cy] in blocked:
            return False
        else:
            return los_loop(sx, sy, ex, ey, xstep, ystep)
    return los_loop(x, y, endx, endy, xstep, ystep)

# convenience funcs
def dist(loc1, loc2):
    return abs(loc1[0] - loc2[0]) + abs(loc1[1] - loc2[1])

# start is coord like [2,3], goal is list of coords like [[2,4],[4,5]...], grid is list of lists where each list is a 'row'
# 'row' holds strings ('', 'EntityID', or 'block')
# returns path from start to goal (list of coords)
def bfs(start, goal, grid):
    path = []
    q = [[start]]
    visited = [start]
    while q:
        path = q[0]
        q = q[1:]
        last = path[-1]
        if last in goal:
            return path
        adj = [c for c in app.coords if dist(c, last) == 1 and grid[c[0]][c[1]] == '']
        for s in adj:
            if s not in visited:
                q.append(path + [s])
                visited.append(s)
    return None

def to_hit(a1, a2):
    base = 50
    dif = a1 - a2
    base += (dif*5)
    rand = randrange(1, 100)
    if rand < base:
        return True
    else:
        return False
        
# add random element?
def damage(a1, a2):
    base = 4
    dif = a1 - a2
    if base + dif < 1: return 1 
    else: return base + dif
    
# takes 2 ent objects, a negative int amount, a string type 'melee', 'ranged', 'poison', or 'magick', and a lockname string to set
# following effects MAY change amount applied (amount is always the only value returned, whether changed or not), OR do different non-damage things
def apply_damage(attacker, defender, amount, type, sourcename, sourcetype, lockname):
    atk_loop(attacker.attack_effects[:] + app.loc_dict[tuple(attacker.loc)].atk_effects, attacker, defender, amount, type, sourcename, sourcetype, lockname)
    
def atk_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname):
    if effects_list == []:
        defense_loop(defender.defense_effects[:] + app.loc_dict[tuple(defender.loc)].def_effects[:], attacker, defender, amount, type, sourcename, sourcetype, lockname)
    else:
        ef = effects_list[0]
        effects_list = effects_list[1:]
        amount, type = lock(ef, attacker, defender, amount, type, sourcename, sourcetype)
        atk_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)
#         amount, time, type = ef(attacker, defender, amount, type, sourcename, sourcetype)
#         root.after(time, lambda el = effects_list, at = attacker, de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : atk_loop(el, at, de, am, ty, sn, st, ln))
        
def defense_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname):
    if effects_list == []:
        # delay to wait for lockvar to be created
        root.after(333, lambda at = attacker, de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : finish_apply_damage(apply_damage, at, de, am, ty, sn, st, ln))
    else:
        ef = effects_list[0]
        effects_list = effects_list[1:]
        amount, type = lock(ef, attacker, defender, amount, type, sourcename, sourcetype)
        defense_loop(effects_list, attacker, defender, amount, type, sourcename, sourcetype, lockname)
#         root.after(time, lambda el = effects_list, at = attacker, de = defender, am = amount, ty = type, sn = sourcename, st = sourcetype, ln = lockname : defense_loop(el, at, de, am, ty, sn, st, ln))

# func that is called with 'lock' must accept lockname which it changes after executing to signal completion
def lock(func, *args, **kwargs):
    name = 'dethlok'+str(app.death_count)
    app.death_count += 1
    app.dethloks[name] = tk.IntVar(0)
    return_args = func(*args, **kwargs, lockname = name)
    app.wait_variable(app.dethloks[name])
    return return_args

#
def finish_apply_damage(apply_damage, attacker, defender, amount, type, sourcename, sourcetype, lockname = None):
    amount = abs(amount) # get amount as pos value to apply resist/wknss
    resist = defender.get_resist()
    if type in resist:
        amount = max(1,amount//2)
    weak = defender.get_weak()
    if type in weak:
        amount = int(amount*1.5)
    pre = defender.spirit
    defender.spirit -= amount
    if defender.spirit > defender.base_spirit:
        defender.spirit = defender.base_spirit
    post = defender.spirit
    d = pre - post
    app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+64-app.moved_down, text = sourcename+' '+str(d)+' spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
    app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+65-app.moved_down, text = sourcename+' '+str(d)+' spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
    if defender.spirit <= 0:
        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+90-app.moved_down, text = defender.name.replace('_',' ') + ' Killed...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+91-app.moved_down, text = defender.name.replace('_',' ') + ' Killed...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        name = 'Dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda id = defender.id, name = name : app.kill(id, name))
        app.wait_variable(app.dethloks[name])
        app.dethloks[lockname].set(1)
    else:
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
        
# takes 2 ent objects, positive int amount
def apply_heal(healer, target, amount):
    target.spirit += amount
    if target.spirit > target.base_spirit:
        target.spirit = target.base_spirit
        
# takes two lists of lists (lists of coords, [[x,y],[x2,y2],...])
# returns a list of their intrsct or []
def intersect(lx,ly):
    tx = [tuple(s) for s in lx]
    ty = [tuple(s) for s in ly]
    nl = list(set(tx) & set(ty))
    return [list(t) for t in nl]

# GLOBALS
curs_pos = [0, 0]
selected = []
selected_vis = []
map_pos = [0, 0]
grid_pos = [0,0]


# change to only import what is neededmm
# import pygame
from pygame import mixer
freq = 44100     # audio CD quality
bitsize = -16    # unsigned 16 bit
channels = 1     # 1 is mono, 2 is stereo
buffer = 1024    # number of samples (experiment to get right sound)
# use this just for intro screen, ideally make it loop smoothly (no lull in sound)
mixer.init(freq, bitsize, channels, buffer)
background_music = mixer.Channel(0) # argument must be int
sound_effects = mixer.Channel(1)
# background_music.music.set_volume(0.7) # optional volume 0 to 1.0
# background_music.music.load('Ove Melaa - Dead, Buried and Cold.ogg')
# background_music.music.play(-1, 0)

class Dummy():
    def __init__(self):
        pass

class Death_Trigger():
    def __init__(self, name = None, level = None, undo_func = None, dt = None):
        self.name = name
        self.level = level
        self.undo_func = undo_func # called if dispelled
        self.dt = dt # death trigger func, called in kill()
        self.ts = app.count # timestamp, if order needed
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            return 'Dispelled'
        else:
            return 'Not Dispelled'


class Proximity_Effect():
    def __init__(self, name = None, ent = None, range = None, abl = None, abl_func = None, eot_func = None, sot_func = None, weak_func = None, resist_func = None):
        self.name = name
        self.ent = ent
        self.range = range
        self.abl = abl
        self.abl_func = abl_func
        self.eot_func = eot_func
        self.sot_func = sot_func
        self.weak_func = weak_func
        self.resist_func = resist_func
        self.ts = app.count
        app.count += 1
        
        self.img = ImageTk.PhotoImage(Image.open('animations/' + name + '/0.png'))
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/' + name + '/' + anim))
            self.anim_dict[i] = a
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]
        
    def get_locs(self):
        return [c for c in app.coords if self.range[0] <= dist(c,self.ent.loc) <= self.range[1]]
        
    
    
class Effect():
    def __init__(self, name = None, duration = None, level = None, undo_func = None, eot_func = None, sot_func = None):
        self.name = name
        self.sot_func = sot_func
        self.eot_func = eot_func
        self.undo_func = undo_func
        self.duration = duration
        self.level = level
        self.ts = app.count
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            return 'Dispelled'
        else:
            return 'Not Dispelled'

# instances of these exist in the effects_dict of Loc instances (one Loc instance for each x,y coord on map)
# app.loc_dict[(x,y)] = inst
class Local_Effect():
    def __init__(self, name = None, duration = None, level = None, undo_func = None, eot_func = None, sot_func = None, loc = None, avoid = None):
        self.name = name
        self.sot_func = sot_func
        self.eot_func = eot_func
        self.undo_func = undo_func
        self.duration = duration
        self.level = level
        self.loc = loc
        self.avoid = avoid
        self.ts = app.count
        app.count += 1
        
    def dispel(self, dsplr_abl):
        mod = (self.level - dsplr_abl) * 5 # apx range (45=>-45)
        chance = 50 - mod # apx range (95=>5)
        r = randrange(0,101)
        if r < chance:
            lock(self.undo_func)
            
            return 'Dispelled'
        else:
            return 'Not Dispelled'

class Vis():
    def __init__(self, name, loc):
        if name == 'Aura':
            self.name = name
            self.img = app.aura_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.aura_anims.items():
                self.anim_dict[k] = v
        elif name == 'Mortar':
            self.name = name
            self.img = app.mortar_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.mortar_anims.items():
                self.anim_dict[k] = v
        elif name == 'Pestilence':
            self.name = name
            self.img = app.pestilence_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.pestilence_anims.items():
                self.anim_dict[k] = v
        elif name == 'Plague':
            self.name = name
            self.img = app.plague_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.plague_anims.items():
                self.anim_dict[k] = v
        elif name == 'Toxic_Miasma':
            self.name = name
            self.img = app.toxic_miasma_anims[0]
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            for k,v in app.toxic_miasma_anims.items():
                self.anim_dict[k] = v
        else:
            self.name = name
            self.img = ImageTk.PhotoImage(Image.open('animations/' + name + '/0.png'))
            self.loc = loc
            self.anim_dict = {}
            self.anim_counter = 0
            anims = [a for r,d,a in walk('animations/' + self.name + '/')][0]
            anims = [a for a in anims[:] if a[0] != '.']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/' + name + '/' + anim))
                self.anim_dict[i] = a
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]


class Loc():
    def __init__(self, loc):
        self.loc = loc
        self.move_range_effects = []
        self.atk_effects = []
        self.def_effects = []
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.msl_effects = []
        self.mm_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.type_effects = []
        self.weak_effects = []
        self.resist_effects = []
        self.move_range_effects = []
        self.action_effects = []
#         self.cantrips_effects = []
        self.smns_effects = []
        self.effects_dict = {}

class Sqr():
    def __init__(self, img, loc):
        self.img = img
        self.loc = loc
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in app.sqr_anims.items():
            self.anim_dict[k] = v
            
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]


class Entity():
    def __init__(self, name, id, img, loc, owner, type = 'normal'):
        self.name = name
        self.id = id
        self.img = img
        self.loc = loc
        self.owner = owner
        self.immovable = False
        self.type = type # just used for 'large' ents
        if self.type == 'large':
            self.tags = ('large', self.id)
        else:
            self.tags = id
        self.base_spirit = self.spirit
        self.base_magick = self.magick
        self.base_mvs = self.mvs
        self.base_acts = self.acts
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.attack_effects = []
        self.defense_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.move_range_effects = []
        self.death_triggers = [] # hold Death_Trigger instances
        self.resist_effects = [] # obj.resist and obj.weak are in subclass instances
        self.weak_effects = [] # resist/weak resolved in apply_damage()
        self.types = [] # holds invis, psyshield...
        self.type_effects = []
        self.effects_dict = {}
        self.anim_dict = {}
        self.init_normal_anims()
        self.anim_counter = randrange(0, len(self.anim_dict.keys()))
        self.action_effects = []
        self.move_type_effects = []
        
    def get_move_type(self):
        type = self.move_type
        for ef in self.move_type_effects:
            type = ef(type)
        return type
        
    def legal_moves(self):
        mt = self.get_move_type()
        if mt == 'normal':
            return self.normal_moves()
        elif mt == 'ethereal' or mt == 'flying' or mt == 'teleport':
            return self.flying_moves()
        elif mt == 'charge':
            return self.charge_moves()
        else:
            print('unknown move type legal moves')
            
    def charge_moves(self):
        loc = self.loc
        # get all cs in each lateral direction, filter by move range
        mvs = []
        cs = app.coords
        def north(dst):
            if [loc[0],loc[1]-dst] in cs and app.grid[loc[0]][loc[1]-dst] == '':
                mvs.append([loc[0],loc[1]-dst])
                north(dst+1)
        north(1)
        def south(dst):
            if [loc[0],loc[1]+dst] in cs and app.grid[loc[0]][loc[1]+dst] == '':
                mvs.append([loc[0],loc[1]+dst])
                south(dst+1)
        south(1)
        def west(dst):
            if [loc[0]-dst,loc[1]] in cs and app.grid[loc[0]-dst][loc[1]] == '':
                mvs.append([loc[0]-dst,loc[1]])
                west(dst+1)
        west(1)
        def east(dst):
            if [loc[0]+dst,loc[1]] in cs and app.grid[loc[0]+dst][loc[1]] == '':
                mvs.append([loc[0]+dst,loc[1]])
                east(dst+1)
        east(1)
        mvs = list(filter(lambda x : dist(x, self.loc) <= self.get_abl('move_range'), mvs))
        return mvs
        
    def flying_moves(self):
        loc = self.loc[:]
        mvlist = []
        for c in app.coords:
            if dist(loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '':
                mvlist.append(c)
        return mvlist
        
    def normal_moves(self):
        loc = self.loc[:]
        mvlist = []
        sqr_cost_map = {}
        def findall(loc, start, distance):
            if start > distance:
                return
            adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
            for s in adj:
                if tuple(s) in sqr_cost_map:
                    if sqr_cost_map[tuple(s)] < start:
                        continue
                sqr_cost_map[tuple(s)] = start
                if s not in mvlist:
                    mvlist.append(s)
                findall(s, start+1, distance)
        findall(loc, 1, self.get_abl('move_range'))
        return mvlist
        
    def sanity_check(self):
        val = randrange(0,101)
        san = self.get_abl('san')
        san *= 10
        if val > san:
            return 'Fail'
        else:
            return 'Pass'
        
    # types holds 'large', 'invisibility', 'psyshield'...
    def get_types(self):
        ts = self.types[:]
        for ef in self.type_effects + app.loc_dict[tuple(self.loc)].type_effects:
            ts = ef(ts)
        return ts
        
    # called in atk/def loops during apply_damage
    def get_resist(self):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get prox efcts with resist funcs
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.resist_func != None and self.loc in ef.get_locs():
                prox_efcts.append(ef.resist_func)
        rs = self.resist[:]
        for ef in self.resist_effects + prox_efcts + app.loc_dict[tuple(self.loc)].resist_effects:
            rs = ef(rs)
        return rs
        
    # called in atk/def loops during apply_damage
    def get_weak(self):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get prox efcts with weak funcs
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.weak_func != None and self.loc in ef.get_locs():
                prox_efcts.append(ef.weak_func)
        ws = self.weak[:]
        for ef in self.weak_effects + prox_efcts + app.loc_dict[tuple(self.loc)].weak_effects:
            ws = ef(ws)
        return ws
        
    # actions are acts/spells that are granted to objects temporarily
    def get_actions(self):
        actions = dict(self.actions)
        for ef in self.action_effects + app.loc_dict[tuple(self.loc)].action_effects:
            actions = ef(actions)
        return actions
            
    # called in animation loop for all objects (ent, vis)
    def rotate_image(self):
        total_imgs = len(self.anim_dict.keys())-1
        if self.anim_counter == total_imgs:
            self.anim_counter = 0
        else:
            self.anim_counter += 1
        self.img = self.anim_dict[self.anim_counter]
            
    # should be called only by ents that HAVE attack animations
    def init_attack_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./attack_animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('attack_animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
    # called for protaganists that have cast anims (witch/agnes)
    def init_cast_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./casting_animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('casting_animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
    # sets an objects animations to those in the same file as its name
    def init_normal_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/' + self.name + '/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/' + self.name + '/' + anim))
            self.anim_dict[i] = a
            
    # get an ability/stat that is affected by an effects stack on the ent itself as well as an effect stack from the location it occupies
    def get_abl(self, abl):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get all prox efcts of same abl
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.abl == abl and self.loc in ef.get_locs():
                prox_efcts.append(ef.abl_func)
        if abl == 'str':
            q = self.str_effects + prox_efcts + app.loc_dict[tuple(self.loc)].str_effects
            base = self.str
        elif abl == 'agl':
            q = self.agl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].agl_effects
            base = self.agl
        elif abl == 'end':
            q = self.end_effects + prox_efcts + app.loc_dict[tuple(self.loc)].end_effects
            base = self.end
        elif abl == 'mm':
            q = self.mm_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mm_effects
            base = self.mm
        elif abl == 'msl':
            q = self.msl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].msl_effects
            base = self.msl
        elif abl == 'bls':
            q = self.bls_effects + prox_efcts + app.loc_dict[tuple(self.loc)].bls_effects
            base = self.bls
        elif abl == 'dodge':
            q = self.dodge_effects + prox_efcts + app.loc_dict[tuple(self.loc)].dodge_effects
            base = self.dodge
        elif abl == 'psyche':
            q = self.psyche_effects + prox_efcts + app.loc_dict[tuple(self.loc)].psyche_effects
            base = self.psyche
        elif abl == 'wis':
            q = self.wis_effects + prox_efcts + app.loc_dict[tuple(self.loc)].wis_effects
            base = self.wis
        elif abl == 'rsn':
            q = self.rsn_effects + prox_efcts + app.loc_dict[tuple(self.loc)].rsn_effects
            base = self.rsn
        elif abl == 'init':
            q = self.init_effects + prox_efcts + app.loc_dict[tuple(self.loc)].init_effects
            base = self.init
        elif abl == 'san':
            q = self.san_effects + prox_efcts + app.loc_dict[tuple(self.loc)].san_effects
            base = self.san
        elif abl == 'acts':
            q = self.acts_effects + prox_efcts + app.loc_dict[tuple(self.loc)].acts_effects
            base = self.base_acts
        elif abl == 'mvs':
            q = self.mvs_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mvs_effects
            base = self.base_mvs
#         elif abl == 'cantrips':
#             q = self.cantrips_effects + app.loc_dict[tuple(self.loc)].cantrips_effects
#             base = self.base_cantrips
        elif abl == 'smns':
            q = self.smns_effects + prox_efcts + app.loc_dict[tuple(self.loc)].smns_effects
            base = self.base_smns
        elif abl == 'move_range':
            q = self.move_range_effects + prox_efcts + app.loc_dict[tuple(self.loc)].move_range_effects
            base = self.move_range
        for func in q:
            base = func(base)
        return base
        
    # the ent performs a save check against one of its abilities with a modifier
    def save_check(self, abl, mod = 0):
        a = self.get_abl(abl)
        a += mod
        a *= 10
        rand = randrange(0, 102)
        if rand < a:
            return 'Pass'
        else:
            return 'Fail'
            
            
    # for use with Legerdemain cantrip
    def leger_move(self, end):
        oldloc = self.loc[:]
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        un ='Teleport'+str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Legerdemain', loc = oldloc[:])
        vis = app.vis_dict[un]
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = un)
        root.after(999, lambda end = end, un = un : self.leger_move_finish(end, un))
        
    def leger_move_finish(self, endloc, un):
#         app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
#         app.grid[endloc[0]][endloc[1]] = self.id
        app.canvas.delete(un)
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        del app.vis_dict[un]
        app.vis_dict[un] = Vis(name = 'Legerdemain', loc = endloc[:])
        vis = app.vis_dict[un]
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = un)
        root.after(999, lambda endloc = endloc, un = un : self.cleanup_leger_move(endloc, un))
        
    def cleanup_leger_move(self, endloc, un):
        try: 
            del app.vis_dict[un]
            app.canvas.delete(un)
        except: pass
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
            
            
    # for use with Berserker throw
    def throw_move(self, sqr, lockname = None):
        global selected
        selected = [self.id]
        ln = lockname
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
#                 self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.throw_move_finish(end_sqr, start_sqr, ln)
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
    def throw_move_finish(self, end, start, ln):
        sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
#         if app.num_players == 2 or self.owner == 'p1':
#         app.unbind_all()
#         app.rebind_all()
        app.dethloks[ln].set(1)
            
            
# For computer controlled entities
class Bot(Entity):
    def __init__(self, name = None, img = None, loc = None, owner = None, type = 'normal'):
        if type == 'large':
            id = self.id
        else:
            id = 'b'+str(app.count)
            app.count += 1
        super().__init__(name, id, img, loc, owner, type = type)
        
    def do_move(self, loc, lockname = None):
        ln = lockname
        mt = self.get_move_type()
        if mt == 'normal' or mt == 'charge':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda loc = loc, ln = ln : self.ai_normal_move(loc, ln))
        elif mt == 'flying' or mt == 'ethereal':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda loc = loc, ln = ln : self.ai_flying_move(loc, ln))
        elif mt == 'teleport':
            root.after(555, lambda loc = loc : app.focus_square(loc))
            root.after(666, lambda loc = loc, ln = ln : self.ai_teleport_move(loc, ln))
        
    # debug add other move sounds...
    def ai_normal_move(self, endloc, lockname):
        global selected
        if isinstance(self, Skeleton):
            effect1 = mixer.Sound('Sound_Effects/undead_move.ogg')
            effect1.set_volume(2)
            sound_effects.play(effect1, -1)
        elif isinstance(self, Undead_Knight):
            effect1 = mixer.Sound('Sound_Effects/undead_knight_move.ogg')
            effect1.set_volume(.5)
            sound_effects.play(effect1, -1)
        else:
            effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, -1)
        selected = [self.id]
        id = self.id
        start_sqr = self.loc[:]
        path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
                Bot.ai_finish_move(self, endloc, start_sqr, lockname)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
    
    # used by flying and ethereal ents (any ai ents that move unobstructed)
    def ai_flying_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        app.focus_square(sqr)
        if isinstance(self, Revenant):
            effect1 = mixer.Sound('Sound_Effects/revenant_move.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, 0)
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 60 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                Bot.ai_finish_move(self, end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
        
    # uses generic teleport animation (yellow circles)
    def ai_teleport_move(self, endloc, lockname):
        global selected
        oldloc = self.loc[:]
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = oldloc[:])
        vis = app.vis_dict['Teleport']
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda  ent = self, el = endloc, ln = lockname : Bot.ai_continue_teleport(ent, el, ln))
        
    def ai_continue_teleport(self, endloc, lockname):
        app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
        app.grid[endloc[0]][endloc[1]] = self.id
        try: 
            del app.vis_dict['Teleport']
            app.canvas.delete('Teleport')
        except: pass
        app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = endloc[:])
        vis = app.vis_dict['Teleport']
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda ent = self, el = endloc, ln = lockname : Bot.ai_cleanup_teleport(ent, el, ln))
        
    def ai_cleanup_teleport(self, endloc, lockname):
        del app.vis_dict['Teleport']
        app.canvas.delete('Teleport')
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
        
    # to be used by ai_normal_move, ai_flying_move
    def ai_finish_move(self, end_sqr, start_sqr, lockname):
        global selected
        sound_effects.stop()
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
        
        
# for user controlled/summoned ents
# wrappers around Entity.do_move(self, endloc, lockname) to handle hotkeys/buttons
class Summon(Entity):
    def __init__(self, name, id, img, loc, owner, type = 'normal'):
        super().__init__(name, id, img, loc, owner, type = type)
        
    # called from the user-interface, dispatches to below functions depending on move_type etc...
    def move(self, event = None):
        if self.mvs < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_move)
        sqrs = self.legal_moves()
        app.animate_squares(sqrs)
        b = tk.Button(app.context_menu, text = 'Confirm Move Square', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.call_do_move(e, sqr, sqrs))
        b.pack(side = 'top', pady = 3)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 20), fg = 'tan3', highlightbackground = 'tan3', command = self.cleanup_move)
        b2.pack(side = 'top', pady = 3)
        app.context_buttons.append(b2)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.call_do_move(e, sqr, sqrs))
        
    def call_do_move(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.mvs -= 1
        lock(self.do_move, sqr[:])
        
    def cleanup_move(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def do_move(self, loc, lockname = None):
        ln = lockname
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        mt = self.get_move_type()
        if mt == 'normal' or mt == 'charge':
            self.normal_move(loc, ln)
        elif mt == 'flying' or mt == 'ethereal':
            self.unobstructed_move(loc, ln)
        elif mt == 'teleport':
            self.teleport_move(loc, ln)
            
    def normal_move(self, loc, lockname = None):
        ln = lockname
        global selected
        effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, -1)
        # start ANIM here
        id = self.id
        start_sqr = self.loc[:]
        end_sqr = loc[:]
        selected = [id]
        # get path and move_loop over each sqr until path consumed
        path = bfs(start_sqr, [end_sqr], app.grid) # end_sqr must be in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            if x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            if y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.normal_move_finish(end_sqr, start_sqr, ln)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path)
            
    def normal_move_finish(self, end, start, ln):
        sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.rebind_all()
        app.dethloks[ln].set(1)
            
    # for flying, ethereal, ents unobstructed by 'block' or other ents
    def unobstructed_move(self, sqr, lockname = None):
        global selected
        selected = [self.id]
        ln = lockname
        if isinstance(self, Familiar_Imp):
            effect1 = mixer.Sound('Sound_Effects/familiar_imp_move.ogg')
            effect1.set_volume(.5)
            sound_effects.play(effect1, -1)
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.normal_move_finish(end_sqr, start_sqr, ln)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
    def teleport_move(self, end, ln):
#         global selected
        oldloc = self.loc[:]
        if isinstance(self, Umbrae_Wolf):
            effect1 = mixer.Sound('Sound_Effects/shadow_move.ogg')
            effect1.set_volume(.3)
            sound_effects.play(effect1, 0)
            app.vis_dict['Mist_Move'] = Vis(name = 'Mist_Move', loc = oldloc[:])
            vis = app.vis_dict['Mist_Move']
        else:
            effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, 0)
            app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = oldloc[:])
            vis = app.vis_dict['Teleport']
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda end = end, ln = ln : self.teleport_move_finish(end, ln))
        
    def teleport_move_finish(self, endloc, ln):
        app.grid[self.loc[0]][self.loc[1]] = ''
        app.canvas.delete(self.id)
        self.loc = endloc[:]
        app.grid[endloc[0]][endloc[1]] = self.id
        app.canvas.delete('Teleport')
        if isinstance(self, Umbrae_Wolf):
            del app.vis_dict['Mist_Move']
            app.vis_dict['Mist_Move'] = Vis(name = 'Mist_Move', loc = endloc[:])
            vis = app.vis_dict['Mist_Move']
        else:
            effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, 0)
            del app.vis_dict['Teleport']
            app.vis_dict['Teleport'] = Vis(name = 'Teleport', loc = endloc[:])
            vis = app.vis_dict['Teleport']
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Teleport')
        root.after(1666, lambda endloc = endloc, ln = ln : self.cleanup_teleport(endloc, ln))
        
    def cleanup_teleport(self, endloc, ln):
        try: 
            del app.vis_dict['Teleport']
            app.canvas.delete('Teleport')
        except: pass
        try: 
            del app.vis_dict['Mist_Move']
            app.canvas.delete('Mist_Move')
        except: pass
        app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        try: app.canvas.tag_lower(self.tags, 'large')
        except: pass
        app.canvas.tag_lower(self.tags, 'maptop')
#         if app.num_players == 2 or self.owner == 'p1':
        app.unbind_all()
        app.rebind_all()
        app.dethloks[ln].set(1)
        
        
        
class Tomb(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Vivify':self.vivify}
            self.str = 1
            self.agl = 1
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 2
            self.wis = 3
            self.rsn = 1
            self.san = 20
            self.init = 1
            self.spirit = 10
            self.magick = 12
            self.acts = 1
            self.mvs = 0
            self.move_range = 0
            self.level = level
        elif level == 2:
            self.actions = {'Vivify':self.vivify}
            self.str = 1
            self.agl = 1
            self.end = 7
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 1
            self.psyche = 3
            self.wis = 4
            self.rsn = 1
            self.san = 20
            self.init = 1
            self.spirit = 13
            self.magick = 15
            self.acts = 1
            self.mvs = 0
            self.move_range = 0
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['slashing', 'fire', 'piercing', 'poison', 'cold', 'magick', 'elec', 'acid']
        super().__init__(name, id, img, loc, owner)
        
    def vivify(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_vivify)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_vivify(event = e, s = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Vivify', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_vivify(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vivify(self, event, s, sqrs):
        id = app.grid[s[0]][s[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, (Witch, Tomb)):
            return
        if s not in sqrs:
            return
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(.6)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         self.init_cast_anims()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Vivify', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Vivify', font = ('chalkduster', 16), fill = 'azure', tags = 'text')
        amt = self.get_abl('psyche')
        apply_heal(self, ent, amt)
        ent.magick += amt
        if ent.magick > ent.base_magick:
            ent.magick = ent.base_magick
        app.vis_dict['Vivify'] = Vis(name = 'Vivify', loc = ent.loc[:])
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+89-app.moved_down, text = '+'+str(amt)+' spirit, magick', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+90-app.moved_down, text = '+'+str(amt)+' spirit, magick', font = ('chalkduster', 13), fill = 'azure', tags = 'text')
        root.after(2111, self.cleanup_vivify)


        
    def cleanup_vivify(self, event = None):
#         self.init_normal_anims()
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Vivify']
            app.canvas.delete('Vivify')
        except: pass
        try: app.canvas.delete('text')
        except: pass
        

class Illusionist(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Pyrotechnics':self.pyrotechnics, 'Simulacrum':self.simulacrum,'Gate':self.gate, 'Mortar':self.mortar, 'Smoke Bomb':self.smoke_bomb, 'Analyze':self.analyze}
            self.str = 2
            self.agl = 4
            self.end = 4
            self.mm = 7
            self.msl = 4
            self.bls = 8
            self.dodge = 7
            self.psyche = 5
            self.wis = 6
            self.rsn = 4
            self.san = 14
            self.init = 6
            self.spirit = 14
            self.magick = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Pyrotechnics':self.pyrotechnics, 'Simulacrum':self.simulacrum,'Gate':self.gate, 'Mortar':self.mortar, 'Smoke Bomb':self.smoke_bomb, 'Analyze':self.analyze, 'Tracer Grenade':self.tracer_grenade, 'Doubling Cube':self.doubling_cube}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 8
            self.msl = 6
            self.bls = 9
            self.dodge = 7
            self.psyche = 6
            self.wis = 7
            self.rsn = 5
            self.san = 14
            self.init = 6
            self.spirit = 21
            self.magick = 17
            self.acts = 2
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'teleport'
        self.weak = ['crushing']
        self.resist = ['explosive', 'fire']
        super().__init__(name, id, img, loc, owner)

    def analyze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_analyze)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_analyze(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Analyze Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_analyze(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_analyze(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Analyze', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Analyze', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Analyze'] = Vis(name = 'Analyze', loc = sqr[:])
        vis = app.vis_dict['Analyze']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Analyze')
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            def analyze_resist(rs):
                return [r for r in rs if r != 'slashing' and r != 'piercing' and r != 'crushing' and r != 'explosive']
            p1 = partial(analyze_resist)
            ent.resist_effects.append(p1)
            def undo(id, p1, lockname = None):
                app.ent_dict[id].resist_effects.remove(p1)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1)
            n = 'Analyze' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Analyze', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Remove physical resists', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Remove physical resists', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_analyze)
        else:
            miss(app.ent_dict[id].loc)
            root.after(2333, self.finish_analyze)

        
    def finish_analyze(self, event = None):
        try: 
            del app.vis_dict['Analyze']
            app.canvas.delete('Analyze')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()


    def smoke_bomb(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Spore_Cloud' in loc_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_smoke_bomb)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_smoke_bomb(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Smoke Bomb Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_smoke_bomb(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_smoke_bomb(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Smoke_Bomb' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Smoke Bomb', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Smoke Bomb', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Smoke_Bomb' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Smoke_Bomb', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def smoke_effect(types):
            return types+['invisibility']
        p = partial(smoke_effect)
        app.loc_dict[tuple(sqr)].type_effects.append(p)
        def undo(s, un, p_ef, lockname = None):
            app.loc_dict[tuple(s)].type_effects.remove(p_ef)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Smoke_Bomb', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('mm'), loc = sqr[:], avoid = -5)
        root.after(1666, self.cleanup_smoke_bomb)
        
    def cleanup_smoke_bomb(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass

    def doubling_cube(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_doubling_cube)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_doubling_cube(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Doubling Cube Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_doubling_cube(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_doubling_cube(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Doubling Cube', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Doubling Cube', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
        def cleanup_dubcube(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        ents = [v for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc,sqr) <= 1]
        for ent in ents:
            if 'Doubling_Cube' not in [v.name for k,v in ent.effects_dict.items()]:
                s = ent.loc[:]
                uniq = 'Doubling_Cube'+str(app.count)
                app.count += 1
                app.vis_dict[uniq] = Vis(name = 'Doubling_Cube', loc = s)
                root.after(2555, lambda n = uniq : cleanup_dubcube(n))
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Doubling_Cube')
                app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+64, text = 'Doubled...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+65, text = 'Doubled...', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
                def doubled(atkr, dfndr, amt, type, sn, st, lockname = None):
                    if st == 'melee' or st == 'ranged' and (type == 'slashing' or type == 'piercing' or type == 'crushing') and amt < 0:
                        if to_hit(atkr.get_abl('psyche'),dfndr.get_abl('psyche')):
                            app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+74, text = 'Attacker psyche hit, avoids double...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                            app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+75, text = 'Attacker psyche hit, avoids double...', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                            return (amt, type)
                        else:
                            app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+74, text = 'Double Absorbs, dmg reduced to 1', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                            app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+75, text = 'Double Absorbs, dmg reduced to 1', justify = 'center', fill = 'goldenrod', font = ('chalkduster', 13), tags = 'text')
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                            return (-1, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amt, type)
                p = partial(doubled)
                ent.defense_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.defense_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Doubling_Cube'+str(app.count)
                app.count += 1
                ent.effects_dict[n] = Effect(name = 'Doubling_Cube', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_doubling_cube)
        
        
        
    def finish_doubling_cube(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)


    def tracer_grenade(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_mortar)
        sqrs = [s for s in app.coords if (self.get_abl('bls')) < dist(self.loc, s) <= (self.get_abl('bls')+2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_tracer_grenade(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Grenade', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_tracer_grenade(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tracer_grenade(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/mortar.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Tracer_Grenade'] = Vis(name = 'Tracer_Grenade', loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
        selected_vis = ['Tracer_Grenade']
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def mortar_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                app.vis_dict['Tracer_Grenade'].rotate_image()
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete('Tracer_Grenade')
                app.canvas.create_image(x, y, image = app.vis_dict['Tracer_Grenade'].img, tags = 'Tracer_Grenade')
                app.canvas.tag_raise('Tracer_Grenade')
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.continue_tracer_grenade(end_sqr)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : mortar_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        mortar_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
        
    def continue_tracer_grenade(self, sqr):
        global selected_vis
        app.canvas.delete('text')
        del app.vis_dict['Tracer_Grenade']
        app.canvas.delete('Tracer_Grenade')
        selected_vis = []
        effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.vis_dict['Tracer_Exploded'] = Vis(name = 'Tracer_Exploded', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Tracer_Exploded'].img, tags = 'Tracer_Exploded')
        def cleanup_explode():
            del app.vis_dict['Tracer_Exploded']
            app.canvas.delete('Tracer_Exploded')
        root.after(999, cleanup_explode)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 2 and 'Tracer_Grenade' not in [j.name for j in v.effects_dict.values()]]
        # mortar loop
        def mortar_loop(ents):
            if ents == []:
                self.cleanup_mortar()
            else:
                effect1 = mixer.Sound('Sound_Effects/traced.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                n = 'Traced' + str(app.count)
                app.count += 1
                loc = app.ent_dict[id].loc[:]
                app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Traced', loc = loc)
                def cleanup_vis(name):
                    app.canvas.delete('text')
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')):
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Traced...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Traced...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    def tracer_effect(stat):
                        stat -= 4
                        if stat < 1:
                            return 1
                        else:
                            return stat
                    p = partial(tracer_effect)
                    app.ent_dict[id].dodge_effects.append(p)
                    def tracer_strip(types):
                        return [t for t in types if t != 'invisibility']
                    p2 = partial(tracer_strip)
                    app.ent_dict[id].type_effects.append(p2)
                    def undo(id, p, p2, lockname = None):
                        app.ent_dict[id].dodge_effects.remove(p)
                        app.ent_dict[id].type_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p, p2)
                    app.ent_dict[id].effects_dict['Tracer_Grenade'] = Effect(name = 'Tracer_Grenade', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('bls'))
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
                else:
                    miss(app.ent_dict[id].loc[:])
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
        mortar_loop(ents)
        
    def cleanup_tracer_grenade(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
#         app.unbind_all()
        app.rebind_all()



    def mortar(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_mortar)
        sqrs = [s for s in app.coords if self.get_abl('bls') < dist(self.loc, s) <= (self.get_abl('bls')+2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_mortar(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location for Mortar', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mortar(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mortar(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/mortar.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Mortar'] = Vis(name = 'Mortar', loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
        selected_vis = ['Mortar']
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def mortar_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                app.vis_dict['Mortar'].rotate_image()
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete('Mortar')
                app.canvas.create_image(x, y, image = app.vis_dict['Mortar'].img, tags = 'Mortar')
                app.canvas.tag_raise('Mortar')
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.continue_mortar(end_sqr)
            else: # CONTINUE LOOP
                root.after(33, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : mortar_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        mortar_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
        
        
    def continue_mortar(self, sqr):
        global selected_vis
        app.canvas.delete('text')
        del app.vis_dict['Mortar']
        app.canvas.delete('Mortar')
        selected_vis = []
        effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.vis_dict['Mortar_Exploded'] = Vis(name = 'Mortar_Exploded', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mortar_Exploded'].img, tags = 'Mortar_Exploded')
        def cleanup_explode():
            del app.vis_dict['Mortar_Exploded']
            app.canvas.delete('Mortar_Exploded')
        root.after(999, cleanup_explode)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 2]
        # mortar loop
        def mortar_loop(ents):
            if ents == []:
                self.cleanup_mortar()
            else:
                effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                n = 'Pain_Explode' + str(app.count)
                app.count += 1
                loc = app.ent_dict[id].loc[:]
#                 root.after(13,lambda loc = loc : app.focus_square(loc))
                app.focus_square(loc)
#                 app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Pain_Explode', loc = loc)
                def cleanup_vis(name):
                    app.canvas.delete('text')
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
                    d = max(1,(self.get_abl('msl')-choice([1,2,3])))
                    root.after(1666, lambda name = n : cleanup_vis(name))
                    lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Mortar', 'ranged')
                    mortar_loop(ents)
                else: # MISS
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda n = n : cleanup_vis(n))
                    root.after(1777, lambda ents = ents : mortar_loop(ents))
        mortar_loop(ents)
        
    def cleanup_mortar(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
#         app.unbind_all()
        app.rebind_all()
        
    def pyrotechnics(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_pyrotechnics)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pyrotechnics(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Pyrotechnics', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pyrotechnics(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pyrotechnics(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Pyrotechnics'] = Vis(name = 'Pyrotechnics', loc = sqr[:])
        vis = app.vis_dict['Pyrotechnics']
        if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
            d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
            root.after(1666, lambda e = None : self.cleanup_pyrotechnics(event = e))
            lock(apply_damage, self, app.ent_dict[id], -d, 'explosive', 'Pyrotechnics', 'ranged')
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, lambda e = None : self.cleanup_pyrotechnics(event = e))
        
    def cleanup_pyrotechnics(self, event = None):
        try: 
            del app.vis_dict['Pyrotechnics']
            app.canvas.delete('Pyrotechnics')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        
        
    def simulacrum(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_simulacrum)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_simulacrum(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Simulacrum', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_simulacrum(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_simulacrum(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 1:
            return
        if 'Simulacrum' in ent.effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 1
        # DO SIMULACRUM EFFECTS
        def simulacrum_effect(stat):
            stat += 4
            return stat
        p = partial(simulacrum_effect)
        ent.agl_effects.append(p)
        def un(ent, func, lockname = None):
            ent.agl_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Simulacrum' + str(app.count)
        ent.effects_dict['Simulacrum'] = Effect(name = 'Simulacrum', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        # DO SIMULACRUM VISUALS
        start_loc = ent.loc[:]
        app.vis_dict['Simulacrum'] = Vis(name = 'Simulacrum', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Simulacrum'].img, tags = ('Simulacrum','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Simulacrum'].img, tags = ('Simulacrum','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Simulacrum', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Simulacrum', font = ('chalkduster', 14), fill = 'lightcyan', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis = ['Simulacrum']
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Simulacrum','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Simulacrum', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Simulacrum','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                root.after(666, self.cleanup_simulacrum)
            else:
                root.after(100, lambda vis = 'Simulacrum', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Simulacrum', x, y, end_left, id)
        simulacrum_loop_right('Simulacrum', x, y, end_right, id)
        
        
    def cleanup_simulacrum(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Simulacrum']
            app.canvas.delete('Simulacrum')
        except: pass
        app.canvas.delete('text')
        
        
    def gate(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_gate)
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if app.ent_dict[id].immovable == True:
            return
        if self.magick < 2:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_gate)
        distance = self.get_abl('rsn')
        app.cleanup_squares()
        sqrs = self.doorway_squares(distance)
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_gate)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id = id, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_gate(e, id, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
    
    def do_gate(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        self.magick -= 2
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/gate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        oldloc = app.ent_dict[id].loc[:]
        newloc = sqr[:]
        app.vis_dict['Gate'] = Vis(name = 'Gate', loc = oldloc[:])
        vis = app.vis_dict['Gate']
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = vis.img, tags = 'Gateway')
        root.after(1666, lambda newloc = newloc, id = id : self.finish_gate(newloc, id))
        
    def finish_gate(self, newloc, id):
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        app.canvas.delete(id)
        app.ent_dict[id].loc = newloc[:]
        app.grid[newloc[0]][newloc[1]] = id
        try: 
            del app.vis_dict['Gate']
            app.canvas.delete('Gate')
        except: pass
        app.vis_dict['Gate'] = Vis(name = 'Gate', loc = newloc[:])
        vis = app.vis_dict['Gate']
        root.after(1666, lambda id = id, newloc = newloc : self.place_entity(id, newloc))
        
    def place_entity(self, id, newloc):
        del app.vis_dict['Gate']
        app.canvas.delete('Gate')
        app.canvas.create_image(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        try: app.canvas.tag_lower((app.ent_dict[id].tags), 'large')
        except: pass
        app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
        root.after(666, self.cleanup_gate)
    
    def doorway_squares(self, distance):
        sqr_list = []
        for c in app.coords:
            if dist(c, self.loc) <= distance: 
                if app.grid[c[0]][c[1]] == '':
                    sqr_list.append(c)
        return sqr_list
    
    def cleanup_gate(self, event = None):
        try:
            del app.vis_dict['Gate']
            app.canvas.delete('Gate')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
    
    
class Umbrae_Wolf(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift}
            self.str = 5
            self.agl = 5
            self.end = 4
            self.mm = 7
            self.msl = 6
            self.bls = 5
            self.dodge = 5
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 13
            self.init = 5
            self.spirit = 17
            self.magick = 9
            self.acts = 1
            self.mvs = 2
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Darkblast':self.darkblast, 'Stalk':self.stalk, 'Phase Shift':self.phase_shift}
            self.str = 6
            self.agl = 8
            self.end = 6
            self.mm = 7
            self.msl = 8
            self.bls = 5
            self.dodge = 5
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.spirit = 22
            self.magick = 13
            self.acts = 2
            self.mvs = 2
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = ['elec']
        self.resist = ['piercing', 'cold']
        self.form = 'umbrae_wolf'
        super().__init__(name, id, img, loc, owner)
        
    def init_normal_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        if self.form == 'umbrae_wolf':
            anims = [a for r,d,a in walk('./animations/Umbrae_Wolf/')][0]
            anims = [a for a in anims[:] if a[-3:] == 'png']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/Umbrae_Wolf/' + anim))
                self.anim_dict[i] = a
        elif self.form == 'umbrae_mist':
            anims = [a for r,d,a in walk('./animations/Umbrae_Mist/')][0]
            anims = [a for a in anims[:] if a[-3:] == 'png']
            for i, anim in enumerate(anims):
                a = ImageTk.PhotoImage(Image.open('animations/Umbrae_Mist/' + anim))
                self.anim_dict[i] = a
        
    def phase_shift(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_phase_shift)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_phase_shift(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Phase Shift', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_phase_shift(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_phase_shift(self, event = None):
        global selected
        selected = [self.tags]
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(0.5)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.acts -= 1
        app.canvas.delete(self.tags)
        app.vis_dict['Phase_Shift'] = Vis(name = 'Phase_Shift', loc = self.loc[:])
        vis = app.vis_dict['Phase_Shift']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Phase_Shift')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Phase Shift', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Phase Shift', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # shift from one phase to the other...
        if self.form == 'umbrae_wolf':
            if self.level == 1:
                self.form = 'umbrae_mist'
                self.str = 2
                self.agl = 4
                self.end = 3
                self.mm = 3
                self.msl = 3
                self.bls = 6
                self.dodge = 7
                self.psyche = 7
                self.wis = 6
                self.rsn = 6
                self.san = 12
                self.init = 4
                old_base = self.base_spirit
                self.base_spirit = 15
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 19
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'ethereal'
                self.weak = ['explosive']
                self.resist = ['magick', 'slashing', 'piercing', 'crushing']
                self.actions = {'Mist Move':self.move, 'Drain Life':self.drain_life, 'Muddle':self.muddle, 'Pierce Shield':self.pierce_shield, 'Haste':self.haste, 'Rend Space':self.rend_space, 'Phase Shift':self.phase_shift}
                def legal_moves(obj):
                    move_list = []
                    for c in app.coords:
                        if app.grid[c[0]][c[1]] == '':
                            if dist(obj.loc, c) <= obj.get_abl('move_range'):
                                move_list.append(c)
                    return move_list
                p = partial(legal_moves, self)
                self.legal_moves = p
            elif self.level == 2:
                self.form = 'umbrae_mist'
                self.str = 3
                self.agl = 5
                self.end = 4
                self.mm = 3
                self.msl = 3
                self.bls = 6
                self.dodge = 7
                self.psyche = 8
                self.wis = 7
                self.rsn = 7
                self.san = 16
                self.init = 5
                old_base = self.base_spirit
                self.base_spirit = 19
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 33
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 2
                self.base_mvs = 1
                self.move_range = 4
                self.move_type = 'ethereal'
                self.weak = ['explosive']
                self.resist = ['magick', 'slashing', 'piercing', 'crushing']
                self.actions = {'Mist Move':self.move, 'Drain Life':self.drain_life, 'Muddle':self.muddle, 'Pierce Shield':self.pierce_shield, 'Haste':self.haste, 'Rend Space':self.rend_space, 'Phase Shift':self.phase_shift, 'Warpfire':self.warpfire, 'Tendrils of Chaos':self.tendrils_of_chaos}
                def legal_moves(obj):
                    move_list = []
                    for c in app.coords:
                        if app.grid[c[0]][c[1]] == '':
                            if dist(obj.loc, c) <= obj.get_abl('move_range'):
                                move_list.append(c)
                    return move_list
                p = partial(legal_moves, self)
                self.legal_moves = p
        elif self.form == 'umbrae_mist':
            if self.level == 1:
                self.form = 'umbrae_wolf'
                self.str = 5
                self.agl = 5
                self.end = 4
                self.mm = 7
                self.msl = 6
                self.bls = 5
                self.dodge = 5
                self.psyche = 3
                self.wis = 3
                self.rsn = 3
                self.san = 13
                self.init = 5
                self.move_range = 4
                old_base = self.base_spirit
                self.base_spirit = 17
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 9
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 1
                self.base_mvs = 2
                self.move_range = 4
                self.move_type = 'normal'
                self.weak = ['elec']
                self.resist = ['piercing', 'cold']
                self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift}
                def legal_moves(obj):
                    loc = obj.loc[:]
                    mvlist = []
                    sqr_cost_map = {}
                    def findall(loc, start, distance):
                        if start > distance:
                            return
                        adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                        for s in adj:
                            if tuple(s) in sqr_cost_map:
                                if sqr_cost_map[tuple(s)] < start:
                                    continue
                            sqr_cost_map[tuple(s)] = start
                            if s not in mvlist:
                                mvlist.append(s)
                            findall(s, start+1, distance)
                    findall(loc, 1, self.get_abl('move_range'))
                    return mvlist
                p = partial(legal_moves, self)
                self.legal_moves = p
            elif self.level == 2:
                self.form = 'umbrae_wolf'
                self.str = 6
                self.agl = 8
                self.end = 6
                self.mm = 7
                self.msl = 8
                self.bls = 5
                self.dodge = 5
                self.psyche = 4
                self.wis = 4
                self.rsn = 3
                self.san = 13
                self.init = 8
                self.move_range = 4
                old_base = self.base_spirit
                self.base_spirit = 22
                self.spirit = round((self.spirit/old_base)*self.base_spirit)
                old_base = self.base_magick
                self.base_magick = 13
                self.magick = round((self.magick/old_base)*self.base_magick)
                self.base_acts = 2
                self.base_mvs = 2
                self.move_range = 4
                self.move_type = 'normal'
                self.weak = ['elec']
                self.resist = ['piercing', 'cold']
                self.actions = {'Move':self.move, 'Umbrae Strike':self.umbrae_strike, 'Dark Shroud':self.dark_shroud, 'Gaze':self.gaze, 'Phase Shift':self.phase_shift, 'Darkblast':self.darkblast, 'Stalk':self.stalk}
                def legal_moves(obj):
                    loc = obj.loc[:]
                    mvlist = []
                    sqr_cost_map = {}
                    def findall(loc, start, distance):
                        if start > distance:
                            return
                        adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                        for s in adj:
                            if tuple(s) in sqr_cost_map:
                                if sqr_cost_map[tuple(s)] < start:
                                    continue
                            sqr_cost_map[tuple(s)] = start
                            if s not in mvlist:
                                mvlist.append(s)
                            findall(s, start+1, distance)
                    findall(loc, 1, self.get_abl('move_range'))
                    return mvlist
                p = partial(legal_moves, self)
                self.legal_moves = p
        def reappear():
            global selected
            selected = []
        root.after(2111, self.init_normal_anims)
        root.after(2222, reappear)
        root.after(2333, self.cancel_phase_shift)
        
    def cancel_phase_shift(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Phase_Shift']
            app.canvas.delete('Phase_Shift')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
        
    def gaze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_gaze)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gaze(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target for Gaze', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gaze(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gaze(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Gaze' in [v.name for k,v in ent.effects_dict.items()]:
            return
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Gaze'] = Vis(name = 'Gaze', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Gaze'].img, tags = 'Gaze')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Gaze', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Gaze', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        my_mm = self.get_abl('mm')
        tar_dod = ent.get_abl('dodge')
        if to_hit(my_mm, tar_dod):
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '-2 psy, str, move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '-2 psy, str, move range', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            def gaze_effect(stat):
                return max(1,stat-2)
            p = partial(gaze_effect)
            ent.psyche_effects.append(p)
            ent.str_effects.append(p)
            ent.move_range_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].psyche_effects.remove(func)
                app.ent_dict[id].str_effects.remove(func)
                app.ent_dict[id].move_range_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Gaze'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Gaze', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('mm'))
        else:
            miss(ent.loc)
        root.after(1666, lambda e = None : self.finish_gaze(event = e))
        
    def finish_gaze(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Gaze']
            app.canvas.delete('Gaze')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()        
        
        
    def encumber(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_encumber)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_encumber(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Encumber', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_encumber(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_encumber(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 1:
            return
        if 'Encumber' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/haste.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 1
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        # DO Encumber VISUALS
        start_loc = ent.loc[:]
        app.vis_dict['Encumber'] = Vis(name = 'Encumber', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = ent.img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = ent.img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Encumber'].img, tags = ('Encumber','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Encumber'].img, tags = ('Encumber','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Encumber', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Encumber', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis = ['Encumber']
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Encumber','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Encumber', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Encumber','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                root.after(666, self.cleanup_encumber)
            else:
                root.after(100, lambda vis = 'Encumber', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Encumber', x, y, end_left, id)
        simulacrum_loop_right('Encumber', x, y, end_right, id)
        # End visuals
        if to_hit(my_wis, tar_wis):
            def encumber_init(stat):
                return max(1,stat-4)
            p1 = partial(encumber_init)
            ent.init_effects.append(p1)
            def encumber_abl(stat):
                return max(1,stat-2)
            p2 = partial(encumber_abl)
            ent.agl_effects.append(p2)
            ent.mm_effects.append(p2)
            ent.dodge_effects.append(p2)
            ent.move_range_effects.append(p2)
            def encumber_mvs(stat):
                return stat-1
            p3 = partial(encumber_mvs)
            ent.mvs_effects.append(p3)
            ent.mvs -= 1
            def undo(id, p1, p2, p3, lockname = None):
                app.ent_dict[id].init_effects.remove(p1)
                app.ent_dict[id].agl_effects.remove(p2)
                app.ent_dict[id].mm_effects.remove(p2)
                app.ent_dict[id].dodge_effects.remove(p2)
                app.ent_dict[id].move_range_effects.remove(p2)
                app.ent_dict[id].mvs_effects.remove(p3)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2, p3)
            n = 'Encumber' + str(app.count)
            ent.effects_dict['Encumber'] = Effect(name = 'Encumber', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(ent.loc)
            root.after(1333, self.cleanup_encumber)
        
    def cleanup_encumber(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Encumber']
            app.canvas.delete('Encumber')
        except: pass
        app.canvas.delete('text')
        
        
    def haste(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_haste)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_haste(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Haste', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_haste(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_haste(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        if 'Haste' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 2
        ent = app.ent_dict[id]
        def haste_init(stat):
            return stat+4
        p1 = partial(haste_init)
        ent.init_effects.append(p1)
        def haste_abl(stat):
            return stat+1
        p2 = partial(haste_abl)
        ent.agl_effects.append(p2)
        ent.dodge_effects.append(p2)
        ent.mvs_effects.append(p2)
        ent.mvs += 1
        def undo(id, p1, p2, lockname = None):
            app.ent_dict[id].init_effects.remove(p1)
            app.ent_dict[id].agl_effects.remove(p2)
            app.ent_dict[id].dodge_effects.remove(p2)
            app.ent_dict[id].mvs_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p1, p2)
        n = 'Haste' + str(app.count)
        app.ent_dict[id].effects_dict['Haste'] = Effect(name = 'Haste', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        # DO Haste VISUALS
        start_loc = app.ent_dict[id].loc[:]
        app.vis_dict['Haste'] = Vis(name = 'Haste', loc = start_loc[:])
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'left')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = 'right')
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Haste'].img, tags = ('Haste','right'))
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Haste'].img, tags = ('Haste','left'))
        app.canvas.create_text(start_loc[0]*100+49-app.moved_right, start_loc[1]*100+84-app.moved_down, text = 'Haste', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+85-app.moved_down, text = 'Haste', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        end_left = start_loc[0]*100-app.moved_right # minus 50 from center
        end_right = start_loc[0]*100+100-app.moved_right # plus 50 from center
        selected_vis = ['Haste']
        def simulacrum_loop_left(vis, x, y, end_left, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('left') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'left')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Haste','left'))
            app.canvas.tag_raise(vis)
            if x > end_left:
                x -= 10
                app.canvas.move('left',-10,0)
            if x == end_left:
                pass
            else:
                root.after(100, lambda vis = 'Haste', x = x, y = y, end_left = end_left, tar = tar : simulacrum_loop_left(vis, x, y, end_left, tar))
        def simulacrum_loop_right(vis, x, y, end_right, tar):
            if x % 5 == 0: # this just gets new image (flickers simulacrum opacity)
                app.vis_dict[vis].rotate_image()
                app.canvas.delete('right') # this deletes both vis left and right
                app.canvas.create_image(x, y, image = app.ent_dict[tar].img, tags = 'right')
                app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = ('Haste','right'))
            app.canvas.tag_raise(vis)
            if x < end_right:
                x += 10
                app.canvas.move('right',10,0)
            if x == end_right:
                root.after(666, self.cleanup_haste)
            else:
                root.after(100, lambda vis = 'Haste', x = x, y = y, end_right = end_right, tar = tar : simulacrum_loop_right(vis, x, y, end_right, tar))
        simulacrum_loop_left('Haste', x, y, end_left, id)
        simulacrum_loop_right('Haste', x, y, end_right, id)
        
    def cleanup_haste(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.delete('left')
        app.canvas.delete('right')
        try: 
            del app.vis_dict['Haste']
            app.canvas.delete('Haste')
        except: pass
        app.canvas.delete('text')
        
        
    def rend_space(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_rend_space)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_rend_space(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_rend_space(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rend_space(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Rend Space', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Rend Space', justify = 'center', fill = 'darkorchid1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Rend_Space'] = Vis(name = 'Rend_Space', loc = sqr[:])
        vis = app.vis_dict['Rend_Space']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Rend_Space')
        ent = app.ent_dict[id]
        d = 3*len([k for k in app.loc_dict[tuple(sqr)].effects_dict.keys()])
        lock(apply_damage, self, ent, -d, 'explosive', 'Rend Space', 'spell')
        root.after(2333, self.finish_rend_space)
        
    def finish_rend_space(self, event = None):
        try: 
            del app.vis_dict['Rend_Space']
            app.canvas.delete('Rend_Space')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def pierce_shield(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pierce_shield)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_pierce_shield(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Analyze Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_pierce_shield(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pierce_shield(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        if self.magick < 1:
            return
        self.magick -= 1
#         effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Pierce Shield', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Pierce Shield', justify = 'center', fill = 'darkorchid1', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Pierce_Shield'] = Vis(name = 'Pierce_Shield', loc = sqr[:])
        vis = app.vis_dict['Pierce_Shield']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Pierce_Shield')
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            def pierce_shield_types(ts):
                return [t for t in ts if t != 'psyshield']
            p1 = partial(pierce_shield_types)
            ent.type_effects.append(p1)
            def pierce_shield_abls(stat):
                return max(1,stat-1)
            p2 = partial(pierce_shield_abls)
            ent.wis_effects.append(p2)
            ent.psyche_effects.append(p2)
            def undo(id, p1, p2, lockname = None):
                app.ent_dict[id].type_effects.remove(p1)
                app.ent_dict[id].wis_effects.remove(p2)
                app.ent_dict[id].psyche_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2)
            n = 'Pierce_Shield' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Pierce_Shield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            sqr = ent.loc
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Lose psyshield, -1 psy, wis', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Lose psyshield, -1 psy, wis', justify = 'center', fill = 'steelblue1', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_pierce_shield)
        else:
            miss(app.ent_dict[id].loc)
            root.after(2333, self.finish_pierce_shield)
        
    def finish_pierce_shield(self, event = None):
        try: 
            del app.vis_dict['Pierce_Shield']
            app.canvas.delete('Pierce_Shield')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def tendrils_of_chaos(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_tendrils_of_chaos)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_tendrils_of_chaos(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Tendrils of Chaos', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_tendrils_of_chaos(e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tendrils_of_chaos(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.spell_target_ents().keys()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/tendrils_of_chaos.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Tendrils_of_Chaos'] = Vis(name = 'Tendrils_of_Chaos', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Tendrils_of_Chaos'].img, tags = 'Tendrils_of_Chaos')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Tendrils of Chaos', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Tendrils of Chaos', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        my_psy = self.get_abl('psyche')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_psy, tar_agl) == True and 'Tendrils_Move' not in [ef.name for k,ef in app.ent_dict[id].effects_dict.items()]:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+74-app.moved_down, text = 'Move Reduced...', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+75-app.moved_down, text = 'Move Reduced...', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            def tendrils_move(move_range):
                return max(1, move_range-2)
            app.ent_dict[id].move_range_effects.append(tendrils_move)
            def un(i, lockname = None):
                app.ent_dict[i].move_range_effects.remove(tendrils_move)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            n = 'Tendrils_Move' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Tendrils_Move', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        # -2 rand stat, cumulative
        tar_str = app.ent_dict[id].get_abl('str')
        if to_hit(my_psy, tar_str) == True:
            def tendrils_effect(stat):
                return max(1, stat-2)
            f = tendrils_effect
            any = choice(['str','end','agl','mm','dodge','psyche','wis','rsn','san','init'])
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+84-app.moved_down, text = '-2 '+any, justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+85-app.moved_down, text = '-2 '+any, justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            if any == 'str':
                app.ent_dict[id].str_effects.append(f)
            elif any == 'end':
                app.ent_dict[id].end_effects.append(f)
            elif any == 'agl':
                app.ent_dict[id].agl_effects.append(f)
            elif any == 'dodge':
                app.ent_dict[id].dodge_effects.append(f)
            elif any == 'mm':
                app.ent_dict[id].mm_effects.append(f)
            elif any == 'psyche':
                app.ent_dict[id].psyche_effects.append(f)
            elif any == 'wis':
                app.ent_dict[id].wis_effects.append(f)
            elif any == 'rsn':
                app.ent_dict[id].rsn_effects.append(f)
            elif any == 'san':
                app.ent_dict[id].san_effects.append(f)
            elif any == 'init':
                app.ent_dict[id].init_effects.append(f)
            def un(i, ef_type, lockname = None):
                if ef_type == 'str':
                    app.ent_dict[i].str_effects.remove(tendrils_effect)
                elif ef_type == 'end':
                    app.ent_dict[i].end_effects.remove(tendrils_effect)
                elif ef_type == 'agl':
                    app.ent_dict[i].agl_effects.remove(tendrils_effect)
                elif ef_type == 'mm':
                    app.ent_dict[i].mm_effects.remove(tendrils_effect)
                elif ef_type == 'dodge':
                    app.ent_dict[i].dodge_effects.remove(tendrils_effect)
                elif ef_type == 'psyche':
                    app.ent_dict[i].psyche_effects.remove(tendrils_effect)
                elif ef_type == 'wis':
                    app.ent_dict[i].wis_effects.remove(tendrils_effect)
                elif ef_type == 'rsn':
                    app.ent_dict[i].rsn_effects.remove(tendrils_effect)
                elif ef_type == 'san':
                    app.ent_dict[i].san_effects.remove(tendrils_effect)
                elif ef_type == 'init':
                    app.ent_dict[i].init_effects.remove(tendrils_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p_undo = partial(un, id, any)
            n = 'Tendrils_Drain' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Tendrils_Drain', undo_func = p_undo, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda e = None : self.finish_tendrils_of_chaos(event = e))
        
    def finish_tendrils_of_chaos(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Tendrils_of_Chaos']
            app.canvas.delete('Tendrils_of_Chaos')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
    # Warpfire effect key is 'Warpfire'+caster.id, to limit 1 Warpfire per caster?
    def warpfire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_warpfire)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_warpfire(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Warpfire Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_warpfire(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_warpfire(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Warpfire' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        if 'Warpfire'+self.id in [k for c in app.coords for k,v in app.loc_dict[tuple(c)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/warpfire.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Warpfire', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Warpfire', font = ('chalkduster', 14), fill = 'deeppink', tags = 'text')
        un = 'Warpfire' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Warpfire', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def warp_move(s, lockname):
            app.focus_square(s)
            ents = [k for k,v in app.all_ents().items() if dist(v.loc,s) <= 3 and v.immovable == False]
            es = [c for c in app.coords if dist(c,s) <= 3 and app.grid[c[0]][c[1]] == '']
            for id in ents:
                if es == []:
                    break
                loc = app.ent_dict[id].loc[:]
                endloc = reduce(lambda a,b : a if dist(a,sqr)<dist(b,sqr) else b, es)
                es.remove(endloc)
                un = 'Warpfire'+str(app.count)
                app.count += 1
                def cleanup_warpfire(n):
                    del app.vis_dict[n]
                    app.canvas.delete(n)
                app.vis_dict[un] = Vis(name = 'Portal', loc = loc[:])
                vis = app.vis_dict[un]
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = vis.img, tags = un)
                root.after(1888, lambda n = un : cleanup_warpfire(n))
                app.grid[loc[0]][loc[1]] = ''
                app.canvas.delete(id)
                app.ent_dict[id].loc = endloc[:]
                app.grid[endloc[0]][endloc[1]] = id
                un2 = 'Portal'+str(app.count)
                app.count += 1
                app.vis_dict[un2] = Vis(name = 'Portal', loc = endloc[:])
                vis2 = app.vis_dict[un2]
                app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = vis2.img, tags = un2)
                root.after(1888, lambda n = un2 : cleanup_warpfire(n))
                app.canvas.create_image(endloc[0]*100+50-app.moved_right, endloc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
                try: app.canvas.tag_lower((app.ent_dict[id].tags), 'large')
                except: pass
                app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
            root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
        sot2 = partial(warp_move, sqr[:])
        def warp_eot(sqr, lockname = None):
            if ent := [v for k,v in app.all_ents().items() if v.loc == sqr]:
                ent = ent[0]
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-2 Sanity', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-2 Sanity', font = ('chalkduster', 14), fill = 'deeppink', tags = 'text')
                def warp_insane(stat):
                    return max(1, stat-2)
                p = partial(warp_insane)
                ent.san_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.san_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Warp_Insane'+str(app.count)
                app.count += 1
                ent.effects_dict[n] = Effect(name = 'Warp_Insane', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(888, lambda t = 'text' : app.canvas.delete(t))
                root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(warp_eot, sqr[:])
        def undo(s, un, myid, lockname = None):
            del app.vis_dict[un]
            app.canvas.delete('Warpfire'+myid)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, self.id)
        app.loc_dict[tuple(sqr)].effects_dict['Warpfire'+self.id] = Local_Effect(name = 'Warpfire', undo_func = u, sot_func = sot2, eot_func = eot, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = 6)
        root.after(1666, self.cleanup_warpfire)
        
    def cleanup_warpfire(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
        
        
    def stalk(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_stalk)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_stalk(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Stalk Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_stalk(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stalk(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if 'Stalk' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/stalk.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Stalk', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Stalk', justify = 'center', fill = 'gray88', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Stalk'] = Vis(name = 'Stalk', loc = sqr[:])
        vis = app.vis_dict['Stalk']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Stalk')
        if to_hit(self.get_abl('mm'), app.ent_dict[id].get_abl('dodge')):
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Stalked...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Stalked...', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
            def stalk_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
                if (type == 'piercing' or type == 'slashing' or type == 'crushing') and amt < 0 and (st == 'melee' or st == 'ranged'):
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+49, dfndr.loc[1]*100-app.moved_down+49, text = '+2 Stalk', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100-app.moved_right+50, dfndr.loc[1]*100-app.moved_down+50, text = '+2 Stalk', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
                    root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt-2, type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            app.ent_dict[id].defense_effects.append(stalk_effect)
            def un(id, lockname = None):
                app.ent_dict[id].defense_effects.remove(stalk_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id)
            n = 'Stalk' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Stalk', undo_func = u, duration = self.get_abl('msl'), level = self.get_abl('bls'))
            root.after(2111, self.finish_stalk)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(2111, self.finish_stalk)
        
    def finish_stalk(self, event = None):
        try: 
            del app.vis_dict['Stalk']
            app.canvas.delete('Stalk')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def darkblast(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_darkblast)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_darkblast(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Darkblast Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_darkblast(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_darkblast(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/darkblast.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Darkblast'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Darkblast', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_darkb(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_darkb(n))
        if app.ent_dict[id].owner != self.owner:
            my_mm = self.get_abl('mm')
            tar_dodge = app.ent_dict[id].get_abl('dodge')
            if to_hit(my_mm, tar_dodge) == True:
                my_msl = self.get_abl('msl')
                tar_end = app.ent_dict[id].get_abl('end')
                d = damage(my_msl, tar_end)
                lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Darkblast', 'ranged')
                if id not in app.all_ents().keys():
                    root.after(666, lambda e = None : self.finish_darkblast(event = e))
                else:# ent still alive, attempt dispel target effect (must create interface to target) then finish_darkblast
                    app.depop_context(event = None)
                    app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
                    bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
                    bg.pack(side = 'top')
                    bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
                    bg.create_text(14, 14, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
                    bg.create_text(15, 15, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
                    app.context_buttons.append(bg)
                    efs_tuples = [(k, v) for k,v in app.ent_dict[id].effects_dict.items()]
                    if efs_tuples == []:
                        root.after(1666, lambda e = None : self.finish_darkblast(event = e))
                    else:# MAKE BUTTONS becomes page effects like page actions
                        self.page_darkblast(efs_tuples = efs_tuples, id = id)
            else:# MISS
                miss(app.ent_dict[id].loc)
                root.after(2666, lambda e = None : self.finish_darkblast(event = e))
        else:# FRIENDLY ENT, heal 3 then attempt target dispel
            if app.ent_dict[id].owner == self.owner:# heal if summon, else just dispel friendly
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Heal 3 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Heal 3 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                apply_heal(self, app.ent_dict[id], 3)
            app.depop_context(event = None)
            app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
            bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
            bg.pack(side = 'top')
            bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
            bg.create_text(14, 14, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'black')
            bg.create_text(15, 15, text= 'Choose Effect...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
            app.context_buttons.append(bg)
            efs_tuples = [(k, v) for k,v in app.ent_dict[id].effects_dict.items()]
            if efs_tuples == []:
                root.after(2666, lambda e = None : self.finish_darkblast(event = e))
            else:
                self.page_darkblast(efs_tuples = efs_tuples, id = id)
                    
                    
    def page_darkblast(self, event = None, efs_tuples = None, id = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()
        for i, key_ef in enumerate(efs_tuples[index:index+5]):
            i += 1
            key = key_ef[0]
            ef = key_ef[1]
            p = partial(self.darkblast_dispel, id = id, ef_name = ef.name, key = key)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ ef.name.replace('_', ' '), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            # below should become effect_description_popup, (there is no equivalent to more info popup, effect desc shown in more info
#             b1.bind('<Button-2>', lambda ef = ef : app.effect_description(ef))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = '9 : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda eft = efs_tuples, id = id, i = index-5 : self.page_darkblast(efs_tuples = eft , id = id, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind(str(9), lambda e, eft = efs_tuples, id = id, i = index-5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
            app.context_buttons.append(b4)
        if len(efs_tuples) > len(efs_tuples[:index+5]):
            b3 = tk.Button(app.context_menu, text = '8 : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda eft = efs_tuples, id = id, i = index+5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind(str(8), lambda e, eft = efs_tuples, id = id, i = index+5 : self.page_darkblast(efs_tuples = eft, id = id, index = i))
                    
                    
            
    def darkblast_dispel(self, event = None, id = None, ef_name = None, key = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        if app.ent_dict[id].effects_dict[key].dispel(self.get_abl('msl')) == 'Dispelled':
            del app.ent_dict[id].effects_dict[key]
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Dispel '+ef_name.replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Dispel '+ef_name.replace('_',' '), justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_darkblast)
        else:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = 'Dispel failed...'+ef_name.replace('_',' '), justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = 'Dispel failed...'+ef_name.replace('_',' '), justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1999, self.finish_darkblast)
            
            
    def finish_darkblast(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
    def dark_shroud(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_dark_shroud)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_dark_shroud(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Dark Shroud', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_dark_shroud(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dark_shroud(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/dark_shroud.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Dark_Shroud'] = Vis(name = 'Dark_Shroud', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Dark_Shroud'].img, tags = 'Dark_Shroud')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Dark Shroud', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Dark Shroud', justify = 'center', fill = 'thistle1', font = ('chalkduster', 13), tags = 'text')
        ents = [app.grid[s[0]][s[1]] for s in app.coords if dist(s, sqr) <= 3 and app.grid[s[0]][s[1]] != '' and app.grid[s[0]][s[1]] != 'block']
        ents = [e for e in ents if app.ent_dict[e].owner == self.owner and e != self.id]
        for id in ents:
            s = app.ent_dict[id].loc[:]
            uniq = 'Dark_Shroud'+str(app.count)
            app.count += 1
            app.vis_dict[uniq] = Vis(name = 'Dark_Shroud', loc = s)
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Dark_Shroud')
            app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+64, text = '+2 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+65, text = '+2 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            # text, heal
            apply_heal(self, app.ent_dict[id], 2)
            # dodge bonus effect if eff does not exist
            ks = [k for k,v in app.ent_dict[id].effects_dict.items() if v.name == 'Dark_Shroud']
            if ks == []:
                app.canvas.create_text(s[0]*100-app.moved_right+49, s[1]*100-app.moved_down+84, text = '+1 dodge', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(s[0]*100-app.moved_right+50, s[1]*100-app.moved_down+85, text = '+1 dodge', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                def dark_shroud_effect(stat):
                    return stat+1
                f = dark_shroud_effect
                app.ent_dict[id].dodge_effects.append(f)
                def un(i, func, lockname = None):
                    app.ent_dict[i].dodge_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, id, f)
                n = 'Dark_Shroud' + str(app.count)
                app.ent_dict[id].effects_dict[n] = Effect(name = 'Dark_Shroud', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3333, self.finish_dark_shroud)
            
            
    def finish_dark_shroud(self, event = None):
        try:
            ks = list(app.vis_dict.keys())
            for k in ks:
                if k.startswith('Dark_Shroud') == True:
                    del app.vis_dict[k]
            app.canvas.delete('Dark_Shroud')
        except: pass
        app.cleanup_squares()
#         app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def drain_life(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_drain_life)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_drain_life(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Drain Life Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_drain_life(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_drain_life(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/drain_life.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Drain_Life'] = Vis(name = 'Drain_Life', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            pre = app.ent_dict[id].spirit
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Drain Life', 'spell')
            if id not in app.all_ents().keys():
                d = pre
            else:
                post = app.ent_dict[id].spirit
                d = pre - post
            max_heal = round(d//2)
            if max_heal < 0:
                max_heal = 0
            apply_heal(self, self, max_heal)
            app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Heal ' + str(max_heal) + ' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Heal ' + str(max_heal) + ' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            root.after(1666, self.finish_drain_life)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_drain_life)
        
    def finish_drain_life(self, event = None):
        try: 
            del app.vis_dict['Drain_Life']
            app.canvas.delete('Drain_Life')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
#         app.unbind_all()
        app.rebind_all()
        
    def muddle(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_muddle)
        sqrs = [c for c in app.coords if 1 <= dist(c, self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_muddle(e, sqr, sqrs))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Muddle', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs: self.do_muddle(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_muddle(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Muddle' in [ef.name for k,ef in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/muddle.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Muddle'] = Vis(name = 'Muddle', loc = sqr[:])
        vis = app.vis_dict['Muddle']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Muddle')
        my_psy = self.get_abl('psyche')
        tar_psy = app.ent_dict[id].get_abl('psyche')
        if to_hit(my_psy, tar_psy) == True:
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+74, text = 'Muddled...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+75, text = 'Muddled...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def un(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = un
            # EOT FUNC
            def attack_self(id, lockname = None):
                app.get_focus(id)
                my_agl = app.ent_dict[id].get_abl('agl')
                if to_hit(my_agl, my_agl) == True:
                    my_str = app.ent_dict[id].get_abl('str')
                    my_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_str, my_end)
                    lock(apply_damage, app.ent_dict[id], app.ent_dict[id], -d, 'crushing', 'Muddle', 'melee')
                else:
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+74-app.moved_down, text = 'Muddle miss...', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+75-app.moved_down, text = 'Muddle miss...', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(attack_self, id)
            n = 'Muddle' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Muddle', undo_func = p, duration = 3, level = self.get_abl('wis'), eot_func = eot)
            root.after(3333, lambda e = None : self.finish_muddle(event = e))
        else:
            miss(app.ent_dict[id].loc)
            root.after(3333, lambda e = None : self.finish_muddle(event = e))
    
    def finish_muddle(self, event = None):
        app.canvas.delete('text')
        try:
            del app.vis_dict['Muddle']
            app.canvas.delete('Muddle')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    def umbrae_strike(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_umbrae_strike)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_umbrae_strike(e, sqr, sqrs))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Attack', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs: self.do_umbrae_strike(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_umbrae_strike(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/umbrae_strike.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        my_mm = self.get_abl('mm')
        target_dodge = app.ent_dict[id].get_abl('dodge')
        app.vis_dict['Umbrae_Strike'] = Vis(name = 'Umbrae_Strike', loc = sqr[:])
        vis = app.vis_dict['Umbrae_Strike']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Umbrae_Strike')
        def cleanup_vis():
            app.canvas.delete('text')
            try:
                del app.vis_dict['Umbrae_Strike']
                app.canvas.delete('Umbrae_Strike')
            except: pass
        if to_hit(my_mm, target_dodge) == True:
            my_msl = self.get_abl('msl')
            target_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, target_end)
            root.after(1999, cleanup_vis)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Umbrae Strike', 'ranged')
            self.finish_umbrae_strike()

        else:
            miss(sqr)
            root.after(1999, self.finish_umbrae_strike)
    
    def finish_umbrae_strike(self, event = None):
        app.canvas.delete('text')
        try:
            del app.vis_dict['Umbrae_Strike']
            app.canvas.delete('Umbrae_Strike')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
    
    
class Wurdulak(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Entrance':self.entrance, 'Enthrall':self.enthrall, 'Chill Touch':self.chill_touch, 'Enervating Grasp':self.enervating_grasp, 'Bat Form':self.bat_form, 'Wolf Form':self.wolf_form}
            self.str = 7
            self.agl = 4
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 7
            self.wis = 5
            self.rsn = 4
            self.san = 12
            self.init = 4
            self.spirit = 19
            self.magick = 17
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Entrance':self.entrance, 'Enthrall':self.enthrall, 'Chill Touch':self.chill_touch, 'Enervating Grasp':self.enervating_grasp, 'Vampiric Bite':self.vampiric_bite, 'Bat Form':self.bat_form, 'Wolf Form':self.wolf_form}
            self.str = 8
            self.agl = 5
            self.end = 9
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 8
            self.wis = 6
            self.rsn = 5
            self.san = 14
            self.init = 5
            self.spirit = 25
            self.magick = 23
            self.acts = 2
            self.mvs = 1
            self.move_range = 2
            self.level = level
        self.move_type = 'normal'
        self.resist = ['slashing', 'crushing', 'magick']
        self.weak = ['fire', 'piercing']
        self.origin_sqr = [1,1] # set on creation of effect that needs it, bat/wolf form
        self.shift_form = 1
        super().__init__(name, id, img, loc, owner)
        
    # on hit psy vs psy, -3 san, cumulative
    def entrance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_entrance)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_entrance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Entrance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_entrance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_entrance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/traced.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Entrance', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Entrance', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Entrance'] = Vis(name = 'Entrance', loc = sqr[:])
        vis = app.vis_dict['Entrance']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Entrance')
        my_psy = self.get_abl('psyche')
        ent = app.ent_dict[id]
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            def entrance_effect(stat):
                return max(1,stat-3)
            p = partial(entrance_effect)
            ent.san_effects.append(p)
            def undo(id, p, lockname = None):
                app.ent_dict[id].san_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Entrance' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Entrance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-3 sanity', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-3 sanity', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_entrance)
        else:
            miss(ent.loc)
            root.after(2333, self.finish_entrance)

        
    def finish_entrance(self, event = None):
        try: 
            del app.vis_dict['Entrance']
            app.canvas.delete('Entrance')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # tar psy vs psy to hit?, -2 str, agl, msl, dod
    def enthrall(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enthrall)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enthrall(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enthrall Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enthrall(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enthrall(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Enthrall' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/muddle.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Enthrall', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Enthrall', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Enthrall'] = Vis(name = 'Enthrall', loc = sqr[:])
        vis = app.vis_dict['Enthrall']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Enthrall')
        my_psy = self.get_abl('psyche')
        ent = app.ent_dict[id]
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            def enthrall_effect(stat):
                return max(1,stat-2)
            p = partial(enthrall_effect)
            ent.str_effects.append(p)
            ent.agl_effects.append(p)
            ent.mm_effects.append(p)
            ent.dodge_effects.append(p)
            def undo(id, p, lockname = None):
                app.ent_dict[id].str_effects.remove(p)
                app.ent_dict[id].agl_effects.remove(p)
                app.ent_dict[id].mm_effects.remove(p)
                app.ent_dict[id].dodge_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Enthrall' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Enthrall', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-2 str, agl, mm, dod', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-2 str, agl, mm, dod', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_enthrall)
        else:
            miss(ent.loc)
            root.after(2333, self.finish_enthrall)

        
    def finish_enthrall(self, event = None):
        try: 
            del app.vis_dict['Enthrall']
            app.canvas.delete('Enthrall')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # on hit agl vs agl to hit, str vs end cold, -1 wis cumulative
    def chill_touch(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chill_touch)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chill_touch(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Chill Touch Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chill_touch(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chill_touch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Chill_Touch'] = Vis(name = 'Chill_Touch', loc = sqr[:])
        vis = app.vis_dict['Chill_Touch']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Chill_Touch')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            def chill_touch_effect(stat):
                return max(1,stat-1)
            p = partial(chill_touch_effect)
            ent.wis_effects.append(p)
            def undo(ent, f, lockname = None):
                ent.wis_effects.remove(f)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            un = 'Chill_Touch'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Chill_Touch', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-1 wisdom', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-1 wisdom', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'cold', 'Chill Touch', 'melee')
            root.after(111, self.finish_chill_touch)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_chill_touch)
        
    def finish_chill_touch(self, event = None):
        try: 
            del app.vis_dict['Chill_Touch']
            app.canvas.delete('Chill_Touch')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # drain magick  agl vs agl to hit
    def enervating_grasp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enervating_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enervating Grasp Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enervating_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Enervating_Grasp'] = Vis(name = 'Enervating_Grasp', loc = sqr[:])
        vis = app.vis_dict['Enervating_Grasp']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Enervating_Grasp')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_psy = self.get_abl('psyche')
            tar_end = ent.get_abl('end')
            d = damage(my_psy, tar_end)
            tar_mgk = ent.magick
            if tar_mgk < d:
                d = tar_mgk
            ent.magick -= d
            self.magick += d
            if self.magick > self.base_magick:
                self.magick = self.base_magick
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            root.after(1999, self.finish_enervating_grasp)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_enervating_grasp)
        
    def finish_enervating_grasp(self, event = None):
        try: 
            del app.vis_dict['Enervating_Grasp']
            app.canvas.delete('Enervating_Grasp')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # minus phys stats plus spl, mv range 7 flying, use Effect dur 1, on undo return to self.origin_sqr
    def bat_form(self, event = None):
        if self.shift_form < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_bat_form)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_bat_form(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Bat Form', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_bat_form(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bat_form(self, event = None):
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(0.5)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.shift_form -= 1
        app.vis_dict['Bat_Form'] = Vis(name = 'Bat_Form', loc = self.loc[:])
        vis = app.vis_dict['Bat_Form']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Bat_Form')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bat Form', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bat Form', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
        def bat_effect(stat):
            return max(1,stat-3)
        p = partial(bat_effect)
        self.str_effects.append(p)
        self.agl_effects.append(p)
        self.end_effects.append(p)
        def bat_move(stat):
            return stat+5
        p2 = partial(bat_move)
        self.move_range_effects.append(p2)
        self.move_type = 'flying'
        def legal_moves(obj):
            move_list = []
            for c in app.coords:
                if app.grid[c[0]][c[1]] == '':
                    if dist(obj.loc, c) <= obj.get_abl('move_range'):
                        move_list.append(c)
            return move_list
        l_mvs = partial(legal_moves, self)
        self.legal_moves = l_mvs
        def undo(ent, p, p2, lockname = None):
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.end_effects.remove(p)
            ent.move_range_effects.remove(p2)
            ent.move_type = 'normal'
            def legal_moves(obj):
                loc = obj.loc[:]
                mvlist = []
                sqr_cost_map = {}
                def findall(loc, start, distance):
                    if start > distance:
                        return
                    adj = [c for c in app.coords if dist(c, loc) == 1 and app.grid[c[0]][c[1]] == '']
                    for s in adj:
                        if tuple(s) in sqr_cost_map:
                            if sqr_cost_map[tuple(s)] < start:
                                continue
                        sqr_cost_map[tuple(s)] = start
                        if s not in mvlist:
                            mvlist.append(s)
                        findall(s, start+1, distance)
                findall(loc, 1, obj.get_abl('move_range'))
                return mvlist
            leg_mvs = partial(legal_moves, ent)
            ent.legal_moves = leg_mvs
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2)
        n = 'Bat_Form'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Bat_Form', undo_func = u, duration = 1, level = self.get_abl('wis'))
        self.init_bat_anims()
        root.after(1999, self.cancel_bat_form)
        
    def init_bat_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Wurdulak_Bat/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Wurdulak_Bat/' + anim))
            self.anim_dict[i] = a
        
    def cancel_bat_form(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Bat_Form']
            app.canvas.delete('Bat_Form')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    # minus spl stats plus phys, mv rang 6 normal, use Effect dur 1, ..
    def wolf_form(self, event = None):
        if self.shift_form < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_wolf_form)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_wolf_form(e))
        app.depop_context(event = None)
        b = tk.Button(app.context_menu, text = 'Confirm Wolf Form', font = ('chalkduster', 22), fg='tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None : self.do_wolf_form(event = e))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wolf_form(self, event = None):
        effect1 = mixer.Sound('Sound_Effects/phase_shift.ogg')
        effect1.set_volume(0.5)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        self.shift_form -= 1
        app.vis_dict['Wolf_Form'] = Vis(name = 'Wolf_Form', loc = self.loc[:])
        vis = app.vis_dict['Wolf_Form']
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = vis.img, tags = 'Wolf_Form')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Wolf Form', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Wolf Form', justify = 'center', fill = 'green2', font = ('chalkduster', 13), tags = 'text')
        def wolf_effect(stat):
            return max(1,stat-3)
        def wolf_effect2(stat):
            return stat+4
        p = partial(wolf_effect)
        p2 = partial(wolf_effect2)
        self.psyche_effects.append(p)
        self.wis_effects.append(p)
        self.agl_effects.append(p2)
        def wolf_move(stat):
            return stat+3
        p3 = partial(wolf_move)
        self.move_range_effects.append(p3)
        def undo(ent, p, p2, p3, lockname = None):
            ent.psyche_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.agl_effects.remove(p2)
            ent.move_range_effects.remove(p3)
            ent.init_normal_anims()
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, p3)
        n = 'Wolf_Form'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Wolf_Form', undo_func = u, duration = 1, level = self.get_abl('wis'))
        self.init_wolf_anims()
        root.after(1999, self.cancel_wolf_form)
        
    def init_wolf_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Wurdulak_Wolf/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Wurdulak_Wolf/' + anim))
            self.anim_dict[i] = a
        
    def cancel_wolf_form(self, event = None):
        try:
            app.canvas.delete('text')
            del app.vis_dict['Wolf_Form']
            app.canvas.delete('Wolf_Form')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.rebind_all()
        
    def vampiric_bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_vampiric_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_vampiric_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Vampiric Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_vampiric_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_vampiric_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Vampiric_Bite'] = Vis(name = 'Vampiric_Bite', loc = sqr[:])
        vis = app.vis_dict['Vampiric_Bite']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Vampiric_Bite')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            def vamp_effect(stat):
                return stat+3
            p = partial(vamp_effect)
            self.psyche_effects.append(p)
            def undo(ent, f, lockname = None):
                ent.psyche_effects.remove(f)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, self, p)
            if 'Vampiric_Bite' not in [v.name for k,v in self.effects_dict.items()]:
                un = 'Vampiric_Bite'+str(app.count)
                app.count += 1
                self.effects_dict[un] = Effect(name = 'Vampiric_Bite', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+64-app.moved_down, text = '+3 psy', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+65-app.moved_down, text = '+3 psy', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            lock(apply_damage, self, ent, -d, 'piercing', 'Vampiric Bite', 'melee')
            root.after(111, self.finish_vampiric_bite)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_vampiric_bite)
        
    def finish_vampiric_bite(self, event = None):
        try: 
            del app.vis_dict['Vampiric_Bite']
            app.canvas.delete('Vampiric_Bite')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        

class Murrain_Wolf(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Pox':self.pox, 'Paralyze':self.paralyze, 'Scarab Gestation':self.scarab_gestation, 'Leprous Bite':self.leprous_bite, 'Toxic Miasma':self.toxic_miasma}
            self.str = 6
            self.agl = 5
            self.end = 6
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 6
            self.wis = 7
            self.rsn = 4
            self.san = 11
            self.init = 3
            self.spirit = 23
            self.magick = 16
            self.acts = 2
            self.mvs = 1
            self.move_range = 2
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Pox':self.pox, 'Paralyze':self.paralyze, 'Scarab Gestation':self.scarab_gestation, 'Leprous Bite':self.leprous_bite, 'Toxic Miasma':self.toxic_miasma, 'Spore Cloud':self.spore_cloud, 'Scarab Swarm':self.scarab_swarm}
            self.str = 7
            self.agl = 6
            self.end = 7
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 7
            self.wis = 8
            self.rsn = 5
            self.san = 14
            self.init = 4
            self.spirit = 31
            self.magick = 35
            self.acts = 2
            self.mvs = 2
            self.move_range = 2
            self.level = level
        self.move_type = 'normal'
        self.resist = ['piercing', 'poison', 'magick']
        self.weak = ['cold']
        super().__init__(name, id, img, loc, owner)
        # ADD CONTAGION DEATH TRIGGER
        def contagion_trigger(lockname = None):
            effect1 = mixer.Sound('Sound_Effects/contagion.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, 0)
            app.focus_square(self.loc)
            sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
            ents = [app.grid[s[0]][s[1]] for s in sqrs if app.grid[s[0]][s[1]] != '' and app.grid[s[0]][s[1]] != 'block']
            ents = [k for k,v in app.all_ents().items() if dist(self.loc,v.loc) == 1 and 'Contagion' not in [j.name for i,j in v.effects_dict.items()]]
            for e in ents:
                n = 'Contagion' + str(app.count)
                def contagion_effect(stat):
                    return max(1,stat-3)
                f = contagion_effect
                app.ent_dict[e].str_effects.append(f)
                app.ent_dict[e].end_effects.append(f)
                app.ent_dict[e].agl_effects.append(f)
                app.ent_dict[e].dodge_effects.append(f)
                def un(id, func, lockname = None):
                    app.ent_dict[id].str_effects.remove(func)
                    app.ent_dict[id].end_effects.remove(func)
                    app.ent_dict[id].agl_effects.remove(func)
                    app.ent_dict[id].dodge_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, e, f)
                app.ent_dict[e].effects_dict[n] = Effect(name = 'Contagion', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                n2 = 'Contagion' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n2] = Vis(name = 'Contagion', loc = app.ent_dict[e].loc[:])
                rand_start_anim = randrange(1,7)
                for i in range(rand_start_anim):
                    app.vis_dict[n2].rotate_image()
                app.canvas.create_text(app.ent_dict[e].loc[0]*100-app.moved_right+49, app.ent_dict[e].loc[1]*100-app.moved_down+89, text = 'CONTAGION', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = ('contagion_text'))
                app.canvas.create_text(app.ent_dict[e].loc[0]*100-app.moved_right+50, app.ent_dict[e].loc[1]*100-app.moved_down+90, text = 'CONTAGION', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = ('contagion_text'))
                app.canvas.create_image(app.ent_dict[e].loc[0]*100+50-app.moved_right, app.ent_dict[e].loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = n2)
            def cleanup_contagion():
                try:
                    keys = [k for k,v in app.vis_dict.items() if v.name == 'Contagion']
                    for k in keys:
                        del app.vis_dict[k]
                    app.canvas.delete('Contagion')
                except: pass
                app.canvas.delete('contagion_text')
            root.after(2222, cleanup_contagion)
            root.after(2333, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(contagion_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Contagion', level = self.get_abl('wis'), undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
    # END CLASS INIT
        
    
    def leprous_bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_leprous_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_leprous_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_leprous_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_leprous_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Leprous_Bite'] = Vis(name = 'Leprous_Bite', loc = sqr[:])
        vis = app.vis_dict['Leprous_Bite']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Leprous_Bite')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            def leper_effect(stat):
                return max(1,stat-1)
            p = partial(leper_effect)
            ent.str_effects.append(p)
            ent.agl_effects.append(p)
            ent.end_effects.append(p)
            ent.mm_effects.append(p)
            ent.psyche_effects.append(p)
            ent.wis_effects.append(p)
            ent.rsn_effects.append(p)
            ent.san_effects.append(p)
            ent.init_effects.append(p)
            def undo(ent, f, lockname = None):
                ent.str_effects.remove(f)
                ent.agl_effects.remove(f)
                ent.end_effects.remove(f)
                ent.mm_effects.remove(f)
                ent.psyche_effects.remove(f)
                ent.wis_effects.remove(f)
                ent.rsn_effects.remove(f)
                ent.san_effects.remove(f)
                ent.init_effects.remove(f)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            un = 'Leprous_Bite'+str(app.count)
            app.count += 1
            ent.effects_dict[un] = Effect(name = 'Leprous_Bite', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-1 abilities', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-1 abilities', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'slashing', 'Leprous Bite', 'melee')
            root.after(111, self.finish_leprous_bite)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_leprous_bite)
        
    def finish_leprous_bite(self, event = None):
        try: 
            del app.vis_dict['Leprous_Bite']
            app.canvas.delete('Leprous_Bite')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # must choose a scarab, remove (do not kill) and replace with scarab swarm
    def scarab_swarm(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_scarab_swarm)
        scarabs = [k for k,v in app.ent_dict.items() if v.name == 'Scarab' and v.owner == self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
        sqrs = []
        for id in scarabs:
            sqrs.append(app.ent_dict[id].loc[:])
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_scarab_swarm(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Scarab To Transform', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_scarab_swarm(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scarab_swarm(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
        ent = app.ent_dict[id]
        if self.magick < 1:
            return
        self.magick -= 1
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scarab_swarm.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.delete(id)
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        del app.ent_dict[id]
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_scarab_swarm(s))
        root.after(2666, self.cleanup_scarab_swarm)
        
    def finish_scarab_swarm(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Scarab_Swarm.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Scarab_Swarm(name = 'Scarab_Swarm', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_scarab_swarm(self, event = None):
        try:
            del app.vis_dict['Summon']
            app.canvas.delete('Summon')
        except:
            pass
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def spore_cloud(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Spore_Cloud' in loc_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spore_cloud)
        sqrs = []
        for c in app.coords:
            if dist(self.loc, c) <= 2:
                sqrs.append(c)
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_spore_cloud(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Spore Cloud Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_spore_cloud(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spore_cloud(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Spore_Cloud' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Spore Cloud', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Spore Cloud', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Spore_Cloud' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Spore_Cloud', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
        def spore_effect(stat):
            return stat+2
        p = partial(spore_effect)
        app.loc_dict[tuple(sqr)].dodge_effects.append(p)
        def spore_def(attacker, defender, amount, type, source, sn, lockname = None):
            if amount < 0 and (type == 'slashing' or type == 'piercing' or type == 'fire') and sn != 'eot' and sn != 'sot':
                app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '-2 (min1) spirit spore cloud', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '-2 (min1) spirit spore cloud', justify ='center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                amount += 2
                if amount > -1:
                    root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1,type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amount,type)
            else:
                return (amount,0)
        app.loc_dict[tuple(sqr)].def_effects.append(spore_def)
        def undo(s, un, p_ef, lockname = None):
            app.loc_dict[tuple(s)].dodge_effects.remove(p_ef)
            app.loc_dict[tuple(s)].def_effects.remove(spore_def)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Spore_Cloud', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = -5)
        root.after(1666, self.cleanup_spore_cloud)
        
    def cleanup_spore_cloud(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
    
    def scarab_gestation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_scarab_gestation)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_scarab_gestation(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Scarab Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_scarab_gestation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_scarab_gestation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if isinstance(ent, (Scarab, Scarab_Swarm, Familiar_Imp, Familiar_Homunculus)):
            return
        if 'Scarab_Gestation' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
#         effect1 = mixer.Sound('Sound_Effects/scarab_gestation.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Scarab Gestation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Scarab Gestation', justify = 'center', fill = 'thistle2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Scarab_Gestation'] = Vis(name = 'Scarab_Gestation', loc = sqr[:])
        vis = app.vis_dict['Scarab_Gestation']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Scarab_Gestation')
        if to_hit(self.get_abl('psyche'),app.ent_dict[id].get_abl('str')) == True: # HIT
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Scarab...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Scarab...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            # SCARAB DEATH TRIGGER
            def scarab_effect(id = None, lockname = None):
                s = app.ent_dict[id].loc[:]
                sqr = reduce(lambda a,b : a if dist(a,s) < dist(b,s) else b, [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Scarab.png'))
                if self.owner == 'p1':
                    id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
                    app.ent_dict[app.p1_witch].summon_ids += 1
                else:
                    id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
                    app.ent_dict[app.p2_witch].summon_ids += 1
                app.ent_dict[id] =  Scarab(name = 'Scarab', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
                app.grid[sqr[0]][sqr[1]] = id
                root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
            dt = partial(scarab_effect, id = id)
            def dt_undo(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            dt_inst = Death_Trigger(name = 'Scarab_Gestation', level = self.get_abl('psyche'), undo_func = dt_undo, dt = dt)
            ent.death_triggers.append(dt_inst)
            def un(id, ts, lockname = None):
                for dt in app.ent_dict[id].death_triggers[:]:
                    if dt.ts == ts:
                        app.ent_dict[id].death_triggers.remove(dt)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, dt_inst.ts)
            n = 'Scarab_Gestation' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Scarab_Gestation', undo_func = u, duration = 13, level = self.get_abl('psyche'))
            root.after(1999, self.finish_scarab_gestation)
        else:
            miss(ent.loc)
            root.after(1999, self.finish_scarab_gestation)
        
    def finish_scarab_gestation(self, event = None):
        try: 
            del app.vis_dict['Scarab_Gestation']
            app.canvas.delete('Scarab_Gestation')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def paralyze(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_paralyze)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_paralyze(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Paralyze Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_paralyze(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_paralyze(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Paralyze' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/paralyze.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Paralyze', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Paralyze', justify = 'center', fill = 'thistle2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Paralyze'] = Vis(name = 'Paralyze', loc = sqr[:])
        vis = app.vis_dict['Paralyze']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Paralyze')
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            def paralyze_move(move_range):
                return max(1, move_range-3)
            def paralyze_acts(acts):
                return max(0,acts-1)
            p1 = partial(paralyze_move)
            app.ent_dict[id].move_range_effects.append(p1)
            p2 = partial(paralyze_acts)
            app.ent_dict[id].acts_effects.append(p2)
            app.ent_dict[id].acts -= 1
            def undo(id, p1, p2, lockname = None):
                app.ent_dict[id].move_range_effects.remove(p1)
                app.ent_dict[id].acts_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p1, p2)
            n = 'Paralyze' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Paralyze', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = '-1 actions, -3 move range', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = '-1 actions, -3 move range', justify = 'center', fill = 'thistle2', font = ('chalkduster', 13), tags = 'text')
            root.after(2333, self.finish_paralyze)
        else:
            miss(app.ent_dict[id].loc)
            root.after(2333, self.finish_paralyze)

        
    def finish_paralyze(self, event = None):
        try: 
            del app.vis_dict['Paralyze']
            app.canvas.delete('Paralyze')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # give all adj units pox Effect if they have no pox effects, causes 2 spirit damage EOT
    def pox(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_pox)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_pox(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pox', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_pox(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pox(self, event = None, sqrs = None):
        effect1 = mixer.Sound('Sound_Effects/pox.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        self.acts -= 1
#         self.init_attack_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        ents = []
        for s in sqrs:
            n2 = 'Pox' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Pox', loc = s)
            rand_start_anim = randrange(1,7)
            for i in range(rand_start_anim):
                app.vis_dict[n2].rotate_image()
            ent = app.grid[s[0]][s[1]]
            if ent in app.all_ents().keys() and isinstance(app.ent_dict[ent], Murrain_Wolf) == False:
                #GIVE POX EFFECT if doesn't exist
                ef_names = [v.name for k,v in app.ent_dict[ent].effects_dict.items()]
                if 'Pox' not in ef_names:
                    n = 'Pox'+str(app.count)
                    def take_2(tar, lockname = None):
                        app.get_focus(tar)
                        lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pox', 'eot')
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    # EOT
                    eot = partial(take_2, ent)
                    # UNDO
                    def un(lockname = None):
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un)
                    # POX VIS
                    app.ent_dict[ent].effects_dict[n] = Effect(name = 'Pox', eot_func = eot , undo_func = u, duration = 4, level = 6)
                    app.canvas.create_text(app.ent_dict[ent].loc[0]*100-app.moved_right+49, app.ent_dict[ent].loc[1]*100-app.moved_down+89, text = 'Pox', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(app.ent_dict[ent].loc[0]*100-app.moved_right+50, app.ent_dict[ent].loc[1]*100-app.moved_down+90, text = 'Pox', justify = 'center', fill = 'darkolivegreen3', font = ('chalkduster', 14), tags = 'text')
        root.after(2999, self.finish_pox)
        
    def finish_pox(self, event = None):
#         self.init_normal_anims()
        try:
            keys = [k for k in app.vis_dict.keys() if k.startswith('Pox')]
            for k in keys:
                del app.vis_dict[k]
            app.canvas.delete('Pox')
        except: pass
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
    
    
    def toxic_miasma(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_toxic_miasma)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_toxic_miasma(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Toxic Miasma', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_toxic_miasma(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_toxic_miasma(self, event = None, sqrs = None):
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/toxic_miasma.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Toxic Miasma', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Toxic Miasma', font = ('chalkduster', 13), fill = 'orchid1', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and isinstance(v,Murrain_Wolf) == False and v.owner != self.owner]
        def cleanup_toxic_miasma(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def toxic_miasma_loop(ents):
            if ents == []:
                self.finish_toxic_miasma()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                misscount = 0
                my_psy = self.get_abl('psyche')
                tar_end = ent.get_abl('end')
                if to_hit(my_psy,tar_end):
                    def miasma_invis(types):
                        return [t for t in types if t != 'invisibility']
                    p = partial(miasma_invis)
                    ent.type_effects.append(p)
                    def undo(id, f, lockname = None):
                        app.ent_dict[id].type_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p)
                    n = 'Toxic_Miasma'+str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Miasma_Invis', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+24, text = 'Lose invisibility', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+25, text = 'Lose invisibility', justify = 'center', fill = 'orchid1', font = ('chalkduster', 14), tags = 'text')
                    misscount += 1
                if to_hit(my_psy,tar_end):
                    def miasma_abls(stat):
                        return max(1,stat-1)
                    p2 = partial(miasma_abls)
                    ent.wis_effects.append(p2)
                    ent.rsn_effects.append(p2)
                    def undo(id, f, lockname = None):
                        app.ent_dict[id].wis_effects.remove(f)
                        app.ent_dict[id].rsn_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u2 = partial(undo, id, p2)
                    n = 'Toxic_Miasma'+str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Miasma_Drain', undo_func = u2, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+44, text = '-1 wis, rsn', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+45, text = '-1 wis, rsn', justify = 'center', fill = 'orchid1', font = ('chalkduster', 14), tags = 'text')
                    misscount += 1
                if misscount == 0:
                    miss(ent.loc)
                n = 'Toxic_Miasma' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Toxic_Miasma', loc = ent.loc[:])
                app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1555, lambda n = n : cleanup_toxic_miasma(n))
                root.after(1666, lambda ents = ents : toxic_miasma_loop(ents))
        toxic_miasma_loop(ents)

        
    def finish_toxic_miasma(self, event = None):
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
    
    

class Scarab_Swarm(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Bite':self.bite, 'Move':self.move}
            self.str = 4
            self.agl = 9
            self.end = 7
            self.mm = 8
            self.msl = 4
            self.bls = 7
            self.dodge = 9
            self.psyche = 5
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 9
            self.spirit = 21
            self.magick = 0
            self.acts = 2
            self.mvs = 2
            self.move_range = 4
        elif level == 2: # level should start at 2 unless spell gained early...same stats as lvl 1 for now
            self.actions = {'Bite':self.bite, 'Move':self.move}
            self.str = 4
            self.agl = 9
            self.end = 7
            self.mm = 8
            self.msl = 4
            self.bls = 7
            self.dodge = 9
            self.psyche = 5
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 9
            self.spirit = 21
            self.magick = 0
            self.acts = 2
            self.mvs = 2
            self.move_range = 4
        self.level = level
        self.move_type = 'flying'
        self.weak = ['crushing']
        self.resist = ['magick', 'slashing', 'piercing', 'fire', 'poison', 'elec']
        super().__init__(name, id, img, loc, owner)
        
        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        

class Scarab(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Bite':self.bite, 'Move':self.move}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 4
            self.wis = 3
            self.rsn = 4
            self.san = 14
            self.init = 6
            self.magick = 0
            self.spirit = 13
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
        elif level == 2:
            self.actions = {'Bite':self.bite, 'Move':self.move}
            self.str = 4
            self.agl = 6
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 16
            self.init = 7
            self.magick = 0
            self.spirit = 19
            self.acts = 2
            self.mvs = 2
            self.move_range = 4
        self.level = level
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['magick', 'slashing', 'piercing', 'fire', 'poison', 'elec']
        super().__init__(name, id, img, loc, owner)
        
    def bite(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bite)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Bite Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bite(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        n = 'Bite' + str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Bite', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_bite(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1666, lambda n = n : cleanup_bite(n))
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Bite', 'melee')
            root.after(333, self.finish_bite)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_bite)
        
    def finish_bite(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    
class Chirurgeon(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.level = level
        if level == 1:
            self.actions = {'Move':self.move, 'Stitch Cadaver':self.stitch_cadaver, 'Bone Pincers':self.bone_pincers, 'Willful Perambulation':self.willful_perambulation, 'Corrosive Glands':self.corrosive_glands, 'Alacrity':self.alacrity, 'Farsight':self.farsight, 'Enervating Grasp':self.enervating_grasp}
            self.str = 3
            self.agl = 4
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 4
            self.wis = 7
            self.rsn = 5
            self.san = 16
            self.init = 5
            self.spirit = 16
            self.magick = 19
            self.acts = 2
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Stitch Cadaver':self.stitch_cadaver, 'Bone Pincers':self.bone_pincers, 'Willful Perambulation':self.willful_perambulation, 'Corrosive Glands':self.corrosive_glands, 'Alacrity':self.alacrity, 'Farsight':self.farsight, 'Enervating Grasp':self.enervating_grasp}
            self.str = 3
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 5
            self.wis = 8
            self.rsn = 5
            self.san = 17
            self.init = 6
            self.spirit = 19
            self.magick = 28
            self.acts = 3
            self.mvs = 2
            self.move_range = 4
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison', 'acid', 'fire', 'magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def enervating_grasp(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_enervating_grasp)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Enervating Grasp Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_enervating_grasp(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enervating_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/bite.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Enervating_Grasp'] = Vis(name = 'Enervating_Grasp', loc = sqr[:])
        vis = app.vis_dict['Enervating_Grasp']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Enervating_Grasp')
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_psy = self.get_abl('psyche')
            tar_end = ent.get_abl('end')
            d = damage(my_psy, tar_end)
            tar_mgk = ent.magick
            if tar_mgk < d:
                d = tar_mgk
            ent.magick -= d
            self.magick += d
            if self.magick > self.base_magick:
                self.magick = self.base_magick
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Drain '+str(d)+' Magick', font = ('chalkduster', 14), fill = 'green2', tags = 'text')
            root.after(1999, self.finish_enervating_grasp)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_enervating_grasp)
        
    def finish_enervating_grasp(self, event = None):
        try: 
            del app.vis_dict['Enervating_Grasp']
            app.canvas.delete('Enervating_Grasp')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def farsight(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_farsight)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_farsight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Grant Farsight to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_farsight(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_farsight(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.name != 'Cadaver':
            return
        if 'Farsight' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 4:
            return
        self.magick -= 4
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/farsight.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Farsight'] = Vis(name = 'Farsight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Farsight'].img, tags = 'Farsight')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Farsight', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Farsight', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = '+6 mm, +2 bls, +1 msl', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = '+6 mm, +2 bls, +1 msl', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # +6 mm, +2 bls, +4 msl
        def alacrity_mm(stat):
            return stat+6
        p1 = partial(alacrity_mm)
        ent.mm_effects.append(p1)
        def alacrity_bls(stat):
            return stat+2
        p2 = partial(alacrity_bls)
        ent.bls_effects.append(p2)
        def alacrity_msl(stat):
            return stat+4
        p3 = partial(alacrity_msl)
        ent.msl_effects.append(p3)
        def un(ent, p1, p2, p3, lockname = None):
            ent.mm_effects.remove(p1)
            ent.bls_effects.remove(p2)
            ent.msl_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p1, p2, p3)
        n = 'Farsight' + str(app.count)
        ent.effects_dict['Farsight'] = Effect(name = 'Farsight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_farsight)
        
        
    def cleanup_farsight(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Farsight']
            app.canvas.delete('Farsight')
        except: pass
        app.canvas.delete('text')
        
        
    def alacrity(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_alacrity)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_alacrity(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Grant Alacrity to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_alacrity(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_alacrity(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.name != 'Cadaver':
            return
        if 'Alacrity' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if self.magick < 4:
            return
        self.magick -= 4
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/alacrity.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Alacrity'] = Vis(name = 'Alacrity', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Alacrity'].img, tags = 'Alacrity')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Alacrity', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Alacrity', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = '+5 agl, +2 move range, +1 moves', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = '+5 agl, +2 move range, +1 moves', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # +4 mv rng, str, +5 agl
        def alac_ef1(stat):
            return stat+4
        p1 = partial(alac_ef1)
        ent.str_effects.append(p1)
        ent.move_range_effects.append(p1)
        def alac_ef2(stat):
            return stat+5
        p2 = partial(alac_ef2)
        ent.agl_effects.append(p2)
        def un(ent, p1, p2, lockname = None):
            ent.str_effects.remove(p1)
            ent.move_range_effects.remove(p1)
            ent.agl_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p1, p2)
        n = 'Alacrity' + str(app.count)
        ent.effects_dict['Alacrity'] = Effect(name = 'Alacrity', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_alacrity)
        
        
    def cleanup_alacrity(self, event = None):
#         app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Alacrity']
            app.canvas.delete('Alacrity')
        except: pass
        app.canvas.delete('text')
        
        
        
        
    def willful_perambulation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_willful_p)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_willful_p(event = e, sqr = s, sqrs = sqrs)) 
        ##
        b = tk.Button(app.context_menu, text = 'Grant Willful Perambulation to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_willful_p(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_willful_p(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Willful_Move' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/bone_pincers.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Willful_Perambulation'] = Vis(name = 'Willful_Perambulation', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Willful_Perambulation'].img, tags = 'Willful_Perambulation')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Willful Perambulation', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Willful Perambulation', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Move Granted', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Move Granted', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        # ADD ACTION TO TARGET
        def add_move(actions = None, obj = None):
            actions['Move'] = ent.move
            return actions
        p2 = partial(add_move, obj = ent)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Willful_Move' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Willful_Move', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_willful_p)
        
    def finish_willful_p(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Willful_Perambulation']
            app.canvas.delete('Willful_Perambulation')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def corrosive_glands(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_c_glands)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_c_glands(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Grant Corrosive Glands to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_c_glands(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_c_glands(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Corrosive_Attack' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/corrosive_glands.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Corrosive_Glands'] = Vis(name = 'Corrosive_Glands', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Corrosive_Glands'].img, tags = 'Corrosive_Glands')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Corrosive Glands', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Corrosive Glands', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Corrosive Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Corrosive Attack', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def c_glands_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(obj.loc,c) <= obj.get_abl('bls')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Corrosive Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/corrosive_attack.ogg')
#                 effect1.set_volume(1)
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = ent.loc[:]
                app.vis_dict['Corrosive_Attack'] = Vis(name = 'Corrosive_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Corrosive_Attack'].img, tags = 'Corrosive_Attack')
                my_mm = obj.get_abl('mm')
                tar_dodge = ent.get_abl('dodge')
                if to_hit(my_mm, tar_dodge):
                    my_msl = obj.get_abl('msl')
                    tar_end = ent.get_abl('end')
                    d = damage(my_msl, tar_end)
                    lock(apply_damage, obj, ent, -d, 'acid', 'Corrosive Attack', 'ranged')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Corrosive_Attack']
                    app.canvas.delete('Corrosive_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(c_glands_attack, obj = ent)
        def add_c_glands_attack(actions = None, func = None):
            actions['Corrosive Attack'] = func
            return actions
        p2 = partial(add_c_glands_attack, func = p)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Corrosive_Attack' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Corrosive_Attack', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_c_glands)
        
    def finish_c_glands(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Corrosive_Glands']
            app.canvas.delete('Corrosive_Glands')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def bone_pincers(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bone_pincers)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_bone_pincers(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Graft Bone Pincers to Cadaver', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_bone_pincers(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bone_pincers(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        if ent.name != 'Cadaver':
            return
        if 'Bone_Pincer_Attack' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/bone_pincers.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Bone_Pincers'] = Vis(name = 'Bone_Pincers', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Bone_Pincers'].img, tags = 'Bone_Pincers')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bone Pincers', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bone Pincers', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        loc = ent.loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Bone Pincer Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Bone Pincer Attack', justify = 'center', fill = 'thistle3', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def pincer_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Bone Pincer Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                ent = app.ent_dict[id]
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/pincer_attack.ogg')
#                 effect1.set_volume(1)
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Bone_Pincer_Attack'] = Vis(name = 'Bone_Pincer_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Bone_Pincer_Attack'].img, tags = 'Bone_Pincer_Attack')
                my_agl = obj.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    my_str = obj.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    lock(apply_damage, obj, ent, -d, 'slashing', 'Bone Pincers', 'melee')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Bone_Pincer_Attack']
                    app.canvas.delete('Bone_Pincer_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(pincer_attack, obj = ent)
        def add_pincer_attack(actions = None, func = None):
            actions['Bone Pincer Attack'] = func
            return actions
        p2 = partial(add_pincer_attack, func = p)
        ent.action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p2)
        n = 'Bone_Pincer_Attack' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Bone_Pincer_Attack', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_bone_pincers)
        
    def finish_bone_pincers(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Bone_Pincers']
            app.canvas.delete('Bone_Pincers')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
        
    def stitch_cadaver(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_stitch_cadaver)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn') and app.grid[c[0]][c[1]]=='']
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_stitch_cadaver(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose Location for Cadaver", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_stitch_cadaver(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_stitch_cadaver(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id != '':
            return
        if self.magick < 4:
            return
        self.magick -= 4
#         effect1 = mixer.Sound('Sound_Effects/stitch_cadaver.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        vis = app.vis_dict['Summon']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Summon')
        def cleanup_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(2666, cleanup_summon)
        root.after(2333, lambda s = sqr[:] : self.continue_stitch_cadaver(s))
        
    def continue_stitch_cadaver(self, sqr):
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Cadaver.png'))
        if self.owner == 'p1':
            id = 'a'+str(app.ent_dict[app.p1_witch].summon_ids)
            app.ent_dict[app.p1_witch].summon_ids += 1
        else:
            id = 'b'+str(app.ent_dict[app.p2_witch].summon_ids)
            app.ent_dict[app.p2_witch].summon_ids += 1
        app.ent_dict[id] =  Cadaver(name = 'Cadaver', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.finish_stitch_cadaver()
        
    def finish_stitch_cadaver(self, event = None):
        app.generic_cancel()
        
        
        # base = slashing mel, wdn skn = crsh mele, calc = pierc mel, unsta = crsh mel, chim = fire,ranged, mold efl = poison, sq crp = slsh, win ver = slsh, nox resp = acid
class Fell_Evolver(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Assail':self.assail, 'Wooden Skin':self.wooden_skin, 'Calcify':self.calcify, 'Unstable Fervor':self.unstable_fervor, 'Chimeric Mutation':self.chimeric_mutation, 'Moldering Effluvium':self.moldering_effluvium, 'Squamous Carapace':self.squamous_carapace, 'Winnowing_Verdure':self.winnowing_verdure, 'Noxious_Respiration':self.noxious_respiration}
            self.str = 7
            self.agl = 7
            self.end = 7
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 5
            self.wis = 5
            self.rsn = 5
            self.san = 17
            self.init = 4
            self.spirit = 25
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Assail':self.assail, 'Wooden Skin':self.wooden_skin, 'Calcify':self.calcify, 'Unstable Fervor':self.unstable_fervor, 'Chimeric Mutation':self.chimeric_mutation, 'Moldering Effluvium':self.moldering_effluvium, 'Squamous Carapace':self.squamous_carapace, 'Winnowing Verdure':self.winnowing_verdure, 'Noxious Respiration':self.noxious_respiration}
            self.str = 8
            self.agl = 8
            self.end = 8
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 6
            self.wis = 6
            self.rsn = 6
            self.san = 19
            self.init = 5
            self.spirit = 31
            self.magick = 0
            self.acts = 2
            self.mvs = 1
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['cold']
        self.resist = ['poison', 'acid', 'explosive']
        self.evolved = False
        super().__init__(name, id, img, loc, owner)
        
        
    # atk efct, add efct -3 rsn, mv rng, atk type becomes poison, rmv all wkns, add all rsts
    def noxious_respiration(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_noxious_respiration)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_noxious_respiration(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Noxious Respiration', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_noxious_respiration(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_noxious_respiration(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Moldering_Effluvium' not in [v.name for v in self.effects_dict.values()] and 'Squamous_Carapace' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Noxious_Respiration' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Winnowing_Verdure' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Noxious Respiration', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Noxious Respiration', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Noxious_Respiration'] = Vis(name = 'Noxious_Respiration', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'atk adds -3 rsn, mv rng and is poison type, remove all wkns, add all resists', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'atk adds -3 rsn, mv rng and is poison type, remove all wkns, add all resists', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATTACK EFFECT
        def noxious_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            loc = dfndr.loc[:]
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'poison'
                def nox_abl(stat):
                    return max(0,stat-3)
                p = partial(nox_abl)
                dfndr.rsn_effects.append(p)
                dfndr.move_range_effects.append(p)
                n = 'nox_venom'+str(app.count)
                app.count += 1
                def undo(ent, p, lockname = None):
                    ent.rsn_effects.remove(p)
                    ent.move_range_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, dfndr, p)
                dfndr.effects_dict[n] = Effect(name = 'Noxious_Venom', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Noxious Venom, -3 rsn, mv rng', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Noxious Venom, -3 rsn, mv rng', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(noxious_atk)
        # RESIST / WEAK
        def noxious_resist(types):
            return types+['crushing','slashing','piercing','fire','cold','elec','explosive','poison','acid','magick']
        self.resist_effects.append(noxious_resist)
        def noxious_weak(types):
            return []
        self.weak_effects.append(noxious_weak)
        def undo(ent, lockname = None):
            ent.attack_effects.remove(noxious_atk)
            ent.resist_effects.remove(noxious_resist)
            ent.weak_effects.remove(noxious_weak)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self)
        self.effects_dict['Noxious_Respiration'] = Effect(name = 'Noxious_Respiration', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_noxious_respiration)
        
    def finish_noxious_respiration(self, event = None):
        try: 
            del app.vis_dict['Noxious_Respiration']
            app.canvas.delete('Noxious_Respiration')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    # prx efct all enemy rng 3 get -4 agl,init, fire wkns
    def winnowing_verdure(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_winnowing_verdure)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_winnowing_verdure(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Winnowing Verdure', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_winnowing_verdure(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_winnowing_verdure(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Moldering_Effluvium' not in [v.name for v in self.effects_dict.values()] and 'Squamous_Carapace' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Noxious_Respiration' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Winnowing_Verdure' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Winnowing Verdure', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Winnowing Verdure', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Winnowing_Verdure'] = Vis(name = 'Winnowing_Verdure', loc = sqr[:])
        # enemy rng 3 -4 agl,init, fire wkns
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'enemy rng 3 -4 agl,init, fire wkns', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'enemy rng 3 -4 agl,init, fire wkns', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def verdure_weak(types):
            return types+['fire']
        p2 = partial(verdure_weak)
        def verdure_ef(stat):
            return max(1,stat-4)
        p = partial(verdure_ef)
        prox_ef = Proximity_Effect(name = 'Winnowing_Verdure', ent = self, range = (1,3), weak_func = p2, abl = 'agl', abl_func = p)
        prox_ef2 = Proximity_Effect(name = 'Winnowing_Verdure', ent = self, range = (1,3), abl = 'init', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prox_ef2.get_locs = p2
        prx_name = 'Winnowing_Verdure'+str(app.count)
        app.count+=1
        prx_name2 = 'Winnowing_Verdure'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        app.proximity_effects_dict[prx_name2] = prox_ef2
        def un(prx_key, prx_key2, lockname = None):
            del app.proximity_effects_dict[prx_key]
            del app.proximity_effects_dict[prx_key2]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name, prx_name2)
        n = 'Winnowing_Verdure' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Winnowing_Verdure', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_winnowing_verdure)
        
    def finish_winnowing_verdure(self, event = None):
        try: 
            del app.vis_dict['Winnowing_Verdure']
            app.canvas.delete('Winnowing_Verdure')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # base melee attack, changed by other actions... starts as piercing melee
    def assail(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_assail)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_assail(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Assail Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_assail(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_assail(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/assail.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Assail'] = Vis(name = 'Assail', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_assail():
                del app.vis_dict['Assail']
                app.canvas.delete('Assail')
            root.after(1666, cleanup_assail)
            lock(apply_damage, self, ent, -d, 'slashing', 'Assail', 'melee')
            root.after(111, self.cancel_assail)
        else:
            miss(sqr)
            root.after(1777, self.cancel_assail)
        
    def cancel_assail(self, event = None):
        self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Assail']
            app.canvas.delete('Assail')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # changes attack to crushing that adds 'splinter' efct, eot 2 piercing, adds rst crsh, wkns fire, cannot use with calcify
    def wooden_skin(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_wooden_skin)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_wooden_skin(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Wooden Skin', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_wooden_skin(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wooden_skin(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Calcify' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Wooden_Skin' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Wooden Skin', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Wooden Skin', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Wooden_Skin'] = Vis(name = 'Wooden_Skin', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Crushing Attack, resist crushing, weak fire', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Crushing Attack, resist crushing, weak fire', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATTACK EFFECT
        def wooden_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            loc = dfndr.loc[:]
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'crushing'
                def take_2(ent, lockname = None):
                    lock(apply_damage, self, ent, -2, 'piercing', 'Splinters', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                eot = partial(take_2, dfndr)
                n = 'Splinters'+str(app.count)
                app.count += 1
                def undo(lockname = None):
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo)
                dfndr.effects_dict[n] = Effect(name = 'Splinters', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Splinters...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Splinters...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(wooden_atk)
        # RESIST / WEAK
        def wooden_resist(types):
            return types+['crushing']
        self.resist_effects.append(wooden_resist)
        def wooden_weak(types):
            return types+['fire']
        self.weak_effects.append(wooden_weak)
        def undo(ent, lockname = None):
            ent.attack_effects.remove(wooden_atk)
            ent.resist_effects.remove(wooden_resist)
            ent.weak_effects.remove(wooden_weak)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self)
        self.effects_dict['Wooden_Skin'] = Effect(name = 'Wooden_Skin', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_wooden_skin)
        
    def finish_wooden_skin(self, event = None):
        try: 
            del app.vis_dict['Wooden_Skin']
            app.canvas.delete('Wooden_Skin')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with wooden skin, +2 end, wis, psy, adds wkns crshng, adds rst mgk, elec
    def calcify(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_calcify)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_calcify(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Calcify', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_calcify(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_calcify(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Calcify' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Wooden_Skin' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Calcify', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Calcify', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Calcify'] = Vis(name = 'Calcify', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+2 end, wis, psy, resist magick elec, weak crushing', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+2 end, wis, psy, resist magick elec, weak crushing', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATK EFFECT
        def calcify_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'piercing'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(calcify_atk)
        # +ABLS
        def calcify_efct(stat):
            return stat+2
        p = partial(calcify_efct)
        self.end_effects.append(p)
        self.wis_effects.append(p)
        self.psyche_effects.append(p)
        # RESIST / WEAK
        def calc_resist(types):
            return types+['magick', 'elec']
        self.resist_effects.append(calc_resist)
        def calc_weak(types):
            return types+['crushing']
        self.weak_effects.append(calc_weak)
        def undo(ent, p, lockname = None):
            ent.end_effects.remove(p)
            ent.wis_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.resist_effects.remove(calc_resist)
            ent.weak_effects.remove(calc_weak)
            ent.attack_effects.remove(calcify_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Calcify'] = Effect(name = 'Calcify', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_calcify)
        
    def finish_calcify(self, event = None):
        try: 
            del app.vis_dict['Calcify']
            app.canvas.delete('Calcify')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with chimeric mutation, +1 acts, mvs, +5 init, removes all resist, must have wooden skin or calcify
    def unstable_fervor(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_unstable_fervor)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_unstable_fervor(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Unstable Fervor', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_unstable_fervor(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_unstable_fervor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Chimeric_Mutation' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Unstable_Fervor' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Unstable Fervor', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Unstable Fervor', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Unstable_Fervor'] = Vis(name = 'Unstable_Fervor', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+1 acts, moves, +5 init, remove resists', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+1 acts, moves, +5 init, remove resists', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # ATK EFFECT
        def unstable_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'crushing'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(unstable_atk)
        # +ABLS
        def unst_fer_efct(stat):
            return stat+1
        p = partial(unst_fer_efct)
        self.acts_effects.append(p)
        self.mvs_effects.append(p)
        def unst_init(stat):
            return stat+5
        p2 = partial(unst_init)
        self.init_effects.append(p2)
        # RESIST / WEAK
        def unst_fer_resist(types):
            return []
        self.resist_effects.append(unst_fer_resist)
        def undo(ent, p, p2, lockname = None):
            ent.acts_effects.remove(p)
            ent.mvs_effects.remove(p)
            ent.init_effects.remove(p2)
            ent.resist_effects.remove(unst_fer_resist)
            ent.attack_effects.remove(unstable_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2)
        self.effects_dict['Unstable_Fervor'] = Effect(name = 'Unstable_Fervor', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_unstable_fervor)
        
    def finish_unstable_fervor(self, event = None):
        try: 
            del app.vis_dict['Unstable_Fervor']
            app.canvas.delete('Unstable_Fervor')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with unstable fervor, changes move type to flying, +5 mv rng, removes all wkns, gets new action: ranged fire dmg to all dist1, must have wooden skin or calcify
    def chimeric_mutation(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chimeric_mutation)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chimeric_mutation(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Chimeric Mutation', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chimeric_mutation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chimeric_mutation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Chimeric_Mutation' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Unstable_Fervor' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Chimeric Mutation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Chimeric Mutation', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Chimeric_Mutation'] = Vis(name = 'Chimeric_Mutation', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'flying, +5 mv rng, remove wkns, scorch fire attack', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'flying, +5 mv rng, remove wkns, scorch fire attack', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # +ABLS
        def chi_mu_efct(stat):
            return stat+5
        p = partial(chi_mu_efct)
        self.move_range_effects.append(p)
        def chi_mv_type(type):
            return 'flying'
        p2 = partial(chi_mv_type)
        self.move_type_effects.append(p2)
        # RESIST / WEAK
        def chi_mu_weak(types):
            return []
        self.weak_effects.append(chi_mu_weak)
        # ATK EFCT FIRE
        def fire_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            type = 'fire'
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            return dmg,type
        self.attack_effects.append(fire_atk)
        # ADD SCORCH
        def scorch_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if 1 <= dist(obj.loc,c) <= obj.get_abl('rsn')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Scorch', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/flare.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                def cleanup_scorch(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                def scorch_loop(ids):
                    if ids == []:
                        cancel_attack(None, obj)
                    else:
                        id = ids[0]
                        ids = ids[1:]
                        ent = app.ent_dict[id]
                        n = 'scorch'+str(app.count)
                        app.count += 1
                        app.vis_dict[n] = Vis(name = 'Immolate', loc = ent.loc)
                        root.after(1666, lambda n = n : cleanup_scorch(n))
                        my_wis = obj.get_abl('wis')
                        tar_wis = ent.get_abl('wis')
                        if to_hit(my_wis, tar_wis) == True:
                            my_psy = obj.get_abl('psyche')
                            tar_psy = ent.get_abl('psyche')
                            d = damage(my_psy, tar_psy)
                            lock(apply_damage, obj, ent, -d, 'fire', 'Scorch', 'ranged')
                            root.after(111, lambda ids = ids : scorch_loop(ids))
                        else:
                            miss(ent.loc)
                            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1444, lambda ids = ids : scorch_loop(ids))
                ids = [k for k,v in app.all_ents().items() if dist(v.loc,sqr)<=1 and v.owner != self.owner]
                scorch_loop(ids)
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                app.rebind_all()
                app.canvas.delete('text')
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        ap = partial(scorch_attack, obj = self)
        def add_scorch(actions = None, func = None):
            actions['Scorch'] = func
            return actions
        ap2 = partial(add_scorch, func = ap)
        self.action_effects.append(ap2)
        def undo(ent, p, p2, ap2, lockname = None):
            ent.move_range_effects.remove(p)
            ent.move_type_effects.remove(p2)
            ent.weak_effects.remove(chi_mu_weak)
            ent.action_effects.remove(ap2)
            ent.attack_effects.remove(fire_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p, p2, ap2)
        self.effects_dict['Chimeric_Mutation'] = Effect(name = 'Chimeric_Mutation', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_chimeric_mutation)
        
    def finish_chimeric_mutation(self, event = None):
        try: 
            del app.vis_dict['Chimeric_Mutation']
            app.canvas.delete('Chimeric_Mutation')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with squ_carapc, prx efct for self, eot all adj enemy get -4 end, add resist poison, acid, remove wkns poison acid, must have unstable fervor or chimeric mutation and wooden skin or calcify
    def moldering_effluvium(self, event = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_moldering_effluvium)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_moldering_effluvium(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Moldering Effluvium', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_moldering_effluvium(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_moldering_effluvium(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Moldering_Effluvium' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Squamous_Carapace' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Moldering Effluvium', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Moldering Effluvium', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Moldering_Effluvium'] = Vis(name = 'Moldering_Effluvium', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'eot -4 end adjacent, add resist poison, acid, remove wkns poison, acid', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'eot -4 end adjacent, add resist poison, acid, remove wkns poison, acid', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # EOT EFCT
        def mold_plag(caster, lockname = None):
            def mold_plag_loop(ids):
                if ids == []:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    id = ids[0]
                    ids = ids[1:]
                    ent = app.ent_dict[id]
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '-4 endurance', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '-4 endurance', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                    def mold_plag(stat):
                        return max(1,stat-4)
                    p = partial(mold_plag)
                    ent.end_effects.append(p)
                    def un(ent, p, lockname = None):
                        ent.end_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, ent, p)
                    n = 'mold_effl_plag' + str(app.count)
                    app.count += 1
                    ent.effects_dict[n] = Effect(name = 'Moldering_Effluvium_Plague', undo_func = u, duration = caster.get_abl('rsn'), level = caster.get_abl('wis'))
                    root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1444, lambda ids = ids : mold_plag_loop(ids))
            ids = [k for k,v in app.all_ents().items() if dist(v.loc,caster.loc)==1 and v.owner != caster.owner]
            mold_plag_loop(ids)
        eot = partial(mold_plag, self)
        # ATK EFFECT
        def mold_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'poison'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(mold_atk)
        # RESIST / WEAK
        def mol_eff_resist(types):
            return types+['poison','acid']
        self.resist_effects.append(mol_eff_resist)
        def mol_eff_wkns(types):
            return [t for t in types if t != 'poison' and t != 'acid']
        self.weak_effects.append(mol_eff_wkns)
        def undo(ent, lockname = None):
            ent.resist_effects.remove(mol_eff_resist)
            ent.weak_effects.remove(mol_eff_wkns)
            ent.attack_effects.remove(mold_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self)
        self.effects_dict['Moldering_Effluvium'] = Effect(name = 'Moldering_Effluvium', undo_func = u, eot_func = eot, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_moldering_effluvium)
        
    def finish_moldering_effluvium(self, event = None):
        try: 
            del app.vis_dict['Moldering_Effluvium']
            app.canvas.delete('Moldering_Effluvium')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # cannot use with mold_effl, eot heal 4 to self, remove wkns slsh, prcng, fire, cold, +2 str, agl, must have unstable fervor or chimeric mutation and wooden skin or calcify
    def squamous_carapace(self, even = None):
        if self.evolved == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_squamous_carapace)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_squamous_carapace(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Squamous Carapace', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_squamous_carapace(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_squamous_carapace(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if ('Calcify' not in [v.name for v in self.effects_dict.values()] and 'Wooden_Skin' not in [v.name for v in self.effects_dict.values()]):
            return
        if ('Chimeric_Mutation' not in [v.name for v in self.effects_dict.values()] and 'Unstable_Fervor' not in [v.name for v in self.effects_dict.values()]):
            return
        if 'Moldering_Effluvium' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Squamous_Carapace' in [v.name for v in self.effects_dict.values()]:
            return
        self.evolved = True
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Squamous Carapace', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Squamous Carapace', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Squamous_Carapace'] = Vis(name = 'Squamous_Carapace', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'eot heal 4, remove wkns slsh, prcng, fire, cold, +2 str, agl', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'eot heal 4, remove wkns slsh, prcng, fire, cold, +2 str, agl', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        # EOT EFCT
        def squam_eot(ent, lockname = None):
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '+4 spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '+4 spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            apply_heal(ent, ent, 4)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
            root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(squam_eot, self)
        # ATK EFFECT
        def squam_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
            if st == 'melee' or st == 'ranged' or st == 'spell':
                type = 'cold'
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return dmg,type
        self.attack_effects.append(squam_atk)
        # RESIST / WEAK
        def squam_wkns(types):
            return [t for t in types if t != 'slashing' and t != 'piercing' and t != 'fire' and t != 'cold']
        self.weak_effects.append(squam_wkns)
        # ABL
        def squam_abl(stat):
            return stat+2
        p = partial(squam_abl)
        self.str_effects.append(p)
        self.agl_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.weak_effects.remove(squam_wkns)
            ent.str_effects.remove(p)
            ent.agl_effects.remove(p)
            ent.attack_effects.remove(squam_atk)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Squamous_Carapace'] = Effect(name = 'Squamous_Carapace', undo_func = u, eot_func = eot, duration = self.get_abl('str'), level = self.get_abl('str'))
        root.after(2666, self.finish_squamous_carapace)
        
    def finish_squamous_carapace(self, event = None):
        try: 
            del app.vis_dict['Squamous_Carapace']
            app.canvas.delete('Squamous_Carapace')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
class Hexmage(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Nimbus of Oppression':self.nimbus_of_oppression, 'Halo of Encumberance':self.halo_of_encumberance, 'Psychic Suffocation':self.psychic_suffocation, 'Torpor Field':self.torpor_field, 'Nix':self.nix, 'Feedback':self.feedback, 'Trenchant Lunula':self.trenchant_lunula, 'Pierce the Heart':self.pierce_the_heart}
            self.str = 5
            self.agl = 5
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 7
            self.wis = 7
            self.rsn = 5
            self.san = 15
            self.init = 6
            self.spirit = 19
            self.magick = 18
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Nimbus of Oppression':self.nimbus_of_oppression, 'Halo of Encumberance':self.halo_of_encumberance, 'Psychic Suffocation':self.psychic_suffocation, 'Torpor Field':self.torpor_field, 'Nix':self.nix, 'Feedback':self.feedback, 'Trenchant Lunula':self.trenchant_lunula, 'Pierce the Heart':self.pierce_the_heart}
            self.str = 6
            self.agl = 6
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 8
            self.wis = 8
            self.rsn = 5
            self.san = 16
            self.init = 6
            self.spirit = 27
            self.magick = 29
            self.acts = 2
            self.mvs = 1
            self.move_range = 5
            self.level = level
        self.move_type = 'normal'
        self.weak = []
        self.resist = ['poison', 'magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def nix(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_nix)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_nix(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nix', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_nix(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nix(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Nix', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Nix', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Nix'] = Vis(name = 'Nix', loc = self.loc[:])
        spacer = 30
        to_remove = []
        for k,v in self.effects_dict.items():
            if v.name == 'Nimbus_of_Oppression' or v.name == 'Halo_of_Encumberance' or v.name == 'Psychic_Suffocation' or v.name == 'Torpor_Field':
                if v.dispel(self.get_abl('wis')+10) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'Ivory', tags = 'text')
                    spacer += 15
        for k in to_remove:
            del self.effects_dict[k]
        root.after(1999, self.cancel_nix)
        
    def cancel_nix(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Nix']
            app.canvas.delete('Nix')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def pierce_the_heart(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_pierce_the_heart)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_pierce_the_heart(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pierce the Heart', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_pierce_the_heart(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pierce_the_heart(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Pierce_the_Heart'] = Vis(name = 'Pierce_the_Heart', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = '-2 strength', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = '-2 strength', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def pierce_efct(stat):
                return max(1,stat-2)
            p = partial(pierce_efct)
            ent.str_effects.append(p)
            def undo(ent, func, lockname = None):
                    ent.str_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Pierce_the_Heart'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Pierce_the_Heart', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Pierce_the_Heart']
                app.canvas.delete('Pierce_the_Heart')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, ent, -d, 'piercing', 'Pierce the Heart', 'melee')
            root.after(111, self.cancel_pierce_the_heart)
        else:
            miss(sqr)
            root.after(1999, self.cancel_pierce_the_heart)
        
    
    def cancel_pierce_the_heart(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Pierce_the_Heart']
            app.canvas.delete('Pierce_the_Heart')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def psychic_suffocation(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_psychic_suffocation)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_psychic_suffocation(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Psychic Suffocation', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_psychic_suffocation(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psychic_suffocation(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) == 1 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Psychic Suffocation', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Psychic Suffocation', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Psychic_Suffocation'] = Vis(name = 'Psychic_Suffocation', loc = self.loc[:])
        def psy_suff_ef(stat):
            return max(0,stat-1)
        p = partial(psy_suff_ef)
        prox_ef = Proximity_Effect(name = 'Psychic_Suffocation', ent = self, range = (1,1), abl = 'acts', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Psychic_Suffocation'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Psychic_Suffocation' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Psychic_Suffocation', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_psychic_suffocation)
        
    def finish_psychic_suffocation(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Psychic_Suffocation']
            app.canvas.delete('Psychic_Suffocation')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def trenchant_lunula(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_trenchant_lunula)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_trenchant_lunula(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Trenchant Lunula', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_trenchant_lunula(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_trenchant_lunula(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Trenchant_Lunula'] = Vis(name = 'Trenchant_Lunula', loc = sqr[:])
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            # -2 reason
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = '-2 reason', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = '-2 reason', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def lunula_efct(stat):
                return max(1,stat-2)
            p = partial(lunula_efct)
            ent.rsn_effects.append(p)
            def undo(ent, func, lockname = None):
                    ent.rsn_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Trenchant_Lunula'+str(app.count)
            ent.effects_dict[n] = Effect(name = 'Trenchant_Lunula', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Trenchant_Lunula']
                app.canvas.delete('Trenchant_Lunula')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, ent, -d, 'slashing', 'Trenchant Lunula', 'melee')
            root.after(111, self.cancel_trenchant_lunula)
        else:
            miss(sqr)
            root.after(1999, self.cancel_trenchant_lunula)
        
    
    def cancel_trenchant_lunula(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Trenchant_Lunula']
            app.canvas.delete('Trenchant_Lunula')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def torpor_field(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_torpor_field)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_torpor_field(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Torpor Field', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_torpor_field(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_torpor_field(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Torpor Field', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Torpor Field', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Torpor_Field'] = Vis(name = 'Torpor_Field', loc = self.loc[:])
        def torpor_ef(stat):
            return max(0,stat-4)
        p = partial(torpor_ef)
        prox_ef = Proximity_Effect(name = 'Torpor_Field', ent = self, range = (1,3), abl = 'move_range', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Torpor_Field'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Torpor_Field' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Torpor_Field', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_torpor_field)
        
    def finish_torpor_field(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Torpor_Field']
            app.canvas.delete('Torpor_Field')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
        
    def nimbus_of_oppression(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_nimbus_of_oppression)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_nimbus_of_oppression(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nimbus of Oppression', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_nimbus_of_oppression(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nimbus_of_oppression(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Nimbus of Oppression', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Nimbus of Oppression', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Nimbus_of_Oppression'] = Vis(name = 'Nimbus_of_Oppression', loc = self.loc[:])
        def nimbus_ef(stat):
            return max(1,stat-4)
        p = partial(nimbus_ef)
        prox_ef = Proximity_Effect(name = 'Nimbus_of_Oppression', ent = self, range = (1,3), abl = 'psyche', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Nimbus_of_Oppression'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Nimbus_of_Oppression' + str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Nimbus_of_Oppression', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_nimbus_of_oppression)
        
    def finish_nimbus_of_oppression(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Nimbus_of_Oppression']
            app.canvas.delete('Nimbus_of_Oppression')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    def halo_of_encumberance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_halo_of_encumberance)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_halo_of_encumberance(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nimbus of Oppression', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_halo_of_encumberance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_halo_of_encumberance(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Nimbus_of_Oppression' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Halo_of_Encumberance' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Psychic_Suffocation' in [v.name for k,v in self.effects_dict.items()]:
            return
        if 'Torpor_Field' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Halo of Encumberance', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Halo of Encumberance', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Halo_of_Encumberance'] = Vis(name = 'Halo_of_Encumberance', loc = self.loc[:])
        def nimbus_ef(stat):
            return max(1,stat-4)
        p = partial(nimbus_ef)
        prox_ef = Proximity_Effect(name = 'Halo_of_Encumberance', ent = self, range = (1,3), abl = 'str', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Halo_of_Encumberance'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Halo_of_Encumberance' + str(app.count)
        self.effects_dict[n] = Effect(name = 'Halo_of_Encumberance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, self.finish_halo_of_encumberance)
        
    def finish_halo_of_encumberance(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Halo_of_Encumberance']
            app.canvas.delete('Halo_of_Encumberance')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def feedback(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_feedback)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_feedback(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Feedback Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_feedback(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_feedback(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Feedback'] = Vis(name = 'Feedback', loc = sqr[:])
        def cleanup_feedback():
            del app.vis_dict['Feedback']
            app.canvas.delete('Feedback')
        d = len([k for k,v in ent.effects_dict.items()])
        root.after(1555, cleanup_feedback)
        lock(apply_damage, self, ent, -d, 'elec', 'Feedback', 'melee')
        root.after(111, self.finish_feedback)
        
    def finish_feedback(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
        
        
class Thaumaturge(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Unholy Chant':self.unholy_chant, 'Arrow of Diana' : self.arrow_of_diana, 'Zephyr Lance':self.zephyr_lance, 'Moonlight' : self.moonlight, 'Esuna':self.esuna, 'Concerted Volley':self.concerted_volley}
            self.str = 3
            self.agl = 8
            self.end = 4
            self.mm = 6
            self.msl = 5
            self.bls = 8
            self.dodge = 5
            self.psyche = 4
            self.wis = 6
            self.rsn = 4
            self.san = 14
            self.init = 7
            self.spirit = 16
            self.magick = 15
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Unholy Chant':self.unholy_chant, 'Arrow of Diana' : self.arrow_of_diana, 'Zephyr Lance':self.zephyr_lance, 'Moonlight' : self.moonlight, 'Esuna':self.esuna, 'Aura':self.aura, 'Tranquility':self.tranquility, 'Concerted Volley':self.concerted_volley, "Devil's Mark":self.devils_mark}
            self.str = 4
            self.agl = 9
            self.end = 5
            self.mm = 8
            self.msl = 6
            self.bls = 9
            self.dodge = 5
            self.psyche = 5
            self.wis = 7
            self.rsn = 5
            self.san = 13
            self.init = 8
            self.spirit = 27
            self.magick = 29
            self.acts = 2
            self.mvs = 2
            self.move_range = 5
            self.level = level
#             name = 'Ranger' #this works, just need appr anim files
        self.move_type = 'normal'
        self.weak = ['poison']
        self.resist = ['slashing']
        super().__init__(name, id, img, loc, owner)
        
        
    def devils_mark(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_devils_mark)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_devils_mark(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Confirm Devil's Mark Target", wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_devils_mark(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_devils_mark(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.spell_target_ents().keys()]:
            return
        if self.magick < 3:
            return
        self.magick -= 3
        if "Devil's_Mark" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/devils_mark.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict["Devil's_Mark"] = Vis(name = "Devil's_Mark", loc = sqr[:])
        vis = app.vis_dict["Devil's_Mark"]
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = "Devil's_Mark")
        app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
        bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
        bg.create_text(15, 15, text= 'Choose Ability...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
        app.context_buttons.append(bg)
        abls = ['strength', 'aglility', 'endurance', 'marksmanship', 'missle', 'ballistics', 'dodge', 'psyche', 'wisdom', 'reason', 'sanity', 'initiative']
        for abl in abls:
            b = tk.Button(app.context_menu, text = abl, wraplength = 190, font = ('chalkduster', 16), fg = 'tan3', highlightbackground = 'tan3', command = lambda id = id, abl = abl : self.choose_mark(id, abl))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            
    def choose_mark(self, id, abl):
        app.depop_context(event = None)
        app.canvas.delete('text')
        ent = app.ent_dict[id]
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = '+2 ability', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = '+2 ability', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def devils_mark_efct(stat):
            return stat+2
        p = partial(devils_mark_efct)
        if abl == 'strength':
            ent.str_effects.append(p)
        elif abl == 'agility':
            ent.agl_effects.append(p)
        elif abl == 'endurance':
            ent.end_effects.append(p)
        elif abl == 'marksmanship':
            ent.mm_effects.append(p)
        elif abl == 'missle':
            ent.msl_effects.append(p)
        elif abl == 'ballistics':
            ent.bls_effects.append(p)
        elif abl == 'dodge':
            ent.dodge_effects.append(p)
        elif abl == 'psyche':
            ent.psyche_effects.append(p)
        elif abl == 'wisdom':
            ent.wis_effects.append(p)
        elif abl == 'reason':
            ent.rsn_effects.append(p)
        elif abl == 'sanity':
            ent.san_effects.append(p)
        elif abl == 'initiative':
            ent.init_effects.append(p)
        def undo(id, abl, func, lockname = None):
            if abl == 'strength':
                app.ent_dict[id].str_effects.remove(func)
            elif abl == 'agility':
                app.ent_dict[id].agl_effects.remove(func)
            elif abl == 'endurance':
                app.ent_dict[id].end_effects.remove(func)
            elif abl == 'marksmanship':
                app.ent_dict[id].mm_effects.remove(func)
            elif abl == 'missle':
                app.ent_dict[id].msl_effects.remove(func)
            elif abl == 'ballistics':
                app.ent_dict[id].bls_effects.remove(func)
            elif abl == 'dodge':
                app.ent_dict[id].dodge_effects.remove(func)
            elif abl == 'psyche':
                app.ent_dict[id].psyche_effects.remove(func)
            elif abl == 'wisdom':
                app.ent_dict[id].wis_effects.remove(func)
            elif abl == 'reason':
                app.ent_dict[id].rsn_effects.remove(func)
            elif abl == 'sanity':
                app.ent_dict[id].san_effects.remove(func)
            elif abl == 'initiative':
                app.ent_dict[id].init_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, abl, p)
        n = "Devil's_Mark"+str(app.count)
        ent.effects_dict[n] = Effect(name = "Devil's_Mark", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.cleanup_devils_mark)
        
    def cleanup_devils_mark(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict["Devil's_Mark"]
            app.canvas.delete("Devil's_Mark")
        except: pass
        app.canvas.delete('text')
        
        
    def aura(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_aura)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_aura(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Aura', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_aura(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aura(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/aura.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3 and v.owner == self.owner]
        app.get_focus(choice(ents))
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Aura', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Aura', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        for id in ents:
            loc = app.ent_dict[id].loc[:]
            r = randrange(1,self.get_abl('psyche')+1)
            apply_heal(self, app.ent_dict[id], r)
            un = 'Aura' + str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Aura', loc = loc[:])
            vis = app.vis_dict[un]
            app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = vis.img, tags = un)
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+74, text = '+'+str(r)+' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+75, text = '+'+str(r)+' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def cleanup_aura(un):
                del app.vis_dict[un]
                app.canvas.delete(un)
            root.after(2666, lambda un = un : cleanup_aura(un))
        root.after(2777, self.finish_aura)
        
    def finish_aura(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)

    def tranquility(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_tranquility)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_tranquility(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Tranquility Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_tranquility(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_tranquility(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/tranquility.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Tranquility', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Tranquility', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Tranquility'] = Vis(name = 'Tranquility', loc = sqr[:])
        vis = app.vis_dict['Tranquility']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Tranquility')
        app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+74, text = 'Dispel Attempt\n Local Effects', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+75, text = 'Dispel Attempt\n Local Effects', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        to_remove = []
        effect_loc = sqr[:]
        for k,v in app.loc_dict[tuple(sqr[:])].effects_dict.items():
            if v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
        def remove_entry(s, key):
            del app.loc_dict[tuple(s)].effects_dict[key]
        for k in to_remove:
            root.after(333, lambda s = effect_loc, k = k : remove_entry(s, k))
        root.after(2666, self.finish_tranquility)
        
    def finish_tranquility(self, event = None):
        try: 
            del app.vis_dict['Tranquility']
            app.canvas.delete('Tranquility')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def esuna(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_esuna)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_esuna(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Esuna Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_esuna(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_esuna(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/esuna.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Esuna', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Esuna', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Esuna'] = Vis(name = 'Esuna', loc = sqr[:])
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
                if spacer > 300:
                    continue
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
            
        root.after(2666, self.finish_esuna)
        
    def finish_esuna(self, event = None):
        try: 
            del app.vis_dict['Esuna']
            app.canvas.delete('Esuna')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def moonlight(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_moonlight)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_moonlight(event = e, s = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Moonlight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_moonlight(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_moonlight(self, event, s, sqrs):
        global selected_vis
        id = app.grid[s[0]][s[1]]
        if id not in app.spell_target_ents().keys():
            return
        if s not in sqrs:
            return
        if self.magick < 2:
            return
        self.magick -= 2
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/moonlight.ogg')
        effect1.set_volume(.2)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         self.init_cast_anims()
        amt = self.get_abl('psyche')
        apply_heal(self, app.ent_dict[id], amt)
        app.vis_dict['Moonlight'] = Vis(name = 'Moonlight', loc = s)
        app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+70-app.moved_down, image = app.vis_dict['Moonlight'].img, tags = 'Moonlight')
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+74-app.moved_down, text = 'Moonlight', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+75-app.moved_down, text = 'Moonlight', font = ('chalkduster', 16), fill = 'azure', tags = 'text')
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+89-app.moved_down, text = '+'+str(amt)+' Spirit', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+90-app.moved_down, text = '+'+str(amt)+' Spirit', font = ('chalkduster', 13), fill = 'azure', tags = 'text')
        selected_vis = ['Moonlight']
        def moonlight_loop(starty, endy, x):
            if starty > endy:
                app.vis_dict['Moonlight'].rotate_image()
                app.canvas.delete('Moonlight')
                app.canvas.create_image(x, starty, image = app.vis_dict['Moonlight'].img, tags = 'Moonlight')
                starty -= 10
                app.canvas.move('Moonlight', 0, -10)
                app.canvas.tag_raise('Moonlight')
            if starty == endy:
                root.after(333, self.cleanup_moonlight)
            else:
                root.after(166, lambda sy = starty, ey = endy, x = x : moonlight_loop(sy, ey, x))
        locy = s[1]*100+70-app.moved_down
        locx = s[0]*100+50-app.moved_right
        moonlight_loop(locy, locy-120, locx)
        
    def cleanup_moonlight(self, event = None):
        global selected, selected_vis
#         self.init_normal_anims()
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Moonlight']
            app.canvas.delete('Moonlight')
        except: pass
        try: app.canvas.delete('text')
        except: pass
        selected = []
        selected_vis = []
        
    def unholy_chant(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_unholy_chant)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_unholy_chant(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Unholy Chant', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_unholy_chant(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_unholy_chant(self, event = None, sqrs = None):
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/unholy_chant.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc, self.loc) <= 2 and 'Unholy_Chant' not in [j.name for i,j in v.effects_dict.items()]]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Unholy Chant', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Unholy Chant', justify = 'center', font = ('chalkduster', 14), fill = 'ivory3', tags = 'text')
        def cleanup_vis(n):
            del app.vis_dict[n]
        for id in ents:
            e = app.ent_dict[id]
            n2 = 'Unholy_Chant' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Unholy_Chant', loc = e.loc)
            app.canvas.create_image(e.loc[0]*100+50-app.moved_right, e.loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = 'Unholy_Chant')
            app.canvas.create_text(e.loc[0]*100+49-app.moved_right, e.loc[1]*100+89-app.moved_down, text = '+1 All Stats', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(e.loc[0]*100+50-app.moved_right, e.loc[1]*100+90-app.moved_down, text = '+1 All Stats', font = ('chalkduster', 12), fill = 'white', tags = 'text')
            root.after(2999, lambda n = n2 : cleanup_vis(n))
            def unholy_chant_effect(stat):
                return stat + 1
            p = partial(unholy_chant_effect)
            e.str_effects.append(p)
            e.end_effects.append(p)
            e.agl_effects.append(p)
            e.mm_effects.append(p)
            e.msl_effects.append(p)
            e.bls_effects.append(p)
            e.dodge_effects.append(p)
            e.psyche_effects.append(p)
            e.wis_effects.append(p)
            e.rsn_effects.append(p)
            e.san_effects.append(p)
            e.init_effects.append(p)
            e.move_range_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                app.ent_dict[i].agl_effects.remove(func)
                app.ent_dict[i].mm_effects.remove(func)
                app.ent_dict[i].msl_effects.remove(func)
                app.ent_dict[i].bls_effects.remove(func)
                app.ent_dict[i].dodge_effects.remove(func)
                app.ent_dict[i].psyche_effects.remove(func)
                app.ent_dict[i].wis_effects.remove(func)
                app.ent_dict[i].rsn_effects.remove(func)
                app.ent_dict[i].san_effects.remove(func)
                app.ent_dict[i].init_effects.remove(func)
                app.ent_dict[i].move_range_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Unholy_Chant' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Unholy_Chant', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(3111, self.finish_unholy_chant)
        
    def finish_unholy_chant(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def concerted_volley(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_concerted_volley)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 2]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_concerted_volley(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Concerted Volley', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_concerted_volley(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def do_concerted_volley(self, event = None, sqrs = None):
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/unholy_chant.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and v.loc in sqrs and 'Concerted_Volley' not in [j.name for i,j in v.effects_dict.items()]]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Concerted Volley', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Concerted Volley', justify = 'center', font = ('chalkduster', 14), fill = 'ivory3', tags = 'text')
        def cleanup_vis(n):
            del app.vis_dict[n]
        num = min(4, len(ents))
        for id in ents:
            ent = app.ent_dict[id]
            n2 = 'Concerted_Volley' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            app.vis_dict[n2] = Vis(name = 'Concerted_Volley', loc = ent.loc)
            app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = 'Concerted_Volley')
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+ '+str(num)+' mm', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+ '+str(num)+' mm', font = ('chalkduster', 12), fill = 'ghostwhite', tags = 'text')
            root.after(1999, lambda n = n2 : cleanup_vis(n))
            def concerted_volley_effect(stat, num = None):
                return stat+num
            p = partial(concerted_volley_effect, num = num)
            ent.mm_effects.append(p)
            def undo(i, func, lockname = None):
                app.ent_dict[i].mm_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Concerted_Volley' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Concerted_Volley', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, self.finish_concerted_volley)
        
    def finish_concerted_volley(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
    
    def zephyr_lance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_zephyr_lance)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_zephyr_lance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Zephyr Lance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_zephyr_lance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_zephyr_lance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Zephyr_Lance'] = Vis(name = 'Zephyr_Lance', loc = sqr[:])
        my_wis = self.get_abl('wis')
        def cleanup_zephyr():
            del app.vis_dict['Zephyr_Lance']
            app.canvas.delete('Zephyr_Lance')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(1555, cleanup_zephyr)
            lock(apply_damage, self, ent, -d, 'slashing', 'Zephyr Lance', 'spell')
            root.after(111, self.finish_zephyr_lance)
        else:
            miss(ent.loc)
            root.after(1888, cleanup_zephyr)
            root.after(1999, self.finish_zephyr_lance)
        
    def finish_zephyr_lance(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    
    
    def arrow_of_diana(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_arrow)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_arrow(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Arrow Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_arrow(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_arrow(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/arrow_of_diana.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Arrow_of_Diana'] = Vis(name = 'Arrow_of_Diana', loc = sqr[:])
        vis = app.vis_dict['Arrow_of_Diana']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Arrow_of_Diana')
        my_mm = self.get_abl('mm')
        def cleanup_arrow():
            del app.vis_dict['Arrow_of_Diana']
            app.canvas.delete('Arrow_of_Diana')
        tar_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, tar_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(1555, cleanup_arrow)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Arrow of Diana', 'ranged')
            root.after(111, self.finish_arrow)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1888, cleanup_arrow)
            root.after(1999, self.finish_arrow)
        
    def finish_arrow(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
# finish inquisitor, cleanse with fire- all wi range3 on wis v wis tohit take psy v psy fire spl, persecute- all wi rng3 on wis v wis tohit lose mgk = psy, prophecy- tar gets +3 rsn efct
class Inquisitor(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Cleanse with Fire':self.cleanse_with_fire, 'Persecute':self.persecute, 'Prophecy':self.prophecy, 'Nullify':self.nullify, 'Abeyance':self.abeyance, 'Anoint':self.anoint, 'Reveal':self.reveal}
            self.str = 4
            self.agl = 4
            self.end = 6
            self.mm = 4
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 6
            self.wis = 7
            self.rsn = 5
            self.san = 14
            self.init = 7
            self.spirit = 19
            self.magick = 21
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Cleanse with Fire':self.cleanse_with_fire, 'Persecute':self.persecute, 'Prophecy':self.prophecy, 'Nullify':self.nullify, 'Abeyance':self.abeyance, 'Anoint':self.anoint, 'Reveal':self.reveal}
            self.str = 5
            self.agl = 5
            self.end = 7
            self.mm = 5
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 7
            self.wis = 8
            self.rsn = 6
            self.san = 16
            self.init = 8
            self.spirit = 27
            self.magick = 26
            self.acts = 2
            self.mvs = 2
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['slashing']
        self.resist = ['crushing', 'cold', 'fire', 'magick']
        super().__init__(name, id, img, loc, owner)
        
        
    def persecute(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_persecute)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_persecute(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Persecute', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_persecute(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_persecute(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Persecute', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Persecute', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        def cleanup_persecute(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def persecute_loop(ids):
            if ids == []:
                self.finish_persecute()
            else:
                effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                id = ids[0]
                app.get_focus(id)
                ids = ids[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                n = 'Persecute' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Persecute', loc = s)
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = self.get_abl('psyche')
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-'+str(d)+' magick', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-'+str(d)+' magick', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                    ent.magick -= d
                    if ent.magick < 0:
                        ent.magick = 0
                    root.after(1555, lambda n = n : cleanup_persecute(n))
                    root.after(1666, lambda ids = ids : persecute_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1555, lambda n = n : cleanup_persecute(n))
                    root.after(1666, lambda ids = ids : persecute_loop(ids))
        persecute_loop(ids)
        
    def finish_persecute(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def cleanse_with_fire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_cleanse_with_fire)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_cleanse_with_fire(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Cleanse with Fire', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_cleanse_with_fire(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cleanse_with_fire(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Cleanse with Fire', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Cleanse with Fire', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs]
        def cleanup_cleanse(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def cleanse_loop(ids):
            if ids == []:
                self.finish_cleanse_with_fire()
            else:
                effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                id = ids[0]
                app.get_focus(id)
                ids = ids[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                n = 'Cleanse' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Cleanse_with_Fire', loc = s)
                if to_hit(self.get_abl('wis'), ent.get_abl('wis')):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    root.after(1555, lambda n = n : cleanup_cleanse(n))
                    lock(apply_damage, self, ent, -d, 'fire', 'Cleanse with Fire', 'ranged')
                    cleanse_loop(ids)
                else:
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1555, lambda n = n : cleanup_cleanse(n))
                    root.after(1666, lambda ids = ids : cleanse_loop(ids))
        cleanse_loop(ids)
        
    def finish_cleanse_with_fire(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    # all wi rng, dispel atmpt all efcts
    def nullify(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_nullify)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_nullify(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Nullify', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_nullify(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_nullify(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/nullify.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Nullify', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Nullify', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and 'psyshield' not in v.get_types() and 'invisibility' not in v.get_types()]
        def cleanup_nullify(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
            app.canvas.delete('text')
        def nullify_loop(ents):
            if ents == []:
                self.finish_nullify()
            else:
                id = ents[0]
                app.get_focus(id)
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Nullify' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Nullify', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Dispel Attempt\nAll Effects', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Dispel Attempt\nAll Effects', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1555, lambda u = u : cleanup_nullify(u))
                root.after(1666, lambda ents = ents : nullify_loop(ents))
        nullify_loop(ents)
        
    def finish_nullify(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    # remove target action
    def abeyance(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_abeyance)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_abeyance(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Abeyance Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_abeyance(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_abeyance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if self.magick < 3:
            return
        self.magick -= 3
#         effect1 = mixer.Sound('Sound_Effects/abeyance.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        n = 'Abeyance'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Abeyance', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        def cleanup_abey(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_abey(n))
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove Action', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove Action', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            actions = [(k, v) for k,v in ent.get_actions().items()]
            if actions == []:
                root.after(2666, lambda e = None : self.finish_abeyance(event = e))
            else:
                self.page_abeyance(actions = actions, id = id)
        else:
            miss(ent.loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda e = None : self.finish_abeyance(event = e))
                    
                    
    def page_abeyance(self, event = None, actions = None, id = None, index = 0):
        app.unbind_all()
        # destroy old buttons
        for b in app.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
#         app.repop_help_buttons()

#         app.depop_context(event = None)
#         app.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png'))
#         bg = tk.Canvas(app.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
#         bg.pack(side = 'top')
#         bg.create_image(0,0, image = app.cntxt_info_bg, anchor = 'nw')
#         bg.create_text(15, 15, text= 'Choose Action...', width = 190, anchor = 'nw', font = ('chalkduster', 16), fill = 'indianred')
#         app.context_buttons.append(bg)

        for i, key_ef in enumerate(actions[index:index+5]):
            i += 1
            key = key_ef[0]
            ef = key_ef[1]
            p = partial(self.abeyance_remove, id = id, func = ef, key = key)
            root.bind(str(i), p)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ key.replace('_', ' '), font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            # below should become effect_description_popup, (there is no equivalent to more info popup, effect desc shown in more info
#             b1.bind('<Button-2>', lambda ef = ef : app.effect_description(ef))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = '9 : Prev', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda actions = actions, id = id, i = index-5 : self.page_abeyance(actions = actions , id = id, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind(str(9), lambda e, actions = actions, id = id, i = index-5 : self.page_abeyance(actions = actions, id = id, index = i))
            app.context_buttons.append(b4)
        if len(actions) > len(actions[:index+5]):
            b3 = tk.Button(app.context_menu, text = '8 : Next', font = ('chalkduster', 14), fg='tan3', highlightbackground = 'tan3', command = lambda actions = actions, id = id, i = index+5 : self.page_abeyance(actions = actions, id = id, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind(str(8), lambda e, actions = actions, id = id, i = index+5 : self.page_abeyance(actions = actions, id = id, index = i))
                    
            
    def abeyance_remove(self, id, func, key):
        app.depop_context(event = None)
        app.canvas.delete('text')
        ent = app.ent_dict[id]
        def abey_rmv(actions_dict):
            if key in actions_dict.keys():
                del actions_dict[key]
            return actions_dict
        p = partial(abey_rmv)
        ent.action_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Abeyance'+str(app.count)
        app.count += 1
        ent.effects_dict[n] = Effect(name = 'Abeyance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = key+' Removed', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = key+' Removed', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
        root.after(1999, self.finish_abeyance)
        
    def finish_abeyance(self, event = None):
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
    def prophecy(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_prophecy)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_prophecy(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Prophecy', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_prophecy(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_prophecy(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 4:
            return
        if 'Prophecy' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 4
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Prophecy', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Prophecy', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Prophecy'] = Vis(name = 'Prophecy', loc = ent.loc[:])
        def prophecy_effect(stat):
            return stat+3
        p = partial(prophecy_effect)
        ent.rsn_effects.append(p)
        def un(id, func, lockname = None):
            app.ent_dict[id].rsn_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p)
        n = 'Prophecy' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Prophecy', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+3 reason', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+3 reason', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(1999, self.cleanup_prophecy)
        
        
    def cleanup_prophecy(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Prophecy']
            app.canvas.delete('Prophecy')
        except: pass
        app.canvas.delete('text')
        
        
        
    # +1 wisdom to target
    def anoint(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_anoint)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_anoint(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Anoint', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_anoint(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_anoint(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 1:
            return
        if 'Anoint' in app.ent_dict[id].effects_dict.keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/simulacrum.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        self.magick -= 1
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Anoint', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Anoint', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Anoint'] = Vis(name = 'Anoint', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Anoint'].img, tags = 'Anoint')
        def anoint_effect(stat):
            return stat+1
        p = partial(anoint_effect)
        ent.wis_effects.append(p)
        def un(id, func, lockname = None):
            app.ent_dict[id].wis_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p)
        n = 'Anoint' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Anoint', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 wisdom', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 wisdom', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(1999, self.cleanup_anoint)
        
        
    def cleanup_anoint(self, event = None):
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict['Anoint']
            app.canvas.delete('Anoint')
        except: pass
        app.canvas.delete('text')
        
        
    # on to-hit, if tar has psysh, efct strips psysh, else efct strips invis
    def reveal(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_reveal)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_reveal(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Reveal Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_reveal(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_reveal(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/reveal.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            if 'psyshield' in ent.get_types():
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove psyshield', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove psyshield', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                def reveal_psyshield(ts):
                    return [t for t in ts if t != 'psyshield']
                p = partial(reveal_psyshield)
                ent.type_effects.append(p)
                def un(id, func, lockname = None):
                    app.ent_dict[id].type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, id, p)
                n = 'Reveal' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Reveal_Psyshield', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1999, self.finish_reveal)
            else:
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Remove invisibility', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Remove invisibility', justify = 'center', fill = 'ghostwhite', font = ('chalkduster', 13), tags = 'text')
                def reveal_invisibility(ts):
                    return [t for t in ts if t != 'invisibility']
                p = partial(reveal_invisibility)
                ent.type_effects.append(p)
                def un(id, func, lockname = None):
                    app.ent_dict[id].type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, id, p)
                n = 'Reveal' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Reveal_Invisibility', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1999, self.finish_reveal)
        else:
            miss(ent.loc)
            root.after(1999, self.finish_reveal)
        
    def finish_reveal(self, event = None):
        try: 
            del app.vis_dict['Reveal']
            app.canvas.delete('Reveal')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
class Transmuter(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Elemental Langour':self.elemental_langour, 'Asthenia':self.asthenia, 'Detox':self.detox, 'Geomantic Clutch':self.geomantic_clutch, 'Biotranspose':self.biotranspose}
            self.str = 3
            self.agl = 8
            self.end = 3
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 8
            self.psyche = 7
            self.wis = 7
            self.rsn = 6
            self.san = 14
            self.init = 8
            self.spirit = 17
            self.magick = 21
            self.acts = 1
            self.mvs = 2
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Elemental Langour':self.elemental_langour, 'Asthenia':self.asthenia, 'Detox':self.detox, 'Geomantic Clutch':self.geomantic_clutch, 'Biotranspose':self.biotranspose}
            self.str = 4
            self.agl = 9
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 9
            self.psyche = 8
            self.wis = 8
            self.rsn = 7
            self.san = 16
            self.init = 10
            self.spirit = 21
            self.magick = 35
            self.acts = 2
            self.mvs = 2
            self.move_range = 6
            self.level = level
        self.move_type = 'flying'
        self.weak = ['crushing', 'slashing', 'piercing']
        self.resist = ['magick', 'fire', 'elec', 'cold', 'explosive']
        super().__init__(name, id, img, loc, owner)
        
        
    def biotranspose(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_biotranspose)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_biotranspose(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Biotranspose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_biotranspose(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_biotranspose(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        if 'Biotranspose' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/biotranspose.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Biotranspose'] = Vis(name = 'Biotranspose', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Switch strength and psyche', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Switch strength and psyche', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            str = ent.get_abl('str')
            psy = ent.get_abl('psyche')
            str_mod = psy-str
            psy_mod = str-psy
            def bio_str(abl, mod = 0):
                return max(1, abl+mod)
            p = partial(bio_str, mod = str_mod)
            def bio_psy(abl, mod  = 0):
                return max(1, abl+mod)
            p2 = partial(bio_psy, mod = psy_mod)
            ent.str_effects.append(p)
            ent.psyche_effects.append(p2)
            def undo(ent, p, p2, lockname = None):
                ent.str_effects.remove(p)
                ent.psyche_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            ent.effects_dict['Biotranspose'] = Effect(name = 'Biotranspose', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_biotranspose)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_biotranspose)
        
    def finish_biotranspose(self, event = None):
        try: 
            del app.vis_dict['Biotranspose']
            app.canvas.delete('Biotranspose')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
    def detox(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_detox)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_detox(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Detox Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_detox(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_detox(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 2:
            return
        self.magick -= 2
        effect1 = mixer.Sound('Sound_Effects/esuna.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Detox', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Detox', justify = 'center', fill = 'ivory', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Detox'] = Vis(name = 'Detox', loc = sqr[:])
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.eot_func != None:
                if v.dispel(self.get_abl('wis')) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                    spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
        root.after(2666, self.finish_detox)
        
    def finish_detox(self, event = None):
        try: 
            del app.vis_dict['Detox']
            app.canvas.delete('Detox')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def geomantic_clutch(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_geomantic_clutch)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_geomantic_clutch(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Geomantic Clutch Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_geomantic_clutch(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_geomantic_clutch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 4:
            return
        ent = app.ent_dict[id]
        self.magick -= 4
        effect1 = mixer.Sound('Sound_Effects/geomantic_clutch.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Geomantic_Clutch'] = Vis(name = 'Geomantic_Clutch', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            if 'Geomantic_Clutch' not in [v.name for k,v in ent.effects_dict.items()]:
                def clutch_move_range(abl):
                    return max(0,abl-3)
                p = partial(clutch_move_range)
                ent.move_range_effects.append(p)
                if ent.get_move_type() == 'flying':
                    d += 3
                    def clutch_move(type):
                        return 'normal'
                    p2 = partial(clutch_move)
                    ent.move_type_effects.append(p2)
                    def undo(ent, p, p2, lockname = None):
                        ent.move_range_effects.remove(p)
                        ent.move_type_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p, p2)
                else:
                    def undo(ent, p, lockname = None):
                        ent.move_range_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                ent.effects_dict['Geomantic_Clutch'] = Effect(name = 'Geomantic_Clutch', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            elif ent.get_move_type() == 'flying':
                d += 3
            lock(apply_damage, self, ent, -d, 'crushing', 'Geomantic Clutch', 'spell')
            root.after(111, self.finish_geomantic_clutch)
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_geomantic_clutch)
        
    def finish_geomantic_clutch(self, event = None):
        try: 
            del app.vis_dict['Geomantic_Clutch']
            app.canvas.delete('Geomantic_Clutch')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
    def asthenia(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_asthenia)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_asthenia(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Asthenia Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_asthenia(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_asthenia(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/discord.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Asthenia'] = Vis(name = 'Asthenia', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Weak Physical Damage', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Weak Physical Damage', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def asthenia_resist(types):
                return [t for t in types if t != 'slashing' and t != 'piercing' and t != 'crushing']
            ent.resist_effects.append(asthenia_resist)
            def asthenia_weak(types):
                return types+['slashing','piercing','crushing']
            ent.weak_effects.append(asthenia_weak)
            def undo(ent, lockname = None):
                ent.resist_effects.remove(asthenia_resist)
                ent.weak_effects.remove(asthenia_weak)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent)
            ent.effects_dict['Asthenia'] = Effect(name = 'Asthenia', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_asthenia)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_asthenia)
        
    def finish_asthenia(self, event = None):
        try: 
            del app.vis_dict['Asthenia']
            app.canvas.delete('Asthenia')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
    def elemental_langour(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_elemental_langour)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_elemental_langour(event = e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Elemental Langour Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_elemental_langour(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_elemental_langour(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        ent = app.ent_dict[id]
        self.magick -= 3
        effect1 = mixer.Sound('Sound_Effects/drain_life.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.vis_dict['Elemental_Langour'] = Vis(name = 'Elemental_Langour', loc = sqr[:])
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Weak Elemental Damage', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Weak Elemental Damage', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def langour_resist(types):
                return [t for t in types if t != 'fire' and t != 'elec' and t != 'cold']
            ent.resist_effects.append(langour_resist)
            def langour_weak(types):
                return types+['fire','cold','elec']
            ent.weak_effects.append(langour_weak)
            def undo(ent, lockname = None):
                ent.resist_effects.remove(langour_resist)
                ent.weak_effects.remove(langour_weak)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent)
            ent.effects_dict['Elemental_Langour'] = Effect(name = 'Elemental_Langour', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1666, self.finish_elemental_langour)
        else:
            miss(ent.loc)
            root.after(1666, self.finish_elemental_langour)
        
    def finish_elemental_langour(self, event = None):
        try: 
            del app.vis_dict['Elemental_Langour']
            app.canvas.delete('Elemental_Langour')
        except: pass
        app.depop_context(event = None)
        app.canvas.delete('text')
        app.cleanup_squares()
        app.rebind_all()
        
        
class Drake(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Spit Venom':self.spit_venom, 'Hindering Mucilage':self.hindering_mucilage, 'Wing Buffet':self.wing_buffet, 'Chameleon Camouflage':self.chameleon_camouflage, 'Shimmering Scales':self.shimmering_scales}
            self.str = 6
            self.agl = 6
            self.end = 6
            self.mm = 8
            self.msl = 4
            self.bls = 4
            self.dodge = 4
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 9
            self.init = 9
            self.spirit = 21
            self.magick = 0
            self.acts = 1
            self.mvs = 2
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Spit Venom':self.spit_venom, 'Hindering Mucilage':self.hindering_mucilage, 'Wing Buffet':self.wing_buffet, 'Chameleon Camouflage':self.chameleon_camouflage, 'Shimmering Scales':self.shimmering_scales}
            self.str = 7
            self.agl = 7
            self.end = 7
            self.mm = 9
            self.msl = 5
            self.bls = 5
            self.dodge = 5
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 11
            self.init = 10
            self.spirit = 29
            self.magick = 0
            self.acts = 2
            self.mvs = 2
            self.move_range = 6
            self.level = level
        self.move_type = 'flying'
        self.weak = ['elec']
        self.resist = ['poison', 'slashing', 'crushing']
        super().__init__(name, id, img, loc, owner)
        
    def wing_buffet(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_wing_buffet)
        max = self.get_abl('str')
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= max]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_wing_buffet(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Wing Buffet', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_wing_buffet(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_wing_buffet(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
        effect1 = mixer.Sound('Sound_Effects/psionic_push.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.vis_dict['Wing_Buffet'] = Vis(name = 'Wing_Buffet', loc = sqr[:])
        if to_hit(self.get_abl('str'),ent.get_abl('str')) == True:
            locs = [c for c in app.coords if dist(c,ent.loc) <= self.get_abl('str') and app.grid[c[0]][c[1]] == '']
            if locs != []:
                newloc = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, locs)
                lock(ent.throw_move, newloc)
                app.canvas.delete('text')
                app.get_focus(id)
            d = damage(self.get_abl('str'),ent.get_abl('end'))
            root.after(1666, self.cleanup_wing_buffet)
            lock(apply_damage, self, ent, -d, 'explosive', 'Wing Buffet', 'ranged')
        else:
            miss(ent.loc)
            root.after(1666, self.cleanup_wing_buffet)
        
    def cleanup_wing_buffet(self, event = None):
        try: 
            del app.vis_dict['Wing_Buffet']
            app.canvas.delete('Wing_Buffet')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        
    def chameleon_camouflage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_chameleon_camouflage)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_chameleon_camouflage(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Chameleon Camouflage', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_chameleon_camouflage(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chameleon_camouflage(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Chameleon_Camouflage' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Shimmering_Scales' in [v.name for v in self.effects_dict.values()]:
            return
        effect1 = mixer.Sound('Sound_Effects/discord.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Chameleon Camouflage', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Chameleon Camouflage', justify = 'center', fill = 'green2', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Chameleon_Camouflage'] = Vis(name = 'Chameleon_Camouflage', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Invisible', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Invisible', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def chameleon_effect(types):
            return types + ['invisibility']
        p = partial(chameleon_effect)
        self.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Chameleon_Camouflage'] = Effect(name = 'Chameleon_Camouflage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_chameleon_camouflage)
        
    def finish_chameleon_camouflage(self, event = None):
        try: 
            del app.vis_dict['Chameleon_Camouflage']
            app.canvas.delete('Chameleon_Camouflage')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def shimmering_scales(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_shimmering_scales)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_shimmering_scales(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Shimmering Scales', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_shimmering_scales(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_shimmering_scales(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Chameleon_Camouflage' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Shimmering_Scales' in [v.name for v in self.effects_dict.values()]:
            return
        effect1 = mixer.Sound('Sound_Effects/biotranspose.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Shimmering Scales', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Shimmering Scales', justify = 'center', fill = 'lightseagreen', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Shimmering_Scales'] = Vis(name = 'Shimmering_Scales', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Psyshield', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Psyshield', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def scales_effect(types):
            return types + ['psyshield']
        p = partial(scales_effect)
        self.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Shimmering_Scales'] = Effect(name = 'Shimmering_Scales', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_shimmering_scales)
        
    def finish_shimmering_scales(self, event = None):
        try: 
            del app.vis_dict['Shimmering_Scales']
            app.canvas.delete('Shimmering_Scales')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def hindering_mucilage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_hindering_mucilage)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hindering_mucilage(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Hindering Mucilage Location', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hindering_mucilage(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hindering_mucilage(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Hindering_Mucilage' in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/spore_cloud.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Hindering Mucilage', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Hindering Mucilage', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        un = 'Hindering_Mucilage' + str(app.count)
        app.count += 1
        app.vis_dict[un] = Vis(name = 'Hindering_Mucilage', loc = sqr[:])
        # -3 move range, agl, dodge if normal move type
        def mucilage_effect(stat, sqr=None):
            id = list(filter(lambda id : app.ent_dict[id].loc == sqr, app.all_ents().keys()))
            if id != []:
                id = id[0]
                if app.ent_dict[id].get_move_type() == 'normal':
                    return max(1,stat-3)
                else:
                    return stat
            else:
                return stat
        p = partial(mucilage_effect, sqr = sqr)
        app.loc_dict[tuple(sqr)].dodge_effects.append(p)
        app.loc_dict[tuple(sqr)].agl_effects.append(p)
        app.loc_dict[tuple(sqr)].move_range_effects.append(p)
        def undo(s, un, p, lockname = None):
            app.loc_dict[tuple(s)].dodge_effects.remove(p)
            app.loc_dict[tuple(s)].agl_effects.remove(p)
            app.loc_dict[tuple(s)].move_range_effects.remove(p)
            del app.vis_dict[un]
            app.canvas.delete(un)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, sqr[:], un, p)
        app.loc_dict[tuple(sqr)].effects_dict[un] = Local_Effect(name = 'Hindering_Mucilage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'), loc = sqr[:], avoid = -7)
        root.after(1666, self.cleanup_hindering_mucilage)
        
    def cleanup_hindering_mucilage(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def spit_venom(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spit_venom)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_spit_venom(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Spit Venom', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_spit_venom(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_spit_venom(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
#         effect1 = mixer.Sound('Sound_Effects/pyrotechnics.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        app.vis_dict['Spit_Venom'] = Vis(name = 'Spit_Venom', loc = sqr[:])
        if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
            def undo():
                pass
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -2, 'poison', 'Drake Venom', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, id)
            n = 'Spit_Venom' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Spit_Venom', eot_func = eot, undo_func = undo, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
            root.after(1666, lambda e = None : self.cleanup_spit_venom(event = e))
            lock(apply_damage, self, app.ent_dict[id], -d, 'poison', 'Spit Venom', 'ranged')
        else:
            miss(app.ent_dict[id].loc)
            root.after(1666, lambda e = None : self.cleanup_spit_venom(event = e))
        
    def cleanup_spit_venom(self, event = None):
        try: 
            del app.vis_dict['Spit_Venom']
            app.canvas.delete('Spit_Venom')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        
        
class Fiend(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Suplex':self.suplex, 'Pounce' : self.pounce, 'Chain Lightning':self.chain_lightning, 'Hidden Strike':self.hidden_strike, 'Overload':self.overload, 'Roar' : self.roar}
            self.str = 6
            self.agl = 6
            self.end = 6
            self.mm = 6
            self.msl = 5
            self.bls = 4
            self.dodge = 4
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 9
            self.init = 5
            self.spirit = 21
            self.magick = 13
            self.acts = 1
            self.mvs = 2
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Suplex':self.suplex, 'Pounce' : self.pounce, 'Chain Lightning':self.chain_lightning, 'Hidden Strike':self.hidden_strike, 'Overload':self.overload, 'Roar' : self.roar}
            self.str = 7
            self.agl = 7
            self.end = 7
            self.mm = 7
            self.msl = 6
            self.bls = 5
            self.dodge = 5
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 11
            self.init = 6
            self.spirit = 29
            self.magick = 16
            self.acts = 2
            self.mvs = 2
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['elec']
        self.resist = ['crushing']
        self.pounce_anims = {}
        for k,v in app.pounce_anims.items():
            self.pounce_anims[k] = v
        super().__init__(name, id, img, loc, owner)
        
    def init_pounce_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.pounce_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
        
    def overload(self, event = None):
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_overload)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_overload(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Overload', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_overload(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_overload(self, event, sqr, sqrs):
        if self.acts < 1:
            return
        if 'Overload' in [v.name for k,v in self.effects_dict.items()]:
            return
        if self.get_abl('str') < self.str+2 or self.get_abl('psyche') < self.psyche+2:
            return
        if sqr not in sqrs:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Overload', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Overload', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Overload'] = Vis(name = 'Overload', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = '+1 acts', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = '+1 acts', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        def overload_efct(stat):
            return stat+1
        p = partial(overload_efct)
        self.acts_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.acts_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        self.effects_dict['Overload'] = Effect(name = 'Overload', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, self.finish_overload)
        
    def finish_overload(self, event = None):
        try: 
            del app.vis_dict['Overload']
            app.canvas.delete('Overload')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def hidden_strike(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_hidden_strike)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_hidden_strike(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_hidden_strike(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hidden_strike(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'invisibility' not in self.get_types():
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Hidden_Strike'] = Vis(name = 'Hidden_Strike', loc = sqr[:])
        my_str = self.get_abl('str')
        target_end = app.ent_dict[id].get_abl('end')
        d = damage(my_str, target_end)
        def cleanup_slash():
            del app.vis_dict['Hidden_Strike']
            app.canvas.delete('Hidden_Strike')
        root.after(1666, cleanup_slash)
        lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Hidden Strike', 'melee')
        root.after(111, self.cancel_hidden_strike)
        
    def cancel_hidden_strike(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def chain_lightning(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_chain_lightning)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_chain_lightning(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Chain Lightning', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_chain_lightning(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_chain_lightning(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        hit = []
        def clean_vis(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def chain_loop(id):
            if id == None:
                self.cleanup_chain_lightning()
            else:
                hit.append(id)
                ent = app.ent_dict[id]
                effect1 = mixer.Sound('Sound_Effects/energize.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                n = 'Chain_Lightning'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Chain_Lightning', loc = ent.loc[:])
                if to_hit(self.get_abl('mm'),app.ent_dict[id].get_abl('dodge')) == True:
                    d = damage(self.get_abl('msl'),app.ent_dict[id].get_abl('end'))
                    root.after(1666, lambda n = n : clean_vis(n))
                    lock(apply_damage, self, ent, -d, 'elec', 'Chain Lightning', 'ranged')
                    ids = [k for k,v in app.all_ents().items() if k not in hit and v != self and dist(v.loc,ent.loc) <= 2]
                    if ids != []:
                        id = choice(ids)
                        chain_loop(id)
                    else:
                        self.cleanup_chain_lightning()
                else:
                    miss(ent.loc)
                    root.after(1666, lambda n = n : clean_vis(n))
                    root.after(1666, self.cleanup_chain_lightning)
        chain_loop(id)
        
    def cleanup_chain_lightning(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        
        
    # jump to loc wi agl that is adj to an ent, atk all adj
    def pounce(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_pounce)
        sqrs = [c for c in app.coords if dist(self.loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '' and [s for s in app.coords if dist(c,s) == 1 and app.grid[s[0]][s[1]] in app.all_ents().keys() and app.ent_dict[app.grid[s[0]][s[1]]].owner != self.owner] != []]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_pounce(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Pounce', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_pounce(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pounce(self, event = None, sqrs = None, sqr = None):
        global selected
        if sqr not in sqrs:
            return
        self.acts -= 1
        self.init_pounce_anims()
#         effect1 = mixer.Sound('Sound_Effects/pounce.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected = [self.id]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda e = end_sqr, s = start_sqr : self.finish_pounce(e, s))
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_pounce(self, end_sqr, start_sqr):
        global selected
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        ents = [e for e in app.all_ents().values() if dist(e.loc, self.loc) == 1 and e.owner != self.owner]
        def pounce_loop(ents):
            if ents == []:
                self.cancel_pounce()
            else:
                ent = ents[0]
                ents = ents[1:]
                my_agl = self.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    my_str = self.get_abl('str')
                    tar_end = ent.get_abl('end')
                    d = damage(my_str, tar_end)
                    lock(apply_damage, self, ent, -d, 'slashing', 'Pounce', 'melee')
                    pounce_loop(ents)
                else:
                    miss(ent.loc)
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ents = ents : pounce_loop(ents))
        pounce_loop(ents)
        
    def cancel_pounce(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
        
        
    # on save_check frndly  +2 san, on to-hit enmy -2 san
    def roar(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_roar)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_roar(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Roar', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_roar(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_roar(self, event = None, sqrs = None):
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/roar.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Roar', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Roar', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs]
        def cleanup_roar(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def roar_loop(ents):
            if ents == []:
                self.finish_roar()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                if ent.owner != self.owner and 'Roar_Enemy' not in [v.name for v in ent.effects_dict.values()]:
                    app.focus_square(s)
                    u = 'Roar' + str(app.count) # not an effect, just need unique int
                    app.count += 1 # that is why this is incr manually here, no Effect init
                    app.vis_dict[u] = Vis(name = 'Roar', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                    root.after(1555, lambda u = u : cleanup_roar(u))
                    my_str = self.get_abl('str')
                    tar_psy = ent.get_abl('psyche')
                    if to_hit(my_str, tar_psy):
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '-2 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '-2 san', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        def roar_effect(stat):
                            return max(1,stat-2)
                        p = partial(roar_effect)
                        ent.san_effects.append(p)
                        n = 'Roar' + str(app.count)
                        def un(i, p, lockname = None):
                            app.ent_dict[i].san_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(un, id, p)
                        ent.effects_dict[n] = Effect(name = 'Roar_Enemy', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                    else:
                        miss(ent.loc)
                        root.after(999, lambda ents = ents : roar_loop(ents))
                elif ent.owner == self.owner and 'Roar_Friendly' not in [v.name for v in ent.effects_dict.values()]:
                    app.focus_square(s)
                    u = 'Roar' + str(app.count) # not an effect, just need unique int
                    app.count += 1 # that is why this is incr manually here, no Effect init
                    app.vis_dict[u] = Vis(name = 'Roar', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                    root.after(1555, lambda u = u : cleanup_roar(u))
                    if ent.save_check('wis') == 'Pass':
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '+2 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '+2 san', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        def roar_effect(stat):
                            return stat+2
                        p = partial(roar_effect)
                        ent.san_effects.append(p)
                        n = 'Roar' + str(app.count)
                        def un(i, p, lockname = None):
                            app.ent_dict[i].san_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(un, id, p)
                        ent.effects_dict[n] = Effect(name = 'Roar_Friendly', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                    else:
                        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Wisdom save fail...', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Wisdom save fail...', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ents = ents : roar_loop(ents))
                else:
                    roar_loop(ents)
        roar_loop(ents)
        
    def finish_roar(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def suplex(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_suplex)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if app.ent_dict[id].immovable == True:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_suplex)
        distance = self.get_abl('str')
        sqrs = [c for c in app.coords if dist(c,self.loc)==1 and app.grid[c[0]][c[1]] != 'block']
        app.cleanup_squares()
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_suplex(e, id = id, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_suplex(e, id, sqr, sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
    
    def do_suplex(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/suplex.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        my_agl = self.get_abl('agl')
        tar_agl = ent.get_abl('agl')
        if to_hit(my_agl, tar_agl):
            oldloc = app.ent_dict[id].loc[:]
            newloc = sqr[:]
            root.after(333, lambda newloc = newloc, id = id : self.finish_suplex(newloc, id))
        else:
            miss(ent.loc)
            root.after(1666, self.cleanup_suplex)
        
    # CHANGE add dmg crshing
    def finish_suplex(self, newloc, id):
        mv2 = None
        ent = app.ent_dict[id]
        if app.grid[newloc[0]][newloc[1]] in app.all_ents().keys():
            # get rand empt sqr (should include original target loc)
            id2 = app.grid[newloc[0]][newloc[1]]
            ent2 = app.ent_dict[id2]
            cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
            cs.append(ent.loc[:])
            mv2 = reduce(lambda a,b : a if dist(ent2.loc,a) < dist(ent2.loc,b) else b, cs)
        lock(ent.throw_move, newloc)
        # add dmg, already hit...
        my_str = self.get_abl('str')
        tar_end = ent.get_abl('end')
        d = damage(my_str, tar_end)
        if mv2:
            start = ent2.loc[:]
            lock(ent2.throw_move, mv2)
            app.grid[start[0]][start[1]] = ent.id
        lock(apply_damage, self, ent, -d, 'crushing', 'Suplex', 'melee')
        if mv2:
            tar2_end = ent2.get_abl('end')
            d = damage(my_str, tar2_end)
            app.get_focus(ent2.id)
            lock(apply_damage, self, ent2, -d, 'crushing', 'Suplex', 'melee')
        root.after(333, self.cleanup_suplex)
        
    def cleanup_suplex(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
class White_Dragon_Top(Bot):
    def __init__(self, name, img, loc, owner, id, waiting = False):
        self.id = id
        self.actions = {}
        self.str = 12
        self.agl = 12
        self.end = 10
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 14
        self.wis = 13
        self.rsn = 8
        self.init = 8
        self.spirit = 136
        self.magick = 99
        self.san = 27
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.resist = ['crushing', 'slashing', 'cold', 'piercing', 'magick']
        self.weak = []
        super().__init__(name, img, loc, owner, type = 'large')
        self.move_type = 'flying'
        self.immovable = True
        
        
class White_Dragon(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Rake':self.rake, 'Iceblast':self.iceblast}
        self.str = 12
        self.agl = 12
        self.end = 10
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 14
        self.wis = 13
        self.rsn = 8
        self.init = 8
        self.spirit = 136
        self.magick = 99
        self.san = 27
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.move_type = 'flying'
        self.waiting = waiting
        self.resist = ['crushing', 'slashing', 'cold', 'piercing', 'magick']
        self.weak = []
        self.summoned_kobolds = False
        self.summoned_orcs = False
        self.free_fly = False
        anims = [a for r,d,a in walk('./animations/White_Dragon_Ascend/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.ascend_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Ascend/' + anim))
            self.ascend_anims.append(a)
        anims = [a for r,d,a in walk('./animations/White_Dragon_Flight/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.flight_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Flight/' + anim))
            self.flight_anims.append(a)
        anims = [a for r,d,a in walk('./animations/White_Dragon_Descend/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        self.descend_anims = []
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Descend/' + anim))
            self.descend_anims.append(a)
        super().__init__(name, img, loc, owner, type = 'large_bottom')
        self.immovable = True
        # create top half
        img = ImageTk.PhotoImage(Image.open('animations/White_Dragon_Top/0.png'))
        app.ent_dict[self.id+'top'] = White_Dragon_Top(name = 'White_Dragon_Top', img = img, loc = [self.loc[0],self.loc[1]], owner = 'p2', id = self.id+'top')
        
    def large_undo(self):
        app.canvas.delete(self.id+'top')
        del app.ent_dict[self.id+'top']
        
    def init_ascend_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.ascend_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
            
    def init_flight_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.flight_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
            
    def init_descend_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for i, anim in enumerate(self.descend_anims):
            self.anim_dict[i] = anim
        self.img = self.anim_dict[0]
        
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            melee_atks = [k for k,v in app.action_target_ents().items() if dist(self.loc, v.loc) == 1 and v.owner != self.owner]
            # RAKE ADJACENT
            if melee_atks != [] and self.acts > 0:
                id = choice(melee_atks)
                app.get_focus(id)
                self.acts -= 1
                root.after(666, lambda id = id : self.rake(id))
            # MOVE ADJACENT TO AN ENT WI MOVE RANGE
            elif [c for c in app.coords for k,v in app.all_ents().items() if dist(c,v.loc) == 1 and v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(c,self.loc) <= self.get_abl('move_range')] and self.mvs > 0:
                goals = [c for c in app.coords for k,v in app.all_ents().items() if dist(c,v.loc) == 1 and v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(c,self.loc) <= self.get_abl('move_range')]
                goal = choice(goals)
                app.focus_square(goal)
                self.mvs -= 1
                root.after(666, lambda g = goal : self.white_dragon_move(g))
            # MOVE TOWARDS CLOSEST ENT
            elif self.mvs > 0:
                ents = [v for k,v in app.all_ents().items() if v.owner != self.owner]
                ent = reduce(lambda a,b : a if dist(a.loc,self.loc) < dist(b.loc,self.loc) else b, ents)
                mvs = self.legal_moves()
                mv = reduce(lambda a,b : a if dist(a,ent.loc) < dist(b,ent.loc) else b, mvs)
                app.focus_square(mv)
                self.mvs -= 1
                root.after(666, lambda mv = mv : self.white_dragon_move(mv))
            # FREE FLY MOVE
            elif self.free_fly == False and [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner] and self.acts < 1:
                print('in free_fly dragon')
                self.free_fly = True
                goals = unique([c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c,v.loc)<=self.get_abl('rsn') and app.grid[c[0]][c[1]] == ''])
                mvs = intersect(self.legal_moves(), goals)
                if mvs == [] and self.legal_moves() != []:
                    els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
                    mvs = self.legal_moves()
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                    app.focus_square(mv)
                    root.after(666, lambda mv = mv : self.white_dragon_move(mv))
                else:
                    els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
                    mvs = self.legal_moves()
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                    app.focus_square(mv)
                    root.after(666, lambda mv = mv : self.white_dragon_move(mv))
            # ATTEMPT ICEBLAST
            else:
                ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner]
                if ids == []:
                    app.handle_action()
                else:
                    id = choice(ids)
                    app.get_focus(id)
                    # EXIT TO HANDLEACTION through iceblast
                    root.after(666, lambda id = id : self.iceblast(id))
                
                
                
                
    def rake(self, id):
        ent = app.ent_dict[id]
#         self.start_melee_anims()
        effect1 = mixer.Sound('Sound_Effects/dragon_melee.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'slashing', 'Rake', 'melee')
            root.after(666, self.do_round)
        else:
            miss(ent.loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
                
            
    def white_dragon_move(self, endloc):
        global selected
        selected = [self.id, self.id+'top']
        app.canvas.delete(self.id)
        app.canvas.delete(self.id+'top')
        self.init_ascend_anims()
        app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+40, image = self.img, tags = self.tags)
        self.type = 'large'
        self.tags = (self.id, 'large')
        effect1 = mixer.Sound('Sound_Effects/dragon_flight.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, -1)
        def ascend_loop(timer):
            if timer == 0:
                self.dragon_flight(endloc)
            else:
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+30, image = self.img, tags = self.tags)
                timer -= 1
                app.canvas.tag_raise('cursor')
                app.canvas.tag_raise('init_q')
                app.canvas.tag_raise('init_ents')
                root.after(333, lambda t = timer : ascend_loop(t))
        root.after(333, lambda t = 2 : ascend_loop(t))
            
    def dragon_flight(self, endloc):
        global selected
        id = self.id
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = endloc[0]*100+50-app.moved_right
        endy = endloc[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = endloc[:]
        self.init_flight_anims()
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, tics):
            if tics == 0:
                tics = 5
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            tics -= 1
            app.canvas.tag_raise('cursor')
            app.canvas.tag_raise('init_q')
            app.canvas.tag_raise('init_ents')
            if x == endx and y == endy:
                self.finish_move(id, end_sqr, start_sqr)
            else:
                root.after(66, lambda id = id, x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, t = tics : move_loop(id, x, y, e, e2, s, s2, t))
        move_loop(id, x, y, endx, endy, start_sqr, end_sqr, 4)
            
    def finish_move(self, id, end_sqr, start_sqr):
        self.loc = end_sqr[:]
        app.focus_square(end_sqr)
        app.ent_dict[id+'top'].loc = [end_sqr[0],end_sqr[1]]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_descend_anims()
        app.canvas.delete(self.id)
        app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+40, image = self.img, tags = self.tags)
        def descend_loop(timer):
            if timer == 0:
                sound_effects.stop()
                self.finish_descend()
            else:
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+50, image = self.img, tags = self.tags)
                timer -= 1
                app.canvas.tag_raise('cursor')
                app.canvas.tag_raise('init_q')
                app.canvas.tag_raise('init_ents')
                root.after(333, lambda t = timer : descend_loop(t))
        root.after(333, lambda t = 2 : descend_loop(t))
        
    def finish_descend(self):
        global selected
        self.init_normal_anims()
        app.canvas.delete(self.id)
        self.type = 'large_bottom'
        self.tags = self.id
        selected = []
        self.do_round()
    
    def iceblast(self, id):
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/iceblast.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) <= 2 and v != self]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Iceblast', justify ='center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Iceblast', justify ='center', font = ('chalkduster', 16), fill = 'aquamarine', tags = 'text')
        def iceblast_loop(ents):
            if ents == []:
                app.handle_action()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                n = 'Iceblast' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                loc = ent.loc[:]
                app.focus_square(loc)
                app.vis_dict[n] = Vis(name = 'Iceblast', loc = loc[:])
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
    #         app.ent_dict[self.id+'top'].init_attack_anims()
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis):
                    my_psy = self.get_abl('psyche')
                    tar_psy = ent.get_abl('psyche')
                    d = damage(my_psy, tar_psy)
                    root.after(1999, lambda n = n : cleanup_vis(n))
                    lock(apply_damage, self, ent, -d, 'cold', 'Iceblast', 'spell')
                    iceblast_loop(ents)
                else:
                    miss(ent.loc)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda n = n : cleanup_vis(n))
                    root.after(1999, lambda ents = ents : iceblast_loop(ents))
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda ents = ents : iceblast_loop(ents))
        
        
        
class Tortured_Soul(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Agony':self.ranged_attack, 'Rend':self.melee_attack}
        self.str = 8
        self.agl = 5
        self.end = 8
        self.mm = 9
        self.msl = 8
        self.bls = 0
        self.dodge = 9
        self.psyche = 9
        self.wis = 9
        self.rsn = 6
        self.init = 7
        self.spirit = 23
        self.magick = 17
        self.san = 12
        self.acts = 1
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'explosive', 'poison']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Agony' in self.actions.keys()]:
                self.magick -= 1
                self.acts -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.ranged_attack(target)
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Rend' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/agony.ogg')
        sound_effects.play(effect1, 0)
        app.vis_dict['Agony'] = Vis(name = 'Agony', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Agony'].img, tags = 'Agony')
        def cleanup_agony():
            del app.vis_dict['Agony']
            app.canvas.delete('Agony')
            app.canvas.delete('text')
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_mm, target_dod):# HIT
            my_msl = self.get_abl('msl')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(1666, self.init_normal_anims)
            root.after(1666, cleanup_agony)
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Agony', 'spell')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, cleanup_agony)
            root.after(1666, self.finish_attack)
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Rend', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
            
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
class Skeleton_Archer(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Black Arrow':self.ranged_attack}
        self.str = 3
        self.agl = 5
        self.end = 3
        self.mm = 7
        self.msl = 4
        self.bls = 12
        self.dodge = 5
        self.psyche = 3
        self.wis = 3
        self.rsn = 1
        self.init = 5
        self.spirit = 13
        self.magick = 0
        self.san = 10
        self.acts = 2
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'slashing', 'poison']
        self.weak = ['crushing', 'magick', 'fire']
        super().__init__(name, img, loc, owner)
        
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Black Arrow' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.acts -= 1
                self.ranged_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
        app.get_focus(id)
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Black_Arrow'] = Vis(name = 'Black_Arrow', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Black_Arrow'].img, tags = 'Black_Arrow')
        my_agl = self.get_abl('agl')
        target_dodge = app.ent_dict[id].get_abl('dodge')
        if to_hit(my_agl, target_dodge):# HIT
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Black Arrow', 'ranged')
            root.after(111, self.finish_attack)
        else:# MISS
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_attack)
        
        
    def finish_attack(self):
        self.init_normal_anims()
        try:
            app.canvas.delete('text')
            del app.vis_dict['Black_Arrow']
            app.canvas.delete('Black_Arrow')
        except: pass
        self.do_round()
            
            
            
class Ghost(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Willowisp':self.willowisp, 'Slow':self.slow, 'Fear':self.fear, 'Wail':self.wail}
        self.str = 8
        self.agl = 11
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 13
        self.psyche = 13
        self.wis = 13
        self.rsn = 10
        self.init = 12
        self.spirit = 99
        self.magick = 666
        self.san = 21
        self.acts = 2
        self.mvs = 2
        self.move_range = 11
        self.waiting = waiting
        self.move_type = 'ethereal'
        self.resist = ['slashing', 'piercing', 'crushing', 'poison']
        self.weak = ['elec', 'cold']
        super().__init__(name, img, loc, owner)
        
    #  GHOST AI
    # all level-based movement should be handled in handle_eot_campaign()
    # change to: cast fear, slow, or willowisp w/i range, then Wail(equake no dmg), then move randomly w/i 4
    # only act if ent w/i range of spells
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else: # ATTEMPT ATTACK FROM STARTLOC
            action_ents = [k for k,v in app.action_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
            spell_ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn')]
            slow_ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc, self.loc) <= self.get_abl('rsn') and 'Slow' not in [j.name for i,j in v.effects_dict.items()]]
            rando = []
            if action_ents != [] and 'Fear' in self.actions.keys():
                rando.append('action')
            if spell_ents != [] and 'Willowisp' in self.actions.keys():
                rando.append('spell')
            if slow_ents != [] and 'Slow' in self.actions.keys():
                rando.append('slow')
            if rando != [] and self.acts > 0:
                self.acts -= 1
                r = choice(rando)
                if r == 'action':
                    id = choice(action_ents)
                    kind = 'fear'
                elif r == 'spell':
                    id = choice(spell_ents)
                    kind = 'willowisp'
                elif r == 'slow':
                    id = choice(slow_ents)
                    kind = 'slow'
                root.after(666, lambda id = id : app.get_focus(id))
                root.after(1333, lambda id = id, kind = kind : self.do_attack(id, kind))
            else:
                self.cleanup_attack()
                    
    # change to cast one of 3 rand spells
    def do_attack(self, id, kind):
        app.get_focus(id)
        if kind == 'fear':
            self.fear(id)
        elif kind == 'willowisp':
            self.willowisp(id)
        elif kind == 'slow':
            self.slow(id)
    
    # tar gets psy reduction, mov reduce by 1, and psy v psy atk with psy v psy dmg
    def fear(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Fear', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Fear', justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'text')
        ent = app.ent_dict[id]
        ents = [k for k,v in app.action_target_ents().items() if dist(v.loc, ent.loc) <= 1 and v.owner == ent.owner]
        def cleanup_fear(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def fear_loop(ents):
            if ents == []:
                self.do_round()
            else:
                effect1 = mixer.Sound('Sound_Effects/terror.ogg')
                sound_effects.play(effect1, 0)
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                ent = app.ent_dict[id]
                # do dmg
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                loc = ent.loc[:]
                n = 'Fear'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Fear', loc = ent.loc[:])
                app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1555, lambda n = n : cleanup_fear(n))
                if to_hit(my_wis, tar_wis):
                    d = damage(self.get_abl('psyche'), ent.get_abl('psyche'))
                    lock(apply_damage, self, ent, -d, 'cold', 'Fear', 'spell')
                    if 'Fear' not in [v.name for k,v in ent.effects_dict.items()]:
                        def fear_move(move_range):
                            return max(0,move_range-1)
                        p = partial(fear_move)
                        ent.move_range_effects.append(p)
                        def fear_effect(stat):
                            return max(1, stat-1)
                        p2 = partial(fear_effect)
                        ent.psyche_effects.append(p2)
                        def undo(ent, p, p2, lockname = None):
                            ent.move_range_effects.remove(p)
                            ent.psyche_effects.remove(p2)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p, p2)
                        n = 'Fear'+str(app.count)
                        app.count += 1
                        ent.effects_dict[n] = Effect(name = 'Fear', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Fear...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Fear...', justify = 'center', fill = 'bisque2', font = ('chalkduster', 13), tags = 'text')
                        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                        root.after(1666, lambda ents = ents : fear_loop(ents))
                    else:
                        miss(ent.loc)
                        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                        root.after(1666, lambda ents = ents : fear_loop(ents))
                else:
                    miss(loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ents = ents : fear_loop(ents))
        fear_loop(ents)
    
    # tar gets move reduce by 3 and atk efct dmg halved rounded down min1
    def slow(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Slow', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Slow', justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'text')
        ent = app.ent_dict[id]
        ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc, ent.loc) <= 1 and v.owner == ent.owner]
        def cleanup_slow(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def slow_loop(ents):
            if ents == []:
                self.do_round()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                if 'Slow' not in [v.name for k,v in ent.effects_dict.items()]:
                    app.get_focus(id)
                    n = 'Slow'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Slow', loc = ent.loc[:])
                    app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                    root.after(1666, lambda n = n : cleanup_slow(n))
                    loc = ent.loc[:]
                    def slow_move(move_range):
                        return max(0,move_range-2)
                    p = partial(slow_move)
                    ent.move_range_effects.append(p)
                    def slow_atk(atkr, dfndr, dmg, type, sn, st, lockname = None):
                        loc = atkr.loc[:]
                        if st == 'melee' or st == 'ranged':
                            app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Attack Slowed...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                            app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Attack Slowed...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                            if dmg < 0:
                                return (min(-1, dmg//2), type)
                            else:
                                return (dmg, type)
                        else:
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            return (dmg, type)
                    p2 = partial(slow_atk)
                    ent.attack_effects.append(p2)
                    def undo(ent, p, p2, lockname = None):
                        ent.move_range_effects.remove(p)
                        ent.attack_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p, p2)
                    n = 'Slow'+str(app.count)
                    app.count += 1
                    ent.effects_dict[n] = Effect(name = 'Slow', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+74, text = 'Slowed...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                    app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+75, text = 'Slowed...', justify = 'center', fill = 'bisque2', font = ('chalkduster', 13), tags = 'text')
                    root.after(2000, lambda t = 'text' : app.canvas.delete(t))
                    root.after(2111, lambda ents = ents : slow_loop(ents))
                else:
                    slow_loop(ents)
        slow_loop(ents)

    # psy v end dmg, end save at -2 or get burn effect, move target to rand sqr w/i rang 4 (use normal move pathing)
    def willowisp(self, id):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = "Will o'Wisp", justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'wisp_text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = "Will o'Wisp", justify = 'center', fill = 'bisque2', font = ('chalkduster', 15), tags = 'wisp_text')
        root.after(1666, lambda t = 'wisp_text' : app.canvas.delete(t))
        ent = app.ent_dict[id]
        def cleanup_willowisp(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        n = 'Willowisp'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Willowisp', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        root.after(1555, lambda n = n : cleanup_willowisp(n))
        my_psy = self.get_abl('psyche')
        tar_end = ent.get_abl('end')
        d = damage(my_psy, tar_end)
        lock(apply_damage, self, ent, -d, 'fire', "Will o' Wisp", 'spell')
        if id in app.all_ents().keys():
            if 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                loc = ent.loc[:]
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Burned...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'burn_text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Burned...', justify = 'center', fill = 'orangered2', font = ('chalkduster', 14), tags = 'burn_text')
                root.after(999, lambda t = 'burn_text' : app.canvas.delete(t))
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and (st == 'melee' or st == 'ranged' or st == 'spell'):
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                p = partial(burn_effect)
                ent.defense_effects.append(p)
                def undo(ent, p, lockname = None):
                    ent.defense_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Burn'+str(app.count)
                app.count += 1
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                # insert rndmly move tar
                sqrs = [s for s in app.coords if dist(s, loc) <= 4 and app.grid[s[0]][s[1]] == '' and bfs(loc, [s], app.grid) and len(bfs(loc, [s], app.grid)) <= 5]
                if sqrs == []:
                    root.after(666, self.cleanup_attack)
                else:
                    sqr = choice(sqrs)
                    root.after(666, lambda s = sqr[:] : app.focus_square(s))
                    lock(Bot.ai_normal_move, ent, sqr)
                    root.after(666, self.do_round)
            else:
                root.after(666, self.do_round)
        else:
            root.after(666, self.do_round)
        
    def cleanup_attack(self):
#         self.init_normal_anims()
        try: 
            app.canvas.delete('text')
        except: pass
        if 'Wail' in self.actions.keys():
            self.wail()
        else:
            self.wander()
        
    # change to ensure path is no greater than 2 or 3, only move to increase distance from ghost
    def wail(self):
        sqrs = [c for c in app.coords if dist(c,self.loc) <= self.get_abl('rsn')]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Wail', font = ('chalkduster', 17), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Wail', font = ('chalkduster', 17), fill = 'bisque2', tags = 'text')
        root.after(1666, lambda t = 'text' : app.canvas.delete(t))
        ents = [k for k,v in app.all_ents().items() if v.owner != self.owner and v.loc in sqrs ]
        def cleanup_wail(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        n = 'Wail'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Wail', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
        root.after(2666, lambda n = n : cleanup_wail(n))
        def wail_loop(ents):
            if ents == []:
                self.wander()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                loc = ent.loc
                app.get_focus(id)
                n = 'Wail'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Wail', loc = loc[:])
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1666, lambda n = n : cleanup_wail(n))
#                 sqrs = [s for s in app.coords if dist(s, loc) <= 4 and app.grid[s[0]][s[1]] == '' and dist(s,self.loc) >= dist(loc,self.loc) and bfs(loc, [s], app.grid) and len(bfs(loc, [s], app.grid)) <= 5]
                sqrs = ent.legal_moves()
                if sqrs == []:
                    root.after(666, lambda ents = ents : wail_loop(ents))
                else:
                    sqr = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, sqrs)
                    app.focus_square(sqr)
                    mt = ent.get_move_type()
                    if mt == 'normal' or mt == 'charge':
                        lock(Bot.ai_normal_move, ent, sqr)
                    elif mt == 'teleport':
                        lock(Bot.ai_teleport_move, ent, sqr)
                    else:
                        lock(Bot.ai_flying_move, ent, sqr)
                    root.after(666, lambda ents = ents : wail_loop(ents))
        root.after(2666, lambda ents = ents : wail_loop(ents))
        
    def wander(self):
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('move_range') and app.grid[s[0]][s[1]] == '']
        if sqrs == []:
            app.handle_action()
        else:
            sqr = choice(sqrs)
            lock(self.do_move, sqr)
            app.handle_action()
            
        
class Revenant(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Terror':self.ranged_attack}
        self.str = 4
        self.agl = 5
        self.end = 5
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 5
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.init = 8
        self.spirit = 16
        self.magick = 17
        self.san = 10
        self.acts = 1
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['slashing', 'piercing', 'crushing', 'poison']
        self.weak = ['fire', 'elec', 'cold', 'acid']
        super().__init__(name, img, loc, owner)
        
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            app.get_focus(self.id)
            if self.acts > 0 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner] and 'Terror' in self.actions.keys():
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.acts -= 1
                root.after(999, lambda t = target : app.get_focus(t))
                root.after(1111, lambda t = target : self.ranged_attack(t))
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()
        
    def ranged_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/terror.ogg')
        sound_effects.play(effect1, 0)
        app.vis_dict['Terror'] = Vis(name = 'Terror', loc = ent.loc[:])
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Terror'].img, tags = 'Terror')
        def cleanup_terror():
            del app.vis_dict['Terror']
            app.canvas.delete('Terror')
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, target_wis):# HIT
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(2111, cleanup_terror)
            lock(apply_damage, self, app.ent_dict[id], -d, 'magick', 'Terror', 'spell')
            root.after(333, self.finish_attack)
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(2111, cleanup_terror)
            root.after(2111, self.finish_attack)
            
    def finish_attack(self):
#         self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
            
        
        
class Kensai(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Lacerate':self.lacerate, 'Lunge':self.lunge, 'Riposte':self.riposte}
        self.str = 7
        self.agl = 17
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 11
        self.psyche = 9
        self.wis = 13
        self.rsn = 4
        self.init = 13
        self.spirit = 46
        self.magick = 0
        self.san = 18
        self.acts = 4
        self.mvs = 3
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != [] and choice([0,1]):
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner and 'Riposte' not in [j.name for i,j in v.effects_dict.items()]] and 'Riposte' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner and 'Riposte' not in [j.name for i,j in v.effects_dict.items()]])
                self.acts -= 1
                self.riposte(target)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Lacerate' in self.get_actions().keys() and choice([0,1]):
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.lacerate(target)
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Lunge' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.lunge(target)
            # debug legal moves not empty but cannot make move for some reason in melee_pursue() or whatever used to move
            # such as all enemy invisible... so no goals to move towards...
            elif self.mvs < 1 or self.legal_moves() == []:
                app.handle_action()
            else:
                self.do_round()
        
    
    def riposte(self, id):
        self.init_attack_anims()
        root.after(1666, self.init_normal_anims)
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Riposte'] = Vis(name = 'Riposte', loc = ent.loc[:])
        def cleanup_lacer():
            del app.vis_dict['Riposte']
            app.canvas.delete('Riposte')
        root.after(1777, cleanup_lacer)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            def riposte_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
                if st == 'melee' and to_hit(atkr.get_abl('agl'),dfndr.get_abl('agl')) == False:
                    app.canvas.create_text(atkr.loc[0]*100-app.moved_right+49, atkr.loc[1]*100-app.moved_down+14, text = 'Riposte miss...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                    app.canvas.create_text(atkr.loc[0]*100-app.moved_right+50, atkr.loc[1]*100-app.moved_down+15, text = 'Riposte miss...', justify = 'center', fill = 'gray88', font = ('chalkduster', 14), tags = 'text')
                    root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1777, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (1, type)
                else:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return(amt, type)
            p = partial(riposte_atk)
            ent.attack_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.attack_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = 'Riposte'+str(app.count)
            app.count += 1
            ent.effects_dict[n] = Effect(name = 'Riposte', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+14, text = 'Riposte...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+15, text = 'Riposte...', justify = 'center', fill = 'gray88', font = ('chalkduster', 14), tags = 'text')
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, self.do_round)
        else:
            miss(ent.loc)
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1888, self.do_round)
                    
        
    def lacerate(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lacerate.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Lacerate'] = Vis(name = 'Lacerate', loc = ent.loc[:])
        def cleanup_lacer():
            del app.vis_dict['Lacerate']
            app.canvas.delete('Lacerate')
        root.after(1777, cleanup_lacer)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, ent, -d, 'slashing', 'Lacerate', 'melee')
            root.after(333, self.do_round)
        else:# MISS
            miss(ent.loc)
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
            
    def lunge(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/lunge.ogg')
#         sound_effects.play(effect1, 0)
        app.vis_dict['Lunge'] = Vis(name = 'Lunge', loc = ent.loc[:])
        def cleanup_lunge():
            del app.vis_dict['Lunge']
            app.canvas.delete('Lunge')
        root.after(1777, cleanup_lunge)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, ent, -d, 'piercing', 'Lunge', 'melee')
            root.after(333, self.do_round)
        else:# MISS
            miss(ent.loc)
            root.after(1777, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
        
        
class Kobold_Cleric(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Bless':self.bless, 'Hex':self.hex, 'Scratch':self.melee_attack}
        self.str = 3
        self.agl = 6
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 8
        self.wis = 6
        self.rsn = 4
        self.init = 6
        self.spirit = 15
        self.magick = 11
        self.san = 12
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'fire']
        self.weak = ['slashing']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v != self and v.owner == self.owner and v.spirit <= v.base_spirit-self.get_abl('psyche')] != []:
                self.magick -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner == self.owner and v != self and v.spirit <= v.base_spirit-self.get_abl('psyche')])
                self.acts -= 1
                root.after(666, lambda t = target : self.bless(t))
            elif self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]]:
                self.magick -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]])
                self.acts -= 1
                root.after(666, lambda t = target : self.hex(t))
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and 'Hex' not in [j.name for i,j in v.effects_dict.items()]] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Scratch' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Scratch', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
            
    def bless(self, id):
        app.get_focus(id)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+14, text = 'Bless', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+15, text = 'Bless', justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        
        visloc = ent.loc[:]
        def cleanup_bless(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        name = 'Bless' + str(app.count)
        app.count += 1
        app.vis_dict[name] = Vis(name = 'Bless', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict[name].img, tags = name)
        amt = self.get_abl('psyche')
        apply_heal(ent, self, amt)
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Heal '+str(amt), justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Heal '+str(amt), justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        root.after(1555, lambda name = name : cleanup_bless(name))
        root.after(1666, self.do_round)

    def hex(self, id):
        app.get_focus(id)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Hex', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Hex', justify = 'center', fill = 'gray88', font = ('chalkduster', 15), tags = 'text')
        
        visloc = ent.loc[:]
        def cleanup_hex(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        name = 'Hex' + str(app.count)
        app.count += 1
        app.vis_dict[name] = Vis(name = 'Hex', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict[name].img, tags = name)
        if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+74, text = 'Hex, -1 stats', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+75, text = 'Hex, -1 stats', justify = 'center', fill = 'gray88', font = ('chalkduster', 13), tags = 'text')
            def hex_effect(stat):
                stat -= 1
                if stat < 1:
                    return 1
                else:
                    return stat
            f = hex_effect
            app.ent_dict[id].str_effects.append(f)
            app.ent_dict[id].end_effects.append(f)
            app.ent_dict[id].agl_effects.append(f)
            app.ent_dict[id].mm_effects.append(f)
            app.ent_dict[id].dodge_effects.append(f)
            app.ent_dict[id].psyche_effects.append(f)
            app.ent_dict[id].wis_effects.append(f)
            app.ent_dict[id].rsn_effects.append(f)
            app.ent_dict[id].san_effects.append(f)
            app.ent_dict[id].init_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].str_effects.remove(hex_effect)
                app.ent_dict[i].end_effects.remove(hex_effect)
                app.ent_dict[i].agl_effects.remove(hex_effect)
                app.ent_dict[i].mm_effects.remove(hex_effect)
                app.ent_dict[i].dodge_effects.remove(hex_effect)
                app.ent_dict[i].psyche_effects.remove(hex_effect)
                app.ent_dict[i].wis_effects.remove(hex_effect)
                app.ent_dict[i].rsn_effects.remove(hex_effect)
                app.ent_dict[i].san_effects.remove(hex_effect)
                app.ent_dict[i].init_effects.remove(hex_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            n = 'Hex' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Hex', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(1555, lambda name = name : cleanup_hex(name))
            root.after(1666, self.do_round)
        else:
            miss(ent.loc)
            root.after(1555, lambda name = name : cleanup_hex(name))
            root.after(1666, self.do_round)
            
        


class Kobold_Shaman(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Firebolt':self.ranged_attack, 'Scratch':self.melee_attack}
        self.str = 3
        self.agl = 5
        self.end = 3
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 6
        self.wis = 5
        self.rsn = 4
        self.init = 7
        self.spirit = 11
        self.magick = 13
        self.san = 11
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['piercing', 'fire']
        self.weak = ['crushing']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'Firebolt' in self.actions.keys()]:
                self.magick -= 1
                self.acts -= 1
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('rsn') and v.owner != self.owner])
                self.ranged_attack(target)
            elif self.magick >= 1 and [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            elif self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner] and 'Scratch' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
#         effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Scratch', 'melee')
            self.do_round()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.do_round)
                
            
    def ranged_attack(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flare.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Flare'] = Vis(name = 'Flare', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Flare'].img, tags = 'Flare')
        selected_vis = ['Flare']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
                # debug here, if within certain range...
            app.vis_dict['Flare'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Flare']
                app.canvas.delete('Flare')
            except: pass
        if to_hit(my_wis, target_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Firebolt', 'spell')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
        
        

class Ghoul(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Claw Rake':self.melee_attack}
        self.str = 4
        self.agl = 5
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 3
        self.psyche = 4
        self.wis = 4
        self.rsn = 4
        self.init = 4
        self.spirit = 13
        self.magick = 0
        self.san = 10
        self.acts = 1
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing', 'piercing', 'poison']
        self.weak = ['crushing', 'fire']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Claw Rake' in self.actions.keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            else:
                app.handle_action()

        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Claw Rake', 'melee')
            if id in app.all_ents().keys() and 'Ghoul_Venom' not in app.ent_dict[id].effects_dict.keys():# HIT, NO KILL add ghoul_venom if not exists
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+49, app.ent_dict[id].loc[1]*100-app.moved_down+84, text = 'Ghoul Venom...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
                app.canvas.create_text(app.ent_dict[id].loc[0]*100-app.moved_right+50, app.ent_dict[id].loc[1]*100-app.moved_down+85, text = 'Ghoul Venom...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
                def ghoul_effect(stat):
                    stat -= 1
                    if stat < 1:
                        return 1
                    else:
                        return stat
                app.ent_dict[id].str_effects.append(ghoul_effect)
                app.ent_dict[id].end_effects.append(ghoul_effect)
                def un(i, lockname = None):
                    app.ent_dict[i].str_effects.remove(ghoul_effect)
                    app.ent_dict[i].end_effects.remove(ghoul_effect)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p = partial(un, id)
                # EOT FUNC
                def take_2(tar, lockname = None):
                    app.get_focus(tar)
                    lock(apply_damage, self, app.ent_dict[tar], -2, 'poison', 'Ghoul Venom', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                eot = partial(take_2, id)
                app.ent_dict[id].effects_dict['Ghoul_Venom'] = Effect(name = 'Ghoul_Venom', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(999, self.finish_attack)
            else:
                root.after(111, self.finish_attack)
        else:# MISS
            miss(app.ent_dict[id].loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Skeleton(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Bone Strike':self.melee_attack}
        self.str = 5
        self.agl = 3
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 2
        self.psyche = 2
        self.wis = 2
        self.rsn = 1
        self.init = 3
        self.spirit = 9
        self.magick = 0
        self.san = 9
        self.acts = 1
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['slashing', 'piercing', 'poison']
        self.weak = ['crushing', 'fire']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Bone Strike' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Bone Strike', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
class Ghast(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Cut':self.melee_attack}
        self.str = 4
        self.agl = 9
        self.end = 4
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 7
        self.psyche = 3
        self.wis = 3
        self.rsn = 2
        self.init = 7
        self.spirit = 9
        self.magick = 0
        self.san = 10
        self.acts = 2
        self.mvs = 1
        self.move_range = 3
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = []
        self.weak = ['fire']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Cut' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    def melee_attack(self, id):
        self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_knight_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Cut', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Undead_Knight(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Cleave':self.melee_attack}
        self.str = 10
        self.agl = 9
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 8
        self.psyche = 7
        self.wis = 7
        self.rsn = 4
        self.init = 6
        self.spirit = 86
        self.magick = 19
        self.san = 15
        self.acts = 3
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'fire', 'poison']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self. acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Cleave' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/undead_knight_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Cleave', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Troll(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Pummel':self.melee_attack}
        self.str = 9
        self.agl = 7
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 5
        self.psyche = 3
        self.wis = 3
        self.rsn = 2
        self.init = 8
        self.spirit = 35
        self.magick = 0
        self.san = 11
        self.acts = 1
        self.mvs = 1
        self.move_range = 8
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'slashing', 'piercing']
        self.weak = ['fire', 'acid']
        self.regen_this_round = False
        super().__init__(name, img, loc, owner)
        
    def troll_regen(self):
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text='Regen 2 Spirit', font= ('chalkduster', 13), fill = 'black', tags = 'regen_text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text='Regen 2 Spirit', font= ('chalkduster', 13), fill = 'white', tags = 'regen_text')
        root.after(999, lambda t = 'regen_text' : app.canvas.delete(t))
        self.spirit += 2
        if self.spirit > 35:
            self.spirit = 35
        self.regen_this_round = True
        
    def do_round(self):
        # TROLL REGEN (regen_this_round reset in app.end_turn)
        if self.spirit < 35 and self.regen_this_round == False:
            self.troll_regen()
            root.after(1666, self.do_round)
        elif self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Pummel' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/orc_axeman_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Pummel', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
        
class Warlock(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Undead':self.summon_undead, 'Duress':self.duress, "Tourach's Hymn":self.tourachs_hymn, 'Staff of Vecna':self.staff_of_vecna}
        self.str = 6
        self.agl = 12
        self.end = 9
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 16
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 9
        self.spirit = 89
        self.magick = 266
        self.san = 22
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_undead = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['magick', 'fire', 'elec', 'cold', 'acid']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
    # OVERRIDE BASE METHOD, WARLOCK ABLS NOT AFFECTED BY EFFECTS
    def get_abl(self, abl):
        if abl == 'str':
            return self.str
        elif abl == 'agl':
            return self.agl
        elif abl == 'end':
            return self.end
        elif abl == 'mm':
            return self.mm
        elif abl == 'msl':
            return self.msl
        elif abl == 'bls':
            return self.bls
        elif abl == 'dodge':
            return self.dodge
        elif abl == 'psyche':
            return self.psyche
        elif abl == 'wis':
            return self.wis
        elif abl == 'rsn':
            return self.rsn
        elif abl == 'init':
            return self.init
        elif abl == 'san':
            return self.san
        elif abl == 'acts':
            return self.base_acts
        elif abl == 'mvs':
            return self.base_mvs
        elif abl == 'move_range':
            return self.move_range
            
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.summoned_undead == False:
                self.summoned_undead = True
                root.after(333, self.summon_undead)
            # DURESS WI RANGE
            elif self.acts > 0 and self.magick >= 5 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')>=v.get_abl('str')] != []:
                self.magick -= 5
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')>=v.get_abl('str')])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.duress(t))
            # TOURACHS HYMN WI RANGE
            elif self.acts > 0 and self.magick >= 3 and [k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')<=v.get_abl('str')] != []:
                self.magick -= 3
                target = choice([k for k,v in app.spell_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and v.get_abl('psyche')<=v.get_abl('str')])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.tourachs_hymn(t))
            # FREE DISPEL PSYSHIELD WI RANGE STAFF OF VECNA
            elif [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()] != []:
                target = choice([k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()])
                app.get_focus(target)
                root.after(666, lambda t = target : self.staff_of_vecna(t))
            # RANGED PURSUE
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()
            
            
    def summon_undead(self):
        effect1 = mixer.Sound('Sound_Effects/warlock_summon.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.count += 3 # skip existing ent ids
        uniq_num = app.count
        app.count += 1
        # get random empty location
        coords = [c for c in app.coords if dist(c, self.loc) <= 9 and app.grid[c[0]][c[1]] == '']
        if len(coords) > 2:
            undead_loc = choice(coords)
            coords.remove(undead_loc)
            undead_loc2 = choice(coords)
            coords.remove(undead_loc2)
            undead_loc3 = choice(coords)
            n ='su'+str(app.count)
            app.count += 1
            n2 = 'su'+str(app.count)
            app.count += 1
            n3 = 'su'+str(app.count)
            app.count += 1
            app.vis_dict[n] = Vis(name = 'Summon_Skeleton', loc = undead_loc[:])
            app.vis_dict[n2] = Vis(name = 'Summon_Skeleton', loc = undead_loc2[:])
            app.vis_dict[n3] = Vis(name = 'Summon_Skeleton', loc = undead_loc3[:])
            app.canvas.create_image(undead_loc[0]*100+50-app.moved_right, undead_loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
            app.canvas.create_image(undead_loc2[0]*100+50-app.moved_right, undead_loc2[1]*100+50-app.moved_down, image = app.vis_dict[n2].img, tags = n2)
            app.canvas.create_image(undead_loc3[0]*100+50-app.moved_right, undead_loc3[1]*100+50-app.moved_down, image = app.vis_dict[n3].img, tags = n3)
            def cleanup_vis(name):
                del app.vis_dict[name]
                app.canvas.delete(name)
            root.after(2222, lambda name = n : cleanup_vis(name))
            root.after(2222, lambda name = n2 : cleanup_vis(name))
            root.after(2222, lambda name = n3 : cleanup_vis(name))
            app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Summon Undead', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Summon Undead', justify = 'center', font = ('chalkduster', 14), fill = 'magenta2', tags = 'text')
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Skeleton.png'))
            img2 = ImageTk.PhotoImage(Image.open('summon_imgs/Ghoul.png'))
            ent = Skeleton(name = 'Skeleton', img = img, loc = undead_loc[:], owner = 'p2')
            ent2 = Skeleton(name = 'Skeleton', img = img, loc = undead_loc2[:], owner = 'p2')
            ent3 = Ghoul(name = 'Ghoul', img = img2, loc = undead_loc3[:], owner = 'p2')
            app.ent_dict[ent.id] = ent
            app.ent_dict[ent2.id] = ent2
            app.ent_dict[ent3.id] = ent3
            app.grid[ent.loc[0]][ent.loc[1]] = ent.id
            app.grid[ent2.loc[0]][ent2.loc[1]] = ent2.id
            app.grid[ent3.loc[0]][ent3.loc[1]] = ent3.id
#             app.canvas.create_image(undead_loc[0]*100+50-app.moved_right, undead_loc[1]*100+50-app.moved_down, image = img, tags = ent.tags)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
        root.after(1333, lambda s = undead_loc[:] : app.focus_square(s))
        root.after(2333, lambda s = undead_loc2[:] : app.focus_square(s))
        root.after(3333, lambda s = undead_loc3[:] : app.focus_square(s))
        root.after(4333, self.do_round)
            
            
    
    def duress(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/warlock_duress.ogg')
        effect1.set_volume(.7)
        sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_duress():
            del app.vis_dict['Duress']
            app.canvas.delete('Duress')
        visloc = ent.loc[:]
        app.vis_dict['Duress'] = Vis(name = 'Duress', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Duress'].img, tags = 'Duress')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Duress', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Duress', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            # add -4 rsn, -7 san
            def rsn_ef(stat):
                return max(1,stat-4)
            p = partial(rsn_ef)
            ent.rsn_effects.append(p)
            def san_ef(stat):
                return max(1,stat-7)
            p2 = partial(san_ef)
            ent.san_effects.append(p2)
            def undo(ent, p, p2, lockname = None):
                ent.rsn_effects.remove(p)
                ent.san_effects.remove(p2)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p, p2)
            n = 'Duress' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Duress', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-3 rsn, -7 san', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-3 rsn, -7 san', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_duress)
            lock(apply_damage, self, ent, -d, 'magick', 'Duress', 'spell')
            root.after(333, self.do_round)
        else:
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, cleanup_duress)
            root.after(2111, self.do_round)
            
            
    def tourachs_hymn(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/tourachs_hymn.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_hymn():
            del app.vis_dict["Tourach's_Hymn"]
            app.canvas.delete("Tourach's_Hymn")
        visloc = ent.loc[:]
        app.vis_dict["Tourach's_Hymn"] = Vis(name = "Tourach's_Hymn", loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict["Tourach's_Hymn"].img, tags = "Tourach's_Hymn")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = "Tourach's Hymn", font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = "Tourach's Hymn", font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            # add -4 str, agl
            def hymn_ef(stat):
                return max(1,stat-4)
            p = partial(hymn_ef)
            ent.str_effects.append(p)
            ent.agl_effects.append(p)
            def undo(ent, p, lockname = None):
                ent.str_effects.remove(p)
                ent.agl_effects.remove(p)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, ent, p)
            n = "Tourach's_Hymn" + str(app.count)
            ent.effects_dict[n] = Effect(name = "Tourach's_Hymn", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+24-app.moved_down, text = '-4 str, agl', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+25-app.moved_down, text = '-4 str, agl', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_hymn)
            lock(apply_damage, self, ent, -d, 'magick', "Tourach's Hymn", 'spell')
            root.after(333, self.do_round)
        else:
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, cleanup_hymn)
            root.after(2111, self.do_round)
            
    def staff_of_vecna(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/staff_of_vecna.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_staff():
            del app.vis_dict['Staff_of_Vecna']
            app.canvas.delete('Staff_of_Vecna')
        visloc = ent.loc[:]
        app.vis_dict['Staff_of_Vecna'] = Vis(name = 'Staff_of_Vecna', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Staff_of_Vecna'].img, tags = 'Staff_of_Vecna')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        def staff_ef(ts):
            return [t for t in ts if t != 'psyshield']
        p = partial(staff_ef)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Staff_of_Vecna' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Staff_of_Vecna', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
        root.after(1999, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, cleanup_staff)
        root.after(2111, self.do_round)
        
        
class Air_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Static Storm':self.static_storm, 'Cyclonic Rift':self.cyclonic_rift, 'Breath of Life':self.breath_of_life, 'Summon Air Elementals':self.summon_elementals}
        self.str = 6
        self.agl = 12
        self.end = 7
        self.mm = 13
        self.msl = 9
        self.bls = 7
        self.dodge = 17
        self.psyche = 11
        self.wis = 11
        self.rsn = 6
        self.init = 9
        self.spirit = 48
        self.magick = 366
        self.san = 17
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['elec', 'cold']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            air_elems = [v for k,v in app.all_ents().items() if v.name == 'Air_Elemental']
            tot_cur_sprt = sum([ent.spirit for ent in air_elems])
            tot_base_sprt = sum([ent.base_spirit for ent in air_elems])
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # BREATH OF LIFE if any air elem exist and total current spirit is at least 15 less than total base spirit
            elif (tot_cur_sprt+15)<=tot_base_sprt and self.acts > 0 and 'Breath of Life' in self.get_actions().keys():
                self.acts -= 1
                self.breath_of_life()
            # STATIC STORM, if close ents have effects and choice01
            elif len([j for k,v in app.all_ents().items() for i,j in v.effects_dict.items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]) >= 3 and self.acts > 0 and 'Static Storm' in self.get_actions().keys() and choice([0,1]):
                self.acts -= 1
                self.static_storm()
            # CYCLONIC RIFT any in range
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')] != [] and self.acts > 0 and 'Cyclonic Rift' in self.get_actions().keys():
                target = choice([k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')])
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.cyclonic_rift(t))
            # RANGED FLYING PURSUE (teleport)
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.ranged_flying_pursue(self, self.get_abl('rsn'), 'spell')
            else:
                app.handle_action()
#########

    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
                    effect1.set_volume(1)
                    sound_effects.play(effect1, 0)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Air Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Air Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Air_Elemental.png'))
                    ent = Air_Elemental(name = 'Air_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
                
            
                
    
    def static_storm(self):
        effect1 = mixer.Sound('Sound_Effects/teleport_move.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Static Storm', font = ('chalkduster', 15), fill = 'gray', tags = 'text')
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v != self]
        def cleanup_static(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def static_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                n = 'Static_Storm'+str(app.count)
                app.count += 1
                app.vis_dict[n] = Vis(name = 'Static_Storm', loc = ent.loc[:])
                root.after(1777, lambda n = n : cleanup_static(n))
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                root.after(1888, lambda ids = ids : static_loop(ids))
        root.after(1777, lambda t = 'text' : app.canvas.delete(t))
        root.after(1888, lambda ids = ids : static_loop(ids))
                
                    
                    
    # dmg and teleport one target
    def cyclonic_rift(self, id):
#         effect1 = mixer.Sound('Sound_Effects/cyclone.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        ent = app.ent_dict[id]
        app.focus_square(loc)
        app.vis_dict['Cyclone'] = Vis(name = 'Cyclone', loc = loc[:])
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Cyclone'].img, tags = 'Cyclone')
        def cleanup_rift():
            del app.vis_dict['Cyclone']
            app.canvas.delete('Cyclone')
        my_wis = self.get_abl('wis')
        tar_wis = app.ent_dict[id].get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Cyclonic Rift', 'spell')
            if id in app.ent_dict.keys():
                cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(ent.loc,c)<=self.get_abl('psyche')]
                if cs == []:
                    self.do_round()
                else:
                    self.cyclone_teleport(id, choice(cs))
            else:
                root.after(1888, cleanup_rift)
                self.do_round()
        else:
            miss(ent.loc)
            root.after(1888, cleanup_rift)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
    
    def cyclone_teleport(self, id, loc):
        global selected
        selected.append(id)
        del app.vis_dict['Cyclone']
        app.canvas.delete('Cyclone')
        app.canvas.delete('text')
        app.vis_dict['Cyclone'] = Vis(name = 'Cyclone', loc = loc[:])
        app.focus_square(loc)
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Cyclone'].img, tags = 'Cyclone')
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        app.canvas.delete(id)
        root.after(1666, lambda id = id, loc = loc : self.finish_cyclone(id, loc))
        
    def finish_cyclone(self, id, loc):
        global selected
        app.ent_dict[id].loc = loc[:]
        app.grid[loc[0]][loc[1]] = id
        del app.vis_dict['Cyclone']
        app.canvas.delete('Cyclone')
        app.get_focus(id)
        app.canvas.create_image(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down, image = app.ent_dict[id].img, tags = app.ent_dict[id].tags)
        selected.remove(id)
        try: app.canvas.tag_lower((app.ent_dict[id].tags), 'large')
        except: pass
        app.canvas.tag_lower((app.ent_dict[id].tags), 'maptop')
        self.do_round()
        
    # only called when summons exist, heal whatever summons remain for some amount, give them stat boost effect
    def breath_of_life(self):
        effect1 = mixer.Sound('Sound_Effects/moonlight.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Breath of Life', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Breath of Life', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
#         app.vis_dict['Breath_of_Life'] = Vis(name = 'Breath_of_Life', loc = self.loc[:])
#         app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Breath_of_Life'].img, tags = 'Breath_of_Life')
        ents = [k for k,v in app.all_ents().items() if v.name == 'Air_Elemental']
        def clean_breath_vis(name):
            app.canvas.delete('text')
            del app.vis_dict[name]
            app.canvas.delete('Breath_of_Life')
        def breath_loop(ents):
            if ents == []:
                self.do_round()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                loc = ent.loc[:]
                app.focus_square(loc)
                n = 'Breath_of_Life'+str(app.count)
                app.count += 1
                app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+74-app.moved_down, text = '+10 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+75-app.moved_down, text = '+10 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                app.vis_dict[n] = Vis(name = 'Breath_of_Life', loc = loc[:])
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = 'Breath_of_Life')
                # HEAL, DISPEL
                apply_heal(self, ent, 10)
                spacer = 30
                to_remove = []
                for k,v in ent.effects_dict.items():
                    if v.dispel(self.get_abl('wis')) == 'Dispelled':
                        to_remove.append(k)
                        if spacer > 300:
                            continue
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                        spacer += 15
                for k in to_remove:
                    del ent.effects_dict[k]
                root.after(2333, lambda t = 'text' : app.canvas.delete(t))
                root.after(2333, lambda n = n : clean_breath_vis(n))
                root.after(2555, lambda e = ents : breath_loop(e))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda e = ents : breath_loop(e))
                
                
                    

class Air_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Gale':self.gale}
        self.str = 5
        self.agl = 9
        self.end = 5
        self.mm = 9
        self.msl = 6
        self.bls = 5
        self.dodge = 9
        self.psyche = 5
        self.wis = 5
        self.rsn = 4
        self.init = 9
        self.spirit = 22
        self.magick = 0
        self.san = 16
        self.acts = 1
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['elec', 'cold']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Gale' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.gale(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
#                 Ai_man.ranged_flying_pursue(self, self.get_abl('bls'), 'action')
            else:
                app.handle_action()
        
                
            
    def gale(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/gale.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Gale'] = Vis(name = 'Gale', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Gale'].img, tags = 'Gale')
        selected_vis = ['Gale']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Gale')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Gale'].img, tags = 'Gale')
                app.canvas.tag_raise('Gale')
                # debug here, if within certain range...
            app.vis_dict['Gale'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Gale']
                app.canvas.delete('Gale')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Gale', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
# water mage, dehydrate- give fire wkns, wis vs wis psy v psy acid spell
# fog- -3 mvrng, 2 cold dmg aoe
# purify- any tar w at least 2 efcts that are not dehydrate, esuna like dispel
class Water_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Dehydrate':self.dehydrate, 'Fog':self.fog, 'Purify':self.purify, 'Summon Water Elementals':self.summon_elementals}
        self.str = 9
        self.agl = 10
        self.end = 9
        self.mm = 12
        self.msl = 11
        self.bls = 6
        self.dodge = 13
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 8
        self.spirit = 76
        self.magick = 666
        self.san = 17
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.summoned_elementals = False
        self.purify_used = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['fire', 'crushing', 'explosive']
        self.weak = ['elec']
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            purify_tars = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and len([i for i,j in v.effects_dict.items() if j.name != 'Dehydrate' and j.name != 'Fog'])>=2]
            dehy_tars = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn') and 'Dehydrate' not in [j.name for i,j in v.effects_dict.items()]]
            fog_tars = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn') and 'Fog' not in [j.name for i,j in v.effects_dict.items()]]
            # SUMMON ELEMENTALS
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # PURIFY (free action)
            elif purify_tars != [] and 'Purify' in self.get_actions().keys() and self.purify_used == False:
                target = choice(purify_tars)
                self.purify_used = True
                app.get_focus(target)
                root.after(666, lambda t = target : self.purify(t))
            # FOG
            elif fog_tars != [] and self.acts > 0 and 'Fog' in self.get_actions().keys():
                target = choice(fog_tars)
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.fog(t))
            # DEHYDRATE
            elif dehy_tars != [] and self.acts > 0 and 'Dehydrate' in self.get_actions().keys():
                target = choice(dehy_tars)
                self.acts -= 1
                app.get_focus(target)
                root.after(666, lambda t = target : self.dehydrate(t))
            # RANGED FLYING PURSUE
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.ranged_flying_pursue(self, self.get_abl('rsn'), 'spell')
            else:
                app.handle_action()
#########

    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Water Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Water Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Water_Elemental.png'))
                    ent = Water_Elemental(name = 'Water_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
        
    
                
    def dehydrate(self, id):
#         effect1 = mixer.Sound('Sound_Effects/dehydrate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Dehydrate', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Dehydrate', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
#             app.vis_dict['Dehydrate'] = Vis(name = 'Dehydrate', loc = self.loc[:])
        ids = [k for k,v in app.all_ents().items() if dist(ent.loc, v.loc) <= 2 and v.owner != self.owner]
        def cleanup_dehy(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def dehydrate_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.focus_square(ent.loc)
                name = 'Dehydrate' + str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Dehydrate', loc = ent.loc[:])
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis):
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Fire weakness', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Fire weakness', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
                    my_psy = self.get_abl('psyche')
                    tar_psy = ent.get_abl('psyche')
                    d = damage(my_psy, tar_psy)
                    lock(apply_damage, self, ent, -d, 'acid', 'Dehydrate', 'spell')
                    if id in app.all_ents().keys():
                        def dehy_wk(wks):
                            return wks+['fire']
                        p = partial(dehy_wk)
                        ent.weak_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.weak_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                        n = 'Dehydrate' + str(app.count)
                        ent.effects_dict[n] = Effect(name = 'Dehydrate', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                        root.after(222, lambda name = name : cleanup_dehy(name))
                        root.after(333, lambda ids = ids : dehydrate_loop(ids))
                    else:
                        root.after(222, lambda name = name : cleanup_dehy(name))
                        root.after(333, lambda ids = ids : dehydrate_loop(ids))
                else:
                    miss(ent.loc[:])
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda name = name : cleanup_dehy(name))
                    root.after(1999, lambda ids = ids : dehydrate_loop(ids))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda ids = ids : dehydrate_loop(ids))
            
            
# fog- -3 mvrng, 3 cold dmg aoe
    def fog(self, id):
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/fog.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Fog', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Fog', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
        def cleanup_fog(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        ids = [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) <= 2 and v.owner != self.owner]
        def fog_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.focus_square(ent.loc)
                name = 'Fog' + str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Fog', loc = ent.loc[:])
                my_wis = self.get_abl('wis')
                tar_wis = ent.get_abl('wis')
                if to_hit(my_wis, tar_wis):
                    if 'Fog' not in [v.name for k,v in ent.effects_dict.items()]:
                        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = '-3 move range', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = '-3 move range', font = ('chalkduster', 13), fill = 'cyan', tags = 'text')
                        def fog_effect(stat):
                            return max(0,stat-3)
                        p = partial(fog_effect)
                        ent.move_range_effects.append(p)
                        def undo(ent, p, lockname = None):
                            ent.move_range_effects.remove(p)
                            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        u = partial(undo, ent, p)
                        n = 'Fog' + str(app.count)
                        ent.effects_dict[n] = Effect(name = 'Fog', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    lock(apply_damage, self, ent, -3, 'cold', 'Fog', 'spell')
                    root.after(111, lambda t = 'text' : app.canvas.delete(t))
                    root.after(111, lambda name = name : cleanup_fog(name))
                    root.after(333, lambda ids = ids : fog_loop(ids))
                else:
                    miss(ent.loc[:])
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda name = name : cleanup_fog(name))
                    root.after(1999, lambda ids = ids : fog_loop(ids))
        root.after(1888, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, lambda ids = ids : fog_loop(ids))
                
# purify- any tar w at least 2 efcts that are not dehydrate, esuna like dispel atmpt all (wis)
    def purify(self, id):
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/purify.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Purify', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Purify', font = ('chalkduster', 16), fill = 'cyan', tags = 'text')
        def cleanup_purify():
            del app.vis_dict['Purify']
            app.canvas.delete('Purify')
        app.vis_dict['Purify'] = Vis(name = 'Purify', loc = ent.loc[:])
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Purify', font = ('chalkduster', 12), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Purify', font = ('chalkduster', 12), fill = 'cyan', tags = 'text')
        spacer = 30
        to_remove = []
        for k,v in ent.effects_dict.items():
            if v.name != 'Dehydrate' and v.name != 'Fog' and v.dispel(self.get_abl('wis')) == 'Dispelled':
                to_remove.append(k)
                if spacer > 300:
                    continue
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'cyan', tags = 'text')
                spacer += 15
        for k in to_remove:
            del ent.effects_dict[k]
        root.after(2333, cleanup_purify)
        root.after(2444, lambda t = 'text' : app.canvas.delete(t))
        root.after(2444, self.do_round)
                

# change to move in straight line, make ranged atk, die when running into obstacle (block, maybe ent)
class Water_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Surge':self.surge}
        self.str = 5
        self.agl = 8
        self.end = 6
        self.mm = 9
        self.msl = 4
        self.bls = 4
        self.dodge = 11
        self.psyche = 7
        self.wis = 7
        self.rsn = 4
        self.init = 13
        self.spirit = 7
        self.magick = 0
        self.san = 16
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['fire', 'crushing', 'explosive']
        self.weak = ['elec']
        self.direction = choice(['up','down','left','right'])
        super().__init__(name, img, loc, owner)
        
        
    # first try to attack, then try to move setting 'dissipating' to True if legal_moves() shorter than move_range (move obstructed)
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            # SURGE ATTACK
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Surge' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.surge(target)
            # MOVE
            elif self.mvs > 0:
                mvs = self.legal_moves()
                if mvs == []:
                    self.dissipate()
                else:
                    mv = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b , mvs)
                    app.focus_square(mv)
                    self.mvs -= 1
                    lock(Bot.ai_normal_move, self, mv)
                    if len(mvs) < self.get_abl('move_range'):
                        self.dissipate()
                    else:
                        self.do_round()
            else:
                app.handle_action()
        
    def surge(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/surge.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Surge'] = Vis(name = 'Surge', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Surge'].img, tags = 'Surge')
        selected_vis = ['Surge']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Surge')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Surge'].img, tags = 'Surge')
                app.canvas.tag_raise('Surge')
                # debug here, if within certain range...
            app.vis_dict['Surge'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Surge']
                app.canvas.delete('Surge')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Surge', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
    def dissipate(self):
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Water Elemental dissipates\n   into a puddle...', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Water Elemental dissipates\n   into a puddle...', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        name = 'dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(1222, lambda t = 'text' : app.canvas.delete(t))
        root.after(333, lambda id = self.id, name = name : app.kill(id, name))
        root.wait_variable(app.dethloks[name])
        app.handle_action()
            
            
    # get only squares in self.direction
    def legal_moves(self):
        s = self.loc[:]
        mvlist = []
        if self.direction == 'up':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0],s[1]-i] in app.coords and app.grid[s[0]][s[1]-i] == '':
                    mvlist.append([s[0],s[1]-i])
                else:
                    break
        elif self.direction == 'down':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0],s[1]+i] in app.coords and app.grid[s[0]][s[1]+i] == '':
                    mvlist.append([s[0],s[1]+i])
                else:
                    break
        elif self.direction == 'left':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0]-i,s[1]] in app.coords and app.grid[s[0]-i][s[1]] == '':
                    mvlist.append([s[0]-i,s[1]])
                else:
                    break
        elif self.direction == 'right':
            for i in range(1,self.get_abl('move_range')+1):
                if [s[0]+i,s[1]] in app.coords and app.grid[s[0]+i][s[1]] == '':
                    mvlist.append([s[0]+i,s[1]])
                else:
                    break
        return list(filter(lambda x : dist(x, self.loc) <= self.get_abl('move_range'), mvlist))
        
        
class Earth_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Earth Elementals':self.summon_elementals, 'Earthquake':self.earthquake}
        self.str = 6
        self.agl = 6
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 7
        self.psyche = 7
        self.wis = 7
        self.rsn = 3
        self.init = 5
        self.spirit = 58
        self.magick = 466
        self.san = 28
        self.acts = 1
        self.mvs = 1
        self.move_range = 4
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['slashing', 'piercing', 'crushing', 'elec']
        self.weak = ['cold', 'explosive', 'acid']
        super().__init__(name, img, loc, owner)
        
    # OVERRIDE BASE METHOD, +1 for each alive elemental
    def get_abl(self, abl):
        # clean proximity effects from ents destroyed
        to_remove = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.ent.id not in app.all_ents().keys():
                to_remove.append(k)
        for key in to_remove:
            del app.proximity_effects_dict[key]
        # get all prox efcts of same abl
        prox_efcts = []
        for k,ef in app.proximity_effects_dict.items():
            if ef.abl == abl and self.loc in ef.get_locs():
                prox_efcts.append(ef.abl_func)
        # Earth elementals alive bonus
        elems = [k for k,v in app.ent_dict.items() if v.name == 'Earth_Elemental']
        bonus = len(elems)
        if abl == 'str':
            q = self.str_effects + prox_efcts + app.loc_dict[tuple(self.loc)].str_effects
            base = self.str+bonus
        elif abl == 'agl':
            q = self.agl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].agl_effects
            base = self.agl+bonus
        elif abl == 'end':
            q = self.end_effects + prox_efcts + app.loc_dict[tuple(self.loc)].end_effects
            base = self.end+bonus
        elif abl == 'mm':
            q = self.mm_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mm_effects
            base = self.mm
        elif abl == 'msl':
            q = self.msl_effects + prox_efcts + app.loc_dict[tuple(self.loc)].msl_effects
            base = self.msl
        elif abl == 'bls':
            q = self.bls_effects + prox_efcts + app.loc_dict[tuple(self.loc)].bls_effects
            base = self.bls
        elif abl == 'dodge':
            q = self.dodge_effects + prox_efcts + app.loc_dict[tuple(self.loc)].dodge_effects
            base = self.dodge+bonus
        elif abl == 'psyche':
            q = self.psyche_effects + prox_efcts + app.loc_dict[tuple(self.loc)].psyche_effects
            base = self.psyche+bonus
        elif abl == 'wis':
            q = self.wis_effects + prox_efcts + app.loc_dict[tuple(self.loc)].wis_effects
            base = self.wis+bonus
        elif abl == 'rsn':
            q = self.rsn_effects + prox_efcts + app.loc_dict[tuple(self.loc)].rsn_effects
            base = self.rsn+bonus
        elif abl == 'init':
            q = self.init_effects + prox_efcts + app.loc_dict[tuple(self.loc)].init_effects
            base = self.init+bonus
        elif abl == 'san':
            q = self.san_effects + prox_efcts + app.loc_dict[tuple(self.loc)].san_effects
            base = self.san+bonus
        elif abl == 'acts':
            q = self.acts_effects + prox_efcts + app.loc_dict[tuple(self.loc)].acts_effects
            base = self.base_acts
        elif abl == 'mvs':
            q = self.mvs_effects + prox_efcts + app.loc_dict[tuple(self.loc)].mvs_effects
            base = self.base_mvs
#         elif abl == 'cantrips':
#             q = self.cantrips_effects + app.loc_dict[tuple(self.loc)].cantrips_effects
#             base = self.base_cantrips
        elif abl == 'smns':
            q = self.smns_effects + prox_efcts + app.loc_dict[tuple(self.loc)].smns_effects
            base = self.base_smns
        elif abl == 'move_range':
            q = self.move_range_effects + prox_efcts + app.loc_dict[tuple(self.loc)].move_range_effects
            base = self.move_range+bonus
        for func in q:
            base = func(base)
        return base
            
    # summon elems once
    # use earthquake
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # goals are any w enemy ent wi rng rsn reduced to maximally close to all enemy, if none then move towards the max close
            elif self.mvs > 0 and self.legal_moves() != [] and [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != []:
                gs = unique([c for c in app.coords for k,v in app.action_target_ents().items() if v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(v.loc,c)<=self.get_abl('rsn')])
                if gs == []:
                    # get empty sqr that is closest to as many enemy ents as possible
                    g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b , [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                else:
                    mvs = intersect(gs,self.legal_moves())
                    if mvs == []:# no goals wi rng, move towards best g
                        g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, gs)
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                    else:# some g in rng, get best g in mvs
                        mv = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, mvs)
                # move to mv
                app.get_focus(self.id)
                root.after(999, lambda s = mv[:] : app.focus_square(s))
                self.mvs -= 1
                lock(Bot.ai_teleport_move, self, mv)
                root.after(333, self.do_round)
            # do earthquake
            elif self.acts > 0 and self.magick > 9:
                self.magick -= 9
                self.acts -= 1
                self.earthquake()
            else:
                app.handle_action()
            
            
    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Earth Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Earth Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Earth_Elemental.png'))
                    ent = Earth_Elemental(name = 'Earth_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
            
            
    
    # earthquake, dmg near ents (non-flying/ethereal) and move them 'back'
    def earthquake(self):
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/earthquake.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('rsn')]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Earthquake', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Earthquake', font = ('chalkduster', 16), fill = 'orange4', tags = 'text')
        app.vis_dict['Earthquake'] = Vis(name = 'Earthquake', loc = self.loc[:])
        def cleanup_equake():
            del app.vis_dict['Earthquake']
            app.canvas.delete('Earthquake')
        root.after(2666, cleanup_equake)
        # get all ents in vicinity
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.get_move_type() != 'flying' and v.get_move_type() != 'ethereal' and v.immovable != True and v != self and v.name != 'Earth_Elemental']
        def earthquake_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                loc = ent.loc[:]
                my_psyche = self.get_abl('psyche')
                target_agl = ent.get_abl('agl')
                d = damage(my_psyche, target_agl)
                lock(apply_damage, self, ent, -d, 'crushing', 'Earthquake', 'spell')
                if id not in app.all_ents().keys():
                    earthquake_loop(ids)
                else: # ENT NOT KILLED, move it 'away' from caster
                    sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('rsn') and app.grid[c[0]][c[1]] == '' and dist(c,ent.loc)<=4]
                    if sqrs == []:
                        earthquake_loop(ids)
                    else:
                        # change to: sqr must be some dist from ent itself...
                        sqr = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, sqrs)
                        app.focus_square(sqr)
                        lock(ent.throw_move, sqr)
                        earthquake_loop(ids)
        root.after(1666, lambda t = 'text' : app.canvas.delete(t))
        root.after(1777, lambda ids = ids : earthquake_loop(ids))
            
            
class Earth_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Rock Punch':self.rock_punch}
        self.str = 16
        self.agl = 7
        self.end = 13
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 4
        self.psyche = 4
        self.wis = 4
        self.rsn = 3
        self.init = 3
        self.spirit = 23
        self.magick = 0
        self.san = 23
        self.acts = 1
        self.mvs = 1
        self.move_range = 7
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['slashing', 'piercing', 'crushing', 'elec']
        self.weak = ['cold', 'acid', 'fire', 'explosive']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Rock Punch' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.rock_punch(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
#                 Ai_man.melee_pursue(self, 'action') # PURSUE UNTIL NO MVS OR ADJ ENEMY
            else:
                app.handle_action()

        
    def rock_punch(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        ent = app.ent_dict[id]
#         effect1 = mixer.Sound('Sound_Effects/rock_punch.ogg')
#         sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):# HIT
            my_str = self.get_abl('str')
            tar_end = ent.get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Rock Punch', 'melee')
            self.do_round()
        else:# MISS
            miss(ent.loc[:])
            root.after(1666, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, self.do_round)
                
        
        
# casts firewall after teleporting randomly within a dist, resummons fire elementals if they all die
# immune to move_effects, does not use legal_moves
class Fire_Mage(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Summon Fire Elementals':self.summon_elementals, 'Firewall':self.firewall, 'Sirocco':self.sirocco}
        self.str = 7
        self.agl = 8
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 12
        self.psyche = 13
        self.wis = 13
        self.rsn = 6
        self.init = 7
        self.spirit = 66
        self.magick = 566
        self.san = 21
        self.acts = 1
        self.mvs = 1
        self.move_range = 7
        self.summoned_elementals = False
        self.waiting = waiting
        self.move_type = 'teleport'
        self.resist = ['elec', 'fire', 'poison', 'acid', 'magick']
        self.weak = ['cold']
        super().__init__(name, img, loc, owner)
        
            
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.summoned_elementals == False:
                self.summoned_elementals = True
                root.after(333, self.summon_elementals)
            # goals are any w enemy ent wi rng rsn reduced to maximally close to all enemy, if none then move towards the max close
            elif self.mvs > 0 and self.legal_moves() != [] and [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != []:
                gs = unique([c for c in app.coords for k,v in app.action_target_ents().items() if v.owner != self.owner and app.grid[c[0]][c[1]] == '' and dist(v.loc,c)<=self.get_abl('rsn')])
                if gs == []:
                    # get empty sqr that is closest to as many enemy ents as possible
                    g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b , [c for c in app.coords if app.grid[c[0]][c[1]] == ''])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                else:
                    mvs = intersect(gs,self.legal_moves())
                    if mvs == []:# no goals wi rng, move towards best g
                        g = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, gs)
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, self.legal_moves())
                    else:# some g in rng, get best g in mvs
                        mv = reduce(lambda a,b : a if sum([dist(a,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) < sum([dist(b,j.loc) for i,j in app.action_target_ents().items() if j.owner != self.owner]) else b, mvs)
                # move to mv
                app.get_focus(self.id)
                root.after(999, lambda s = mv[:] : app.focus_square(s))
                self.mvs -= 1
                lock(Bot.ai_teleport_move, self, mv)
                root.after(333, self.do_round)
            # do firewall
            elif self.acts > 0 and self.magick > 9:
                self.magick -= 9
                self.acts -= 1
                self.firewall()
            else:
                app.handle_action()
            
            
    def summon_elementals(self):
        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
        if len(empty) >= 3:
            s1 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s1)
            s2 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s2)
            s3 = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, empty)
            empty.remove(s3)
            def summon_loop(locs):
                if locs == []:
                    self.do_round()
                else:
                    loc = locs[0]
                    locs = locs[1:]
                    app.focus_square(loc)
                    app.vis_dict['Summon_Skeleton'] = Vis(name = 'Summon_Skeleton', loc = loc[:])
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Summon_Skeleton'].img, tags = 'Summon_Skeleton')
                    def cleanup_vis():
                        del app.vis_dict['Summon_Skeleton']
                        app.canvas.delete('Summon_Skeleton')
                    root.after(1888, cleanup_vis)
                    app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+89-app.moved_down, text = 'Summon Fire Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+90-app.moved_down, text = 'Summon Fire Elemental', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Fire_Elemental.png'))
                    ent = Fire_Elemental(name = 'Fire_Elemental', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                    app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = ent.img, tags = ent.tags)
                    root.after(1888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1999, lambda locs = locs : summon_loop(locs))
            summon_loop([s1,s2,s3])
        else:
            self.do_round()
            
            
    def sirocco(self, id):
        pass
            
    def firewall(self):
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/firewall.ogg')
        effect1.set_volume(.7)
        sound_effects.play(effect1, 0)
        sqrs = []
        for c in app.coords:
            if c[0] == self.loc[0] and abs(c[1] - self.loc[1]) <= self.get_abl('rsn'):
                sqrs.append(c)
            elif abs(c[0] - self.loc[0]) <= self.get_abl('rsn') and c[1] == self.loc[1]:
                sqrs.append(c)
        sqrs.remove(self.loc)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Firewall', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Firewall', font = ('chalkduster', 16), fill = 'firebrick', tags = 'text')
        names = []
        for s in sqrs:
            u_name = 'Firewall' + str(app.count)
            app.count += 1
            app.vis_dict[u_name] = Vis(name = 'Firewall', loc = s[:])
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u_name].img, tags = 'Firewall')
            names.append(u_name)
        # get all ents in paths
        ents = [k for k,v in app.all_ents().items() if v.name != 'Fire_Elemental' and v.loc in sqrs]
        if ents != []:
            # check for dmg and create text object
            def firewall_loop(ents):
                if ents == []:
                    self.cleanup_firewall(names)
                else:
                    app.canvas.delete('text')
                    id = ents[0]
                    ents = ents[1:]
                    app.get_focus(id)
                    my_psyche = self.get_abl('psyche')
                    target_psy = app.ent_dict[id].get_abl('psyche')
                    d = damage(my_psyche, target_psy)
                    lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Firewall', 'spell')
                    firewall_loop(ents)
            root.after(1666, lambda e = ents : firewall_loop(e))
        else: # cleanup vis / cont ai_loop
            root.after(1999, lambda names = names : self.cleanup_firewall(names))
            
        
    def cleanup_firewall(self, names):
        for n in names:
            del app.vis_dict[n]
            app.canvas.delete(n)
        app.canvas.delete('text')
        self.do_round()
        
class Sorceress(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Fireblast':self.fireblast, 'Teleport':self.teleport, 'Charged Bolt':self.charged_bolt, 'Staff of Vecna':self.staff_of_vecna}
        self.str = 4
        self.agl = 12
        self.end = 8
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 12
        self.psyche = 12
        self.wis = 15
        self.rsn = 7
        self.init = 6
        self.spirit = 46
        self.magick = 366
        self.san = 18
        self.acts = 2
        self.mvs = 1
        self.move_range = 5
        self.waiting = waiting
        self.move_type = 'teleport'
        self.teleport_used = False
        self.resist = ['magick', 'fire', 'elec']
        self.weak = []
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            # try free teleport other
            if self.teleport_used == False:
                self.teleport_used = True
                ents = [v for k,v in app.all_ents().items() if dist(self.loc,v.loc) <= self.get_abl('rsn') and v.owner == self.owner and v != self]
                if ents == []:
                    self.do_round()
                else:
                    app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Teleport', font = ('chalkduster', 16), fill = 'black', tags = 'text')
                    app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Teleport', font = ('chalkduster', 16), fill = 'cyan2', tags = 'text')
                    # grab ent who is maximally dist from all enemy ents
                    ent = reduce(lambda a,b : a if sum([dist(a.loc,v.loc) for k,v in app.all_ents().items() if v.owner != a.owner])>sum([dist(b.loc,v.loc) for k,v in app.all_ents().items() if v.owner != b.owner]) else b, ents)
                    # move it among the locs wi range rsn that puts it minimally distant to any enemy ent
                    cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(self.loc,c)<=self.get_abl('rsn')]
                    c = reduce(lambda a,b : a if sum([dist(v.loc,a) for k,v in app.all_ents().items() if v.owner != self.owner])<sum([dist(v.loc,b) for k,v in app.all_ents().items() if v.owner != self.owner]) else b, cs)
                    app.focus_square(c)
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    lock(Bot.ai_teleport_move, ent, c)
                    root.after(333, self.do_round)
            # use fireblast or charged bolt on any spell target wi range
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')] != [] and self.acts > 0 and self.magick >= 4:
                self.magick -= 4
                ents = [k for k,v in app.spell_target_ents().items() if v.owner != self.owner and dist(v.loc,self.loc)<=self.get_abl('rsn')]
                id = choice(ents)
                self.acts -= 1
                app.get_focus(self.id)
                root.after(999, lambda id = id : app.get_focus(id))
                if choice([0,1]):
                    root.after(999, lambda id = id : self.fireblast(id))
                else:
                    root.after(999, lambda id = id : self.charged_bolt(id))
            # FREE DISPEL PSYSHIELD WI RANGE STAFF OF VECNA
            elif [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()] != []:
                target = choice([k for k,v in app.all_ents().items() if dist(v.loc, self.loc) <= self.get_abl('rsn') and v.owner != self.owner and 'psyshield' in v.get_types()])
                app.get_focus(target)
                root.after(666, lambda t = target : self.staff_of_vecna(t))
            # ranged pursue
            elif [k for k,v in app.spell_target_ents().items() if v.owner != self.owner] and self.mvs > 0 and self.legal_moves() != []:
                app.get_focus(self.id)
                Ai_man.pursue(self, 'spell', 'smart', self.get_move_type(), self.get_abl('rsn'))
            else:
                app.handle_action()

    def staff_of_vecna(self, id):
        app.get_focus(id)
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/staff_of_vecna.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        ent = app.ent_dict[id]
        def cleanup_staff():
            del app.vis_dict['Staff_of_Vecna']
            app.canvas.delete('Staff_of_Vecna')
        visloc = ent.loc[:]
        app.vis_dict['Staff_of_Vecna'] = Vis(name = 'Staff_of_Vecna', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Staff_of_Vecna'].img, tags = 'Staff_of_Vecna')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+89-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+90-app.moved_down, text = 'Staff of Vecna', font = ('chalkduster', 16), fill = 'magenta2', tags = 'text')
        def staff_ef(ts):
            return [t for t in ts if t != 'psyshield']
        p = partial(staff_ef)
        ent.type_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Staff_of_Vecna' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Staff_of_Vecna', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', font = ('chalkduster', 13), fill = 'magenta2', tags = 'text')
        root.after(1999, lambda t = 'text' : app.canvas.delete(t))
        root.after(1999, cleanup_staff)
        root.after(2111, self.do_round)
    
    def fireblast(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Fireblast'] = Vis(name = 'Fireblast', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
        selected_vis = ['Fireblast']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Fireblast')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Fireblast'].img, tags = 'Fireblast')
                app.canvas.tag_raise('Fireblast')
            app.vis_dict['Fireblast'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_fireblast(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_fireblast(self, id):
        ent = app.ent_dict[id]
        loc = ent.loc[:]
        my_wis = self.get_abl('wis')
        target_wis = ent.get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Fireblast']
                app.canvas.delete('Fireblast')
            except: pass
        if to_hit(my_wis, target_wis):
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            if 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                loc = ent.loc[:]
                app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+54, text = 'Burned...', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
                app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+55, text = 'Burned...', justify = 'center', fill = 'firebrick1', font = ('chalkduster', 14), tags = 'text')
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and (st == 'melee' or st == 'ranged' or st == 'spell'):
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'firebrick1', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                p = partial(burn_effect)
                def undo(ent, p, lockname = None):
                    ent.defense_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, ent, p)
                n = 'Burn'+str(app.count)
                app.count += 1
            d = damage(my_psy, tar_psy)
            root.after(1999, cleanup_fireball)
            lock(apply_damage, self, ent, -d, 'fire', 'Fireblast', 'spell')
            if id in app.all_ents().keys() and 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                ent.defense_effects.append(p)
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
            
            
    def charged_bolt(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Charged_Bolt'] = Vis(name = 'Charged_Bolt', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
        selected_vis = ['Charged_Bolt']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Charged_Bolt')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Charged_Bolt'].img, tags = 'Charged_Bolt')
                app.canvas.tag_raise('Charged_Bolt')
            app.vis_dict['Charged_Bolt'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(333, lambda id = id : self.continue_charged_bolt(id))
            else:
                root.after(40, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_charged_bolt(self, id):
        loc = app.ent_dict[id].loc[:]
        my_wis = self.get_abl('wis')
        target_wis = app.ent_dict[id].get_abl('wis')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Charged_Bolt']
                app.canvas.delete('Charged_Bolt')
            except: pass
        if to_hit(my_wis, target_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = app.ent_dict[id].get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Charged Bolt', 'spell')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)

    # here just for purposes of occupying action dict, teleport action handled in do_round
    def teleport(self):
        pass
        
        
        
class Orc_Axeman(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Chop':self.melee_attack}
        self.str = 11
        self.agl = 7
        self.end = 6
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 4
        self.wis = 4
        self.rsn = 3
        self.init = 6
        self.spirit = 29
        self.magick = 0
        self.san = 11
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'normal'
        self.resist = ['crushing', 'fire', 'poison']
        self.weak = ['magick']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner] and 'Chop' in self.get_actions().keys():
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) == 1 and v.owner != self.owner])
                self.acts -= 1
                self.melee_attack(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), 1)
            else:
                app.handle_action()

    def pass_priority(self):
        app.handle_action()
        
    # abstract this func into Ai_man, change to accept needed abl scores and apply_damage args
    def melee_attack(self, id):
#         self.init_attack_anims()
        app.get_focus(id)
        effect1 = mixer.Sound('Sound_Effects/orc_axeman_attack.ogg')
        sound_effects.play(effect1, 0)
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:# HIT
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            root.after(1666, self.init_normal_anims)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Chop', 'melee')
            self.finish_attack()
        else:# MISS
            loc = app.ent_dict[id].loc[:]
            miss(loc)
            root.after(1333, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, self.finish_attack)
                
    def finish_attack(self):
        self.init_normal_anims()
        try: app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
class Fire_Elemental(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Flare':self.flare}
        self.str = 5
        self.agl = 8
        self.end = 6
        self.mm = 8
        self.msl = 7
        self.bls = 4
        self.dodge = 8
        self.psyche = 8
        self.wis = 4
        self.rsn = 4
        self.init = 7
        self.spirit = 17
        self.magick = 0
        self.san = 11
        self.acts = 2
        self.mvs = 2
        self.move_range = 4
        self.waiting = waiting
        self.move_type = 'flying'
        self.resist = ['elec', 'fire', 'poison', 'acid', 'magick']
        self.weak = ['cold', 'explosive']
        super().__init__(name, img, loc, owner)
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            if self.acts > 0 and [k for k,v in app.action_target_ents().items() if dist(v.loc, self.loc) <= self.get_abl('bls') and v.owner != self.owner] and 'Flare' in self.actions.keys():
                self.acts -= 1
                target = choice([k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc) <= self.get_abl('bls') and v.owner != self.owner])
                self.flare(target)
            elif [k for k,v in app.action_target_ents().items() if v.owner != self.owner] != [] and self.mvs > 0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'smart', self.get_move_type(), self.get_abl('bls'))
            else:
                app.handle_action()
        
                
            
    def flare(self, id):
        global selected_vis
        app.get_focus(id)
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flare.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        loc = app.ent_dict[id].loc[:]
        app.vis_dict['Flare'] = Vis(name = 'Flare', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Flare'].img, tags = 'Flare')
        selected_vis = ['Flare']
        def fireball_loop(startx, endx, starty, endy, xstep, ystep):
            if starty > endy:
                starty -= ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif starty < endy:
                starty += ystep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            if startx > endx:
                startx -= xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
            elif startx < endx:
                startx += xstep
                app.canvas.delete('Flare')
                app.canvas.create_image(startx, starty, image = app.vis_dict['Flare'].img, tags = 'Flare')
                app.canvas.tag_raise('Flare')
                # debug here, if within certain range...
            app.vis_dict['Flare'].rotate_image()
            if abs(starty - endy) < 13 and abs(startx - endx) < 13:
                root.after(111, lambda id = id : self.continue_ranged_attack(id))
            else:
                root.after(25, lambda sx = startx, ex = endx, sy = starty, ey = endy, xs = xstep, ys = ystep  : fireball_loop(sx, ex, sy, ey, xs, ys))
        startx = self.loc[0]*100+50-app.moved_right
        starty = self.loc[1]*100+50-app.moved_down
        endx = loc[0]*100+50-app.moved_right
        endy = loc[1]*100+50-app.moved_down
        if startx == endx:
            xstep = 0
            ystep = 10
        elif starty == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(startx - endx), abs(starty - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        fireball_loop(startx, endx, starty, endy, xstep, ystep)
            
    def continue_ranged_attack(self, id):
        loc = app.ent_dict[id].loc[:]
        my_mm = self.get_abl('mm')
        target_dod = app.ent_dict[id].get_abl('dodge')
        def cleanup_fireball():
            global selected_vis
            selected_vis = []
            self.init_normal_anims()
            try: 
                del app.vis_dict['Flare']
                app.canvas.delete('Flare')
            except: pass
        if to_hit(my_mm, target_dod) == True:
            my_msl = self.get_abl('msl')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_msl, tar_end)
            root.after(666, cleanup_fireball)
            lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Flare', 'ranged')
            root.after(666, self.do_round)
        else:# MISS
            miss(loc)
            root.after(666, cleanup_fireball)
            root.after(888, lambda t = 'text' : app.canvas.delete(t))
            root.after(999, self.do_round)
        
        
        
class Barbarian(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Frenzy':self.frenzy, 'Shout':self.shout, 'Leap':self.leap}
        self.str = 11
        self.agl = 14
        self.end = 12
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 6
        self.psyche = 4
        self.wis = 4
        self.rsn = 4
        self.init = 9
        self.spirit = 113
        self.magick = 0
        self.san = 14
        self.acts = 2
        self.mvs = 1
        self.move_range = 4
        self.leap_used = False
        self.waiting = waiting
        self.move_type = 'charge'
        self.resist = ['slashing', 'piercing', 'crushing', 'cold', 'elec', 'fire', 'poison']
        self.weak = ['magick']
        self.leap_anims = {}
        anims = [a for r,d,a in walk('./animations/Barbarian_Leap/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Barbarian_Leap/' + anim))
            self.leap_anims[i] = a
        super().__init__(name, img, loc, owner)

        
    def init_leap_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.leap_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
    def do_round(self):
        if self.waiting == True:
            app.handle_action()
        else:
            # MOVE charge move towards goal
            if self.mvs>0 and self.legal_moves() != []:
                Ai_man.pursue(self, 'action', 'dumb', self.get_move_type(), 1)
            # LEAP to move towards best goal
            elif self.leap_used == False and self.leap_moves() != [] and 'Leap' in self.get_actions().keys():
                self.leap_used = True
                # leap to sqr that has most adj, non-invis enemy ents
                goals = unique([c for c in app.coords for k,v in app.action_target_ents().items() if app.grid[c[0]][c[1]] == '' and dist(v.loc,c)==1 and v.owner != self.owner])
                if intersect(goals,self.leap_moves())==[]:# no goals in range or no goals, leap closest to an enemy ent
                    mvs = self.leap_moves()
                    g = reduce(lambda a,b : a if dist(a,self.loc)<dist(b,self.loc) else b, [v.loc for k,v in app.action_target_ents().items() if v.owner != self.owner])
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, mvs)
                    app.focus_square(mv)
                    root.after(999, lambda mv = mv : self.leap(mv))
                else: # can leap to a goal, find best goal in leap moves
                    goal = reduce(lambda a,b : a if len([c for c in app.coords if dist(c,a)==1 and app.grid[c[0]][c[1]] in app.action_target_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner])>len([c for c in app.coords if dist(c,b)==1 and app.grid[c[0]][c[1]] in app.action_target_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]) else b, [g for g in goals if dist(g,self.loc)<=self.get_abl('move_range')])
                    app.focus_square(goal)
                    root.after(999, lambda g = goal[:] : self.leap(g))
            # FRENZY if any adj enemy, also hit frndly, ww hits invis altho barbarian does not pursue invis
            elif self.acts > 0 and 'Frenzy' in self.get_actions().keys() and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc)==1 and v.owner != self.owner]:
                self.acts -= 1
                self.frenzy()
            # SHOUT, -1 sanity all enemy range rsn
            elif 'Shout' in self.get_actions().keys() and self.acts>0 and [k for k,v in app.action_target_ents().items() if dist(v.loc,self.loc)<=self.get_abl('str') and v.owner != self.owner] != []:
                self.acts -= 1
                self.shout()
            else:
                app.handle_action()
                
                
        
    def leap_moves(self):
        cs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c,self.loc)<=self.get_abl('move_range')]
        return cs
        
    def leap(self, sqr):
        global selected
        self.init_leap_anims()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected = [self.id]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda es = end_sqr, ss = start_sqr : self.finish_leap(es, ss)) # EXIT
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_leap(self, end_sqr, start_sqr):
        global selected
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        root.after(666, self.do_round)
        
    
    def shout(self):
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)<=self.get_abl('rsn') and v.owner != self.owner]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Shout', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Shout', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        def cleanup_shout(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def shout_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                un = 'Shout'+str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Shout', loc = ent.loc[:])
                my_str = self.get_abl('str')
                target_psy = ent.get_abl('psyche')
                if to_hit(my_str, target_psy):
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = '-2 sanity', justify = 'center', fill = 'black', font = ('chalkduster', 15), tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = '-2 sanity', justify = 'center', fill = 'indianred', font = ('chalkduster', 15), tags = 'text')
                    def shout_effect(stat):
                        return max(1,stat-2)
                    p = partial(shout_effect)
                    ent.san_effects.append(p)
                    def undo(ent, p, lockname = None):
                        ent.san_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    n = 'Shout' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Shout', undo_func = u, duration = self.get_abl('str'), level = self.get_abl('str'))
                    root.after(1555, lambda un = un : cleanup_shout(un))
                    root.after(1666, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1777, lambda ids = ids : shout_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda un = un : cleanup_shout(un))
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : shout_loop(ids))
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        root.after(1666, lambda ids = ids : shout_loop(ids))


        
    def frenzy(self):
        ids = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc)==1]
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Frenzy', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Frenzy', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        def cleanup_ww(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def ww_loop(ids):
            if ids == []:
                self.do_round()
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                sqr = ent.loc[:]
                un = 'Frenzy'+str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Frenzy', loc = sqr[:])
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                root.after(1999, lambda un = un : cleanup_ww(un))
                my_agl = self.get_abl('agl')
                target_agl = ent.get_abl('agl')
                if to_hit(my_agl, target_agl):
                    my_str = self.get_abl('str')
                    target_end = ent.get_abl('end')
                    d = damage(my_str, target_end)
                    lock(apply_damage, self, ent, -d, 'slashing', 'Frenzy', 'melee')
                    ww_loop(ids)
                else:
                    miss(sqr)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : ww_loop(ids))
        root.after(999, lambda ids = ids : ww_loop(ids))
        
        
    # if no ent within immediate move/attack range, only move toward witch
class Minotaur_Top(Bot):
    def __init__(self, name, img, loc, owner, id, waiting = False):
        self.id = id
        self.actions = {}
        self.str = 14
        self.agl = 9
        self.end = 11
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.init = 8
        self.spirit = 666
        self.magick = 0
        self.san = 19
        self.acts = 2
        self.mvs = 2
        self.move_range = 5
        self.waiting = waiting
        self.resist = ['crushing', 'piercing', 'magick']
        self.weak = []
        super().__init__(name, img, loc, owner, type = 'large')
        self.move_type = 'normal'
        self.immovable = True
        
    def init_stomp_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Stomp_Top/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Stomp_Top/' + anim))
            self.anim_dict[i] = a
            
    def init_move_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Move_Top/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Move_Top/' + anim))
            self.anim_dict[i] = a
            
    # 'tall' ent, bigger than 100 pixels height, needs to be split into 2 images so the 'top' image is 'large' (raised above 'maptop', bottom part of ent is hidden behind 'maptop'
class Minotaur(Bot):
    def __init__(self, name, img, loc, owner, waiting = False):
        self.actions = {'Charge':self.charge, 'Stomp':self.stomp, 'Pound':self.pound}
        self.str = 14
        self.agl = 9
        self.end = 11
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 8
        self.wis = 8
        self.rsn = 5
        self.init = 8
        self.spirit = 666
        self.magick = 0
        self.san = 19
        self.acts = 2
        self.mvs = 2
        self.move_range = 5
        self.waiting = waiting
        self.resist = ['crushing', 'piercing', 'magick']
        self.weak = []
        self.move_type = 'normal'
        super().__init__(name, img, loc, owner, type = 'large_bottom')
        self.immovable = True
        # create top half
        img = ImageTk.PhotoImage(Image.open('animations/Minotaur_Top/0.png'))
        app.ent_dict[self.id+'top'] = Minotaur_Top(name = 'Minotaur_Top', img = img, loc = [self.loc[0],self.loc[1]], owner = 'p2', id = self.id+'top')
        
    def large_undo(self):
        app.canvas.delete(self.id+'top')
        del app.ent_dict[self.id+'top']
        
    def init_stomp_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Stomp_Bot/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Stomp_Bot/' + anim))
            self.anim_dict[i] = a
            
    def init_move_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        anims = [a for r,d,a in walk('./animations/Minotaur_Move_Bot/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Minotaur_Move_Bot/' + anim))
            self.anim_dict[i] = a
        
    # takes 2 locs that share 1 axis, returns True if all sqrs between are empty ('')
    def clear_path(self, myloc, enloc):
        if myloc[0] == enloc[0]:
            def check_loop(start, end):
                if start[0] > end[0]:
                    x = start[0] - 1
                    start = [x,start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
                elif start[0] < end[0]:
                    x = start[0] + 1
                    start = [x,start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
            return check_loop(myloc[:], enloc[:])
        elif myloc[1] == enloc[1]:
            def check_loop(start, end):
                if start[0] > end[0]:
                    x = start[0] - 1
                    start = [x, start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
                elif start[0] < end[0]:
                    x = start[0] + 1
                    start = [x, start[1]]
                    if start == end:
                        return True
                    elif app.grid[start[0]][start[1]] != '':
                        return False
                    else:
                        return check_loop(start, end)
            return check_loop(myloc[:], enloc[:])
        else:
            return False
            
    def charge(self, id):
        global selected
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_charge_attack.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, -1)
        self.init_move_anims()
        app.ent_dict[self.id+'top'].init_move_anims()
        selected = [self.id, self.id+'top']
        start_sqr = self.loc[:]
        goals = [c for c in app.coords if dist(c, ent.loc) == 1]
        path = bfs(start_sqr, goals, app.grid)
        end_sqr = path[-1]
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(x, y, endx, endy, start_sqr, end_sqr, path, acm, speed):
            if speed > 15:
                speed -= 1
            acm += 10
            if acm >= 40:
                app.ent_dict[self.id+'top'].rotate_image()
                self.rotate_image()
                acm = 0
            if x > endx:
                x -= 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if x < endx: 
                x += 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if y > endy: 
                y -= 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            if y < endy: 
                y += 10
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(self.id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[self.id+'top'].img, tags = (self.id+'top','large'))
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.finish_charge(end_sqr, start_sqr, id)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(x, y, endx, endy, start_sqr, end_sqr, path, acm, speed)
            else: # CONTINUE LOOP
                root.after(speed, lambda x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path, acm = acm, spd = speed : move_loop(x, y, ex, ey, s, s2, p, acm, spd))
        move_loop(x, y, endx, endy, start_sqr, end_sqr, path, 0, 60)
        
    def finish_charge(self, end_sqr, start_sqr, id):
        global selected
        sound_effects.stop()
        self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        app.ent_dict[self.id+'top'].loc = [end_sqr[0],end_sqr[1]]
        root.after(666, lambda id = id : app.get_focus(id))
        root.after(1333, lambda id = id : self.charge_hit(id)) # EXIT THROUGH ATTACK
        
    def charge_hit(self, id):
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_attack.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.get_focus(id)
        app.ent_dict[self.id+'top'].init_attack_anims()
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl): # HIT
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Charge', 'melee')
            root.after(666, lambda id = id : self.cleanup_charge(id)) # EXIT THROUGH CLEANUP_ATTACK()
        else: # MISS
            miss(ent.loc)
            root.after(1999, lambda t = 'text' : app.canvas.delete(t))
            root.after(2111, lambda id = id : self.cleanup_charge(id))
            
    def cleanup_charge(self, id):
        app.ent_dict[self.id+'top'].init_normal_anims()
        app.canvas.delete('text')
        self.do_round()
        
        
    #  Minotaur AI
    # if no other enemy is within atk range, will always attempt moving towards witch
    def do_round(self):
        if self.waiting == True:
            self.pass_priority(ents_list)
        else:
            w = app.ent_dict[app.p1_witch]
            charge_ents = [k for k,v in app.all_ents().items() if self.get_abl('move_range') <= dist(v.loc, self.loc) <= self.get_abl('move_range')*2 and (v.loc[0] == self.loc[0] or v.loc[1] == self.loc[1]) and self.clear_path(self.loc[:], v.loc[:]) == True and v.owner != self.owner]
            # IF CAN CHARGE WITCH
            if self.get_abl('move_range') <= dist(w.loc, self.loc) <= self.get_abl('move_range')*2 and (w.loc[0] == self.loc[0] or w.loc[1] == self.loc[1]) and self.clear_path(self.loc[:], w.loc[:]) and self.acts > 0:
                self.acts -= 1
                app.get_focus(w.id)
                root.after(666, lambda id = w.id : self.charge(id)) # CHARGE WITCH
            # CHARGE NON-WITCH
            elif charge_ents != [] and self.acts > 0:
                self.acts -= 1
                id = choice(charge_ents)
                app.get_focus(id)
                root.after(666, lambda id = id : self.charge(id))# CHARGE ANY
            # ATTEMPT POUND ATTACK ADJ
            elif self.acts > 0 and [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner]:
                adj_ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) == 1 and v.owner != self.owner]
                self.acts -= 1
                id = choice(adj_ents)
                app.get_focus(id)
                root.after(666, lambda id = id : self.pound(id))
            # MOVE ADJ TO AN ENT WI MOVE RANGE
            elif intersect(self.legal_moves(), [c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c, v.loc) == 1 and app.grid[c[0]][c[1]] == '']) != [] and self.mvs > 0:
                goals = [c for c in app.coords for k,v in app.all_ents().items() if v.owner != self.owner and dist(c, v.loc) == 1 and app.grid[c[0]][c[1]] == '']
                path = bfs(self.loc[:], goals, app.grid)
                self.mvs -= 1
                app.focus_square(path[-1])
                root.after(666, lambda s = path[-1] : self.minotaur_move(s))
            elif self.mvs > 0: # OTHERWISE PURSUE WITCH
                # if no path on grid, use egrid, then stomp
                goals = [c for c in app.coords if dist(c, w.loc) == 1 and app.grid[c[0]][c[1]] != 'block'] # doesn't matter if they are occupied here
                path = bfs(self.loc[:], goals, app.grid)
                if path == None:
                    egrid = deepcopy(app.grid)
                    ent_locs = [v.loc for k,v in app.all_ents().items() if v != self]
                    for eloc in ent_locs:
                        egrid[eloc[0]][eloc[1]] = '' # EGRID NOW EMPTIED OF ENTS
                    path = bfs(self.loc[:], goals, egrid)
                moves = intersect(self.legal_moves(), path)
                if moves == []:
                    self.mvs -= 1
                    self.do_round()
                else:
                    move = reduce(lambda a,b : a if dist(a, self.loc) > dist(b, self.loc) else b, moves)
                    self.mvs -= 1
                    app.focus_square(move)
                    root.after(666, lambda m = move : self.minotaur_move(m))
            # EXIT BACK TO HANDLE_ACTION THROUGH STOMP
            else:
                app.get_focus(self.id)
                root.after(666, self.stomp)
            
    def minotaur_move(self, endloc):
        global selected
        effect1 = mixer.Sound('Sound_Effects/minotaur_move.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, -1)
        self.init_move_anims()
        app.ent_dict[self.id+'top'].init_move_anims()
        selected = [self.id, self.id+'top']
        id = self.id
        end_sqr = endloc[:] # redundant naming of vars
        path = bfs(self.loc, [end_sqr], app.grid) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path, acm):
            acm += 10
            if acm >= 40:
                app.ent_dict[id+'top'].rotate_image()
                self.rotate_image()
                acm = 0
            if x > endx:
                x -= 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            elif x < endx: 
                x += 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            if y > endy: 
                y -= 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            elif y < endy: 
                y += 10
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.delete(id+'top')
                app.canvas.create_image(x, y, image = app.ent_dict[id+'top'].img, tags = (id+'top','large'))
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == end_sqr[0]*100+50-app.moved_right and y == end_sqr[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.finish_move(end_sqr, start_sqr)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, end_sqr, path, acm)
            else: # CONTINUE LOOP
                root.after(66, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = end_sqr, p = path, acm = acm : move_loop(id, x, y, ex, ey, s, s2, p, acm))
        move_loop(id, x, y, endx, endy, self.loc, end_sqr, path, 0)
        
    def finish_move(self, end_sqr, start_sqr):
        global selected
        sound_effects.stop()
        self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        app.ent_dict[self.id+'top'].loc = [end_sqr[0],end_sqr[1]]
        self.do_round()
#     
    def pound(self, id):
        ent = app.ent_dict[id]
        effect1 = mixer.Sound('Sound_Effects/minotaur_attack.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.get_focus(id)
        app.ent_dict[self.id+'top'].init_attack_anims()
        my_agl = self.get_abl('agl')
        target_agl = ent.get_abl('agl')
        if to_hit(my_agl, target_agl):
            my_str = self.get_abl('str')
            target_end = ent.get_abl('end')
            d = damage(my_str, target_end)
            lock(apply_damage, self, ent, -d, 'crushing', 'Pound', 'melee')
            root.after(666, lambda id = id : self.cleanup_attack(id)) # EXIT THROUGH CLEANUP_ATTACK()
        else:
            miss(ent.loc)
            root.after(1888, lambda t = 'text' : app.canvas.delete(t))
            root.after(1999, lambda id = id : self.cleanup_attack(id))
        
            
    def cleanup_attack(self, id):
#         self.init_normal_anims()
        app.ent_dict[self.id+'top'].init_normal_anims()
        try: 
            app.canvas.delete('text')
        except: pass
        self.do_round()
        
        
    # all non-flying ents w/i range 8 take 8-dist(self.loc,id.loc) and are moved randomly (psi-push)
    # changing to 'pull' ents towards minotaur, move to sqr that minimizes dist between
    def stomp(self):
        app.focus_square(self.loc)
        def stomp_sound():
            effect1 = mixer.Sound('Sound_Effects/minotaur_stomp.ogg')
            effect1.set_volume(1)
            sound_effects.play(effect1, 0)
        # insert start_stomp_anims() here
        self.init_stomp_anims()
        app.ent_dict[self.id+'top'].init_stomp_anims()
        # insert stomp vis
        def earthquake_loop(ids):
            global selected
            if ids == []:
                self.cleanup_stomp()
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                loc = app.ent_dict[id].loc[:]
                d = max(1,6-dist(self.loc, loc))
                lock(apply_damage, self, app.ent_dict[id], -d, 'elec', 'Stomp', 'ranged')
                if id not in app.all_ents().keys():
                    earthquake_loop(ids)
                else: # ENT NOT KILLED, INSERT PSI PUSH
                    start_loc = app.ent_dict[id].loc[:]
                    # recursively check adj sqr of ent that minimizes dist from minotaur
                    sqr = reduce(lambda a,b : a if dist(a, self.loc) < dist(b, self.loc) else b, [s for s in app.coords if dist(start_loc, s) == 1])
                    if app.grid[sqr[0]][sqr[1]] == '':
                        sqr2 = reduce(lambda a,b : a if dist(a, self.loc) < dist(b, self.loc) else b, [s for s in app.coords if dist(sqr, s) == 1])
                        if app.grid[sqr2[0]][sqr2[1]] == '':
                            dest = sqr2
                        else:
                            dest = sqr
                    else:
                        dest = start_loc[:]
                    # end destination logic
                    x = start_loc[0]*100+50-app.moved_right
                    y = start_loc[1]*100+50-app.moved_down
                    endx = dest[0]*100+50-app.moved_right
                    endy = dest[1]*100+50-app.moved_down
                    if start_loc != dest: # do move then go to next eq loop, else go to next eq loop
                        selected = [id]
                        def finish_psionic_push(tar, end_loc, start_loc):
                            global selected
                            selected = []
                            app.ent_dict[tar].loc = end_loc[:]
                            app.grid[start_loc[0]][start_loc[1]] = ''
                            app.grid[end_loc[0]][end_loc[1]] = tar
                            root.after(888, lambda t = 'text' : app.canvas.delete(t))
                            root.after(999, lambda ids = ids : earthquake_loop(ids))
                        def psi_move_loop(ent, x, y, endx, endy, sqr, start_sqr):
                            if x % 25 == 0 and y % 25 == 0:
                                app.ent_dict[ent].rotate_image()
                                app.canvas.delete(ent)
                                app.canvas.create_image(x, y, image = app.ent_dict[ent].img, tags = app.ent_dict[ent].tags)
                            if x > endx:
                                x -= 10
                                app.canvas.move(ent, -10, 0)
                            elif x < endx: 
                                x += 10
                                app.canvas.move(ent, 10, 0)
                            if y > endy: 
                                y -= 10
                                app.canvas.move(ent, 0, -10)
                            elif y < endy: 
                                y += 10
                                app.canvas.move(ent, 0, 10)
                            try: app.canvas.tag_lower(app.ent_dict[ent].tags, 'large')
                            except: pass
                            app.canvas.tag_lower(app.ent_dict[ent].tags, 'maptop')
                            if x == endx and y == endy:
                                root.after(666, lambda e = ent, s = sqr, ss = start_sqr : finish_psionic_push(e, s, ss))
                            else:
                                root.after(50, lambda id = id, x = x, y = y, endx = endx, endy = endy, s = sqr, s2 = start_sqr : psi_move_loop(id, x, y, endx, endy, s, s2))
                        psi_move_loop(id, x, y, endx, endy, dest, start_loc)
                    else:
                        root.after(888, lambda t = 'text' : app.canvas.delete(t))
                        root.after(999, lambda ids = ids : earthquake_loop(ids))
            # first call of eq loop, called if affected ents exist
        ents = [k for k,v in app.all_ents().items() if v.immovable != True and v.get_move_type() != 'ethereal' and v.get_move_type() != 'flying']
        root.after(2333, self.init_normal_anims)
        root.after(2333, app.ent_dict[self.id+'top'].init_normal_anims)
        root.after(2111, stomp_sound)
        root.after(2555, lambda ids = ents : earthquake_loop(ids))
        
    def cleanup_stomp(self):
        app.canvas.delete('text')
        app.handle_action()
        
        
class Berserker(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Move':self.move, 'Leap':self.leap, 'Slash':self.slash, 'Howl From Beyond':self.howl_from_beyond, 'Track':self.track}
            self.str = 7
            self.agl = 7
            self.end = 5
            self.mm = 2
            self.msl = 0
            self.bls = 0
            self.dodge = 3
            self.psyche = 3
            self.wis = 3
            self.rsn = 3
            self.san = 12
            self.init = 5
            self.spirit = 23
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Move':self.move, 'Leap':self.leap, 'Slash':self.slash, 'Whirlwind':self.whirlwind, 'Howl From Beyond':self.howl_from_beyond, 'Track':self.track,  'Hurl':self.hurl, 'Rage':self.rage, 'Molten Claws':self.molten_claws, 'Bane Claws':self.bane_claws}
            self.str = 8
            self.agl = 8
            self.end = 6
            self.mm = 3
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 4
            self.san = 13
            self.init = 9
            self.spirit = 35
            self.magick = 0
            self.acts = 2
            self.mvs = 1
            self.move_range = 4
        self.move_type = 'charge'
        self.weak = []
        self.resist = ['crushing', 'poison']
        self.leap_used = False
        self.leap_anims = {}
        for k,v in app.leap_anims.items():
            self.leap_anims[k] = v
        super().__init__(name, id, img, loc, owner)
        
    def init_leap_anims(self):
        self.anim_dict = {}
        self.anim_counter = 0
        for k,v in self.leap_anims.items():
            self.anim_dict[k] = v
        self.img = self.anim_dict[0]
        
        
    def track(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_track)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_track(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Track', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_track(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_track(self, event = None, sqrs = None):
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/howl.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = 'Track', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = 'Track', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        def cleanup_track(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def track_loop(ents):
            if ents == []:
                self.finish_track()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Track' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Track', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_track(u))
                my_agl = self.get_abl('agl')
                tar_agl = ent.get_abl('agl')
                if to_hit(my_agl, tar_agl):
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Lose Invisibility', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Lose Invisibility', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                    def track_effect(ts):
                        return [t for t in ts if t != 'invisibility']
                    p = partial(track_effect)
                    ent.type_effects.append(p)
                    n = 'Track' + str(app.count)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p)
                    n = 'Track' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Track', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : track_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(999, lambda ents = ents : track_loop(ents))
        track_loop(ents)
        
    def finish_track(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.canvas.delete('text')
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def howl_from_beyond(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_howl)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_howl(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Howl From Beyond', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_howl(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_howl(self, event = None, sqrs = None):
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/howl_from_beyond.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        s = self.loc[:]
        app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = 'Howl From Beyond', font = ('chalkduster', 13), fill = 'gray33', tags = 'text')
        app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = 'Howl From Beyond', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner and 'Howl_From_Beyond' not in [j.name for i,j in v.effects_dict.items()]]
        def cleanup_howl(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def howl_loop(ents):
            if ents == []:
                self.finish_howl()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Howl_From_Beyond' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Howl_From_Beyond', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_howl(u))
                my_str = self.get_abl('str')
                tar_str = ent.get_abl('str')
                if to_hit(my_str, tar_str):
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '-3 san, -2 rsn', font = ('chalkduster', 13), fill = 'gray33', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '-3 san, -2 rsn', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
                    def howl_effect(stat):
                        return max(1,stat-3)
                    def howl_rsn_effect(stat):
                        return max(1, stat-2)
                    p = partial(howl_effect)
                    p2 = partial(howl_rsn_effect)
                    ent.san_effects.append(p)
                    ent.rsn_effects.append(p2)
                    n = 'Howl_From_Beyond' + str(app.count)
                    def un(i, p, p2, lockname = None):
                        app.ent_dict[i].san_effects.remove(p)
                        app.ent_dict[i].rsn_effects.remove(p2)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p, p2)
                    ent.effects_dict[n] = Effect(name = 'Howl_From_Beyond', undo_func = u, duration = self.get_abl('end'), level = self.get_abl('str'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : howl_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : howl_loop(ents))
        howl_loop(ents)
        
    def finish_howl(self, event = None):
#         self.init_normal_anims()
        app.canvas.delete('text')
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
        
    def whirlwind(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_whirlwind)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_whirlwind(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Whirlwind', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = sqrs : self.do_whirlwind(event = e, sqrs = s))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_whirlwind(self, event = None, sqrs = None):
#         effect1 = mixer.Sound('Sound_Effects/whirlwind.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.acts -= 1
        self.init_attack_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.unbind_all()
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Whirlwind', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Whirlwind', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1]
        if ents == []:
            root.after(1666, self.finish_whirlwind)
        else:
            root.after(1666, self.init_normal_anims)
            self.whirlwind_loop(ents)
    
    def whirlwind_loop(self, ents):
        if ents == []:
            self.finish_whirlwind()
        else:
            id = ents[0]
            ents = ents[1:]
            sqr = app.ent_dict[id].loc[:]
            un = 'Whirlwind'+str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Berserker_Slash', loc = sqr[:])
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
            def cleanup_whirlwind_vis(un):
                app.canvas.delete(un)
                del app.vis_dict[un]
                app.canvas.delete('text')
            my_agl = max(1, self.get_abl('agl')-3)
            target_agl = app.ent_dict[id].get_abl('agl')
            if to_hit(my_agl, target_agl) == True:
                my_str = self.get_abl('str')
                target_end = app.ent_dict[id].get_abl('end')
                d = damage(my_str, target_end)
                root.after(1666, lambda un = un : cleanup_whirlwind_vis(un))
                lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Whirlwind', 'melee')
                self.whirlwind_loop(ents)
            else:
                miss(sqr)
                root.after(1555, lambda un = un : cleanup_whirlwind_vis(un))
                root.after(1666, lambda ents = ents : self.whirlwind_loop(ents))
        
    def finish_whirlwind(self, event = None):
        self.init_normal_anims()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        
    def rage(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_rage)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_rage(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Rage', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_rage(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rage(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Rage', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Rage', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Rage'] = Vis(name = 'Rage', loc = sqr[:])
        vis = app.vis_dict['Rage']
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = vis.img, tags = 'Rage')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+74, text = 'Attempt Dispel Effects\n +3 str, end, +4 psy', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+75, text = 'Attempt Dispel Effects\n +3 str, end, +4 psy', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
        to_remove = []
        for k,v in self.effects_dict.items():
            if v.dispel(self.get_abl('str')) == 'Dispelled':
                to_remove.append(k)
        for k in to_remove:
            del self.effects_dict[k]
        # add effects
        def rage_effect(stat):
            return stat+3
        self.str_effects.append(rage_effect)
        self.end_effects.append(rage_effect)
        def rage_effect2(stat):
            return stat+4
        self.psyche_effects.append(rage_effect2)
        def undo(id, lockname = None):
            app.ent_dict[id].str_effects.remove(rage_effect)
            app.ent_dict[id].end_effects.remove(rage_effect)
            app.ent_dict[id].psyche_effects.remove(rage_effect2)
            d = 3
            ent = app.ent_dict[id]
            lock(apply_damage, ent, ent, -d, 'magick', 'Rage', 'undo')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        id = self.id
        u = partial(undo, id)
        self.effects_dict['Rage'] = Effect(name = 'Rage', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('str'))
        root.after(2666, self.finish_rage)
        
    def finish_rage(self, event = None):
        try: 
            del app.vis_dict['Rage']
            app.canvas.delete('Rage')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def molten_claws(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_molten_claws)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_molten_claws(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Molten Claws', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_molten_claws(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_molten_claws(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Molten_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Bane_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Molten Claws', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Molten Claws', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Molten_Claws'] = Vis(name = 'Molten_Claws', loc = sqr[:])
        # add effects
        def molten_attack(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'fire'
                amt -= 2
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = '+2 spirit, fire dmg, Molten Claws', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = '+2 spirit, fire dmg, Molten Claws', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, 'fire')
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(molten_attack)
        self.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'Molten_Claws'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Molten_Claws', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, self.finish_molten_claws)
        
    def finish_molten_claws(self, event = None):
        try: 
            del app.vis_dict['Molten_Claws']
            app.canvas.delete('Molten_Claws')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def bane_claws(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_bane_claws)
        sqrs = [self.loc[:]]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_bane_claws(event = e, sqr = sqr, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Bane Claws', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.do_bane_claws(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bane_claws(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        if 'Bane_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Molten_Claws' in [v.name for v in self.effects_dict.values()]:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/rage.ogg')
#         effect1.set_volume(.5)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Bane Claws', justify = 'center', fill = 'black', font = ('chalkduster', 16), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Bane Claws', justify = 'center', fill = 'indianred', font = ('chalkduster', 16), tags = 'text')
        app.vis_dict['Bane_Claws'] = Vis(name = 'Bane_Claws', loc = sqr[:])
        # add effects
        def bane_attack(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee':
                type = 'poison'
                def undo(lockname = None):
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo)
                def take_2(ent, lockname = None):
                    app.get_focus(ent.id)
                    lock(apply_damage, self, ent, -2, 'poison', 'Bane Poison', 'eot')
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                n = 'Bane_Poison' + str(app.count)
                eot = partial(take_2, dfndr)
                dfndr.effects_dict[n] = Effect(name = 'Bane_Poison', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+54-app.moved_down, text = 'Bane Poison, poison dmg, Bane Claws', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+55-app.moved_down, text = 'Bane Poison, poison dmg, Bane Claws', justify ='center', font = ('chalkduster', 13), fill = 'green3', tags = 'text')
                root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, 'poison')
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(bane_attack)
        self.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, self, p)
        n = 'Bane_Claws'+str(app.count)
        app.count += 1
        self.effects_dict[n] = Effect(name = 'Bane_Claws', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, self.finish_bane_claws)
        
    def finish_bane_claws(self, event = None):
        try: 
            del app.vis_dict['Bane_Claws']
            app.canvas.delete('Bane_Claws')
        except: pass
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
        
    def hurl(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_throw)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.choose_target(e, sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqr = grid_pos, sqrs = sqrs : self.choose_target(event = e, sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def choose_target(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in [k for k in app.action_target_ents().keys()]:
            return
        if app.ent_dict[id].immovable == True:
            return
        if app.ent_dict[id].owner != self.owner:
            return
        app.depop_context(event = None)
        app.unbind_all()
        app.rebind_arrows()
        root.bind('<q>', self.cleanup_throw)
        distance = self.get_abl('str')
        sqrs = [c for c in app.coords if dist(c,self.loc)<=self.get_abl('str') and app.grid[c[0]][c[1]] == '']
        app.cleanup_squares()
        if sqrs == []:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+59-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+60-app.moved_down, text = 'No Available Area', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            root.after(999, self.cleanup_throw)
        else:
            app.animate_squares(sqrs)
            root.bind('<a>', lambda e, id = id, sqr = grid_pos, sqrs = sqrs : self.do_throw(e, id = id, sqr = sqr, sqrs = sqrs))
            b = tk.Button(app.context_menu, text = 'Choose Location', font = ('chalkduster', 22), fg = 'tan3', wraplength = 190, highlightbackground = 'tan3', command = lambda e = None, id = id, sqr = grid_pos, sqrs = sqrs : self.do_throw(e, id, sqr, sqrs))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
    
    def do_throw(self, event = None, id = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
#         effect1 = mixer.Sound('Sound_Effects/throw.ogg')
#         effect1.set_volume(.4)
#         sound_effects.play(effect1, 0)
        oldloc = app.ent_dict[id].loc[:]
        newloc = sqr[:]
        root.after(333, lambda newloc = newloc, id = id : self.finish_throw(newloc, id))
        
    def finish_throw(self, newloc, id):
        lock(app.ent_dict[id].throw_move, newloc)
        root.after(333, self.cleanup_throw)
    
    def cleanup_throw(self, event = None):
        app.canvas.delete('text')
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    # TO IMPLEMENT GUARD: redirect dmg in a way that can not cause infi loops
    # either by hardcoding a check for guard(or other potential redirecting effects) OR limiting the amount of redirects OR limiting the number of 'redirect' type effects 'in play' OR changing atk/def loops...
#     def guard(self, event = None):
#         if self.attack_used == True:
#             return
#         app.unbind_nonarrows()
#         root.bind('<q>', self.cancel_attack)
#         sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
#         app.animate_squares(sqrs)
#         app.depop_context(event = None)
#         root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_guard(event = e, sqrs = sqrs, sqr = sqr)) 
#         b = tk.Button(app.context_menu, text = 'Confirm Guard', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_guard(event = e, sqrs = sqrs, sqr = sqr))
#         b.pack(side = 'top')
#         app.context_buttons.append(b)
#         
#     def do_guard(self, event = None, sqrs = None, sqr = None):
#         if sqr not in sqrs:
#             return
#         id = app.grid[sqr[0]][sqr[1]]
#         if id == '' or id == 'block':
#             return
#         if app.ent_dict[id].owner != self.owner:
#             return
#         self.attack_used = True
#         effect1 = mixer.Sound('Sound_Effects/guard.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
#         app.depop_context(event = None)
#         app.unbind_all()
#         app.cleanup_squares()
#         app.vis_dict['Guard'] = Vis(name = 'Guard', loc = sqr[:])
#         app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Guard'].img, tags = 'Guard')
#         app.canvas.create_text(sqr[0]*100-app.moved_right+49, sqr[1]*100-app.moved_down+84, text = 'Guard', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
# 
#         app.canvas.create_text(sqr[0]*100-app.moved_right+50, sqr[1]*100-app.moved_down+85, text = 'Guard', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
#         # EFFECT
#         def guard_effect(attacker, defender, amount, type, redir_obj = None):
#             if amount < 0:
#                 app.canvas.create_text(defender.loc[0]*100-app.moved_right+49, defender.loc[1]*100-app.moved_down+84, text = 'Guard Redirect', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.canvas.create_text(defender.loc[0]*100-app.moved_right+50, defender.loc[1]*100-app.moved_down+85, text = 'Guard Redirect', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.get_focus(redir_obj.number)
#                 pre = redir_obj.spirit
#                 lock(apply_damage, attacker, redir_obj, amount, type)
#                 post = redir_obj.spirit
#                 d = pre - post
#                 app.canvas.create_text(redir_obj.loc[0]*100-app.moved_right+49, redir_obj.loc[1]*100-app.moved_down+74, text = str(d)+' spirit', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                 app.canvas.create_text(redir_obj.loc[0]*100-app.moved_right+50, redir_obj.loc[1]*100-app.moved_down+75, text = str(d)+' spirit', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                 root.after(1888, lambda t = 'guard_text' : app.canvas.delete(t))
#                 # check for guard death...
#                 if redir_obj.spirit <= 0:
#                     app.canvas.create_text(defender.loc[0]*100-app.moved_right+49, defender.loc[1]*100-app.moved_down+14, text = 'Guard Death', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#                     app.canvas.create_text(defender.loc[0]*100-app.moved_right+50, defender.loc[1]*100-app.moved_down+15, text = 'Guard Death', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#                     name = 'dethlok'+str(app.death_count)
#                     app.death_count += 1
#                     app.dethloks[name] = tk.IntVar(0)
#                     root.after(999, lambda id = redir_obj.number, name = name : app.kill(id, name))
#                     root.wait_variable(app.dethloks[name])
#                     defender.defense_effects.remove(guard_effect)
#                     defender.effects_dict.remove(guard_effect)
#                 return 0
#             else:
#                 return amount
#         f = partial(guard_effect, redir_obj = self)
#         app.ent_dict[id].defense_effects.append(f)
#         # give self a death trigger to remove guard from obj
#         def death_trigger(obj, f):
#             app.canvas.create_text(obj.loc[0]*100-app.moved_right+49, obj.loc[1]*100-app.moved_down+34, text = 'Guard Removed', justify = 'center', fill = 'black', font = ('chalkduster', 12), tags = 'guard_text')
#             app.canvas.create_text(obj.loc[0]*100-app.moved_right+50, obj.loc[1]*100-app.moved_down+35, text = 'Guard Removed', justify = 'center', fill = 'white', font = ('chalkduster', 12), tags = 'guard_text')
#             root.after(2222, lambda t = 'guard_text' : app.canvas.delete(t))
#             obj.defense_effects.remove(f)
#         dt = partial(death_trigger, app.ent_dict[id], f)
#         self.death_triggers.append(dt)
#         def un(i, f, dt):
#             self.death_triggers.remove(dt)
#             app.ent_dict[id].defense_effects.remove(f)
#             return None
#         u = partial(un, id, f, dt)
#         # EOT FUNC
#         def nothing():
#             return None
#         eot = nothing
#         n = 'Guard' + str(app.count)
#         app.ent_dict[id].effects_dict[n] = Effect(name = 'Guard', info = 'Guard, redir dmg', eot_func = eot, undo = u, duration = 3, level = 8)
#         root.after(2666, lambda e = None: self.cancel_attack(e))
        
        
    # could change leap to use variable int amount of 'uses' that can be incr/decr...
    # could also change leap to use acts?
    # currently lvl1 war can act twice AND leap...
    def leap(self, event = None):
        if self.leap_used == True:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.end_leap)
        sqrs = []
        for c in app.coords:
            if dist(self.loc, c) <= self.get_abl('move_range') and app.grid[c[0]][c[1]] == '':
                sqrs.append(c)
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_leap(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Leap', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_leap(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_leap(self, event = None, sqrs = None, sqr = None):
        global selected
        if sqr not in sqrs:
            return
        self.leap_used = True
        self.init_leap_anims()
#         effect1 = mixer.Sound('Sound_Effects/leap.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        selected = [self.id]
        total_distance = abs(x - endx) + abs(y - endy)
        tic = total_distance/6 # tic is based on number of images in image source folders
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        # need to call rotate_image every tic
        def leap_loop(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif x < endx:
                acm += xstep
                x += xstep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if y > endy:
                acm += ystep
                y -= ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            elif y < endy:
                acm += ystep
                y += ystep
                app.canvas.delete(self.id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
                app.canvas.tag_raise(self.id)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                root.after(23, lambda es = end_sqr, ss = start_sqr : self.finish_leap(es, ss)) # EXIT
            else: # CONTINUE LOOP
                root.after(23, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : leap_loop(x, y, e, e2, s, s2, acm, tic, xs, ys))
        leap_loop(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)
            
            
    def finish_leap(self, end_sqr, start_sqr):
        global selected
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        self.init_normal_anims()
        self.end_leap()
        
    def end_leap(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
        
    def slash(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_slash)
        sqrs = [c for c in app.coords if dist(c,self.loc) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos : self.do_slash(event = e, sqrs = sqrs, sqr = sqr)) 
        b = tk.Button(app.context_menu, text = 'Confirm Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos : self.do_slash(event = e, sqrs = sqrs, sqr = sqr))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_slash(self, event = None, sqrs = None, sqr = None):
        if sqr not in sqrs:
            return
        if 'Rage' in [v.name for v in self.effects_dict.values()]:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
        self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/slash.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.vis_dict['Berserker_Slash'] = Vis(name = 'Berserker_Slash', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Berserker_Slash'].img, tags = 'Berserker_Slash')
        my_agl = self.get_abl('agl')
        target_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, target_agl) == True:
            my_str = self.get_abl('str')
            target_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, target_end)
            def cleanup_slash():
                del app.vis_dict['Berserker_Slash']
#                 app.canvas.delete('Berserker_Slash')
                app.cleanup_squares()
                self.init_normal_anims()
            root.after(1666, cleanup_slash)
            lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Slash', 'melee')
            root.after(111, self.cancel_slash)
        else:
            miss(sqr)
            root.after(1999, self.cancel_slash)
        
    
    def cancel_slash(self, event = None):
        self.init_normal_anims()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Berserker_Slash']
#             app.canvas.delete('Berserker_Slash')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
                    
                    
    # confuse, target must make psyche check before attack
    # fuse trap, set global effect on sqr, when effect ends all ents within range 2 take 5 dmg 
class Familiar_Homunculus(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Mesmerize':self.mesmerize, 'Fuse Trap':self.fuse_trap, 'Move':self.move}
            self.str = 3
            self.agl = 6
            self.end = 3
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 6
            self.psyche = 4
            self.wis = 4
            self.rsn = 3
            self.san = 11
            self.init = 9
            self.magick = 11
            self.spirit = 6
            self.acts = 1
            self.mvs = 1
            self.move_range = 6
            self.level = level
        elif level == 2:
            self.actions = {'Mesmerize':self.mesmerize, 'Fuse Trap':self.fuse_trap, 'Move':self.move}
            self.str = 4
            self.agl = 7
            self.end = 4
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 7
            self.psyche = 5
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 10
            self.magick = 15
            self.spirit = 9
            self.acts = 2
            self.mvs = 2
            self.move_range = 7
        self.move_type = 'normal'
        self.weak = ['crushing']
        self.resist = ['magick']
        super().__init__(name, id, img, loc, owner)
        def familiar_trigger(lockname = None):
            if self.owner == 'p1':
                witch = app.p1_witch
            else:
                witch = app.p2_witch
            loc = app.ent_dict[witch].loc[:]
            app.focus_square(loc)
            lock(apply_damage, app.ent_dict[witch], app.ent_dict[witch], -5, 'magick', 'Familiar Death', 'dt')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(familiar_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Familiar_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
                    
                    
    def fuse_trap(self, event = None):
        if self.acts < 1:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_fuse_trap)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] != 'block']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_fuse_trap(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Square For Fuse Trap', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_fuse_trap(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    # place in unoccupied sqr?
    def do_fuse_trap(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        visuals = [v.name for k,v in app.vis_dict.items() if v.loc == sqr]
        if 'Fuse_Trap' in visuals:
            return
        effect1 = mixer.Sound('Sound_Effects/fuse_trap.ogg')
        effect1.set_volume(.07)
        sound_effects.play(effect1, 0)
        self.acts -= 1
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Fuse Trap', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        if 'Fuse_Trap' not in [v.name for k,v in app.loc_dict[tuple(sqr)].effects_dict.items()]:
            un = 'Fuse_Trap' + str(app.count)
            app.count += 1
            app.vis_dict[un] = Vis(name = 'Fuse_Trap', loc = sqr[:])
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
            def undo(sqr = None, name = None, lockname = None):
                del app.vis_dict[name]
                app.canvas.delete(name)
                app.focus_square(sqr)
                effect1 = mixer.Sound('Sound_Effects/fuse_explosion.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                ents = [k for k,v in app.all_ents().items() if dist(v.loc, sqr) <= 3]
                def clean_explosion(n):
                    del app.vis_dict[n]
                    app.canvas.delete(n)
                    app.canvas.delete('text')
                def fuse_loop(ents):
                    if ents == []:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = ents[0]
                        app.get_focus(id)
                        ents = ents[1:]
                        ent = app.ent_dict[id]
                        loc = ent.loc[:]
                        n = 'Fuse_Explosion'+str(app.count)
                        app.count += 1
                        app.vis_dict[n] = Vis(name = 'Fuse_Explosion', loc = loc[:])
                        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                        lock(apply_damage, self, ent, -3, 'explosive', 'Fuse Trap', 'undo')
                        root.after(111, lambda n = n : clean_explosion(n))
                        root.after(222, lambda ents = ents : fuse_loop(ents))
                fuse_loop(ents)
            u = partial(undo, sqr = sqr[:], name = un)
            app.loc_dict[tuple(sqr[:])].effects_dict[un] = Local_Effect(name = 'Fuse_Trap', undo_func = u, duration = 1, level = 5, loc = sqr[:], avoid = 5)
        self.cleanup_fuse_trap()
                    
    def cleanup_fuse_trap(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
                    
    def mesmerize(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_mesmerize)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mesmerize(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Mesmerize', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mesmerize(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    # add mesmerize fail text
    def do_mesmerize(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [k for k in app.ent_dict[id].effects_dict.keys()]
        if 'Mesmerize' in effs:
            return
        if self.magick < 1:
            return
        self.magick -= 1
        effect1 = mixer.Sound('Sound_Effects/mesmerize.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        app.vis_dict['Mesmerize'] = Vis(name = 'Mesmerize', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mesmerize'].img, tags = 'Mesmerize')
        if to_hit(my_wis, tar_wis):
            def un(lockname = None):
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            # SOT FUNC
            def mesmerized(tar, lockname = None):
                app.get_focus(tar)
                ent = app.ent_dict[tar]
                if app.ent_dict[tar].save_check('psyche', mod = 0) == 'Fail':
                    def mesmer_efct(stat):
                        return max(0, stat-1)
                    p = partial(mesmer_efct)
                    ent.acts_effects.append(p)
                    def undo(ent, p, lockname=None):
                        ent.acts_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    ent.effects_dict['Mesmerized'] = Effect(name = 'Mesmerized', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    my_str = ent.get_abl('str')
                    my_end = ent.get_abl('end')
                    d = damage(my_str, my_end)
                    lock(apply_damage, ent, ent, -d, 'crushing', 'Mesmerized', 'melee')
                    root.after(333, lambda ln = lockname : app.dethloks[ln].set(1))
                else:
                    app.canvas.create_text(app.ent_dict[tar].loc[0]*100+49-app.moved_right, app.ent_dict[tar].loc[1]*100+69-app.moved_down, text = 'Mesmerize Psyche Save', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(app.ent_dict[tar].loc[0]*100+50-app.moved_right, app.ent_dict[tar].loc[1]*100+70-app.moved_down, text = 'Mesmerize Psyche Save', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
            sot = partial(mesmerized, id)
            ent.effects_dict['Mesmerize'] = Effect(sot_func = sot, name = 'Mesmerize', undo_func = un, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = 'Mesmerized...', fill = 'black', font = ('chalkduster', 14), tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Mesmerized...', fill = 'ghostwhite', font = ('chalkduster', 14), tags = 'text')
            root.after(2333, self.cancel_mesmerize)
        else:
            miss(ent.loc)
            root.after(1999, self.cancel_mesmerize)
        
        
    def cancel_mesmerize(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Mesmerize']
            app.canvas.delete('Mesmerize')
        except: pass
                    

class Lesser_Demon(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Dire Charm':self.dire_charm, 'Baleful Stare':self.baleful_stare, 'Brambles':self.brambles, 'Move': self.move}
            self.str = 4
            self.agl = 4
            self.end = 5
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 4
            self.psyche = 5
            self.wis = 5
            self.rsn = 4
            self.san = 13
            self.init = 8
            self.magick = 19
            self.spirit = 16
            self.acts = 1
            self.mvs = 1
            self.move_range = 4
            self.level = level
        elif level == 2:
            self.actions = {'Dire Charm':self.dire_charm, 'Baleful Stare':self.baleful_stare, 'Brambles':self.brambles, 'Move': self.move}
            self.str = 5
            self.agl = 5
            self.end = 6
            self.mm = 1
            self.msl = 0
            self.bls = 0
            self.dodge = 5
            self.psyche = 6
            self.wis = 6
            self.rsn = 5
            self.san = 14
            self.init = 9
            self.magick = 27
            self.spirit = 19
            self.acts = 2
            self.mvs = 1
            self.move_range = 4
            self.level = level
        self.move_type = 'normal'
        self.weak = ['acid']
        self.resist = []
        super().__init__(name, id, img, loc, owner)
        
        
    def brambles(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_brambles)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_brambles(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Brambles', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_brambles(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_brambles(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/brambles.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Brambles', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Brambles', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2]
        def cleanup_brambles(name):
            app.canvas.delete(name)
            del app.vis_dict[name]
            app.canvas.delete('text')
        def brambles_loop(ents):
            if ents == []:
                self.finish_brambles()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                s = app.ent_dict[id].loc[:]
                u = 'Brambles' + str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Brambles', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = 'Brambles')
                # ADD brambles effects
                if app.ent_dict[id].get_move_type() == 'normal':
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+14-app.moved_down, text = '-1 move range', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+15-app.moved_down, text = '-1 move range', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    def brambles_move(move_range):
                        return max(0,move_range-1)
                    p = partial(brambles_move)
                    ent.move_range_effects.append(p)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].move_range_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    uf = partial(un, id, p)
                    n = 'Brambles' + str(app.count)
                    app.ent_dict[id].effects_dict[n] = Effect(name = 'Brambles', undo_func = uf, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                if to_hit(self.get_abl('wis'),ent.get_abl('agl')):
                    my_psyche = self.get_abl('psyche')
                    tar_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_psyche, tar_end)
                    lock(apply_damage, self, app.ent_dict[id], -d, 'slashing', 'Brambles', 'spell')
                    root.after(111, lambda name = u : cleanup_brambles(name))
                    root.after(222, lambda ents = ents : brambles_loop(ents))
                else:
                    root.after(1555, lambda name = u : cleanup_brambles(name))
                    root.after(1666, lambda ents = ents : brambles_loop(ents))
        root.after(666, lambda ents = ents : brambles_loop(ents))
            

            
    def finish_brambles(self, event = None):
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
    
        
    def baleful_stare(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_baleful_stare)
        sqrs = [c for c in app.coords if 1 <= dist(c,self.loc) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_baleful_stare(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Choose Target Baleful Stare', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_baleful_stare(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_baleful_stare(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        efs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Baleful_Stare' in efs:
            return
#         self.init_attack_anims()
#         effect1 = mixer.Sound('Sound_Effects/baleful_stare.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.acts -= 1
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Baleful_Stare'] = Vis(name = 'Baleful_Stare', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Baleful_Stare'].img, tags = 'Baleful_Stare')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Baleful Stare', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Baleful Stare', justify ='center', font = ('chalkduster', 13), fill = 'antiquewhite', tags = 'text')
        my_wis = self.get_abl('wis')
        target_str = app.ent_dict[id].get_abl('str')
        if to_hit(my_wis, target_str) == True:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+74-app.moved_down, text = '-1 psyche, eot 2 acid dmg', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+75-app.moved_down, text = '-1 psyche, eot 2 acid dmg', justify ='center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
            # baleful effect
            def baleful_stare_effect(stat):
                stat -= 1
                if stat < 1:
                    return 1
                else:
                    return stat
            f = baleful_stare_effect
            app.ent_dict[id].psyche_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].psyche_effects.remove(baleful_stare_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            # EOT FUNC
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -2, 'acid', 'Baleful Stare', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            n = 'Baleful_Stare' + str(app.count)
            eot = partial(take_2, id)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Baleful_Stare', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(app.ent_dict[id].loc)
        root.after(2666, lambda e = None : self.finish_baleful_stare(event = e))
        
    def finish_baleful_stare(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Baleful_Stare']
            app.canvas.delete('Baleful_Stare')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
    def dire_charm(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_dire_charm)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_dire_charm(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Dire Charm', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_dire_charm(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dire_charm(self, event = None, sqrs = None):
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         effect1 = mixer.Sound('Sound_Effects/dire_charm.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        app.vis_dict['Dire_Charm'] = Vis(name = 'Dire_Charm', loc = self.loc[:])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict['Dire_Charm'].img, tags = 'Dire_Charm')
        def cleanup_charm(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def dire_charm_loop(ents):
            app.canvas.delete('text')
            if ents == []:
                self.finish_dire_charm()
            else:
                id = ents[0]
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = app.ent_dict[id].loc[:]
                app.focus_square(s)
                uniq = 'Dire_Charm'+str(app.count)
                app.count += 1
                app.vis_dict[uniq] = Vis(name = 'Dire_Charmed', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq].img, tags = 'Dire_Charm')
                if to_hit(self.get_abl('psyche'),ent.get_abl('psyche')):
                    d = damage(ent.get_abl('str'), ent.get_abl('end'))
                    root.after(1555, lambda n = uniq : cleanup_charm(n))
                    lock(apply_damage, ent, ent, -d, 'crushing', 'Dire Charmed', 'melee')
                    root.after(111, lambda ents = ents : dire_charm_loop(ents))
                else:
                    miss(ent.loc)
                    root.after(1555, lambda n = uniq : cleanup_charm(n))
                    root.after(1666, lambda ents = ents : dire_charm_loop(ents))
        dire_charm_loop(ents)
            
            
    def finish_dire_charm(self, event = None):
        try:
            del app.vis_dict['Dire_Charm']
            app.canvas.delete('Dire_Charm')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)


class Cenobite(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Strength Through Wounding':self.strength_through_wounding, 'Flesh Hooks': self.flesh_hooks, 'Hellfire': self.hellfire, 'Move': self.move}
            self.str = 5
            self.agl = 5
            self.end = 8
            self.mm = 9
            self.msl = 5
            self.bls = 6
            self.dodge = 4
            self.psyche = 8
            self.wis = 9
            self.rsn = 5
            self.san = 15
            self.init = 6
            self.spirit = 16
            self.magick = 19
            self.acts = 1
            self.mvs = 1
            self.move_range = 3
            self.level = level
        elif level == 2:
            self.actions = {'Strength Through Wounding':self.strength_through_wounding, 'Flesh Hooks': self.flesh_hooks, 'Hellfire': self.hellfire, 'Move': self.move}
            self.str = 6
            self.agl = 6
            self.end = 9
            self.mm = 10
            self.msl = 6
            self.bls = 6
            self.dodge = 5
            self.psyche = 9
            self.wis = 9
            self.rsn = 5
            self.san = 16
            self.init = 7
            self.spirit = 19
            self.magick = 21
            self.acts = 2
            self.mvs = 2
            self.move_range = 3
            self.level = level
        self.move_type = 'normal'
        self.weak = ['acid']
        self.resist = []
        super().__init__(name, id, img, loc, owner)
        
    # all w/i rang3 take 2 piercing, friendly get +1 end, +1 psy for 2 turns
    def strength_through_wounding(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_strength_through_wounding)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc, c) <= 3]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = sqrs : self.do_strength_through_wounding(event = e, sqrs = s)) 
        b = tk.Button(app.context_menu, text = 'Confirm Strength Through Wounding', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_strength_through_wounding(event = e, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_strength_through_wounding(self, event = None, sqrs = None):
        self.acts -= 1
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        ents = [k for k,v in app.all_ents().items() if v.loc in sqrs]
        def cleanup_stw(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        def stw_loop(ents):
            if ents == []:
                self.finish_strength_through_wounding()
            else:
                id = ents[0]
                app.get_focus(id)
                ents = ents[1:]
                ent = app.ent_dict[id]
                s = ent.loc[:]
                u = 'Strength_Through_Wounding' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[u] = Vis(name = 'Strength_Through_Wounding', loc = s)
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                root.after(1555, lambda u = u : cleanup_stw(u))
                lock(apply_damage, self, ent, -2, 'piercing', 'Strength Through Wounding', 'ranged')
                # give stat bonus if friendly and not dead
                if id in app.all_ents().keys() and ent.owner == self.owner and 'Strength_Through_Wounding' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+84-app.moved_down, text = '+1 End, Psy', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+85-app.moved_down, text = '+1 End, Psy', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    def strength_through_wounding_effect(stat):
                        return stat+1
                    f = strength_through_wounding_effect
                    ent.end_effects.append(f)
                    ent.psyche_effects.append(f)
                    n = 'Strength_Through_Wounding' + str(app.count)
                    def un(i, func, lockname = None):
                        app.ent_dict[i].end_effects.remove(func)
                        app.ent_dict[i].psyche_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    p = partial(un, id, f)
                    n = 'Strength_Through_Wounding' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Strength_Through_Wounding', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(888, lambda t = 'text' : app.canvas.delete(t))
                    root.after(999, lambda ents = ents : stw_loop(ents))
                else:
                    root.after(111, lambda ents = ents : stw_loop(ents))
        stw_loop(ents)
        
    def finish_strength_through_wounding(self, event = None):
#         self.init_normal_anims()
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.depop_context(event = None)
        
    # give ranged attack to friendly ent
    def flesh_hooks(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.finish_flesh_hooks)
        sqrs = [c for c in app.coords if dist(self.loc, c) == 1]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_flesh_hooks(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Bestow Flesh Hooks', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_flesh_hooks(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_flesh_hooks(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        if app.ent_dict[id].owner != self.owner:
            return
        if 'Hook Attack' in app.ent_dict[id].get_actions().keys():
            return
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/flesh_hooks.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.vis_dict['Flesh_Hooks'] = Vis(name = 'Flesh_Hooks', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Flesh_Hooks'].img, tags = 'Flesh_Hooks')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+49, self.loc[1]*100-app.moved_down+84, text = 'Flesh Hooks', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(self.loc[0]*100-app.moved_right+50, self.loc[1]*100-app.moved_down+85, text = 'Flesh Hooks', justify = 'center', fill = 'gainsboro', font = ('chalkduster', 14), tags = 'text')
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100-app.moved_right+49, loc[1]*100-app.moved_down+84, text = 'Hook Attack', justify = 'center', fill = 'black', font = ('chalkduster', 14), tags = 'text')
        app.canvas.create_text(loc[0]*100-app.moved_right+50, loc[1]*100-app.moved_down+85, text = 'Hook Attack', justify = 'center', fill = 'gainsboro', font = ('chalkduster', 14), tags = 'text')
        # add action to ent
        def hook_attack(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [c for c in app.coords if dist(obj.loc,c) <= obj.get_abl('rsn')]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Hook Attack', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
                effect1 = mixer.Sound('Sound_Effects/hook_attack.ogg')
                effect1.set_volume(1)
                sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Hook_Attack'] = Vis(name = 'Hook_Attack', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Hook_Attack'].img, tags = 'Hook_Attack')
                my_wis = obj.get_abl('wis')
                target_dodge = app.ent_dict[id].get_abl('dodge')
                if to_hit(my_wis, target_dodge) == True:
                    my_psy = obj.get_abl('psyche')
                    target_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_psy, target_end)
                    lock(apply_damage, obj, app.ent_dict[id], -d, 'piercing', 'Hook Attack', 'ranged')
                    root.after(111, lambda e = None, obj = obj : cancel_attack(e, obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1666, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims() # to init attack anims, provide them for each possible unit that can gain hook_attack
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Hook_Attack']
                    app.canvas.delete('Hook_Attack')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(hook_attack, obj = app.ent_dict[id])
        def add_hook_attack(actions = None, func = None):
            actions['Hook Attack'] = func
            return actions
        p2 = partial(add_hook_attack, func = p)
        app.ent_dict[id].action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id, p2)
        n = 'Hook_Attack' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Hook_Attack', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(1999, self.finish_flesh_hooks)
        
    def finish_flesh_hooks(self, event = None):
#         self.init_normal_anims()
        try:
            del app.vis_dict['Flesh_Hooks']
            app.canvas.delete('Flesh_Hooks')
        except: pass
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        app.canvas.delete('text')
        app.depop_context(event = None)
        
    # damage and possible burn to target
    # vis, self 'glows', target flames
    def hellfire(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_hellfire)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= max(1,self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hellfire(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Hellfire', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hellfire(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hellfire(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if self.magick < 3:
            return
        self.magick -= 3
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/beleths_command.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Hellfire'] = Vis(name = 'Hellfire', loc = visloc)
        def cleanup_hellfire():
            app.canvas.delete('Hellfire')
            del app.vis_dict['Hellfire']
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        if to_hit(my_wis, tar_wis) == True:
            my_psy = self.get_abl('psyche')
            tar_psy = ent.get_abl('psyche')
            d = damage(my_psy, tar_psy)
            root.after(1555, cleanup_hellfire)
            lock(apply_damage, self, ent, -d, 'fire', 'Hellfire', 'spell')
            if id in app.all_ents().keys() and ent.save_check('end', mod = -5) == 'Fail' and 'Burn' not in [v.name for k,v in ent.effects_dict.items()]:
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Burned', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Burned', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
            # burn effect, every time burned ent takes spirit dmg it takes that much dmg plus 2
                def burn_effect(attacker, defender, amount, type, sn, st, lockname = None):
                    if amount < 0 and type in ['slashing','crushing','piercing','fire','explosive'] and st != 'eot' and st != 'sot' and st != 'undo':
                        app.canvas.create_text(defender.loc[0]*100+49-app.moved_right, defender.loc[1]*100+54-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                        app.canvas.create_text(defender.loc[0]*100+50-app.moved_right, defender.loc[1]*100+55-app.moved_down, text = '+2 spirit burn', justify ='center', font = ('chalkduster', 13), fill = 'orangered2', tags = 'text')
                        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
                        amount -= 2
                        root.after(1444, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount, type)
                    else:
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                        return (amount,type)
                p = partial(burn_effect)
                ent.defense_effects.append(p)
                def undo(i, func, lockname = None):
                    app.ent_dict[i].defense_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, id, p)
                n = 'Burn' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Burn', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(999, lambda e = None : self.cancel_hellfire(event = e))
            else:
                root.after(111, lambda e = None : self.cancel_hellfire(event = e))
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cancel_hellfire(event = e))
        
    def cancel_hellfire(self, event = None):
#         self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Hellfire']
            app.canvas.delete('Hellfire')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
        
        
class Familiar_Imp(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        if level == 1:
            self.actions = {'Poison Sting':self.poison_sting, 'Darkness':self.darkness, 'Flying Move':self.move}
            self.str = 2
            self.agl = 6
            self.end = 3
            self.mm = 6
            self.msl = 3
            self.bls = 6
            self.dodge = 7
            self.psyche = 4
            self.wis = 6
            self.rsn = 4
            self.san = 12
            self.init = 7
            self.magick = 13
            self.spirit = 5
            self.acts = 1
            self.mvs = 1
            self.move_range = 5
            self.level = level
        elif level == 2:
            self.actions = {'Poison Sting':self.poison_sting, 'Darkness':self.darkness, 'Flying Move':self.move}
            self.str = 3
            self.agl = 7
            self.end = 4
            self.mm = 7
            self.msl = 4
            self.bls = 7
            self.dodge = 8
            self.psyche = 5
            self.wis = 7
            self.rsn = 5
            self.san = 13
            self.init = 9
            self.magick = 19
            self.spirit = 8
            self.acts = 2
            self.mvs = 2
            self.move_range = 5
        self.move_type = 'flying'
        self.weak = ['cold', 'elec']
        self.resist = ['fire', 'magick']
        super().__init__(name, id, img, loc, owner)
        def familiar_trigger(lockname = None):
            if self.owner == 'p1':
                witch = app.p1_witch
            else:
                witch = app.p2_witch
            loc = app.ent_dict[witch].loc[:]
            app.focus_square(loc)
            lock(apply_damage, app.ent_dict[witch], app.ent_dict[witch], -5, 'magick', 'Familiar Death', 'dt')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        dt = partial(familiar_trigger)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        d_inst = Death_Trigger(name = 'Familiar_Death', level = 10, undo_func = u, dt = dt)
        self.death_triggers.append(d_inst)
        
        
    def darkness(self, event = None):
#         loc_effects = [v.name for k,v in app.loc_dict.items()]
#         if 'Darkness' in g_effects:
#             return
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_attack)
        sqrs = [c for c in app.coords if dist(self.loc,c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_darkness(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Darkness', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_darkness(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_darkness(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        if self.magick < 1:
            return
        self.magick -= 1
        self.acts -= 1
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/darkness.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Darkness', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Darkness', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        # create vis on every sqr within distance 3 from sqr
        affected_sqrs = [c for c in app.coords if dist(c, sqr) <= 1 and app.grid[c[0]][c[1]] != 'block']
        for s in affected_sqrs:
            if 'Darkness' not in [v.name for k,v in app.loc_dict[tuple(s)].effects_dict.items()]:
                un = 'Darkness' + str(app.count)
                app.count += 1
                app.vis_dict[un] = Vis(name = 'Darkness', loc = s[:])
                app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                def dark_move(move_range, sqr = None):
                    id =  app.grid[sqr[0]][sqr[1]]
                    if id in app.all_ents().keys():
                        ent = app.ent_dict[id]
                        if (ent.get_move_type() == 'normal' or ent.get_move_type() == 'flying') and ent.immovable == False:
                            return max(1, move_range-2)
                        else:
                            return move_range
                    else:
                        return move_range
                p = partial(dark_move, sqr = s)
                app.loc_dict[tuple(s)].move_range_effects.append(p)
                def undo(s, un, p_dark_move, lockname = None):
                    app.loc_dict[tuple(s)].move_range_effects.remove(p_dark_move)
                    del app.vis_dict[un]
                    app.canvas.delete(un)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, s, un, p)
                app.loc_dict[tuple(s)].effects_dict[un] = Local_Effect(name = 'Darkness', undo_func = u, duration = 2, level = self.get_abl('wis'), loc = s[:], avoid = 6)
        self.cleanup_darkness()
        
    def cleanup_darkness(self, event = None):
        app.unbind_all()
        app.rebind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: app.canvas.delete('text')
        except: pass
        
        
    def poison_sting(self, event = None):
        if self.acts < 1:
            return
        app.unbind_nonarrows()
        root.bind('<q>', self.cancel_attack)
        sqrs = [c for c in app.coords if 1 <= dist(self.loc,c) <= self.get_abl('bls')]
        app.animate_squares(sqrs)
        app.depop_context(event = None)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_poison_sting(event = e, sqr = s, sqrs = sqrs)) 
        b = tk.Button(app.context_menu, text = 'Confirm Poison Sting', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_poison_sting(event = e, sqr = s, sqrs = sqrs))
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_poison_sting(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.acts -= 1
#         self.init_attack_anims()
        effect1 = mixer.Sound('Sound_Effects/poison_sting.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        visloc = app.ent_dict[id].loc[:]
        app.vis_dict['Poison_Sting'] = Vis(name = 'Poison_Sting', loc = visloc)
        app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Poison_Sting'].img, tags = 'Poison_Sting')
        ent = app.ent_dict[id]
        my_mm = self.get_abl('mm')
        target_dodge = ent.get_abl('dodge')
        if to_hit(my_mm, target_dodge) == True:
            def poison_sting_effect(stat):
                return max(1,stat-1)
            f = poison_sting_effect
            ent.str_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].str_effects.remove(poison_sting_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id)
            # EOT FUNC
            def take_2(tar, lockname = None):
                app.get_focus(tar)
                lock(apply_damage, self, app.ent_dict[tar], -1, 'poison', 'Poison Sting', 'eot')
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            eot = partial(take_2, id)
            n = 'Poison_Sting' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Poison_Sting', eot_func = eot, undo_func = p, duration = self.get_abl('msl'), level = self.get_abl('bls'))
            my_msl = self.get_abl('msl')
            tar_end = ent.get_abl('end')
            d = damage(my_msl, tar_end)
            lock(apply_damage, self, ent, -d, 'poison', 'Poison Sting', 'ranged')
            root.after(111, lambda e = None : self.cancel_attack(event = e))
        else:
            miss(ent.loc)
            root.after(1666, lambda e = None : self.cancel_attack(event = e))
        
    def cancel_attack(self, event):
        self.init_normal_anims()
        app.rebind_all()
        app.canvas.delete('text')
        try: 
            del app.vis_dict['Poison_Sting']
            app.canvas.delete('Poison_Sting')
        except: pass
        app.depop_context(event = None)
        app.cleanup_squares()
                    
                    
class Hunting_Hawk(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        self.str = 2
        self.agl = 8
        self.end = 2
        self.mm = 1
        self.msl = 0
        self.bls = 0
        self.dodge = 9
        self.psyche = 3
        self.wis = 4
        self.rsn = 3
        self.san = 15
        self.init = 9
        self.spirit = 9
        self.magick = 0
        self.acts = 1
        self.mvs = 1
        self.move_range = 6
        self.move_type = 'flying'
        self.attack_range = 4
        self.resist = ['magick', 'fire', 'elec', 'cold', 'poison', 'acid']
        self.weak = ['piercing', 'slashing']
        super().__init__(name, id, img, loc, owner)
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            # move hawk to sqr w/i moverange that is w/i attackrange(5) and maximally distant from all enemies and then atk
            # if no enemies w/i attack range, move to a random sqr w/i move range
            els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
            sqrs = [s for s in app.coords for el in els if dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                # move to rand sqr in moves
                if moves == []:
                    # cannot move at all, attempt attack wo moving
                    ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
                    if ents == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = choice(ents)
                        app.get_focus(id)
                        root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
                else:
                    move = choice(moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.hawk_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.hawk_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Hawk", eot_func = e, undo_func = u, duration = 666, level = 666)
                
    def hawk_attack(self, id, lockname):
        ent = app.ent_dict[id]
        app.vis_dict['Hawk_Attack'] = Vis(name = 'Hawk_Attack', loc = ent.id )
        app.canvas.create_image(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+50-app.moved_down, image = app.vis_dict['Hawk_Attack'].img, tags = 'Hawk_Attack')
        def cleanup_hawk_attack():
            app.canvas.delete('Hawk_Attack')
            del app.vis_dict['Hawk_Attack']
        root.after(1666, cleanup_hawk_attack)
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl) == True:
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'piercing', 'Hawk Attack', 'melee')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(app.ent_dict[id].loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def hawk_move(self, sqr, lockname):
        global selected
        selected = [self.id]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        start_sqr = self.loc[:]
        end_sqr = sqr[:]
        total_distance = abs(x - endx) + abs(y - endy)
        # tic doesnt matter for circular image loop, would need to make flying_anims and switch to
        tic = 30 #total_distance/9 # Magic Number debug, number of images for vis
        if x == endx:
            xstep = 0
            ystep = 10
        elif y == endy:
            xstep = 10
            ystep = 0
        else:
            slope = Fraction(abs(x - endx), abs(y - endy))
            # needs to be moving at least 10 pixels, xstep + ystep >= 10
            xstep = slope.numerator
            ystep = slope.denominator
            while xstep + ystep < 10:
                xstep *= 2
                ystep *= 2
        def flying_arc(x, y, endx, endy, start_sqr, end_sqr, acm, tic, xstep, ystep):
            if acm >= tic:
                acm = 0
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                acm += xstep
                x -= xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif x < endx:
                acm += xstep
                x += xstep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if y > endy:
                acm += ystep
                y -= ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            elif y < endy:
                acm += ystep
                y += ystep
                self.rotate_image()
                app.canvas.delete(self.tags)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if abs(x - endx) < 13 and abs(y - endy) < 13:
                self.finish_move( end_sqr, start_sqr, lockname)
            else: # CONTINUE LOOP
                root.after(66, lambda x = x, y = y, e = endx, e2 = endy, s = start_sqr, s2 = end_sqr, acm = acm, tic = tic, xs = xstep, ys = ystep : flying_arc(x, y, e, e2, s, s2, acm, tic, xs, ys))
        flying_arc(x, y, endx, endy, start_sqr, end_sqr, tic+1, tic, xstep, ystep)

    def finish_move(self, end, start, lockname):
#         sound_effects.stop()
        global selected
        selected = []
        self.loc = end[:]
        app.grid[start[0]][start[1]] = ''
        app.grid[end[0]][end[1]] = self.id
        self.mvs -= 1
        # if enemy w/i range: atk else done
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
        if ents == []:
            root.after(1999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            root.after(666, lambda id = id, ln = lockname : self.hawk_attack(id, ln))
    
        
class Cadaver(Summon):
    def __init__(self, name, id, img, loc, owner, level):
        self.actions = {}
        self.level = level
        if level == 1:
            self.str = 3
            self.agl = 3
            self.end = 5
            self.mm = 4
            self.msl = 2
            self.bls = 3
            self.dodge = 3
            self.psyche = 2
            self.wis = 2
            self.rsn = 2
            self.san = 10
            self.init = 3
            self.spirit = 13
            self.magick = 0
            self.acts = 1
            self.mvs = 1
            self.move_range = 2
        elif level == 2:
            self.str = 4
            self.agl = 4
            self.end = 6
            self.mm = 5
            self.msl = 3
            self.bls = 4
            self.dodge = 3
            self.psyche = 2
            self.wis = 2
            self.rsn = 2
            self.san = 10
            self.init = 3
            self.spirit = 15
            self.magick = 0
            self.acts = 2
            self.mvs = 1
            self.move_range = 3
        self.move_type = 'normal'
        self.attack_range = 1
        self.resist = ['elec', 'cold', 'poison', 'slashing', 'crushing', 'acid', 'magick']
        self.weak = []
        super().__init__(name, id, img, loc, owner)
#         self.id = id
#         self.tags = id
        def eot(lockname = None):
            self.effects_dict['control'].duration += 1 # permanent effect
            els = [v.loc for k,v in app.all_ents().items() if v.owner != self.owner]
            sqrs = [s for s in app.coords for el in els if 1 <= dist(s,el) <= self.attack_range]
            moves = self.legal_moves()
            gs = intersect(sqrs, moves)
            if gs == []:
                # move to rand sqr in moves
                if moves == []:
                    # cannot move at all, attempt attack wo moving
                    ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
                    if ents == []:
                        root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                    else:
                        id = choice(ents)
                        app.get_focus(self.id)
                        root.after(666, lambda id = id, ln = lockname : self.cadaver_attack(id, ln))
                else:
                    move = choice(moves)
                    app.focus_square(move)
                    root.after(666, lambda m = move, ln = lockname : self.cadaver_move(m, ln))
            else:
                g = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, gs)
                app.focus_square(g)
                root.after(666, lambda sqr = g[:], ln = lockname : self.cadaver_move(sqr, ln))
        e = partial(eot)
        def undo(lockname = None):
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo)
        self.effects_dict['control'] = Effect(name = self.owner+"'s Cadaver", eot_func = e, undo_func = u, duration = 666, level = 666)
                
    def cadaver_attack(self, id, lockname):
        my_agl = self.get_abl('agl')
        tar_agl = app.ent_dict[id].get_abl('agl')
        if to_hit(my_agl, tar_agl):
            my_str = self.get_abl('str')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_str, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'crushing', 'Cadaver Mob', 'melee')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        else: # miss
            miss(app.ent_dict[id].loc)
            root.after(1555, lambda t = 'text' : app.canvas.delete(t))
            root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))

    def cadaver_move(self, endloc, lockname):
        global selected
        effect1 = mixer.Sound('Sound_Effects/footsteps.ogg')
        effect1.set_volume(.5)
        sound_effects.play(effect1, -1)
        selected = [self.id]
        id = self.id
        start_sqr = self.loc[:]
        path = bfs(start_sqr, [endloc], app.grid[:]) # end_sqr must be put in list
        begin = path[0]
        end = path[1]
        x = begin[0]*100+50-app.moved_right
        y = begin[1]*100+50-app.moved_down
        endx = end[0]*100+50-app.moved_right
        endy = end[1]*100+50-app.moved_down
        def move_loop(id, x, y, endx, endy, start_sqr, endloc, path):
            if x % 20 == 0 or y % 20 == 0:
                self.rotate_image()
                app.canvas.delete(id)
                app.canvas.create_image(x, y, image = self.img, tags = self.tags)
            if x > endx:
                x -= 10
                app.canvas.move(id, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(id, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(id, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(id, 0, 10)
            try: app.canvas.tag_lower((self.tags), 'large')
            except: pass
            app.canvas.tag_lower((self.tags), 'maptop')
            app.canvas.tag_raise('cursor')
            if x == endloc[0]*100+50-app.moved_right and y == endloc[1]*100+50-app.moved_down: # END WHOLE MOVE
                self.cadaver_finish_move(endloc, start_sqr, lockname)
            elif x == endx and y == endy: # END PORTION OF PATH
                path = path[1:]
                begin = path[0]
                end = path[1]
                x = begin[0]*100+50-app.moved_right
                y = begin[1]*100+50-app.moved_down
                endx = end[0]*100+50-app.moved_right
                endy = end[1]*100+50-app.moved_down
                move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
            else: # CONTINUE LOOP
                root.after(44, lambda id = id, x = x, y = y, ex = endx, ey = endy, s = start_sqr, s2 = endloc, p = path : move_loop(id, x, y, ex, ey, s, s2, p))
        move_loop(id, x, y, endx, endy, start_sqr, endloc, path)
# 
    def cadaver_finish_move(self, end_sqr, start_sqr, lockname):
        global selected
        sound_effects.stop()
        self.mvs -= 1
        selected = []
        self.loc = end_sqr[:]
        app.grid[start_sqr[0]][start_sqr[1]] = ''
        app.grid[end_sqr[0]][end_sqr[1]] = self.id
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,self.loc) <= self.attack_range and v.owner != self.owner]
        if ents == []:
            root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
        else:
            id = choice(ents)
            app.get_focus(id)
            root.after(666, lambda id = id, ln = lockname : self.cadaver_attack(id, ln))
                    
                    
class Witch(Summon):
    def __init__(self, name, img, loc, owner, level):
        p = partial(self.page_summons, index = 0)
        self.actions = {'Move':self.move, 'Arcana':self.arcana, 'Summon':p}
        self.level = level
        self.owner = owner
        self.name = name
        self.summon_cap = 6
#         self.summon_level = 1
        self.summon_count = 0
        self.arcane_dict = {}
#         self.cantrip_dict = {}
        self.summon_ids = 0
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.attack_effects = [] # resolved when applying damage
        self.defense_effects = [] # resolved when receiving damage
        self.acts_effects = [] # affect number of actions/arcanespells per round
#         self.cantrips_effects = [] # affect number of cantrips per round
        self.smns_effects = [] # affect number of summons placed per round
        self.mvs_effects = [] # affect number of moves per round
        self.move_range_effects = [] # affect move_range
        self.action_effects = [] # holds effects that grant addtnl actions/spells
        self.resist_effects = [] # obj.resist and obj.weak are in subclass instances
        self.weak_effects = [] # resist/weak resolved in apply_damage()
        self.types = [] # holds invis, psyshield...
        self.type_effects = [] # effects that add/rmv types
        self.death_triggers = []
        self.effects_dict = {}
        self.anim_dict = {}
        self.init_normal_anims()
        self.anim_counter = randrange(0, len(self.anim_dict.keys()))
        self.entomb_used = False
        if name == 'Agnes_Sampson':
            if level == 1:
                self.arcane_dict['Entomb'] = (self.entomb, 0)
                self.arcane_dict['Psionic_Push'] = (self.psionic_push, 2)
                self.arcane_dict["Minerva's_Gift"] = (self.minervas_gift, 1)
                self.arcane_dict['Bewitch'] = (self.bewitch, 1)
                self.arcane_dict['Read_the_Stars'] = (self.read_the_stars, 1)
                self.arcane_dict['Energize'] = (self.energize, 2)
                self.arcane_dict['Psi_Blades'] = (self.psi_blades, 1)
                self.arcane_dict['Cosmic_Sight'] = (self.cosmic_sight, 1)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 3)
                self.arcane_dict['Plague'] = (self.plague, 5)
                self.arcane_dict['Pestilence'] = (self.pestilence, 11)
                self.arcane_dict['Curse_of_Oriax'] = (self.curse_of_oriax, 4)
                self.arcane_dict['Demonic_Sight'] = (self.demonic_sight, 3)
                self.arcane_dict['Molecular_Subversion'] = (self.molecular_subversion, 6)
                self.arcane_dict['Plutonian_Cloak'] = (self.plutonian_cloak, 6)
                self.arcane_dict['Hidden_From_the_Stars'] = (self.hidden_from_the_stars, 4)
                self.arcane_dict['Strength_of_the_Void'] = (self.strength_of_the_void, 4)
                self.arcane_dict['Iron_Spirit'] = (self.iron_spirit, 4)
                self.arcane_dict["Mercury's_Blessing"] = (self.mercurys_blessing, 4)
                self.arcane_dict['Gift_of_Mars'] = (self.gift_of_mars, 4)
                self.arcane_dict['Gravity'] = (self.gravity, 5)
                self.arcane_dict["Beleth's_Command"] = (self.beleths_command, 7)
                self.arcane_dict['Lift'] = (self.lift, 3)
                self.arcane_dict['Cloister'] = (self.cloister, 3)
                self.arcane_dict['Aura_of_Agony'] = (self.aura_of_agony, 4)
                self.arcane_dict['Dampening_Emanation'] = (self.dampening_emanation, 5)
                self.arcane_dict['Blind'] = (self.blind, 6)
                self.arcane_dict['Enmeshing_Coils'] = (self.enmeshing_coils, 6)
                self.arcane_dict['Mirror_Armor'] = (self.mirror_armor, 5)
#                 self.base_cantrips = 1
#                 self.cantrips = 1
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'normal'
                self.str = 4
                self.agl = 4
                self.end = 4
                self.mm = 4
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 6
                self.rsn = 6
                self.san = 15
                self.init = 9
                self.spirit = 40
                self.magick = 0
                self.weak = []
                self.resist = ['poison', 'fire']
                self.base_spirit = 40
#                 self.base_magick = 75
                self.magick_regen = 2
            elif level == 2:
                self.arcane_dict['Entomb'] = (self.entomb, 0)
                self.arcane_dict['Psionic_Push'] = (self.psionic_push, 2)
                self.arcane_dict["Minerva's_Gift"] = (self.minervas_gift, 1)
                self.arcane_dict['Bewitch'] = (self.bewitch, 1)
                self.arcane_dict['Read_the_Stars'] = (self.read_the_stars, 1)
                self.arcane_dict['Energize'] = (self.energize, 2)
                self.arcane_dict['Psi_Blades'] = (self.psi_blades, 1)
                self.arcane_dict['Cosmic_Sight'] = (self.cosmic_sight, 1)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 3)
                self.arcane_dict['Plague'] = (self.plague, 5)
                self.arcane_dict['Pestilence'] = (self.pestilence, 11)
                self.arcane_dict['Curse_of_Oriax'] = (self.curse_of_oriax, 4)
                self.arcane_dict['Demonic_Sight'] = (self.demonic_sight, 3)
                self.arcane_dict['Molecular_Subversion'] = (self.molecular_subversion, 6)
                self.arcane_dict['Plutonian_Cloak'] = (self.plutonian_cloak, 6)
                self.arcane_dict['Hidden_From_the_Stars'] = (self.hidden_from_the_stars, 4)
                self.arcane_dict['Strength_of_the_Void'] = (self.strength_of_the_void, 4)
                self.arcane_dict['Iron_Spirit'] = (self.iron_spirit, 4)
                self.arcane_dict["Mercury's_Blessing"] = (self.mercurys_blessing, 4)
                self.arcane_dict['Gift_of_Mars'] = (self.gift_of_mars, 4)
                self.arcane_dict['Gravity'] = (self.gravity, 4)
                self.arcane_dict["Beleth's_Command"] = (self.beleths_command, 7)
                self.arcane_dict['Lift'] = (self.lift, 3)
                self.arcane_dict['Cloister'] = (self.cloister, 3)
                self.arcane_dict['Vengeance'] = (self.vengeance, 8)
                self.arcane_dict['Pain'] = (self.pain, 5)
                self.arcane_dict['Torment'] = (self.torment, 11)
                self.arcane_dict['Hatred'] = (self.hatred, 7)
                self.arcane_dict['Mass_Hysteria'] = (self.mass_hysteria, 7)
                self.arcane_dict['Genjutsushi'] = (self.genjutsushi, 3)
                self.arcane_dict['Aura_of_Agony'] = (self.aura_of_agony, 4)
                self.arcane_dict['Dampening_Emanation'] = (self.dampening_emanation, 5)
                self.arcane_dict['Blind'] = (self.blind, 6)
                self.arcane_dict['Enmeshing_Coils'] = (self.enmeshing_coils, 6)
                self.arcane_dict['Mirror_Armor'] = (self.mirror_armor, 5)
                self.arcane_dict['Summon_Lesser_Demon'] = (self.summon_lesser_demon, 15)
                self.arcane_dict['Summon_Cenobite'] = (self.summon_cenobite, 15)
#                 self.base_cantrips = 1
#                 self.cantrips = 1
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'normal'
                self.str = 7
                self.agl = 7
                self.end = 8
                self.mm = 6
                self.msl = 0
                self.bls = 0
                self.dodge = 8
                self.psyche = 10
                self.wis = 10
                self.rsn = 7
                self.san = 15
                self.init = 9
                self.spirit = 50
                self.magick = 0
                self.weak = []
                self.resist = ['poison', 'fire']
                self.base_spirit = 50
#                 self.base_magick = 85
                self.magick_regen = 3
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Agnes_Sampson_Color/Agnes_Sampson_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Agnes_Sampson_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        elif name == 'Fakir_Ali':
            if level == 1:
                self.arcane_dict['Entomb'] = (self.entomb, 0)
                self.arcane_dict['Boiling_Blood'] = (self.boiling_blood, 2)
                self.arcane_dict['Dark_Sun'] = (self.dark_sun, 3)
                self.arcane_dict['Meditate'] = (self.meditate, 2)
                self.arcane_dict['Legerdemain'] = (self.legerdemain, 2)
                self.arcane_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 3)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 3)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,7)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,8)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Pain'] = (self.pain, 5)
                self.arcane_dict['Dispel'] = (self.dispel,7)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 3)
                self.arcane_dict['Immolate'] = (self.immolate, 8)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Lift'] = (self.lift, 3)
                self.arcane_dict['Cloister'] = (self.cloister, 3)
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'normal'
                self.str = 3
                self.agl = 3
                self.end = 5
                self.mm = 3
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 5
                self.rsn = 6
                self.san = 17
                self.init = 8
                self.spirit = 50
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 50
                self.magick_regen = 2
            elif level == 2:
                self.arcane_dict['Entomb'] = (self.entomb, 0)
                self.arcane_dict['Boiling_Blood'] = (self.boiling_blood, 2)
                self.arcane_dict['Dark_Sun'] = (self.dark_sun, 3)
                self.arcane_dict['Meditate'] = (self.meditate, 2)
                self.arcane_dict['Legerdemain'] = (self.legerdemain, 2)
                self.arcane_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 3)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 3)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,7)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,8)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Dispel'] = (self.dispel,7)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 3)
                self.arcane_dict['Immolate'] = (self.immolate, 8)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Vengeance'] = (self.vengeance, 8)
                self.arcane_dict['Pain'] = (self.pain, 5)
                self.arcane_dict['Torment'] = (self.torment, 11)
                self.arcane_dict['Hatred'] = (self.hatred, 7)
                self.arcane_dict['Lift'] = (self.lift, 3)
                self.arcane_dict['Cloister'] = (self.cloister, 3)
                self.arcane_dict['Genjutsushi'] = (self.genjutsushi, 3)
                self.arcane_dict['Hidden_From_the_Stars'] = (self.hidden_from_the_stars, 4)
                self.arcane_dict['Strength_of_the_Void'] = (self.strength_of_the_void, 4)
                self.arcane_dict['Iron_Spirit'] = (self.iron_spirit, 4)
                self.arcane_dict["Mercury's_Blessing"] = (self.mercurys_blessing, 4)
                self.arcane_dict['Gift_of_Mars'] = (self.gift_of_mars, 4)
                self.arcane_dict['Summon_Lesser_Demon'] = (self.summon_lesser_demon, 15)
                self.arcane_dict['Summon_Cenobite'] = (self.summon_cenobite, 15)
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'normal'
                self.str = 8
                self.agl = 7
                self.end = 9
                self.mm = 5
                self.msl = 0
                self.bls = 0
                self.dodge = 6
                self.psyche = 9
                self.wis = 9
                self.rsn = 7
                self.san = 17
                self.init = 8
                self.spirit = 60
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 60
                self.magick_regen = 3
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Fakir_Ali_Color/Fakir_Ali_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Fakir_Ali_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        elif name == 'Morgan_LeFay':
            if level == 1:
                self.arcane_dict['Fleet_of_Paw'] = (self.fleet_of_paw, 0)
                self.arcane_dict['Hunting_Hawk'] = (self.hunting_hawk, 0)
                self.arcane_dict['Entangle'] = (self.entangle, 0)
                self.arcane_dict['Boiling_Blood'] = (self.boiling_blood, 0)
                self.arcane_dict['Dark_Sun'] = (self.dark_sun, 0)
                self.arcane_dict['Meditate'] = (self.meditate, 0)
                self.arcane_dict['Legerdemain'] = (self.legerdemain, 0)
                self.arcane_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 0)
                self.arcane_dict['Foul_Familiar'] = (self.foul_familiar, 0)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,5)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,3)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Dispel'] = (self.dispel,4)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 5)
                self.arcane_dict['Immolate'] = (self.immolate, 7)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Vengeance'] = (self.vengeance, 4)
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'flying'
                self.str = 3
                self.agl = 3
                self.end = 5
                self.mm = 3
                self.msl = 0
                self.bls = 0
                self.dodge = 4
                self.psyche = 6
                self.wis = 5
                self.rsn = 6
                self.san = 17
                self.init = 8
                self.spirit = 50
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 50
            elif level == 2:
                self.cantrip_dict['Fleet_of_Paw'] = (self.fleet_of_paw, 0)
                self.cantrip_dict['Hunting_Hawk'] = (self.hunting_hawk, 0)
                self.cantrip_dict['Entangle'] = (self.entangle, 0)
                self.cantrip_dict['Boiling_Blood'] = (self.boiling_blood, 0)
                self.cantrip_dict['Dark_Sun'] = (self.dark_sun, 0)
                self.cantrip_dict['Meditate'] = (self.meditate, 0)
                self.cantrip_dict['Legerdemain'] = (self.legerdemain, 0)
                self.cantrip_dict['Grasp_of_the_Old_Ones'] = (self.grasp_of_the_old_ones, 0)
                self.cantrip_dict['Foul_Familiar'] = (self.foul_familiar, 0)
                self.arcane_dict['Horrid_Wilting'] = (self.horrid_wilting,5)
                self.arcane_dict['Mind_Rot'] = (self.mind_rot,3)
                self.arcane_dict['Dust_Devil'] = (self.dust_devil,5)
                self.arcane_dict['Dispel'] = (self.dispel,4)
                self.arcane_dict['Disintegrate'] = (self.disintegrate, 5)
                self.arcane_dict['Mummify'] = (self.mummify, 5)
                self.arcane_dict['Immolate'] = (self.immolate, 7)
                self.arcane_dict['Command_of_Osiris'] = (self.command_of_osiris, 8)
                self.arcane_dict['Vengeance'] = (self.vengeance, 4)
                self.arcane_dict['Pain'] = (self.pain, 5)
                self.arcane_dict['Torment'] = (self.torment, 5)
                self.arcane_dict['Hatred'] = (self.hatred, 9)
                self.arcane_dict['Entomb'] = (self.entomb, 7)
                self.arcane_dict['Summon_Lesser_Demon'] = (self.summon_lesser_demon, 10)
                self.arcane_dict['Summon_Cenobite'] = (self.summon_cenobite, 10)
#             self.spell_dict['Enchant'] = (self.enchant, 4)
#             self.spell_dict['Counterspell'] = (self.counterspell, 3)
#             self.spell_dict["Nature's_Wrath"] = (self.natures_wrath, 5)
#             self.spell_dict["Ceridwen's_Command"] = (self.ceridwens_command, 6)
#             self.spell_dict['Wild_Hunt'] = (self.wild_hunt, 7)
#                 self.base_cantrips = 1
#                 self.cantrips = 1
                self.base_smns = 1
                self.smns = 1
                self.base_acts = 1
                self.acts = 1
                self.base_mvs = 1
                self.mvs = 1
                self.move_range = 3
                self.move_type = 'flying'
                self.str = 8
                self.agl = 7
                self.end = 9
                self.mm = 5
                self.msl = 0
                self.bls = 0
                self.dodge = 6
                self.psyche = 9
                self.wis = 9
                self.rsn = 7
                self.san = 17
                self.init = 8
                self.spirit = 60
                self.magick = 0
                self.weak = []
                self.resist = ['slashing', 'piercing', 'fire']
                self.base_spirit = 60
#                 self.base_magick = 80
            self.color_img = ImageTk.PhotoImage(Image.open('animations/Morgan_LeFay_Color/Morgan_LeFay_Color.png'))
            self.minimap_img = ImageTk.PhotoImage(Image.open('animations/Morgan_LeFay_Minimap_Img/0.png').resize((10,10)))
            if self.owner == 'p1':
                app.p1_minimap_img = self.minimap_img
                app.p1_color_img = self.color_img
            else:
                app.p2_minimap_img = self.minimap_img
                app.p2_color_img = self.color_img
        id = self.name
        super().__init__(name, id, img, loc, owner, type = 'normal')
        
        
    # clean protagonist object (Witch) between levels DEBUG debug change to new...
    def reset_transient_vars(self):
        # attrs directly altered, reset
        self.summon_ids = 0
#         self.cantrips = self.base_cantrips
        self.acts = self.base_acts
        self.mvs = self.base_mvs
        self.smns = self.base_smns
        self.spirit = self.base_spirit
        self.magick = 0
        # attrs altered by effects stacks, reset stacks
        self.str_effects = []
        self.agl_effects = []
        self.end_effects = []
        self.mm_effects = []
        self.msl_effects = []
        self.bls_effects = []
        self.dodge_effects = []
        self.psyche_effects = []
        self.wis_effects = []
        self.rsn_effects = []
        self.san_effects = []
        self.init_effects = []
        self.action_effects = []
        self.attack_effects = []
        self.defense_effects = []
        self.resist_effects = []
        self.weak_effects = []
        self.type_effects = []
        self.acts_effects = []
        self.mvs_effects = []
        self.move_range_effects = []
        self.death_trigger_effects = []
        self.effects_dict = {}
        self.summon_count = 0
        self.move_type_effects = []
        self.entomb_used = False
    
    
    def page_summons(self, event = None, index = None):
        app.depop_context(event = None)
        sum_list = ['Berserker','Illusionist','Umbrae_Wolf','Thaumaturge','Murrain_Wolf','Fiend','Wurdulak','Chirurgeon','Hexmage','Fell_Evolver','Drake','Inquisitor','Transmuter']
        for i, smn in enumerate(sum_list[index:index+7]):
            i += 1
            p = partial(self.place_summon, type = smn)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+smn.replace('_',' '), font = ('chalkduster', 20), fg='tan3', highlightbackground = 'tan3', command = p)
            b1.pack(side = 'top', pady = 2)
            if self.summon_count >= self.summon_cap or self.smns < 1:
                b1.config(state = 'disabled')
            else:
#                 p2 = partial(self.place_summon
                root.bind(str(i), p)
            app.context_buttons.append(b1)
#             b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = '9 : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda i = index-7 : self.page_summons(index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind(str(9), lambda e, i = index-7 : self.page_summons(index = i))
            app.context_buttons.append(b4)
        if len(sum_list) > len(sum_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = '8 : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda i = index+7 : self.page_summons(index = i))
            b3.pack(side = 'top', pady = 2)
            root.bind(str(8), lambda e, i = index+7 : self.page_summons(index = i))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        
    def cancel_placement(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
    
    def place_summon(self, event = None, type = None):
        if self.summon_count >= self.summon_cap:
            return
        root.bind('<q>', self.cancel_placement)
        app.depop_context(event = None)
        sqrs = [c for c in app.coords if dist(c, self.loc) == 1 and app.grid[c[0]][c[1]] == '']
        app.animate_squares(sqrs)
        if type == 'Berserker':
            cls = Berserker
        elif type == 'Illusionist':
            cls = Illusionist
        elif type == 'Umbrae_Wolf':
            cls = Umbrae_Wolf
        elif type == 'Thaumaturge':
            cls = Thaumaturge
        elif type == 'Murrain_Wolf':
            cls = Murrain_Wolf
        elif type == 'Fiend':
            cls = Fiend
        elif type == 'Wurdulak':
            cls = Wurdulak
        elif type == 'Chirurgeon':
            cls = Chirurgeon
        elif type == 'Hexmage':
            cls = Hexmage
        elif type == 'Fell_Evolver':
            cls = Fell_Evolver
        elif type == 'Drake':
            cls = Drake
        elif type == 'Inquisitor':
            cls = Inquisitor
        elif type == 'Transmuter':
            cls = Transmuter
        cmd = lambda e = None, x = cls, y = sqrs, s = grid_pos : self.continue_place_summon(e, summon = x, sqrs = y, sqr = s)
        root.bind('<a>', lambda e, x = cls, y = sqrs, s = grid_pos : self.continue_place_summon(e, x, y, s))
        b = tk.Button(app.context_menu, text = 'Place '+type.replace('_',' '), font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', wraplength = 190, command = cmd)
        b.pack(side = 'top')
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
        
    def continue_place_summon(self, event, summon, sqrs, sqr):
        if sqr not in sqrs:
            return
        app.unbind_all()
        root.bind('<q>', app.depop_context)
        root.bind('<a>', app.populate_context)
        # SOUND
        effect1 = mixer.Sound('Sound_Effects/summon.ogg')
        effect1.set_volume(.7)
        sound_effects.play(effect1, 0)
        # place visual summon
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        def cleanup_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(2666, cleanup_summon)
        if self.owner == 'p1':
            id = 'a' + str(self.summon_ids)
            self.summon_ids += 1
            self.summon_count += 1
        elif self.owner == 'p2':
            id = 'b' + str(self.summon_ids)
            self.summon_ids += 1
            self.summon_count += 1
        if summon == Berserker:
            name = 'Berserker'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Berserker.png'))
        elif summon == Illusionist:
            name = 'Illusionist'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Illusionist.png'))
        elif summon == Umbrae_Wolf:
            name = 'Umbrae_Wolf'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Umbrae_Wolf.png'))
        elif summon == Thaumaturge:
            name = 'Thaumaturge'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Thaumaturge.png'))
        elif summon == Murrain_Wolf:
            name = 'Murrain_Wolf'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Murrain_Wolf.png'))
        elif summon == Fiend:
            name = 'Fiend'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Fiend.png'))
        elif summon == Wurdulak:
            name = 'Wurdulak'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Wurdulak.png'))
        elif summon == Chirurgeon:
            name = 'Chirurgeon'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Chirurgeon.png'))
        elif summon == Hexmage:
            name = 'Hexmage'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Hexmage.png'))
        elif summon == Fell_Evolver:
            name = 'Fell_Evolver'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Fell_Evolver.png'))
        elif summon == Drake:
            name = 'Drake'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Drake.png'))
        elif summon == Inquisitor:
            name = 'Inquisitor'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Inquisitor.png'))
        elif summon == Transmuter:
            name = 'Transmuter'
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Transmuter.png'))
        s = summon(name = name, id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.cleanup_squares()
        app.depop_context(event = None)
        # separate here to finish summon vis, place ent after a sec or two
        root.after(1999, lambda s = s, sqr = sqr, id = id : self.finish_place(s, sqr, id))
        
    def finish_place(self, summon, sqr, id):
        app.ent_dict[id] = summon
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = summon.img, tags = summon.tags)
        app.grid[sqr[0]][sqr[1]] = id
        self.smns -= 1
        app.unbind_all()
        app.rebind_all()
        
        
    def spell(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spell)
        b1 = tk.Button(app.context_menu, wraplength = 190, text = 'Cantrip', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = self.cantrip)
        b1.pack(side = 'top', pady = 2)
        app.context_buttons.append(b1)
        root.bind(str(1), self.cantrip)
        b2 = tk.Button(app.context_menu, wraplength = 190, text = 'Arcane', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = self.arcane)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
        root.bind(str(2), self.arcane)
        b6 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 20), highlightbackground = 'tan3', fg='tan3', command = self.cancel_placement)
        b6.pack(side = 'top')
        app.context_buttons.append(b6)
        
#     def cantrip(self, event = None):
#         if self.cantrips < 1:
#             return
#         app.depop_context(event = None)
#         app.unbind_nonarrows()
#         root.bind('<q>', self.cleanup_spell)
#         tup_list = list(self.cantrip_dict.items())
#         self.page_spells(tup_list = tup_list, index = 0)
        
    def arcana(self, event = None):
#         if self.acts < 1:
#             return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', self.cleanup_spell)
        tup_list = list(self.arcane_dict.items())
        # sort list of tups by sec elm
        tup_list = sorted(tup_list, key=lambda t : t[1][1])
        self.page_spells(tup_list = tup_list, index = 0)
        
    def page_spells(self, event = None, tup_list = None, index = None):
        app.depop_context(event = None)
        for i, name_spellcosttuple in enumerate(tup_list[index:index+7]):
            name = name_spellcosttuple[0]
            name = name.replace('_', ' ')
            spell = name_spellcosttuple[1][0]
            cost = name_spellcosttuple[1][1]
            i += 1
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name + ' '+str(cost), font = ('chalkduster', 18), fg='tan3', highlightbackground = 'tan3', command = spell)
            b1.pack(side = 'top', pady = 2)
            if cost > self.magick or (name == 'Entomb' and self.entomb_used == True):
                b1.config(state = 'disabled')
            else:
                root.bind(str(i), spell)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = '9 : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind(str(9), lambda e, t = tup_list, i = index-7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+7]):
            b3 = tk.Button(app.context_menu, text = '8 : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            b3.pack(side = 'top', pady = 2)
            root.bind(str(8), lambda e, t = tup_list, i = index+7 : self.page_spells(tup_list = t, index = i))
            app.context_buttons.append(b3)
        b2 = tk.Button(app.context_menu, text = 'Cancel', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = self.cleanup_spell)
        b2.pack(side = 'top', pady = 2)
        app.context_buttons.append(b2)
    
    def cleanup_spell(self, event = None, name = None):
        global selected, selected_vis
        app.unbind_all()
        self.init_normal_anims()
        app.cleanup_squares()
        app.depop_context(event = None)
        try: 
            del app.vis_dict[name]
            app.canvas.delete(name)
        except: pass
        try: app.canvas.delete('text')
        except: pass
        selected = []
        selected_vis = []
        app.get_focus(self.id)
        app.rebind_all()
        
        
        # SPELLS
        # available to all through powerups
    # drain_life cantrip, deal 2 to any enemy target, heal 2 spirit?
    # exchange positions of friendly summon and enemy summon, or any two summons?
    # cantrip boost stats of a summon for multiple turns, non-stacking?
    
    # destroy familiar..., make a little taller and resemble the imp in some way, image should be combo of imp and homunc
    def summon_lesser_demon(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Summon_Lesser_Demon' : self.cleanup_spell(name = name))
        familiars = [k for k,v in app.all_ents().items() if v.owner == self.owner and dist(v.loc,self.loc) <= self.get_abl('rsn') and (v.name == 'Familiar_Imp' or v.name == 'Familiar_Homunculus')]
        sqrs = []
        for id in familiars:
            sqrs.append(app.ent_dict[id].loc[:])
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_summon_lesser_demon(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Familiar To Transform', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_summon_lesser_demon(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_summon_lesser_demon(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        my_ent_names = [v.name for k,v in app.all_ents().items() if v.owner == self.owner]
        if 'Lesser_Demon' in my_ent_names:
            return
        id = app.grid[sqr[0]][sqr[1]]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_lesser_demon.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Summon_Lesser_Demon'][1]
        app.canvas.delete(id)
        app.grid[app.ent_dict[id].loc[0]][app.ent_dict[id].loc[1]] = ''
        del app.ent_dict[id]
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_summon_lesser_demon(s))
        root.after(1999, self.cleanup_summon_lesser_demon)
        root.after(2111, lambda name = 'Summon_Lesser_Demon' : self.cleanup_spell(name = name))
        
    def finish_summon_lesser_demon(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Lesser_Demon.png'))
        app.ent_dict[id] = Lesser_Demon(name = 'Lesser_Demon', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_summon_lesser_demon(self):
        del app.vis_dict['Summon']
        app.canvas.delete('Summon')
    
    
    def summon_cenobite(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Summon_Cenobite' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= 3 and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_summon_cenobite(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_summon_cenobite(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_summon_cenobite(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        my_ent_names = [v.name for k,v in app.all_ents().items() if v.owner == self.owner]
        if 'Cenobite' in my_ent_names:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/summon_cenobite.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Summon_Cenobite'][1]
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Summon'].img, tags = 'Summon')
        root.after(1666, lambda s = sqr : self.finish_summon_cenobite(s))
        root.after(1777, self.cleanup_summon_cenobite)
        root.after(1999, lambda name = 'Summon_Cenobite' : self.cleanup_spell(name = name))
        
    def finish_summon_cenobite(self, sqr):
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Cenobite.png'))
        app.ent_dict[id] = Cenobite(name = 'Cenobite', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        
    def cleanup_summon_cenobite(self):
        del app.vis_dict['Summon']
        app.canvas.delete('Summon')
        
# Agnes' spells center around Death/Decay/Disease/Telekinetics/Cosmology
    # target summon may move again this turn
    def energize(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Energize' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_energize(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Energize', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_energize(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_energize(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Energize' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/energize.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Energize'][1]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Energize', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Energize', justify = 'center', font = ('chalkduster', 13), fill = 'cyan2', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+74-app.moved_down, text = '+1 moves', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+75-app.moved_down, text = '+1 moves', justify = 'center', font = ('chalkduster', 13), fill = 'cyan2', tags = 'text')
        def energize_efct(stat):
            return stat+1
        p = partial(energize_efct)
        ent.mvs_effects.append(p)
        ent.mvs += 1
        def undo(ent, p, lockname = None):
            ent.mvs_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        app.vis_dict['Energize'] = Vis(name = 'Energize', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Energize'].img, tags = 'Energize')
        n = 'Energize' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Energize', undo_func = u, duration = 2, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Energize' : self.cleanup_spell(name = name))
    
    def minervas_gift(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = "Minerva's_Gift" : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_minervas_gift(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Gift', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_minervas_gift(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_minervas_gift(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if "Minerva's_Gift" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict["Minerva's_Gift"][1]
        app.vis_dict["Minerva's_Gift"] = Vis(name = "Minerva's_Gift", loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict["Minerva's_Gift"].img, tags = "Minerva's_Gift")
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = '+1 agl, init\n+1 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = '+1 agl, init\n+1 spirit', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        apply_heal(self, app.ent_dict[id], 1)
        def minervas_gift_effect(stat):
            stat += 1
            return stat
        f = minervas_gift_effect
        app.ent_dict[id].agl_effects.append(f)
        app.ent_dict[id].init_effects.append(f)
        def un(i, lockname = None):
            app.ent_dict[i].agl_effects.remove(minervas_gift_effect)
            app.ent_dict[i].init_effects.remove(minervas_gift_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = "Minerva's_Gift" + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = "Minerva's_Gift", undo_func = p, duration = 2, level = self.get_abl('wis'))
        root.after(2999, lambda  name = "Minerva's_Gift" : self.cleanup_spell(name = name))

    # target gains psyshield (friendly or foe, non-witch) 2 turns (cannot target with most spells, anything that checks app.spell_target_ents())
    def bewitch(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Bewitch' : self.cleanup_spell(name = name))
        # test visual lag from 'blinking' whole map?
        # alternatively only blink the sqrs with legal targets?
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_bewitch(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Bewitch', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_bewitch(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_bewitch(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if id not in app.spell_target_ents().keys():
            return
        if 'Bewitch' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Bewitch'][1]
        app.vis_dict['Bewitch'] = Vis(name = 'Bewitch', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Bewitch'].img, tags = 'Bewitch')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psyshield', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        def bewitch_effect(types):
            return types+['psyshield']
        p = partial(bewitch_effect)
        app.ent_dict[id].type_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].type_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Bewitch' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Bewitch', undo_func = u, duration = 1, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Bewitch' : self.cleanup_spell(name = name))
        
        
    def read_the_stars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_rts(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Read the Stars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_rts(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_rts(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Read_the_Stars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         effect1 = mixer.Sound('Sound_Effects/read_the_stars.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Read_the_Stars'][1]
        ent = app.ent_dict[id]
        app.vis_dict['Read_the_Stars'] = Vis(name = 'Read_the_Stars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Read_the_Stars'].img, tags = 'Read_the_Stars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Read the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Read the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+2 cold, elec dmg', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+2 cold, elec dmg', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def rts_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (type == 'cold' or type == 'elec') and (st == 'melee' or st == 'ranged' or st == 'spell'):
                amt -= 2
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+84-app.moved_down, text = '+2 Read the Stars', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+85-app.moved_down, text = '+2 Read the Stars', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(rts_atk)
        ent.attack_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.attack_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        un = partial(undo, ent, p)
        n = 'Read_the_Stars' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Read_the_Stars', undo_func = un, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Read_the_Stars' : self.cleanup_spell(name = name))
        
        
    def psi_blades(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Psi_Blades' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_psi_blades(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Psi Blades', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_psi_blades(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psi_blades(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Psi_Blades' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/scrye.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Psi_Blades'][1]
        app.vis_dict['Psi_Blades'] = Vis(name = 'Psi_Blades', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Psi_Blades'].img, tags = 'Psi_Blades')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psi Blades', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psi Blades', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        def psi_slash(event = None, obj = None):
            if obj.acts < 1:
                return
            app.unbind_nonarrows()
            root.bind('<q>', lambda e, obj = obj : cancel_attack(obj = obj))
            sqrs = [s for s in app.coords if dist(s,obj.loc) == 1]
            app.animate_squares(sqrs)
            app.depop_context(event = None)
            root.bind('<a>', lambda e, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj)) 
            b = tk.Button(app.context_menu, text = 'Confirm Psi Slash', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs, sqr = grid_pos, obj = obj : check_hit(event = e, sqrs = sqrs, sqr = sqr, obj = obj))
            b.pack(side = 'top')
            app.context_buttons.append(b)
            b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
            b2.pack(side = 'top')
            app.context_buttons.append(b2)
            # INNER-INNER FUNCS, context must be passed to obj receiving this action
            def check_hit(event = None, sqrs = None, sqr = None, obj = None):
                if sqr not in sqrs:
                    return
                id = app.grid[sqr[0]][sqr[1]]
                if id == '' or id == 'block':
                    return
                if id not in app.action_target_ents().keys():
                    return
                obj.acts -= 1
#                 obj.init_attack_anims()
#                 effect1 = mixer.Sound('Sound_Effects/psi_slash.ogg')
#                 effect1.set_volume(1)
#                 sound_effects.play(effect1, 0)
                app.depop_context(event = None)
                app.unbind_all()
                app.cleanup_squares()
                visloc = app.ent_dict[id].loc[:]
                app.vis_dict['Psi_Slash'] = Vis(name = 'Psi_Slash', loc = visloc)
                app.canvas.create_image(visloc[0]*100+50-app.moved_right, visloc[1]*100+50-app.moved_down, image = app.vis_dict['Psi_Slash'].img, tags = 'Psi_Slash')
                def cleanup_vis():
                    app.canvas.delete('text')
                    try:
                        del app.vis_dict['Psi_Slash']
                        app.canvas.delete('Psi_Slash')
                    except: pass
                my_agl = obj.get_abl('agl')
                target_agl = app.ent_dict[id].get_abl('agl')
                if to_hit(my_agl, target_agl) == True:
                    my_psyche = app.ent_dict[id].get_abl('psyche')
                    target_psyche = app.ent_dict[id].get_abl('psyche')
                    d = damage(my_psyche, target_psyche)
                    root.after(1666, cleanup_vis)
                    lock(apply_damage, obj, app.ent_dict[id], -d, 'elec', 'Psi Slash', 'melee')
                    root.after(333, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1999, lambda e = None, obj = obj : cancel_attack(event = e, obj = obj))
            # INNER INNER FUNC
            def cancel_attack(event = None, obj = None):
                obj.init_normal_anims()
                app.rebind_all()
                app.canvas.delete('text')
                try:
                    del app.vis_dict['Psi_Slash']
                    app.canvas.delete('Psi_Slash')
                except: pass
                app.depop_context(event = None)
                app.cleanup_squares()
            # END INNER-INNER FUNCS
        # ADD ACTION TO TARGET
        p = partial(psi_slash, obj = app.ent_dict[id])
        def add_psi_slash(actions = None, func = None):
            actions['Psi Slash'] = func
            return actions
        p2 = partial(add_psi_slash, func = p)
        app.ent_dict[id].action_effects.append(p2)
        def un(i, func, lockname = None):
            app.ent_dict[i].action_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id, p2)
        n = 'Psi_Blades' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Psi_Blades', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = "Psi_Blades" : self.cleanup_spell(name = name))
        
    def foul_familiar(self, event = None):
        names = [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]
        if 'Familiar_Imp' in names or 'Familiar_Homunculus' in names or 'Familiar_Pseudodragon' in names:
            return
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Foul_Familiar' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1 and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_foul_familiar(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_foul_familiar(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_foul_familiar(self, event = None, sqr = None, sqrs = None):
        if sqr not in sqrs:
            return
        loc = sqr[:]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/foul_familiar.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Foul_Familiar'][1]
        app.vis_dict['Foul_Familiar'] = Vis(name = 'Foul_Familiar', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Foul_Familiar'].img, tags = 'Foul_Familiar')
        # summon familiar based on witch
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        if self.name == 'Agnes_Sampson':
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Familiar_Imp.png'))
            app.ent_dict[id] = Familiar_Imp(name = 'Familiar_Imp', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
            app.grid[sqr[0]][sqr[1]] = id
        elif self.name == 'Fakir_Ali':
            img = ImageTk.PhotoImage(Image.open('summon_imgs/Familiar_Homunculus.png'))
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = img, tags = id)
            app.ent_dict[id] = Familiar_Homunculus(name = 'Familiar_Homunculus', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
            app.grid[sqr[0]][sqr[1]] = id
        
        root.after(666, lambda  name = 'Foul_Familiar' : self.cleanup_spell(name = name))
    
    # create 'tomb' in current location, tomb is summon entity with no movement or attacks that doesnt count towards summon cap, teleport self to new location, only 1 tomb can exist at a time
    def entomb(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Entomb' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn') and app.grid[s[0]][s[1]] == '']
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_entomb(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_entomb(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_entomb(self, event, sqr, sqrs):
        global selected
        if self.entomb_used == True:
            return
        if sqr not in sqrs:
            return
        loc = app.grid[sqr[0]][sqr[1]]
        if loc != '':
            return
        self.entomb_used = True
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/strength_through_wounding.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Entomb'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.acts -= 1
        selected = [self.tags]
        app.canvas.delete(self.tags)
        oldloc = self.loc[:]
        # ENTOMB VIS
        app.vis_dict['Entomb'] = Vis(name = 'Entomb', loc = oldloc[:])
        app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = app.vis_dict['Entomb'].img, tags = 'Entomb')
        # CREATE TOMB ENTITY
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(self.summon_ids)
        self.summon_ids += 1
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Tomb.png'))
        app.ent_dict[id] = Tomb(name = 'Tomb', id = id, img = img, loc = oldloc[:], owner = self.owner, level = self.level)
        app.grid[oldloc[0]][oldloc[1]] = id
        newloc = sqr[:]
#         app.vis_dict['Entomb'] = Vis(name = 'Entomb', loc = oldloc)
#         app.canvas.create_image(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+50-app.moved_down, image = app.vis_dict['Entomb'].img, tags = 'Entomb')
        app.canvas.create_text(oldloc[0]*100+49-app.moved_right, oldloc[1]*100+74-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(oldloc[0]*100+50-app.moved_right, oldloc[1]*100+75-app.moved_down, text = 'Entomb', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        root.after(1666, lambda loc = newloc : self.finish_entomb(loc))
        
    def finish_entomb(self, loc):
        del app.vis_dict['Entomb']
        app.canvas.delete('Entomb')
        app.vis_dict['Entomb'] = Vis(name = 'Entomb', loc = loc[:])
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict['Entomb'].img, tags = 'Entomb')
        selected = []
        self.loc = loc[:]
        app.grid[loc[0]][loc[1]] = self.tags
        root.after(1333, lambda x = loc[0]*100+50-app.moved_right, y = loc[1]*100+50-app.moved_down, i = self.img, t = self.tags : app.canvas.create_image(x, y, image = i, tags = t))
#         app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = self.img, tags = self.tags)
        root.after(1999, lambda  name = 'Entomb' : self.cleanup_spell(name = name))
        

    # add def efct to smn, on non-sot/eot dmg, add +1 ablts 
    def vengeance(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Vengeance' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_vengeance(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Vengeance', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_vengeance(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_vengeance(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Vengeance' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/vengeance.ogg')
        effect1.set_volume(.08)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Vengeance'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Vengeance', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Vengeance', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
        app.vis_dict['Vengeance'] = Vis(name = 'Vengeance', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Vengeance'].img, tags = 'Vengeance')
        def vengeance_efct(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged') and len([v for k,v in dfndr.effects_dict.items() if v.name == 'Vengeance_Boost']) <= 3:
                def vngnc_tmp(stat):
                    return stat+1
                p = partial(vngnc_tmp)
                dfndr.str_effects.append(p)
                dfndr.agl_effects.append(p)
                dfndr.end_effects.append(p)
                dfndr.psyche_effects.append(p)
                dfndr.wis_effects.append(p)
                dfndr.rsn_effects.append(p)
                def undo(dfndr, func, lockname = None):
                    dfndr.str_effects.remove(p)
                    dfndr.agl_effects.remove(p)
                    dfndr.end_effects.remove(p)
                    dfndr.psyche_effects.remove(p)
                    dfndr.wis_effects.remove(p)
                    dfndr.rsn_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, dfndr, p)
                n = 'Vengeance_Boost'+str(app.count)
                dfndr.effects_dict[n] = Effect(name = 'Vengeance_Boost', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Vengeance\n+1 str, agl, end, psy, wis, rsn', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Vengeance\n+1 str, agl, end, psy, wis, rsn', justify = 'center', font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(vengeance_efct)
        ent.defense_effects.append(p)
        def undo(id, func, lockname = None):
            app.ent_dict[id].defense_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, id, p)
        n = 'Vengeance'+str(app.count)
        ent.effects_dict[n] = Effect(name = 'Vengeance', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Vengeance' : self.cleanup_spell(name = name))
      
    def hatred(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hatred(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Hatred', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hatred(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hatred(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Hatred' in effs:
            return
        self.magick -= self.arcane_dict['Hatred'][1]
        effect1 = mixer.Sound('Sound_Effects/hatred.ogg')
        effect1.set_volume(.9)
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Hatred'] = Vis(name = 'Hatred', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Hatred'].img, tags = 'Hatred')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Hatred', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Hatred', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick1', tags = 'text')
        ent = app.ent_dict[id]
        def hatred_atk(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'melee' and len([v for k,v in atkr.effects_dict.items() if v.name == 'Hatred_Strength']) <= 4:
                def hatred_effect(stat):
                    return stat+1
                p = partial(hatred_effect)
                atkr.str_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.str_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, atkr, p)
                n = 'Hatred_Strength' + str(app.count)
                atkr.effects_dict[n] = Effect(name = 'Hatred_Strength', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+84-app.moved_down, text = 'Hatred, +1 str', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+85-app.moved_down, text = 'Hatred, +1 str', justify = 'center', font = ('chalkduster', 14), fill = 'firebrick1', tags = 'text')
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        p = partial(hatred_atk)
        ent.attack_effects.append(p)
        def undo(ent, func, lockname = None):
            ent.attack_effects.remove(func)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Hatred' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Hatred', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Hatred' : self.cleanup_spell(name = name))
        
        
    # target gets -2 psyche for 4 turns (does not stack), takes psyche versus end damage on cast
    def torment(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Torment' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_torment(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Torment', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_torment(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_torment(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/torment.ogg')
        effect1.set_volume(.07)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Torment'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Torment'] = Vis(name = 'Torment', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Torment'].img, tags = 'Torment')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Torment', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Torment', justify = 'center', font = ('chalkduster', 14), fill = 'thistle1', tags = 'text')
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Torment' not in effs:
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+24-app.moved_down, text = '-2 psyche', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+25-app.moved_down, text = '-2 psyche', justify = 'center', font = ('chalkduster', 14), fill = 'thistle1', tags = 'text')
            def torment_effect(stat):
                return max(1,stat-2)
            p = partial(torment_effect)
            ent.psyche_effects.append(p)
            def un(id, func, lockname = None):
                app.ent_dict[id].psyche_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Torment' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Torment', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        my_psyche = self.get_abl('psyche')
        tar_end = ent.get_abl('end')
        d = damage(my_psyche, tar_end)
        lock(apply_damage, self, ent, -d, 'magick', 'Torment', 'spell')
        root.after(333, lambda  name = 'Torment' : self.cleanup_spell(name = name))

    # destroy a summon you own to deal dmg to adj ents
    def pain(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Pain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pain(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Pain', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pain(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pain(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if app.ent_dict[id].owner != self.owner or not isinstance(app.ent_dict[id], Summon):
            return
        effect1 = mixer.Sound('Sound_Effects/pain.ogg')
        effect1.set_volume(.07)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Pain'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Pain'] = Vis(name = 'Pain', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Pain'].img, tags = 'Pain')
        def cleanup_pain():
            del app.vis_dict['Pain']
            app.canvas.delete('Pain')
        root.after(1999, cleanup_pain)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+74-app.moved_down, text = 'Pain', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+75-app.moved_down, text = 'Pain', font = ('chalkduster', 14), fill = 'firebrick2', tags = 'text')
#         self.init_cast_anims()
        # kill here and handle death triggers, then make explosion
        loc = app.ent_dict[id].loc[:]
        name = 'dethlok'+str(app.death_count)
        app.death_count += 1
        app.dethloks[name] = tk.IntVar(0)
        root.after(333, lambda id = id, name = name : app.kill(id, name))
        root.wait_variable(app.dethloks[name])
        self.continue_pain(loc)
        
    def continue_pain(self, loc):
        adj_ents = [k for k,v in app.all_ents().items() if dist(v.loc,loc)==1]
        all_targets = adj_ents
        for id in all_targets:
            n = 'Pain' + str(app.count) # not an effect, just need unique int
            app.count += 1 # that is why this is incr manually here, no Effect init
            loc = app.ent_dict[id].loc[:]
            app.vis_dict[n] = Vis(name = 'Pain_Explode', loc = loc)
            def cleanup_vis(name):
                del app.vis_dict[name]
                app.canvas.delete(name)
            root.after(2222, lambda n = n : cleanup_vis(n))
            rand_start_anim = randrange(1,7)
            for i in range(rand_start_anim):
                app.vis_dict[n].rotate_image()
            app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
            # Damage
            my_psyche = self.get_abl('psyche')
            tar_end = app.ent_dict[id].get_abl('end')
            d = damage(my_psyche, tar_end)
            lock(apply_damage, self, app.ent_dict[id], -d, 'explosive', 'Pain', 'ranged')
        root.after(2333, lambda  name = 'Pain' : self.cleanup_spell(name = name))
        
        
    # change to -4 random attr, affect every adj recursively
    def plague(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Plague' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_plague(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Plague', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_plague(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_plague(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        # PLAGUE CANNOT BE STACKED WITH OTHER PLAGUES
        if 'Plague' in app.ent_dict[id].effects_dict.keys():
            return
        self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/plague.ogg')
        effect1.set_volume(2)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Plague'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Plague', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Plague', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        visited = [app.ent_dict[id].id]
        ents = [app.ent_dict[id].id]
        def cleanup_vis(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def plague_loop(ents, visited):
            if ents == []:
                self.cleanup_spell(name = 'Plague')
            else:
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                loc = app.ent_dict[id].loc
                u = 'Plague'+str(app.count)
                app.count += 1
                app.vis_dict[u] = Vis(name = 'Plague', loc = loc)
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[u].img, tags = u)
                def plague_effect(stat):
                    return max(1,stat-4)
                f = plague_effect
                any = choice(range(1,11))
                if any == 1:
                    app.ent_dict[id].str_effects.append(f)
                    ef_type = 'str'
                elif any == 2:
                    app.ent_dict[id].end_effects.append(f)
                    ef_type = 'end'
                elif any == 3:
                    app.ent_dict[id].agl_effects.append(f)
                    ef_type = 'agl'
                elif any == 4:
                    app.ent_dict[id].dodge_effects.append(f)
                    ef_type = 'dodge'
                elif any == 5:
                    app.ent_dict[id].psyche_effects.append(f)
                    ef_type = 'psyche'
                elif any == 6:
                    app.ent_dict[id].rsn_effects.append(f)
                    ef_type = 'rsn'
                elif any == 7:
                    app.ent_dict[id].wis_effects.append(f)
                    ef_type = 'wis'
                elif any == 8:
                    app.ent_dict[id].san_effects.append(f)
                    ef_type = 'san'
                elif any == 9:
                    app.ent_dict[id].init_effects.append(f)
                    ef_type = 'init'
                elif any == 10:
                    app.ent_dict[id].mm_effects.append(f)
                    ef_type = 'mm'
                app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-4 '+ef_type, font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-4 '+ef_type, font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                def un(i, ef_type, lockname = None):
                    if ef_type == 'str':
                        app.ent_dict[i].str_effects.remove(plague_effect)
                    elif ef_type == 'end':
                        app.ent_dict[i].end_effects.remove(plague_effect)
                    elif ef_type == 'agl':
                        app.ent_dict[i].agl_effects.remove(plague_effect)
                    elif ef_type == 'dodge':
                        app.ent_dict[i].dodge_effects.remove(plague_effect)
                    elif ef_type == 'psyche':
                        app.ent_dict[i].psyche_effects.remove(plague_effect)
                    elif ef_type == 'wis':
                        app.ent_dict[i].wis_effects.remove(plague_effect)
                    elif ef_type == 'rsn':
                        app.ent_dict[i].rsn_effects.remove(plague_effect)
                    elif ef_type == 'san':
                        app.ent_dict[i].san_effects.remove(plague_effect)
                    elif ef_type == 'init':
                        app.ent_dict[i].init_effects.remove(plague_effect)
                    elif ef_type == 'mm':
                        app.ent_dict[i].mm_effects.remove(plague_effect)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                p_undo = partial(un, id, ef_type)
                n = 'Plague' + str(app.count)
                app.ent_dict[id].effects_dict['Plague'] = Effect(name = 'Plague', undo_func = p_undo, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                # get adj
                adj = [k for k,v in app.all_ents().items() if dist(v.loc, loc) == 1 and k not in visited]
                adj = [id for id in adj if 'Plague' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]]
                ents += adj
                visited += adj
                root.after(1999, lambda u = u : cleanup_vis(u))
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ents = ents, v = visited : plague_loop(ents, v))
        plague_loop(ents, visited)



    def enmeshing_coils(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Enmeshing_Coils' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_enmeshing_coils(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Enmeshing Coils', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_enmeshing_coils(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_enmeshing_coils(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/plague.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Enmeshing_Coils'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Enmeshing Coils', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Enmeshing Coils', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
        def cleanup_enmesh(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def enmesh_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Enmeshing_Coils')
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                ent = app.ent_dict[id]
                name = 'Enmeshing_Coils'+str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Enmeshing_Coils', loc = ent.loc)
                def enmesh_efct(stat):
                    return max(1,stat-3)
                p = partial(enmesh_efct)
                ent.agl_effects.append(p)
                app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '-3 agility', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '-3 agility', font = ('chalkduster', 14), fill = 'limegreen', tags = 'text')
                def un(ent, p, lockname = None):
                    ent.agl_effects.remove(p)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(un, ent, p)
                n = 'Enmeshing_Coils' + str(app.count)
                ent.effects_dict[n] = Effect(name = 'Enmeshing_Coils', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                root.after(1999, lambda n = name : cleanup_enmesh(n))
                root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                root.after(1666, lambda ids = ids : enmesh_loop(ids))
        locs = [c for c in app.coords if dist(c,sqr) <= 1]
        ids = [k for k,v in app.all_ents().items() if v.loc in locs and 'Enmeshing_Coils' not in [j.name for i,j in v.effects_dict.items()] and v.owner != self.owner]
        enmesh_loop(ids)

            
    # PSIONIC PUSH
    def psionic_push(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Psionic_Push' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_psionic_push(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Psionic Push', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_psionic_push(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_psionic_push(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        # cannot target immovable
        if app.ent_dict[id].immovable == True:
            return
        app.unbind_nonarrows()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Psionic_Push'][1]
        loc = app.ent_dict[id].loc[:]
        ps = []
        ps.append(loc)
        for c in app.coords:
            if c[0] == (loc[0] + 1) and c[1] == loc[1] and app.grid[c[0]][c[1]] == '':
                ps.append(c)
                n = [loc[0]+2, loc[1]]
                if n in app.coords:
                    if n[0] == (loc[0] + 2) and n[1] == loc[1] and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == (loc[0] - 1) and c[1] == loc[1] and app.grid[c[0]][c[1]] == '':
                n = [loc[0]-2, loc[1]]
                ps.append(c)
                if n in app.coords:
                    if n[0] == (loc[0] - 2) and n[1] == loc[1] and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == loc[0] and c[1] == (loc[1] + 1) and app.grid[c[0]][c[1]] == '':
                n = [loc[0], loc[1]+2]
                ps.append(c)
                if n in app.coords:
                    if n[0] == loc[0] and n[1] == (loc[1] + 2) and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
            elif c[0] == loc[0] and c[1] == (loc[1] - 1) and app.grid[c[0]][c[1]] == '':
                n = [loc[0], loc[1]-2]
                ps.append(c)
                if n in app.coords:
                    if n[0] == loc[0] and n[1] == (loc[1] - 2) and app.grid[n[0]][n[1]] == '':
                        ps.append(n)
        app.animate_squares(ps)
        root.bind('<a>', lambda e, id = id, s = grid_pos, sqrs = ps : self.choose_psi_square(event = e, id = id, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Square to Push', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, id = id, s = grid_pos, sqrs = ps : self.choose_psi_square(e, id, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
            
    def choose_psi_square(self, event, id, sqr, sqrs):
        global selected, selected_vis
        if sqr not in sqrs:
            return
        self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/psionic_push.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        start_loc = app.ent_dict[id].loc[:]
        app.vis_dict['Psionic_Push'] = Vis(name = 'Psionic_Push', loc = start_loc)
        app.canvas.create_image(start_loc[0]*100+50-app.moved_right, start_loc[1]*100+50-app.moved_down, image = app.vis_dict['Psionic_Push'].img, tags = 'Psionic_Push')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Psionic Push', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Psionic Push', font = ('chalkduster', 14), fill = 'lightgreen', tags = 'text')
        x = start_loc[0]*100+50-app.moved_right
        y = start_loc[1]*100+50-app.moved_down
        endx = sqr[0]*100+50-app.moved_right
        endy = sqr[1]*100+50-app.moved_down
        if start_loc != sqr:
            selected = [id]
            selected_vis = ['Psionic_Push']
        def psi_move_loop(vis, ent, x, y, endx, endy, sqr, start_sqr):
            app.vis_dict[vis].rotate_image()
            app.canvas.delete(vis)
            app.canvas.create_image(x, y, image = app.vis_dict[vis].img, tags = 'Psionic_Push')
            if x % 25 == 0 and y % 25 == 0:
                app.ent_dict[ent].rotate_image()
                app.canvas.delete(ent)
                app.canvas.create_image(x, y, image = app.ent_dict[ent].img, tags = app.ent_dict[ent].tags)
            if x > endx:
                x -= 10
                app.canvas.move(vis, -10, 0)
                app.canvas.move(ent, -10, 0)
            elif x < endx: 
                x += 10
                app.canvas.move(vis, 10, 0)
                app.canvas.move(ent, 10, 0)
            if y > endy: 
                y -= 10
                app.canvas.move(vis, 0, -10)
                app.canvas.move(ent, 0, -10)
            elif y < endy: 
                y += 10
                app.canvas.move(vis, 0, 10)
                app.canvas.move(ent, 0, 10)
            app.canvas.tag_raise(vis)
            try: app.canvas.tag_lower(app.ent_dict[ent].tags, 'large')
            except: pass
            app.canvas.tag_lower(app.ent_dict[ent].tags, 'maptop')
            if x == endx and y == endy:
                root.after(666, lambda e = ent, s = sqr, ss = start_sqr : self.finish_psionic_push(tar = e, end_loc = s, start_loc = ss))
            else:
                root.after(50, lambda p = 'Psionic_Push', id = id, x = x, y = y, endx = endx, endy = endy, s = sqr, s2 = start_sqr : psi_move_loop(p, id, x, y, endx, endy, s, s2))
        if sqr == start_loc:
            self.finish_psionic_push(id, sqr, start_loc)
        else:
            psi_move_loop('Psionic_Push', id, x, y, endx, endy, sqr, start_loc)
        
    def finish_psionic_push(self, tar, end_loc, start_loc):
        global selected, selected_vis
        ent1 = app.ent_dict[tar]
        tar_str = ent1.get_abl('str')
        ent1.loc = end_loc[:]
        app.grid[start_loc[0]][start_loc[1]] = ''
        app.grid[end_loc[0]][end_loc[1]] = ent1.id
        ents = [v for k,v in app.all_ents().items() if dist(ent1.loc,v.loc)<=1]
        def psi_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Psionic_Push')
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                if ent.save_check('agl', mod = 1) == 'Fail':
                    d = damage(tar_str, ent.get_abl('end'))
                    lock(apply_damage, ent1, ent, -d, 'crushing', 'Psionic Push', 'melee')
                    root.after(111, lambda ids = ids : psi_loop(ids))
                else:# Miss
                    miss(ent.loc)
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : psi_loop(ids))
        adj_ids = [k for k,v in app.all_ents().items() if dist(v.loc,ent1.loc)==1]
        if adj_ids == []:
            self.cleanup_spell(name = 'Psionic_Push')
        else:
            psi_loop([e.id for e in ents])
        
    # deal dmg to targ and w/i r3 of targ, decr dmg with distance, main targ gets death_trigger pass this death_trigger EOT 1 spirit
    def pestilence(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_pestilence(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Area For Pestilence', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_pestilence(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_pestilence(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
#         id = app.grid[sqr[0]][sqr[1]]
#         if id == '' or id == 'block':
#             return
        loc = sqr[:]
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        effect1 = mixer.Sound('Sound_Effects/pestilence.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Pestilence'][1]
        self.init_cast_anims()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 16), fill = 'gray75', tags = 'text')
        # do all vis now, staggered
        def pestil_vis_loop(index):
            for sqr in [s for s in app.coords if dist(s, loc) == index]:
                n = 'Pestilence' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                app.vis_dict[n] = Vis(name = 'Pestilence', loc = sqr[:])
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                root.after(1666, lambda n = n : cleanup_vis(n))
            if index == 3:
                ents = [k for k,v in app.all_ents().items() if dist(v.loc, loc) <= 3]
                self.continue_pestilence(ents, loc)
            else:
                root.after(666, lambda j = index+1 : pestil_vis_loop(j))
        pestil_vis_loop(0)
        
    # dmg ents based on dist from sqr (main target)
    def continue_pestilence(self, ents, sqr):
        def pestil_loop(ents):
            if ents == []:
                self.cleanup_spell(name = 'Pestilence')
            else:
                id = ents[0]
                ents = ents[1:]
                loc = app.ent_dict[id].loc[:]
                app.focus_square(loc)
                # DAMAGE
                my_psyche = self.get_abl('psyche')
                tar_psyche = app.ent_dict[id].get_abl('psyche')
                d = damage(my_psyche, tar_psyche)
                d -= dist(loc, sqr)*2
                if d < 1:
                    d = 1
                lock(apply_damage, self, app.ent_dict[id], -d, 'poison', 'Pestilence', 'spell')
                if id in app.all_ents().keys() and app.ent_dict[id].loc == sqr and 'Pestilence' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    def pestil_death_trigger(obj = None, lockname = None):
                        adj = [k for k,v in app.all_ents().items() if dist(v.loc, obj.loc) == 1 and 'Pestilence' not in [j.name for i,j in v.effects_dict.items()]]
                        for id,s in [(k,v.loc) for k,v in app.all_ents().items() if k in adj]:
                            # INNER effect given by death trigger of original target
                            n = 'Pestilence' + str(app.count) # not an effect, just need unique int
                            app.count += 1 # that is why this is incr manually here, no Effect init
                            app.vis_dict[n] = Vis(name = 'Pestilence', loc = s[:])
                            app.canvas.create_text(s[0]*100+49-app.moved_right, s[1]*100+74-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                            app.canvas.create_text(s[0]*100+50-app.moved_right, s[1]*100+75-app.moved_down, text = 'Pestilence', justify ='center', font = ('chalkduster', 13), fill = 'gray88', tags = 'text')
                            def cleanup_vis(name):
                                del app.vis_dict[name]
                                app.canvas.delete(name)
                                app.canvas.delete('text')
                            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                            root.after(888, lambda n = n : cleanup_vis(n))
                            p_inner = partial(pestil_death_trigger, app.ent_dict[id])
                            def dt_undo(lockname = None):
                                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            dt = Death_Trigger(name = 'Pestilence', level = self.get_abl('wis'), undo_func = dt_undo, dt = p_inner)
                            app.ent_dict[id].death_triggers.append(dt)
                            def un(id, ts, lockname = None):
                                for dt in app.ent_dict[id].death_triggers[:]:
                                    if dt.ts == ts:
                                        app.ent_dict[id].death_triggers.remove(dt)
                                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                            u = partial(un, id, dt.ts)
                            def take_3(tar, lockname = None):
                                app.get_focus(tar)
                                lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pestilence', 'eot')
                                root.after(666, lambda ln = lockname : app.dethloks[ln].set(1))
                            eot = partial(take_3, id)
                            n = 'Pestilence' + str(app.count)
                            app.ent_dict[id].effects_dict[n] = Effect(name = 'Pestilence', eot_func = eot, undo_func = u, duration = self.get_abl('rsn')*2, level = self.get_abl('wis'))
                        root.after(999, lambda ln = lockname : app.dethloks[ln].set(1))
                    # END inner effect passed on death trigger
                    p_death = partial(pestil_death_trigger, app.ent_dict[id])
                    def dt_undo(lockname = None):
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    dt = Death_Trigger(name = 'Pestilence', level = self.get_abl('wis'), undo_func = dt_undo, dt = p_death)
                    app.ent_dict[id].death_triggers.append(dt)
                    def un(id, ts, lockname = None):
                        for dt in app.ent_dict[id].death_triggers[:]:
                            if dt.ts == ts:
                                app.ent_dict[id].death_triggers.remove(dt)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, dt.ts)
                    # EOT FUNC
                    def take_3(tar, lockname = None):
                        app.get_focus(tar)
                        lock(apply_damage, self, app.ent_dict[tar], -3, 'poison', 'Pestilence', 'eot')
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    eot = partial(take_3, id)
                    n = 'Pestilence' + str(app.count)
                    app.ent_dict[id].effects_dict[n] = Effect(name = 'Pestilence', eot_func = eot, undo_func = u, duration = self.get_abl('rsn')*2, level = self.get_abl('wis'))
                root.after(555, lambda t = 'text' : app.canvas.delete(t))
                root.after(666, lambda ents = ents : pestil_loop(ents))
        app.canvas.delete('text')
        pestil_loop(ents)
    
    # CURSE OF ORIAX
    def curse_of_oriax(self, event = None):
        # Any target is inflicted with 'curse', while cursed takes 2 spirit damage at end of every owner's turn and minus 1 to every stat (not spirit, magick, movement)
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_curse_of_oriax(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Curse of Oriax', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_curse_of_oriax(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_curse_of_oriax(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Curse_of_Oriax' in effs:
            return
        self.magick -= self.arcane_dict['Curse_of_Oriax'][1]
        effect1 = mixer.Sound('Sound_Effects/curse_of_oriax.ogg')
        effect1.set_volume(1.4)
        sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+19-app.moved_down, text = 'Curse\nof\nOriax', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+20-app.moved_down, text = 'Curse\nof\nOriax', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        app.vis_dict['Curse_of_Oriax'] = Vis(name = 'Curse_of_Oriax', loc = sqr)
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Curse_of_Oriax'].img, tags = 'Curse_of_Oriax')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+99-app.moved_down, text = '-1 psy,wis,rsn,san,init', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+100-app.moved_down, text = '-1 psy,wis,rsn,san,init', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # DO Curse_of_Oriax EFFECTS
        def curse_of_oriax_effect(stat):
            stat -= 1
            if stat < 1:
                return 1
            else:
                return stat
        f = curse_of_oriax_effect
        app.ent_dict[id].psyche_effects.append(f)
        app.ent_dict[id].wis_effects.append(f)
        app.ent_dict[id].rsn_effects.append(f)
        app.ent_dict[id].san_effects.append(f)
        app.ent_dict[id].init_effects.append(f)
        def un(i, lockname = None):
            app.ent_dict[i].psyche_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].wis_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].rsn_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].san_effects.remove(curse_of_oriax_effect)
            app.ent_dict[i].init_effects.remove(curse_of_oriax_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        # EOT FUNC
        def take_2(tar, lockname = None):
            app.get_focus(tar)
            lock(apply_damage, self, app.ent_dict[tar], -2, 'magick', 'Curse of Oriax', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(take_2, id)
        n = 'Curse_of_Oriax' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Curse_of_Oriax', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3666, lambda  name = 'Curse_of_Oriax' : self.cleanup_spell(name = name))
        


    def dampening_emanation(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dampening_emanation(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dampening Emanation', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dampening_emanation(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dampening_emanation(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Dampening_Emanation' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Dampening_Emanation'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Dampening_Emanation'] = Vis(name = 'Dampening_Emanation', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Dampening Emanation', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Dampening Emanation', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def damp_ef(stat):
            return max(0,stat-3)
        p = partial(damp_ef)
        prox_ef = Proximity_Effect(name = 'Dampening_Emanation', ent = ent, range = (1,2), abl = 'move_range', abl_func = p)
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys()]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        prx_name = 'Dampening_Emanation'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Dampening_Emanation' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Dampening_Emanation', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Dampening Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Dampening Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Dampening_Emanation' : self.cleanup_spell(name = name))


        
    def aura_of_agony(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_aura_of_agony(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Aura of Agony', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_aura_of_agony(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_aura_of_agony(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Aura_of_Agony' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Aura_of_Agony'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Aura_of_Agony'] = Vis(name = 'Aura_of_Agony', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+24-app.moved_down, text = 'Aura of Agony', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+25-app.moved_down, text = 'Aura of Agony', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def aura_ag_ef(stat):
            return max(1,stat-3)
        p = partial(aura_ag_ef)
        prox_ef = Proximity_Effect(name = 'Aura_of_Agony', ent = ent, range = (1,2), abl = 'san', abl_func = p)
        
        def get_locs(prx_ef):
            locs = [c for c in app.coords if prx_ef.range[0] <= dist(c,prx_ef.ent.loc) <= prx_ef.range[1]]
            locs = [c for c in locs if app.grid[c[0]][c[1]] in app.all_ents().keys() and app.ent_dict[app.grid[c[0]][c[1]]].owner != self.owner]
            return locs
        p2 = partial(get_locs, prox_ef)
        prox_ef.get_locs = p2
        
        prx_name = 'Aura_of_Agony'+str(app.count)
        app.count+=1
        app.proximity_effects_dict[prx_name] = prox_ef
        def un(prx_key, lockname = None):
            del app.proximity_effects_dict[prx_key]
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, prx_name)
        n = 'Aura_of_Agony' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Aura_of_Agony', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Agonizing Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Agonizing Presence...', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Aura_of_Agony' : self.cleanup_spell(name = name))
        
        
    def molecular_subversion(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_molecular_subversion(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Molecular Subversion', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_molecular_subversion(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_molecular_subversion(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Molecular_Subversion' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Molecular_Subversion'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Molecular_Subversion'] = Vis(name = 'Molecular_Subversion', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Molecular_Subversion'].img, tags = 'Molecular_Subversion')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Molecular Subversion', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Molecular Subversion', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def molsub_resist_effect(rs):
            return [r for r in rs if r != 'acid' and r != 'explosive']
        app.ent_dict[id].resist_effects.append(molsub_resist_effect)
        def molsub_wkns_effect(ws):
            return ws + ['acid', 'explosive']
        app.ent_dict[id].weak_effects.append(molsub_wkns_effect)
        def un(i, lockname = None):
            app.ent_dict[i].resist_effects.remove(molsub_resist_effect)
            app.ent_dict[i].weak_effects.remove(molsub_wkns_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = 'Molecular_Subversion' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Molecular_Subversion', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = 'Weak explsv and acid', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = 'Weak explsv and acid', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Molecular_Subversion' : self.cleanup_spell(name = name))
        
        
    def lift(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_lift(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Lift', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_lift(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_lift(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.magick -= self.arcane_dict['Lift'][1]
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Lift'] = Vis(name = 'Lift', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Lift', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Lift', justify = 'center', font = ('chalkduster', 16), fill = 'olivedrab2', tags = 'text')
        def lift_ef(move_type):
            return 'flying'
        p = partial(lift_ef)
        ent.move_type_effects.append(p)
        def un(ent, p, lockname = None):
            ent.move_type_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Lift' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Lift', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = 'Flying', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = 'Flying', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Lift' : self.cleanup_spell(name = name))
        
        
    def cloister(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_cloister(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Cloister', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_cloister(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cloister(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        self.magick -= self.arcane_dict['Cloister'][1]
#         effect1 = mixer.Sound('Sound_Effects/lift.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Cloister'] = Vis(name = 'Cloister', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Cloister', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Cloister', justify = 'center', font = ('chalkduster', 16), fill = 'olivedrab2', tags = 'text')
        for k,v in ent.effects_dict.items():
            v.level += 6
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = 'Effects level +6', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = 'Effects level +6', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Cloister' : self.cleanup_spell(name = name))
        
        
    def plutonian_cloak(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_plutonian_cloak(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Plutonian Cloak', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_plutonian_cloak(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_plutonian_cloak(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Plutonian_Cloak' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Plutonian_Cloak'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Plutonian_Cloak'] = Vis(name = 'Plutonian_Cloak', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Plutonian_Cloak'].img, tags = 'Plutonian_Cloak')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Plutonian Cloak', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Plutonian Cloak', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
        def plut_cloak_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (type == 'slashing' or type == 'crushing' or type == 'piercing') and (st == 'melee' or st == 'ranged'):
                if 'Plutonian_Invisibility' in [v.name for k,v in dfndr.effects_dict.items()]:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
                else:
                    app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Plutonian invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Plutonian invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
                    def plu_invis(types):
                        return types+['invisibility']
                    p = partial(plu_invis)
                    dfndr.type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, dfndr.id, p)
                    n = 'Plutonian_Cloak' + str(app.count)
                    dfndr.effects_dict[n] = Effect(name = 'Plutonian_Invisibility', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            elif st == 'spell':
                if 'Plutonian_Psyshield' in [v.name for k,v in dfndr.effects_dict.items()]:
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
                else:
                    def plu_psysh(types):
                        return types+['psyshield']
                    p = partial(plu_psysh)
                    dfndr.type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, dfndr.id, p)
                    n = 'Plutonian_Cloak' + str(app.count)
                    dfndr.effects_dict[n] = Effect(name = 'Plutonian_Psyshield', undo_func = u, duration = 1, level = self.get_abl('wis'))
                    app.canvas.create_text(dfndr.loc[0]*100+49-app.moved_right, dfndr.loc[1]*100+74-app.moved_down, text = 'Plutonian psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(dfndr.loc[0]*100+50-app.moved_right, dfndr.loc[1]*100+75-app.moved_down, text = 'Plutonian psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'orchid1', tags = 'text')
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
        app.ent_dict[id].defense_effects.append(plut_cloak_effect)
        def undo(id, lockname = None):
            app.ent_dict[id].defense_effects.remove(plut_cloak_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(undo, id)
        n = 'Plutonian_Cloak' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Plutonian_Cloak', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Plutonian_Cloak' : self.cleanup_spell(name = name))
        
        
        
        
    def mirror_armor(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mirror_armor(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mirror Armor', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mirror_armor(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mirror_armor(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Mirror_Armor' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Mirror_Armor'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mirror_Armor'] = Vis(name = 'Mirror_Armor', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+54-app.moved_down, text = 'Mirror Armor', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+55-app.moved_down, text = 'Mirror Armor', justify = 'center', font = ('chalkduster', 16), fill = 'cyan3', tags = 'text')
        def mirror_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if st == 'spell' and to_hit(atkr.get_abl('wis'),dfndr.get_abl('dodge') == False):
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Mirror Armor reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Mirror Armor reflect damage', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                ids = [k for k,v in app.all_ents().items() if 1 <= dist(v.loc,dfndr.loc)<=3]
                if ids == []:
                    root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
                else:
                    id = choice(ids)
                    app.get_focus(id)
                    ent = app.ent_dict[id]
                    n = 'Mirror_Armor'+str(app.count)
                    app.count += 1
                    app.vis_dict[n] = Vis(name = 'Mirror_Armor', loc = ent.loc[:])
                    def clean_mir(n):
                        del app.vis_dict[n]
                        app.canvas.delete(n)
                    root.after(1666, lambda n = n : clean_mir(n))
                    lock(apply_damage, atkr, ent, amt, type, 'Mirror Redirect', 'redirect')
                    app.get_focus(dfndr.id)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    return (-1, type)
            else:
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+24-app.moved_down, text = 'Pierce Mirror Armor', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+25-app.moved_down, text = 'Pierce Mirror Armor', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                return(amt, type)
        p = partial(mirror_effect)
        ent.defense_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.defense_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Mirror_Armor' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Mirror_Armor', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Mirror_Armor' : self.cleanup_spell(name = name))
        
        
    def genjutsushi(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_genjutsushi(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Genjutsushi', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_genjutsushi(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_genjutsushi(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Genjutsushi' in [v.name for k,v in ent.effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Genjutsushi'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Genjutsushi'] = Vis(name = 'Genjutsushi', loc = sqr[:])
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+54-app.moved_down, text = 'Genjutsushi', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+55-app.moved_down, text = 'Genjutsushi', justify = 'center', font = ('chalkduster', 16), fill = 'cyan3', tags = 'text')
        def genju_effect(atkr, dfndr, amt, type, sn, st, lockname = None):
            if (st == 'melee' or st == 'ranged') and 'Genju_Invisibility' not in [v.name for k,v in atkr.effects_dict.items()]:
                app.canvas.create_text(atkr.loc[0]*100+49-app.moved_right, atkr.loc[1]*100+74-app.moved_down, text = 'Genjutsushi invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                app.canvas.create_text(atkr.loc[0]*100+50-app.moved_right, atkr.loc[1]*100+75-app.moved_down, text = 'Genjutsushi invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'cyan3', tags = 'text')
                def genju_invis(types):
                    return types+['invisibility']
                p = partial(genju_invis)
                atkr.type_effects.append(p)
                def undo(ent, func, lockname = None):
                    ent.type_effects.remove(func)
                    root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                u = partial(undo, atkr, p)
                n = 'Genjutsushi' + str(app.count)
                atkr.effects_dict[n] = Effect(name = 'Genju_Invisibility', undo_func = u, duration = 1, level = atkr.get_abl('agl'))
                root.after(1222, lambda t = 'text' : app.canvas.delete(t))
                root.after(1333, lambda ln = lockname : app.dethloks[ln].set(1))
                return (amt, type)
            else:
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                return(amt, type)
        p = partial(genju_effect)
        ent.attack_effects.append(p)
        def undo(ent, p, lockname = None):
            ent.attack_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(undo, ent, p)
        n = 'Genjutsushi' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Genjutsushi', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Genjutsushi' : self.cleanup_spell(name = name))
        
        
        
        
    def gift_of_mars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gift_of_mars(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose target for Gift of Mars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gift_of_mars(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gift_of_mars(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Gift_of_Mars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Gift_of_Mars'][1]
#         effect1 = mixer.Sound('Sound_Effects/gift_of_mars.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Gift_of_Mars'] = Vis(name = 'Gift_of_Mars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Gift_of_Mars'].img, tags = 'Gift_of_Mars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Gift of Mars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Gift of Mars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Msl, MM, Psy', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Msl, MM, Psy', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def gift_of_mars_stat_effect(stat):
            return stat+1
        p = partial(gift_of_mars_stat_effect)
        ent.msl_effects.append(p)
        ent.mm_effects.append(p)
        ent.psyche_effects.append(p)
        def un(ent, p, lockname = None):
            ent.msl_effects.remove(p)
            ent.mm_effects.remove(p)
            ent.psyche_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Gift_of_Mars' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Gift_of_Mars', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Gift_of_Mars' : self.cleanup_spell(name = name))
        
        
        
    def mercurys_blessing(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mercurys_blessing(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Choose target for Mercury's Blessing", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mercurys_blessing(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mercurys_blessing(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if "Mercury's_Blessing" in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict["Mercury's_Blessing"][1]
#         effect1 = mixer.Sound('Sound_Effects/mercurys_blessing.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict["Mercury's_Blessing"] = Vis(name = "Mercury's_Blessing", loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict["Mercury's_Blessing"].img, tags = "Mercury's_Blessing")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = "Mercury's Blessing", justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = "Mercury's Blessing", justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Agl, Dod, Move range', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Agl, Dod, Move range', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def merc_blessing_stat_effect(stat):
            return stat+1
        p = partial(merc_blessing_stat_effect)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        ent.move_range_effects.append(p)
        def un(ent, p, lockname = None):
            ent.agl_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.move_range_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Mercurys_Blessing' + str(app.count)
        ent.effects_dict[n] = Effect(name = "Mercury's_Blessing", undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = "Mercury's_Blessing" : self.cleanup_spell(name = name))
        
        
    def iron_spirit(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_iron_spirit(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Iron Spirit', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_iron_spirit(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_iron_spirit(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Iron_Spirit' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Iron_Spirit'][1]
#         effect1 = mixer.Sound('Sound_Effects/iron_spirit.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Iron_Spirit'] = Vis(name = 'Iron_Spirit', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Iron_Spirit'].img, tags = 'Iron_Spirit')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Iron Spirit', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Iron Spirit', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Str, End, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Str, End, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def iron_spirit_stat_effect(stat):
            return stat+1
        p = partial(iron_spirit_stat_effect)
        ent.str_effects.append(p)
        ent.end_effects.append(p)
        ent.wis_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.end_effects.remove(p)
            ent.wis_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Iron_Spirit' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Iron_Spirit', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Iron_Spirit' : self.cleanup_spell(name = name))
        
    def strength_of_the_void(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_sotv(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Strength of the Void', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_sotv(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_sotv(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Strength_of_the_Void' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Strength_of_the_Void'][1]
#         effect1 = mixer.Sound('Sound_Effects/strength_of_the_void.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Strength_of_the_Void'] = Vis(name = 'Strength_of_the_Void', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Strength_of_the_Void'].img, tags = 'Strength_of_the_Void')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Strength of the Void', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Strength of the Void', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Str, Psy, End', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Str, Psy, End', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def sotv_stat_effect(stat):
            return stat+1
        p = partial(sotv_stat_effect)
        ent.str_effects.append(p)
        ent.psyche_effects.append(p)
        ent.end_effects.append(p)
        def un(ent, p, lockname = None):
            ent.str_effects.remove(p)
            ent.psyche_effects.remove(p)
            ent.end_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Sotv' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Strength_of_the_Void', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Strength_of_the_Void' : self.cleanup_spell(name = name))
        
        
    def hidden_from_the_stars(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_hfts(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Hidden From the Stars', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_hfts(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_hfts(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if isinstance(app.ent_dict[id], Witch):
            return
        if 'Hidden_From_the_Stars' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        self.magick -= self.arcane_dict['Hidden_From_the_Stars'][1]
        effect1 = mixer.Sound('Sound_Effects/hidden_from_the_stars.ogg')
        effect1.set_volume(.9)
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Hidden_From_the_Stars'] = Vis(name = 'Hidden_From_the_Stars', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Hidden_From_the_Stars'].img, tags = 'Hidden_From_the_Stars')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Hidden From the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Hidden From the Stars', justify = 'center', font = ('chalkduster', 14), fill = 'turquoise', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = '+1 Agl, Dod, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = '+1 Agl, Dod, Wis', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        def hfts_stat_effect(stat):
            return stat+1
        p = partial(hfts_stat_effect)
        ent.wis_effects.append(p)
        ent.dodge_effects.append(p)
        ent.agl_effects.append(p)
        def un(ent, p, lockname = None):
            ent.wis_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.agl_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Hfts' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Hidden_From_the_Stars', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2111, lambda  name = 'Hidden_From_the_Stars' : self.cleanup_spell(name = name))
        
        
    def cosmic_sight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= 3]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_cosmic_sight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Cosmic Sight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_cosmic_sight(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_cosmic_sight(self, event, sqr, sqrs):
        self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.cleanup_squares()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Cosmic_Sight'][1]
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Cosmic_Sight'] = Vis(name = 'Cosmic_Sight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Cosmic_Sight'].img, tags = 'Cosmic_Sight')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Cosmic Sight', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Cosmic Sight', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
        # all enemy w/i range 3 make psy save(-1) or lose psyshield
        ids = [k for k,v in app.all_ents().items() if v.loc in sqrs and v.owner != self.owner]
        if ids == []:
            root.after(1666, lambda  name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
        else:
            root.after(1666, lambda ids = ids : self.continue_cosmic_sight(ids))
    
    def continue_cosmic_sight(self, ids):
        def cosmic_loop(ids):
            if ids == []:
                root.after(1666, lambda  name = 'Cosmic_Sight' : self.cleanup_spell(name = name))
            else:
                id = ids[0]
                ids = ids[1:]
                app.get_focus(id)
                if app.ent_dict[id].save_check('wis',mod = -2) == 'Fail':
                    un = 'Cosmic_Sight'+str(app.count)
                    app.count += 1
                    def clean_cosmic_sight(name):
                        app.canvas.delete(name)
                        del app.vis_dict[name]
                        app.canvas.delete('text')
                    sqr = app.ent_dict[id].loc[:]
                    app.vis_dict[un] = Vis(name = 'Cosmic_Sight', loc = sqr[:])
                    app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                    app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Psyshield Removed', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Psyshield Removed', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                    def cosmic_effect(types):
                        return [t for t in types if t != 'psyshield']
                    p = partial(cosmic_effect)
                    app.ent_dict[id].type_effects.append(p)
                    def undo(id, func, lockname = None):
                        app.ent_dict[id].type_effects.remove(func)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, id, p)
                    n = 'Cosmic_Sight' + str(app.count)
                    app.ent_dict[id].effects_dict[n] = Effect(name = 'Cosmic_Sight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1555, lambda un = un : clean_cosmic_sight(un))
                    root.after(1666, lambda ids = ids : cosmic_loop(ids))
                else:
                    sqr = app.ent_dict[id].loc[:]
                    app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Wisdom Save', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Wisdom Save', justify = 'center', font = ('chalkduster', 13), fill = 'turquoise', tags = 'text')
                    root.after(1555, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1666, lambda ids = ids : cosmic_loop(ids))
        cosmic_loop(ids)
        
        
    def demonic_sight(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_demonic_sight(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Demonic Sight', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_demonic_sight(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_demonic_sight(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Demonic_Sight'][1]
#         effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
#         effect1.set_volume(.9)
#         sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Demonic_Sight'] = Vis(name = 'Demonic_Sight', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Demonic_Sight'].img, tags = 'Demonic_Sight')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Demonic Sight', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Demonic Sight', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        my_psy = self.get_abl('psyche')
        tar_psy = app.ent_dict[id].get_abl('psyche')
        if to_hit(my_psy, tar_psy) == True:
            ent = app.ent_dict[id]
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Lose invisibility...', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Lose invisibility...', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
            def demonic_invis(types):
                return [t for t in types if t != 'invisibility']
            p = partial(demonic_invis)
            app.ent_dict[id].type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Demonic_Sight' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Demonic_Sight', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        else:
            miss(app.ent_dict[id].loc)
        root.after(2666, lambda  name = 'Demonic_Sight' : self.cleanup_spell(name = name))
        
        
    def mass_hysteria(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        root.bind('<a>', self.do_mass_hysteria)
        b = tk.Button(app.context_menu, text = 'Confirm Mass Hysteria', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_mass_hysteria(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mass_hysteria(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Mass_Hysteria'][1]
        app.unbind_all()
        app.depop_context(event = None)
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Mass Hysteria', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Mass Hysteria', justify = 'center', font = ('chalkduster', 16), fill = 'green3', tags = 'text')
        def cleanup_hysteria(name):
            del app.vis_dict[name]
            app.canvas.delete(name)
        def hysteria_loop(ids):
            if ids == []:
                self.cleanup_spell(name = 'Mass_Hysteria')
            else:
                id = ids[0]
                ids = ids[1:]
                ent = app.ent_dict[id]
                app.get_focus(id)
                name = 'Mass_Hysteria'+str(app.count)
                app.count += 1
                app.vis_dict[name] = Vis(name = 'Mass_Hysteria', loc = ent.loc[:])
                if to_hit(self.get_abl('wis'),ent.get_abl('wis')):
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+34-app.moved_down, text = '-5 sanity', justify = 'center', font = ('chalkduster', 16), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+35-app.moved_down, text = '-5 sanity', justify = 'center', font = ('chalkduster', 16), fill = 'green3', tags = 'text')
                    def hys_ef(stat):
                        return max(1,stat-5)
                    p = partial(hys_ef)
                    ent.san_effects.append(p)
                    def undo(ent, p, lockname = None):
                        ent.san_effects.remove(p)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(undo, ent, p)
                    n = 'Mass_Hysteria' + str(app.count)
                    ent.effects_dict[n] = Effect(name = 'Mass_Hysteria', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
                    root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda n = name : cleanup_hysteria(n))
                    root.after(1999, lambda ids = ids : hysteria_loop(ids))
                else:
                    miss(ent.loc)
                    root.after(1777, lambda t = 'text' : app.canvas.delete(t))
                    root.after(1888, lambda n = name : cleanup_hysteria(n))
                    root.after(1999, lambda ids = ids : hysteria_loop(ids))
        ids = app.init_q[:5]
        root.after(1333, lambda t = 'text' : app.canvas.delete(t))
        root.after(1444, lambda ids = ids : hysteria_loop(ids))
        
        
    def blind(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_blind(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Blind', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_blind(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_blind(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Blind' in effs:
            return
        self.magick -= self.arcane_dict['Blind'][1]
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Blind'] = Vis(name = 'Blind', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Blind'].img, tags = 'Blind')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Blind', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Blind', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def blind_efct(stat):
            return max(1, stat-3)
        p = partial(blind_efct)
        ent.rsn_effects.append(p)
        ent.bls_effects.append(p)
        def un(ent, p, lockname = None):
            ent.rsn_effects.remove(p)
            ent.bls_effects.remove(p)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p)
        n = 'Blind' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Blind', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = ent.loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-3 ballistics, reason', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-3 ballistics, reason', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Blind' : self.cleanup_spell(name = name))
        
        
    def gravity(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_gravity(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Gravity', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_gravity(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_gravity(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if 'Gravity' in [v.name for k,v in ent.effects_dict.items()]:
            return
        if ent.immovable == True:
            return
        self.magick -= self.arcane_dict['Gravity'][1]
        effect1 = mixer.Sound('Sound_Effects/gravity.ogg')
        effect1.set_volume(.9)
        sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Gravity'] = Vis(name = 'Gravity', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Gravity'].img, tags = 'Gravity')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+84-app.moved_down, text = 'Gravity', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+85-app.moved_down, text = 'Gravity', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        # DO gravity EFFECTS
        def grav_minus2(stat):
            return max(1, stat-2)
        p = partial(grav_minus2)
        ent.agl_effects.append(p)
        ent.dodge_effects.append(p)
        def gravity_move(move_range):
            return max(0,move_range-2)
        p2 = partial(gravity_move)
        ent.move_range_effects.append(p2)
        def un(ent, p, p2, lockname = None):
            ent.agl_effects.remove(p)
            ent.dodge_effects.remove(p)
            ent.move_range_effects.remove(p2)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, ent, p, p2)
        n = 'Gravity' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Gravity', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = app.ent_dict[id].loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-2 move range, agl, dod', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-2 move range, agl, dod', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Gravity' : self.cleanup_spell(name = name))
        
    # change to: must choose ranged tar, rang2-6, lightning strike main tar, still do adj fire
    def beleths_command(self, event = None):
        app.depop_context(event = None)
        sqrs = [c for c in app.coords if 2 <= dist(self.loc, c) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<q>', self.cleanup_spell)
        root.bind('<a>', lambda e, sqr = grid_pos, sqrs = sqrs : self.do_beleths_command(sqr = sqr, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = "Beleth's Command Target", wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda sqr = grid_pos, sqrs = sqrs : self.do_beleths_command(sqr = sqr, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_beleths_command(self, event = None, sqr = None, sqrs = None):
        global selected_vis
        if self.mvs < 1:
            return
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id == '' or id == 'block':
            return
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict["Beleth's_Command"][1]
        effect1 = mixer.Sound('Sound_Effects/beleths_command.ogg')
        effect1.set_volume(.7)
        sound_effects.play(effect1, 0)
        self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        self.mvs -= 1
        app.focus_square(self.loc)
        app.vis_dict["Beleth's_Command"] = Vis(name = "Beleth's_Command", loc = self.loc)
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down, image = app.vis_dict["Beleth's_Command"].img, tags = "Beleth's_Command")
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+9-app.moved_down, text = "Beleth's Command", justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+10-app.moved_down, text = "Beleth's Command", justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab', tags = 'text')
        # LIGHTNING VIS
        selected_vis.append("Beleth's_Lightning")
        loc = app.ent_dict[id].loc[:]
        def cleanup_lightning():
            app.canvas.delete("Beleth's_Lightning")
            del app.vis_dict["Beleth's_Lightning"]
        app.vis_dict["Beleth's_Lightning"] = Vis(name = "Beleth's_Lightning", loc = loc)
        app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict["Beleth's_Lightning"].img, tags = "Beleth's_Lightning")
        x2 = loc[0]*100+50-app.moved_right
        y2 = loc[1]*100+50-app.moved_down
        def beleths_lightning(timeout):
            if timeout > 0:
                app.vis_dict["Beleth's_Lightning"].rotate_image()
                app.canvas.delete("Beleth's_Lightning")
                app.canvas.create_image(x2, y2, image = app.vis_dict["Beleth's_Lightning"].img, tags = "Beleth's_Lightning")
                timeout -= 1
                root.after(60, lambda t = timeout : beleths_lightning(t))
            else:
                cleanup_lightning()
        app.get_focus(id)
        beleths_lightning(8)
        # BURN AT STAKE LOOP
        selected_vis = ["Beleth's_Command"]
        def cleanup_beleths_fire():
            app.canvas.delete("Beleth's_Command")
            del app.vis_dict["Beleth's_Command"]
        x = self.loc[0]*100+50-app.moved_right
        y = self.loc[1]*100+50-app.moved_down
        def beleths_loop(timeout):
            if timeout > 0:
                app.vis_dict["Beleth's_Command"].rotate_image()
                app.canvas.delete("Beleth's_Command")
                app.canvas.create_image(x, y, image = app.vis_dict["Beleth's_Command"].img, tags = "Beleth's_Command")
                app.canvas.tag_lower("Beleth's_Command", (self.tags))
                timeout -= 1
                root.after(99, lambda t = timeout : beleths_loop(t))
            else:
                cleanup_beleths_fire()
        beleths_loop(30)
        # LIGHTNING EFFECTS ranged target, dmg, stun chance
        my_psyche = self.get_abl('psyche')
        tar_psyche = app.ent_dict[id].get_abl('psyche')
        d1 = damage(my_psyche, tar_psyche)
        s1 = app.ent_dict[id].loc[:]
        lock(apply_damage, self, app.ent_dict[id], -d1, 'elec', 'Lightning Strike', 'spell')
        # if tar still alive, stun chance
        if id in app.all_ents().keys() and to_hit(self.get_abl('psyche'),app.ent_dict[id].get_abl('str')) and 'Beleth_Stun' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]: # Fail Save
            app.canvas.create_text(s1[0]*100-app.moved_right+49, s1[1]*100-app.moved_down+84, text = 'Stun, -1 mvs', justify = 'center', fill = 'black', font = ('chalkduster', 13), tags = 'text')
            app.canvas.create_text(s1[0]*100-app.moved_right+50, s1[1]*100-app.moved_down+85, text = 'Stun, -1 mvs', justify = 'center', fill = 'white', font = ('chalkduster', 13), tags = 'text')
            def beleths_stun_effect(amt):
                return max(0,amt-1)
            p_stun = partial(beleths_stun_effect)
            app.ent_dict[id].mvs_effects.append(p_stun)
            app.ent_dict[id].mvs -= 1
            def un(i, func, lockname = None):
                app.ent_dict[i].mvs_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, id, p_stun)
            n = 'Beleth_Stun' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Beleth_Stun', undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        ents = [k for k,v in app.all_ents().items() if dist(v.loc, self.loc) == 1]
        root.after(2555, lambda t = 'text' : app.canvas.delete(t))
        root.after(2666, lambda ents = ents : self.finish_beleths(ents))
        
    def finish_beleths(self, ents):
        for e in ents:
            s = app.ent_dict[e].loc[:]
            app.focus_square(s)
#             app.canvas.delete('text')
            uniq_name = 'Immolate'+str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Immolate', loc = s) # using Immolate animations
            app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = "Beleth's_Command")
            d = damage(self.get_abl('psyche'),app.ent_dict[e].get_abl('psyche'))
            lock(apply_damage, self, app.ent_dict[e], -d, 'fire', 'Witchfire', 'spell')
            def clean_beleths_command(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(3666, lambda n = uniq_name : clean_beleths_command(n))
        # DO Beleth's Command EFFECTS ON CASTER
        effs = [v.name for k,v in self.effects_dict.items()]
        if "Beleth's_Command" not in effs:
            def beleths_command_effect(stat):
                stat += 1
                return stat
            f = beleths_command_effect
            self.end_effects.append(f)
            self.psyche_effects.append(f)
            def un(i, lockname = None):
                app.ent_dict[i].end_effects.remove(beleths_command_effect)
                app.ent_dict[i].psyche_effects.remove(beleths_command_effect)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            p = partial(un, self.id)
            self.effects_dict["Beleth's_Command"] = Effect(name = "Beleth's_Command", undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(3666, lambda  name = "Beleth's_Command" : self.cleanup_spell(name = name))
        
        
# FAKIR ALI SPELLS
        # Ali's spells center around Heat/Fire/Resistance/Mummification
    def legerdemain(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Legerdemain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_legerdemain(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose First Target', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_legerdemain(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_legerdemain(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Legerdemain'][1]
        root.bind('<q>', lambda name = 'Legerdemain' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs, id = id : self.cont_legerdemain(event = e, sqr = s, sqrs = sqrs, id1 = id))
        b = tk.Button(app.context_menu, text = 'Choose Second Target', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs, id = id : self.cont_legerdemain(e, s, sqrs, id))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        
    def cont_legerdemain(self, event, sqr, sqrs, id1):
        if sqr not in sqrs:
            return
        id2 = app.grid[sqr[0]][sqr[1]]
        if id2 not in app.spell_target_ents().keys():
            return
        if id1 == id2:
            return
        app.depop_context(event = None)
        app.unbind_nonarrows()
        app.cleanup_squares()
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Legerdemain', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Legerdemain', justify = 'center', font = ('chalkduster', 13), fill = 'darkorchid1', tags = 'text')
        # have each call teleport move, same time, no need to avoid ent or vis loc collision
        loc1 = app.ent_dict[id1].loc[:]
        loc2 = app.ent_dict[id2].loc[:]
        app.ent_dict[id1].leger_move(loc2)
        app.ent_dict[id2].leger_move(loc1)
        def assign_loc(id, loc):
            app.grid[loc[0]][loc[1]] = id
#         root.after(666, lambda id2 = id2, loc1 = loc1 : app.ent_dict[id2].leger_move(loc1))
        root.after(1777, lambda loc1 = loc1, id2 = id2 : assign_loc(id2, loc1))
        root.after(1888, lambda loc2 = loc2, id1 = id1 : assign_loc(id1, loc2))
        root.after(2111, lambda  name = 'Legerdemain' : self.cleanup_spell(name = name))

        
    def meditate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Meditate' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_meditate)
        b = tk.Button(app.context_menu, text = 'Confirm Meditate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_meditate(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_meditate(self, event):
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        self.magick -= self.arcane_dict['Meditate'][1]
        id = self.id
        sqr = self.loc[:]
        app.vis_dict['Meditate'] = Vis(name = 'Meditate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Meditate'].img, tags = 'Meditate')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Meditate', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Meditate', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
        # DO Meditate EFFECTS
        def meditate_effect(stat):
            stat += 1
            return stat
        f = meditate_effect
        app.ent_dict[id].psyche_effects.append(f)
############################################
        def meditate_move(move_range):
            return move_range + 2
        app.ent_dict[id].move_range_effects.append(meditate_move)
        def un(i, lockname = None):
            app.ent_dict[i].psyche_effects.remove(meditate_effect)
            app.ent_dict[i].move_range_effects.remove(meditate_move)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        n = 'Meditate' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Meditate', undo_func = p, duration = 1, level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Meditate' : self.cleanup_spell(name = name))
        
        
    def mind_rot(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= max(1,self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mind_rot(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mind Rot', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mind_rot(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mind_rot(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Mind_Rot' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        ent = app.ent_dict[id]
        if isinstance(id, Witch):
            return
        self.magick -= self.arcane_dict['Mind_Rot'][1]
        effect1 = mixer.Sound('Sound_Effects/disintegrate.ogg')
        effect1.set_volume(.9)
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mind_Rot'] = Vis(name = 'Mind_Rot', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mind_Rot'].img, tags = 'Mind_Rot')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Mind Rot', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Mind Rot', justify = 'center', font = ('chalkduster', 14), fill = 'olivedrab2', tags = 'text')
        def mind_rot_effect(stat):
            return max(1, stat-3)
        p = partial(mind_rot_effect)
        def mind_rot_wis(stat):
            return max(1, stat-2)
        p2 = partial(mind_rot_wis)
        def mind_rot_rsn(stat):
            return max(1, stat-1)
        p3 = partial(mind_rot_rsn)
        ent.san_effects.append(p)
        ent.wis_effects.append(p2)
        ent.rsn_effects.append(p3)
        def un(id, p, p2, p3, lockname = None):
            app.ent_dict[id].san_effects.remove(p)
            app.ent_dict[id].wis_effects.remove(p2)
            app.ent_dict[id].rsn_effects.remove(p3)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, p, p2, p3)
        n = 'Mind_Rot' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Mind_Rot', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        loc = ent.loc
        app.canvas.create_text(loc[0]*100+49-app.moved_right, loc[1]*100+84-app.moved_down, text = '-1 rsn, -2 wis, -3 san', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
        app.canvas.create_text(loc[0]*100+50-app.moved_right, loc[1]*100+85-app.moved_down, text = '-1 rsn, -2 wis, -3 san', justify = 'center', font = ('chalkduster', 13), fill = 'olivedrab2', tags = 'text')
        root.after(2666, lambda  name = 'Mind_Rot' : self.cleanup_spell(name = name))
        
    def horrid_wilting(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Horrid_Wilting' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_horrid_wilting(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Location For Horrid Wilting', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_horrid_wilting(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_horrid_wilting(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        effect1 = mixer.Sound('Sound_Effects/horrid_wilting.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Horrid_Wilting'][1]
        ents = [k for k,v in app.all_ents().items() if dist(v.loc,sqr) <= 2]
        def horrid_loop(ents):
            if ents == []:
                root.after(666, lambda  name = 'Horrid_Wilting' : self.cleanup_spell(name = name))
            else:
                id = ents[0]
                ents = ents[1:]
                app.get_focus(id)
                n = 'Horrid_Wilting' + str(app.count) # not an effect, just need unique int
                app.count += 1 # that is why this is incr manually here, no Effect init
                loc = app.ent_dict[id].loc[:]
                app.vis_dict[n] = Vis(name = 'Horrid_Wilting', loc = loc)
                def cleanup_vis(name):
                    del app.vis_dict[name]
                    app.canvas.delete(name)
                    app.canvas.delete('text')
                rand_start_anim = randrange(1,7)
                for i in range(rand_start_anim):
                    app.vis_dict[n].rotate_image()
                app.canvas.create_image(loc[0]*100+50-app.moved_right, loc[1]*100+50-app.moved_down, image = app.vis_dict[n].img, tags = n)
                # tohit?
                if to_hit(self.get_abl('wis'),app.ent_dict[id].get_abl('wis')):
                    my_psyche = self.get_abl('psyche')
                    tar_end = app.ent_dict[id].get_abl('end')
                    d = damage(my_psyche, tar_end)
                    root.after(1555, lambda n = n : cleanup_vis(n))
                    lock(apply_damage, self, app.ent_dict[id], -d, 'acid', 'Horrid Wilting', 'spell')
                    root.after(111, lambda ents = ents : horrid_loop(ents))
                else:
                    miss(app.ent_dict[id].loc)
                    root.after(1555, lambda n = n : cleanup_vis(n))
                    root.after(1666, lambda ents = ents : horrid_loop(ents))
        horrid_loop(ents)
        
        
    def grasp_of_the_old_ones(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_grasp(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Grasp', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_grasp(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_grasp(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.all_ents().keys():
            return
#         effect1 = mixer.Sound('Sound_Effects/grasp_of_the_old_ones.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Grasp_of_the_Old_Ones'][1]
        ent = app.ent_dict[id]
        app.vis_dict['Grasp_of_the_Old_Ones'] = Vis(name = 'Grasp_of_the_Old_Ones', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Grasp_of_the_Old_Ones'].img, tags = 'Grasp_of_the_Old_Ones')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Grasp of the Old Ones', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Grasp of the Old Ones', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        my_psy = self.get_abl('psyche')
        tar_psy = ent.get_abl('psyche')
        if to_hit(my_psy, tar_psy):
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+84-app.moved_down, text = 'Lose psyshield, invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+85-app.moved_down, text = 'Lose psyshield, invisibility', justify = 'center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
            def grasp_effect(types):
                return [t for t in types if t != 'psyshield' or t != 'invisibility']
            p = partial(grasp_effect)
            ent.type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Grasp_of_the_Old_Ones' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Grasp_of_the_Old_Ones', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
            root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        

        root.after(2333, lambda  name = 'Grasp_of_the_Old_Ones' : self.cleanup_spell(name = name))
        
    def boiling_blood(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Boiling_Blood' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_boiling_blood(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Boiling Blood', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_boiling_blood(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_boiling_blood(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        ent = app.ent_dict[id]
        if ent.owner != self.owner:
            return
        effs = [v.name for k,v in ent.effects_dict.items()]
        if 'Boiling_Blood' in effs:
            return
        effect1 = mixer.Sound('Sound_Effects/boiling_blood.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        app.cleanup_squares()
        self.magick -= self.arcane_dict['Boiling_Blood'][1]
        app.vis_dict['Boiling_Blood'] = Vis(name = 'Boiling_Blood', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Boiling_Blood'].img, tags = 'Boiling_Blood')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = 'Boiling\nBlood', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        # DO Boiling_Blood EFFECTS
        def boiling_blood_str_effect(stat):
            stat += 4
            return stat
        def boiling_blood_end_effect(stat):
            return max(1, stat-4)
        ent.str_effects.append(boiling_blood_str_effect)
        ent.end_effects.append(boiling_blood_end_effect)
        def un(i, lockname = None):
            app.ent_dict[i].str_effects.remove(boiling_blood_str_effect)
            app.ent_dict[i].end_effects.remove(boiling_blood_end_effect)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p = partial(un, id)
        # EOT FUNC
        def take_2(tar, lockname = None):
            app.get_focus(tar)
            lock(apply_damage, self, app.ent_dict[tar], -2, 'fire', 'Boiling Blood', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(take_2, id)
        n = 'Boiling_Blood' + str(app.count)
        ent.effects_dict[n] = Effect(name = 'Boiling_Blood', eot_func = eot, undo_func = p, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2333, lambda  name = 'Boiling_Blood' : self.cleanup_spell(name = name))
        
    
        
    def dark_sun(self, event = None):
        app.depop_context(event = None)
        app.unbind_nonarrows()
        root.bind('<q>', lambda name = 'Dark_Sun' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if dist(self.loc, s) == 1]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dark_sun(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dark Sun', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dark_sun(e, s, sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dark_sun(self, event, sqr, sqrs):
        global selected_vis
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        if 'Dark_Sun' in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
            return
        effect1 = mixer.Sound('Sound_Effects/dark_sun.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.depop_context(event = None)
        app.unbind_all()
        self.magick -= self.arcane_dict['Dark_Sun'][1]
        app.cleanup_squares()
        app.vis_dict['Dark_Sun'] = Vis(name = 'Dark_Sun', loc = sqr[:]) #[sqr[0],sqr[1]-1])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Dark_Sun'].img, tags = 'Dark_Sun')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down+14, text = 'Dark Sun', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+50-app.moved_down+15, text = 'Dark Sun', justify ='center', font = ('chalkduster', 14), fill = 'ghostwhite', tags = 'text')
        selected_vis = ['Dark_Sun']
        def dark_sun_loop(starty, endy, x):
            if starty > endy:
                app.vis_dict['Dark_Sun'].rotate_image()
                app.canvas.delete('Dark_Sun')
                app.canvas.create_image(x, starty, image = app.vis_dict['Dark_Sun'].img, tags = 'Dark_Sun')
                starty -= 10
                app.canvas.move('Dark_Sun', 0, -10)
                app.canvas.tag_raise('Dark_Sun')
            if starty == endy:
                root.after(1333, lambda  name = 'Dark_Sun' : self.cleanup_spell(name = name))
            else:
                root.after(299, lambda sy = starty, ey = endy, x = x : dark_sun_loop(sy, ey, x))
        locy = sqr[1]*100+70-app.moved_down
        locx = sqr[0]*100+50-app.moved_right
        # Effect
        if app.ent_dict[id].save_check('wis') == 'Pass':
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+49-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+74, text = '+1 actions', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+75, text = '+1 actions', justify ='center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
            def dark_acts(acts):
                return acts+1
            p = partial(dark_acts)
            app.ent_dict[id].acts_effects.append(p)
            app.ent_dict[id].acts += 1
            def undo(id, func, lockname = None):
                app.ent_dict[id].acts_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Dark_Sun' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Dark_Sun', undo_func = u, duration = 1, level = self.get_abl('wis'))
        else:
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+74, text = 'Save fail...', justify ='center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(app.ent_dict[id].loc[0]*100+50-app.moved_right, app.ent_dict[id].loc[1]*100+50-app.moved_down+75, text = 'Save fail...', justify ='center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        dark_sun_loop(locy, locy-90, locx)

        
    # change mummify, too good with leap still make useful combo, disable leap
    def mummify(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_mummify(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Mummify', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_mummify(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_mummify(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Mummify' in effs:
            return
        effect1 = mixer.Sound('Sound_Effects/mummify.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        self.magick -= self.arcane_dict['Mummify'][1]
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Mummify'] = Vis(name = 'Mummify', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Mummify'].img, tags = 'Mummify')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Mummify', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Mummify', justify = 'center', font = ('chalkduster', 14), fill = 'darkgoldenrod', tags = 'text')
        # DO Mummify EFFECTS
        def mummify_effect(stat):
            stat += 4
            return stat
        f = mummify_effect
        app.ent_dict[id].end_effects.append(f)
        def mummy_moves(move_range):
            if move_range < 2:
                return move_range
            else:
                return 1
        app.ent_dict[id].move_range_effects.append(mummy_moves)
        if isinstance(app.ent_dict[id], Berserker):
            app.ent_dict[id].leap_used = True
        def sot(id, lockname = None):
            if isinstance(app.ent_dict[id], Berserker):
                app.ent_dict[id].leap_used = True
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        p_sot = partial(sot, id)
        def un(i, lockname = None):
            app.ent_dict[i].end_effects.remove(mummify_effect)
            app.ent_dict[i].move_range_effects.remove(mummy_moves)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id)
        n = 'Mummify' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Mummify', undo_func = u, sot_func = p_sot, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Mummify' : self.cleanup_spell(name = name))
        
        
    def dust_devil(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dust_devil(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dust Devil', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dust_devil(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dust_devil(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Dust_Devil'][1]
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Dust Devil', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Dust Devil', justify = 'center', font = ('chalkduster', 14), fill = 'goldenrod', tags = 'text')
        ent = app.ent_dict[id]
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        n = 'Dust_Devil'+str(app.count)
        app.count += 1
        app.vis_dict[n] = Vis(name = 'Dust_Devil', loc = sqr[:])
        def cleanup_dustd(n):
            del app.vis_dict[n]
            app.canvas.delete(n)
        root.after(1999, lambda n = n : cleanup_dustd(n))
        if to_hit(my_wis, tar_wis):
            my_psyche = self.get_abl('psyche')
            tar_psyche = ent.get_abl('psyche')
            d = damage(my_psyche, tar_psyche)
            locs = [c for c in app.coords if dist(c,ent.loc) <= self.get_abl('psyche') and app.grid[c[0]][c[1]] == '']
            if locs != []:
                newloc = reduce(lambda a,b : a if dist(a,self.loc)>dist(b,self.loc) else b, locs)
                lock(ent.throw_move, newloc)
                app.canvas.delete('text')
                app.get_focus(id)
            lock(apply_damage, self, ent, -d, 'explosive', 'Dust Devil', 'spell')
            root.after(333, lambda  name = 'Dust_Devil' : self.cleanup_spell(name = name))
        else:
            miss(ent.loc)
            root.after(1666, lambda  name = 'Dust_Devil' : self.cleanup_spell(name = name))
        
        
    def dispel(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_dispel(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Dispel', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_dispel(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_dispel(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.action_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Dispel'][1]
#         effect1 = mixer.Sound('Sound_Effects/dispel.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        ent = app.ent_dict[id]
        app.vis_dict['Dispel'] = Vis(name = 'Dispel', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Dispel'].img, tags = 'Dispel')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Dispel', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Dispel', justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
        my_wis = self.get_abl('wis')
        tar_wis = ent.get_abl('wis')
        misswatch = 0
        if to_hit(my_wis, tar_wis):
            misswatch += 1
            spacer = 30
            to_remove = []
            for k,v in ent.effects_dict.items():
                if v.dispel(self.get_abl('wis')) == 'Dispelled':
                    to_remove.append(k)
                    if spacer > 300:
                        continue
                    app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+spacer-app.moved_down, text = 'Dispel '+v.name.replace('_',' '), justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
                    spacer += 15
            for k in to_remove:
                del app.ent_dict[id].effects_dict[k]
        if to_hit(my_wis, tar_wis):
            misswatch += 1 
            app.canvas.create_text(ent.loc[0]*100+49-app.moved_right, ent.loc[1]*100+14-app.moved_down, text = 'Lose psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(ent.loc[0]*100+50-app.moved_right, ent.loc[1]*100+15-app.moved_down, text = 'Lose psyshield', justify = 'center', font = ('chalkduster', 14), fill = 'darkorchid1', tags = 'text')
            def dispel_effect(types):
                return [t for t in types if t != 'psyshield']
            p = partial(dispel_effect)
            ent.type_effects.append(p)
            def undo(id, func, lockname = None):
                app.ent_dict[id].type_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(undo, id, p)
            n = 'Dispel' + str(app.count)
            ent.effects_dict[n] = Effect(name = 'Dispel', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        if misswatch == 0:
            miss(ent.loc)
        root.after(2666, lambda  name = 'Dispel' : self.cleanup_spell(name = name))
        
    def immolate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= max(1,self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_immolate(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Immolate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_immolate(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_immolate(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        self.magick -= self.arcane_dict['Immolate'][1]
#         self.init_cast_anims()
        effect1 = mixer.Sound('Sound_Effects/immolate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Immolate'] = Vis(name = 'Immolate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Immolate'].img, tags = 'Immolate')
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Immolate', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Immolate', justify = 'center', font = ('chalkduster', 14), fill = 'indianred3', tags = 'text')
        my_psyche = self.get_abl('psyche')
        tar_psyche = app.ent_dict[id].get_abl('psyche')
        d = damage(my_psyche, tar_psyche)
        lock(apply_damage, self, app.ent_dict[id], -d, 'fire', 'Immolate', 'spell')
        root.after(333, lambda  name = 'Immolate' : self.cleanup_spell(name = name))
        
        
    def disintegrate(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if 1 <= dist(self.loc, s) <= self.get_abl('rsn')]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, s = grid_pos, sqrs = sqrs : self.do_disintegrate(event = e, sqr = s, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Choose Target For Disintegrate', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, s = grid_pos, sqrs = sqrs : self.do_disintegrate(e, s, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_disintegrate(self, event, sqr, sqrs):
        if sqr not in sqrs:
            return
        id = app.grid[sqr[0]][sqr[1]]
        if id not in app.spell_target_ents().keys():
            return
        effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
        if 'Disintegrate' in effs:
            return
        self.magick -= self.arcane_dict['Disintegrate'][1]
        effect1 = mixer.Sound('Sound_Effects/disintegrate.ogg')
        effect1.set_volume(1)
        sound_effects.play(effect1, 0)
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        app.vis_dict['Disintegrate'] = Vis(name = 'Disintegrate', loc = sqr[:])
        app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict['Disintegrate'].img, tags = 'Disintegrate')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, self.loc[1]*100+14-app.moved_down, text = 'Disintegrate', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, self.loc[1]*100+15-app.moved_down, text = 'Disintegrate', justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        # DO Disintegrate EFFECTS
        def disintegrate_effect(stat):
            return max(1,stat-1)
        f = disintegrate_effect
        rnd = choice(['str','end','agl','rsn','san'])
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '-1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '-1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
        if rnd == 'str':
            app.ent_dict[id].str_effects.append(f)
        elif rnd == 'end':
            app.ent_dict[id].end_effects.append(f)
        elif rnd == 'agl':
            app.ent_dict[id].agl_effects.append(f)
        elif rnd == 'rsn':
            app.ent_dict[id].rsn_effects.append(f)
        elif rnd == 'san':
            app.ent_dict[id].san_effects.append(f)
        def un(i, f, lockname = None):
            if f in app.ent_dict[i].str_effects:
                app.ent_dict[i].str_effects.remove(f)
            elif f in app.ent_dict[i].end_effects:
                app.ent_dict[i].end_effects.remove(f)
            elif f in app.ent_dict[i].agl_effects:
                app.ent_dict[i].agl_effects.remove(f)
            elif f in app.ent_dict[i].rsn_effects:
                app.ent_dict[i].rsn_effects.remove(f)
            elif f in app.ent_dict[i].san_effects:
                app.ent_dict[i].san_effects.remove(f)
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        u = partial(un, id, f)
        # EOT FUNC
        def disint(tar, lockname = None):
            def disintegrate_effect(stat):
                return max(1,stat-1)
            f = disintegrate_effect
            rnd = choice(['str','end','agl','rsn','san'])
            sqr = app.ent_dict[tar].loc[:]
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+14-app.moved_down, text = 'Disintegrate, -1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+15-app.moved_down, text = 'Disintegrate, -1 '+rnd, justify = 'center', font = ('chalkduster', 14), fill = 'antiquewhite', tags = 'text')
            if rnd == 'str':
                app.ent_dict[tar].str_effects.append(f)
            elif rnd == 'end':
                app.ent_dict[tar].end_effects.append(f)
            elif rnd == 'agl':
                app.ent_dict[tar].agl_effects.append(f)
            elif rnd == 'rsn':
                app.ent_dict[tar].rsn_effects.append(f)
            elif rnd == 'san':
                app.ent_dict[tar].san_effects.append(f)
            def un(prev_undo, i, f, lockname = None):
                if f in app.ent_dict[i].str_effects:
                    app.ent_dict[i].str_effects.remove(f)
                elif f in app.ent_dict[i].end_effects:
                    app.ent_dict[i].end_effects.remove(f)
                elif f in app.ent_dict[i].agl_effects:
                    app.ent_dict[i].agl_effects.remove(f)
                elif f in app.ent_dict[i].rsn_effects:
                    app.ent_dict[i].rsn_effects.remove(f)
                elif f in app.ent_dict[i].san_effects:
                    app.ent_dict[i].san_effects.remove(f)
                prev_undo(lockname)
            for k,v in app.ent_dict[tar].effects_dict.items():
                if v.name == 'Disintegrate':
                    key = k
            app.ent_dict[tar].effects_dict[k].undo_func = partial(un, app.ent_dict[tar].effects_dict[k].undo_func, tar, f)
            app.get_focus(tar)
            lock(apply_damage, self, app.ent_dict[tar], -1, 'acid', 'Disintegrate', 'eot')
            root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
        eot = partial(disint, id)
        n = 'Disintegrate' + str(app.count)
        app.ent_dict[id].effects_dict[n] = Effect(name = 'Disintegrate', eot_func = eot, undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2666, lambda  name = 'Disintegrate' : self.cleanup_spell(name = name))
        
        
        
    # all friendly ents within range 3 get +1 all attrs and heals 1 spirit, all enemy ents get -1 all attrs and loses 1 spirit, lasts 3 turns, does not stack
    def command_of_osiris(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', self.cleanup_spell)
        sqrs = [s for s in app.coords if dist(self.loc, s) <= max(1, self.get_abl('rsn')//2)]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e, sqrs = sqrs : self.do_command_of_osiris(event = e, sqrs = sqrs))
        b = tk.Button(app.context_menu, text = 'Confirm Command of Osiris', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None, sqrs = sqrs : self.do_command_of_osiris(e, sqrs = sqrs))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_command_of_osiris(self, event, sqrs):
        self.magick -= self.arcane_dict['Command_of_Osiris'][1]
#         self.init_cast_anims()
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        friendly_ents = [k for k,v in app.all_ents().items() if v.owner == self.owner and v.loc in sqrs]
        enemy_ents = [k for k,v in app.all_ents().items() if v.owner != self.owner and v.loc in sqrs]
        # SUN VIS
        app.vis_dict['Osiris_Sun'] = Vis(name = 'Osiris_Sun', loc = [self.loc[0],self.loc[1]-4])
        app.canvas.create_image(self.loc[0]*100+50-app.moved_right, (self.loc[1]-4)*100+50-app.moved_down, image = app.vis_dict['Osiris_Sun'].img, tags = 'Command_of_Osiris')
        app.canvas.create_text(self.loc[0]*100+49-app.moved_right, (self.loc[1]-3)*100+14-app.moved_down, text = 'Command of Osiris', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(self.loc[0]*100+50-app.moved_right, (self.loc[1]-3)*100+15-app.moved_down, text = 'Command of Osiris', justify = 'center', font = ('chalkduster', 14), fill = 'tan3', tags = 'text')
        def cleanup_sun():
            del app.vis_dict['Osiris_Sun']
            app.canvas.delete('Osiris_Sun')
        root.after(2666, cleanup_sun)
        # FRIENDLY ENTS
        for id in friendly_ents:
            effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
            if 'Osiris_Blessing' in effs:
                continue
            sqr = app.ent_dict[id].loc[:]
            uniq_name = 'Command_of_Osiris' + str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Command_of_Osiris', loc = sqr)
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = 'Command_of_Osiris')
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '+1 Str,End +1 Spirit', justify = 'center', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '+1 Str,End +1 Spirit', justify = 'center', font = ('chalkduster', 12), fill = 'tan3', tags = 'text')
            # CLEANUP UNIQUE VIS
            def cleanup_osiris(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(2666, lambda n = uniq_name : cleanup_osiris(n))
            # SPIRIT
            apply_heal(self, app.ent_dict[id], 1)
            # DO Command of Osiris EFFECTS
            def osiris_effect(stat):
                return stat+1
            p = partial(osiris_effect)
            app.ent_dict[id].str_effects.append(p)
            app.ent_dict[id].end_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Command_of_Osiris' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Osiris_Blessing', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        #  ENEMY ENTS
        for id in enemy_ents:
            effs = [v.name for k,v in app.ent_dict[id].effects_dict.items()]
            if 'Osiris_Curse' in effs:
                continue
            sqr = app.ent_dict[id].loc[:]
            uniq_name = 'Command_of_Osiris' + str(app.count)
            app.count += 1
            app.vis_dict[uniq_name] = Vis(name = 'Command_of_Osiris', loc = sqr)
            app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = app.vis_dict[uniq_name].img, tags = 'Command_of_Osiris')
            app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+74-app.moved_down, text = '-1 Str,End', justify = 'center', font = ('chalkduster', 12), fill = 'black', tags = 'text')
            app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+75-app.moved_down, text = '-1 Str,End', justify = 'center', font = ('chalkduster', 12), fill = 'tan3', tags = 'text')
            # CLEANUP UNIQUE VIS
            def cleanup_osiris(n):
                del app.vis_dict[n]
                app.canvas.delete(n)
            root.after(2666, lambda n = uniq_name : cleanup_osiris(n))
            # DO Command of Osiris EFFECTS
            def osiris_effect(stat):
                return max(1,stat-1)
            p = partial(osiris_effect)
            app.ent_dict[id].str_effects.append(p)
            app.ent_dict[id].end_effects.append(p)
            def un(i, func, lockname = None):
                app.ent_dict[i].str_effects.remove(func)
                app.ent_dict[i].end_effects.remove(func)
                root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
            u = partial(un, id, p)
            n = 'Command_of_Osiris' + str(app.count)
            app.ent_dict[id].effects_dict[n] = Effect(name = 'Osiris_Curse', undo_func = u, duration = self.get_abl('rsn'), level = self.get_abl('wis'))
        root.after(2777, lambda  name = 'Command_of_Osiris' : self.cleanup_spell(name = name))
        
# MORGAN SPELLS
        # Morgan's spells center around Nature/Earth/Weather/Illusion
        
    def fleet_of_paw(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Fleet_of_Paw' : self.cleanup_spell(name = name))
        root.bind('<a>', self.do_fleet_of_paw)
        b = tk.Button(app.context_menu, text = 'Confirm Fleet of Paw', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_fleet_of_paw(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
        
    def do_fleet_of_paw(self, event):
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/meditate.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        id = self.name
        sqr = self.loc[:]
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Fleet of Paw', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Fleet of Paw', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        def cleanup_fop(un):
            app.canvas.delete(un)
            del app.vis_dict[un]
            app.canvas.delete('text')
        def fop_loop(ents):
            if ents == []:
                self.cleanup_spell('Fleet_of_Paw')
            else:
                id = ents[0]
                ents = ents[1:]
                if 'Fleet_of_Paw' not in [v.name for k,v in app.ent_dict[id].effects_dict.items()]:
                    app.get_focus(id)
                    s = app.ent_dict[id].loc[:]
                    un = 'FOP' + str(app.count)
                    app.vis_dict['Fleet_of_Paw'] = Vis(name = 'Fleet_of_Paw', loc = s)
                    app.canvas.create_image(s[0]*100+50-app.moved_right, s[1]*100+50-app.moved_down, image = app.vis_dict[un].img, tags = un)
                    def fop_move(r):
                        return r + 1
                    p = partial(fop_move)
                    app.ent_dict[id].move_range_effects.append(p)
                    def un(id, f, lockname = None):
                        app.ent_dict[id].move_range_effects.remove(f)
                        root.after(111, lambda ln = lockname : app.dethloks[ln].set(1))
                    u = partial(un, id, p)
                    app.ent_dict[id].effects_dict[un] = Effect(name = 'Fleet_of_Paw', undo_func = u, duration = 1, level = self.get_abl('psyche'))
                    root.after(1555, lambda un = un : cleanup_fop(un))
                    root.after(1666, lambda ents = ents : fop_loop(ents))
                else:
                    fop_loop(ents)
        root.after(1555, lambda t = 'text' : app.canvas.delete(t))
        ents = [k for k,v in app.ent_dict.items() if v.owner == self.owner and isinstance(v, (Thaumaturge, Illusionist, Umbrae_Wolf, Berserker, Murrain_Wolf))]
        root.after(1666, lambda ents = ents : fop_loop(ents))
                    
                    
    def hunting_hawk(self, event = None):
        app.depop_context(event = None)
        root.bind('<q>', lambda name = 'Hunting_Hawk' : self.cleanup_spell(name = name))
        sqrs = [s for s in app.coords if s == self.loc]
        app.animate_squares(sqrs)
        root.bind('<a>', lambda e : self.do_hunting_hawk(event = e))
        b = tk.Button(app.context_menu, text = 'Confirm Hunting Hawk', wraplength = 190, font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'tan3', command = lambda e = None : self.do_hunting_hawk(e))
        b.pack(side = 'top', pady = 2)
        app.context_buttons.append(b)
        b2 = tk.Button(app.context_menu, text = 'Cancel', wraplength = 190, font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = app.generic_cancel)
        b2.pack(side = 'top')
        app.context_buttons.append(b2)
    
    def do_hunting_hawk(self, event = None):
        if 'Hunting_Hawk' in [v.name for k,v in app.ent_dict.items() if v.owner == self.owner]:
            return
#         self.init_cast_anims()
#         effect1 = mixer.Sound('Sound_Effects/hunting_hawk.ogg')
#         effect1.set_volume(1)
#         sound_effects.play(effect1, 0)
        app.unbind_all()
        app.depop_context(event = None)
        app.cleanup_squares()
        sqrs = [s for s in app.coords if app.grid[s[0]][s[1]] == '']
        sqr = choice(sqrs)
        app.focus_square(sqr)
        app.vis_dict['Summon'] = Vis(name = 'Summon', loc = sqr[:])
        def clean_summon():
            app.canvas.delete('Summon')
            del app.vis_dict['Summon']
        root.after(1555, clean_summon)
        app.canvas.create_text(sqr[0]*100+49-app.moved_right, sqr[1]*100+84-app.moved_down, text = 'Hunting Hawk', justify = 'center', font = ('chalkduster', 14), fill = 'black', tags = 'text')
        app.canvas.create_text(sqr[0]*100+50-app.moved_right, sqr[1]*100+85-app.moved_down, text = 'Hunting Hawk', justify = 'center', font = ('chalkduster', 14), fill = 'white', tags = 'text')
        num = self.summon_ids
        self.summon_ids += 1
        if self.owner == 'p1':
            prefix = 'a'
        else:
            prefix = 'b'
        id = prefix + str(num)
        img = ImageTk.PhotoImage(Image.open('summon_imgs/Hunting_Hawk.png'))
        app.ent_dict[id] = Hunting_Hawk(name = 'Hunting_Hawk', id = id, img = img, loc = sqr[:], owner = self.owner, level = self.level)
        app.grid[sqr[0]][sqr[1]] = id
        root.after(1666, lambda  name = 'Hunting_Hawk' : self.cleanup_spell(name = name))
    
    
    
    def entangle():
        pass
        
    def enchant(self, event = None):
            # any summon within range 4 has attrs (str, agl, end, dodge, psyche) set to 5 until 3 opp turns have passed, prevents further modification while active
        print('enchant')
        
    def wild_hunt(self, event = None):
            # Creates 3 summons within range 2 of caster or up to 3 if not enough squares available, first is Boar (stats 3,3,3,2,2,4,0) movement range 2 attack any adjacent, second is wolf (2,3,2,4,2,3,0) movement range 3 attack any adjacent, third is hawk (2,4,2,4,3,2,0) movement range 4 not impeded by other units/obstacles attack any adjacent
        print('wild_hunt')
        
    def ceridwens_command(self, event = None):
            # Command rules apply, caster cannot move, all squares within range 2 of caster become 'water' (impassable terrain) any ents currently occupying these squares are moved to a random square 'at edge' (closest available square to edge of water squares or first unoccupied square if all 'edge' squares are occupied), at end of turn caster heals 4 spirit, lasts until caster has 3 turns end (healing happens first)
        print('ceridwens_command')
        
    def natures_wrath(self, event = None):
            # Choose a square within range 5, all ents within range 2 of square must 'to hit' their inverted agl versus dodge at the end of every caster's turn, those that 'hit' suffer 3 spirit damage, lasts 3 caster's turns (effect happens 'before' end turn, effects happen 3 times)
        print('natures_wrath')
        
    def counterspell(self, event = None):
            # Choose a spell effect 'in play', make 'to hit' psyche versus effect's owner's psyche, on success cancel all effects from the spell (call its cleanup function) and effect's owner takes magick damage psyche versus psyche
        print('counterspell')
        
    
    
class VerticalScrolledFrame(tk.Frame): 
    '''
    * Use the 'interior' attribute to place widgets inside the scrollable frame
    * Construct and pack/place/grid normally
    * This frame only allows vertical scrolling
    '''
    def __init__(self, parent, *args, **kw):
        tk.Frame.__init__(self, parent, *args, **kw)
        # create a canvas object and a vertical scrollbar for scrolling it
        vscrollbar = tk.Scrollbar(self, orient=tk.VERTICAL, relief = 'raised', troughcolor = 'black', highlightbackground = 'black', width = 13)
        vscrollbar.pack(fill=tk.Y, side=tk.RIGHT, expand=tk.FALSE)
        canvas = tk.Canvas(self, bd=0, highlightthickness=0, bg = 'black',
                        yscrollcommand=vscrollbar.set)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=tk.TRUE)
        vscrollbar.config(command=canvas.yview)
        # reset the view
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        # create a frame inside the canvas which will be scrolled with it
        self.interior = interior = tk.Frame(canvas)
        interior_id = canvas.create_window(0, 0, window = interior, anchor = 'nw')
        # track changes to the canvas and frame width and sync them,
        # also updating the scrollbar
        def _configure_interior(event):
            # update the scrollbars to match the size of the inner frame
            size = (interior.winfo_reqwidth(), interior.winfo_reqheight())
            canvas.config(scrollregion="0 0 %s %s" % size)
            if interior.winfo_reqwidth() != canvas.winfo_width():
                # update the canvas's width to fit the inner frame
                canvas.config(width=interior.winfo_reqwidth())
        interior.bind('<Configure>', _configure_interior)

        def _configure_canvas(event):
            if interior.winfo_reqwidth() != canvas.winfo_width():
                # update the inner frame's width to fill the canvas
                canvas.itemconfigure(interior_id, width=canvas.winfo_width())
        canvas.bind('<Configure>', _configure_canvas)

# static class / interface used by computer controlled entities
class Ai_man():
    # handles computer or user controlled berserk ent
    # exits back to app.handle_action()
    def handle_berserk_ent_action(ent):
        def flail_loop(ent):# LOOPING in here or not exiting properly, focus stays on berserk ent
            if (ent.acts < 1 and ent.mvs < 1) or (ent.mvs < 1 and [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) == 1] == []):
                root.after(111, app.handle_action)
            else:
                if ent.acts > 0 and choice((0,1)):# rand choose, acts and mvs until they are exhausted
                    if ids := [k for k,v in app.all_ents().items() if dist(v.loc, ent.loc) == 1]:
                        if ent.acts > 0:
                            ent.acts -= 1
                            id = choice(ids)
                            app.get_focus(id)
                            my_agl = ent.get_abl('agl')
                            tar_agl = app.ent_dict[id].get_abl('agl')
                            if to_hit(my_agl, tar_agl) == True:
                                my_str = ent.get_abl('str')
                                tar_end = app.ent_dict[id].get_abl('end')
                                d = damage(my_str, tar_end)
                                lock(apply_damage, ent, app.ent_dict[id], -d, 'crushing', 'Flail', 'melee')
                                if ent in app.ent_dict.values():
                                    flail_loop(ent)
                                else:
                                    app.handle_action()
                            else:
                                miss(app.ent_dict[id].loc)
                                root.after(1111, lambda t = 'text' : app.canvas.delete(t))
                                root.after(1333, lambda e = ent : flail_loop(e))
                        else:##
                            if ent.legal_moves() == []:
                                app.handle_action()
                            else:
                                flail_loop(ent)
                    else:
                        flail_loop(ent)
                elif ent.mvs > 0:
                    if ent.legal_moves() != []:
                        mvs = ent.legal_moves()
                        mv = choice(mvs)
                        # DEBUG debug here, ethereal/flying/unobstructed moves may have no path...
                        app.focus_square(mv)
                        ent.mvs -= 1
                        name = 'dethlok'+str(app.death_count)
                        app.death_count += 1
                        app.dethloks[name] = tk.IntVar(0)
                        if ent.get_move_type() == 'normal' or ent.get_move_type() == 'charge':
                            Bot.ai_normal_move(ent, mv, name)
                        elif ent.get_move_type() == 'teleport':
                            Bot.ai_teleport_move(ent, mv, name)
                        else:
                            Bot.ai_flying_move(ent, mv, name)
                        app.wait_variable(app.dethloks[name])
#                         lock(ent.do_move, mv)
                        app.unbind_all()
                        flail_loop(ent)
                    else:## 
                        if ent.acts > 0 and [v for k,v in app.all_ents().items() if dist(v.loc,ent.loc) == 1] != []:
                            flail_loop(ent)
                        else:
                            app.handle_action()
                else:
                    flail_loop(ent)
        flail_loop(ent)
            
            
    # dispatches to other pursue functions
    # no dumb ranged pursue yet...
    def pursue(ent, target_type, smart_dumb, move_type, ideal_range):
        if ideal_range == 1:
            if smart_dumb == 'smart':
                if move_type == 'normal' or move_type == 'charge':
                    Ai_man.melee_pursue(ent, target_type)
                else:
                    Ai_man.ranged_flying_pursue(ent, ideal_range, target_type)
            else:
                Ai_man.melee_dumb_pursue(ent, target_type)
        else:
            if move_type == 'normal' or move_type == 'charge':
                Ai_man.ranged_pursue(ent, ideal_range, target_type)
            else:
                Ai_man.ranged_flying_pursue(ent, ideal_range, target_type)
            

    def ranged_flying_pursue(ent, ideal_range, target_type):
        ir = ideal_range
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('ranged_flying_pursue unknown target_type')
            gs1 = unique([g for g in app.coords for el in els if dist(el,g) <= ir and app.grid[g[0]][g[1]] == ''])
            # strip of all not closest to self
            gs1 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs1]), gs1))
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(30,60)]
            mvs = ent.legal_moves()
            # 'flee' to maxim dist among legal_moves if already inside range of atk, already atked
            if target_type == 'spell':
                close_ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'action':
                close_ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'all':
                close_ents = [k for k,v in app.all_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            else:
                print('ranged_flying_pursue unknown target_type')
            if close_ents and ent.acts <= 0: # FLEE
                ms = intersect(mvs,cs)
                if ms == []:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                else:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, ms)
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, app.handle_action)
            elif mvs != []: #
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, gs1)
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs))
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            else:
                root.after(666, app.handle_action)
            
    # pursue for normal move_type, ranged attack at ideal_range while avoiding detrimental local/map effects, with 'flee' behavior
    def ranged_pursue(ent, ideal_range, target_type):
        ir = ideal_range
        if ent.mvs < 1 or ent.normal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('ranged_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            gs1 = [g for g in app.coords for el in els if dist(el,g) <= ir and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in app.coords for el in els if dist(el,g) <= ir and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            # strip of all not closest to self
            gs1 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs1]), gs1))
            gs2 = list(filter(lambda a : dist(a,ent.loc) == min([dist(x,ent.loc) for x in gs2]), gs2))
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(30,60)]
            # 
            cs1 = cs + gs1
            cs2 = cs + gs2
            mvs = ent.legal_moves()
            # 'flee' to maxim dist among legal_moves if already inside range of atk, already atked
            if target_type == 'spell':
                close_ents = [k for k,v in app.spell_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'action':
                close_ents = [k for k,v in app.action_target_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            elif target_type == 'all':
                close_ents = [k for k,v in app.all_ents().items() if dist(v.loc,ent.loc) <= ir and v.owner != ent.owner]
            else:
                print('ranged_pursue unknown target_type')
            if close_ents and ent.acts <= 0:
                ms = intersect(mvs,cs)
                if ms == []:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, mvs)
                else:
                    mv = reduce(lambda a,b : a if sum([dist(a,el) for el in els]) > sum([dist(b,el) for el in els]) else b, ms)
                ent.mvs -= 1
                lock(ent.do_move, mv)
                root.after(666, app.handle_action)
            elif path := bfs(ent.loc[:], gs1, app.grid[:]):
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs1))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                if mvs := intersect(path,mvs):
                    g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                    if intersect(mvs,cs) == []:
                        mv = g
                    else:
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs2))
                    ent.mvs -= 1
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                root.after(666, app.handle_action)
            
    # Purse while avoiding detrimental local effects (based on rand val compared to cumulative 'avoid' val of efcts at location)
    def melee_pursue(ent, target_type):
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('melee_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            mvs = ent.legal_moves()
            gs1 = [g for g in app.coords for el in els if dist(el,g) == 1 and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in app.coords for el in els if dist(el,g) == 1 and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            cs = [c for c in app.coords if sum([ef.avoid for k,ef in app.loc_dict[tuple(c)].effects_dict.items()])*10 < randrange(40,60)]
            cs1 = cs + gs1
            cs2 = cs + gs2
            if path := bfs(ent.loc[:], gs1, app.grid[:]):
                g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                if intersect(mvs,cs) == []:
                    mv = g
                else:
                    mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs1))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                if mvs := intersect(path,mvs):
                    g = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,mvs))
                    if intersect(mvs,cs) == []:
                        mv = g
                    else:
                        mv = reduce(lambda a,b : a if dist(a,g)<dist(b,g) else b, intersect(mvs,cs2))
                    ent.mvs -= 1
#                     root.after(444, lambda mv = mv : app.focus_square(mv))
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                root.after(666, app.handle_action)
                
    # do not avoid loc_effects, move towards any sqr adj to an enemy, if none exist find a path by removing friendly ents and move on that path until blocked by friendly ent
    def melee_dumb_pursue(ent, target_type):
        if ent.mvs < 1 or ent.legal_moves() == []:
            ent.do_round()
        else:
            if target_type == 'spell':
                els = [v.loc for k,v in app.spell_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'action':
                els = [v.loc for k,v in app.action_target_ents().items() if v.owner != ent.owner]
            elif target_type == 'all':
                els = [v.loc for k,v in app.all_ents().items() if v.owner != ent.owner]
            else:
                print('melee_dumb_pursue unknown target_type')
            fls = [v.loc for k,v in app.all_ents().items() if v.owner == ent.owner]
            cs = [c for c in app.coords]
            egrid = deepcopy(app.grid)
            for s in fls:
                egrid[s[0]][s[1]] = ''
            gs1 = [g for g in cs for el in els if dist(el,g) == 1 and app.grid[g[0]][g[1]] == '']
            gs1 = unique(gs1)
            gs2 = [g for g in cs for el in els if dist(el,g) == 1 and egrid[g[0]][g[1]] == '']
            gs2 = unique(gs2)
            if path := bfs(ent.loc[:], gs1, app.grid[:]):
                mv = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, intersect(path,ent.legal_moves()))
                ent.mvs -= 1
#                 root.after(444, lambda mv = mv : app.focus_square(mv))
                lock(ent.do_move, mv)
                root.after(666, ent.do_round)
            elif path := bfs(ent.loc[:], gs2, egrid[:]):
                mvs = intersect(path, ent.legal_moves())
                if mvs:
                    mv = reduce(lambda a,b : a if dist(a,ent.loc)>dist(b,ent.loc) else b, mvs)
                    ent.mvs -= 1
#                     root.after(444, lambda mv = mv : app.focus_square(mv))
                    lock(ent.do_move, mv)
                    root.after(666, ent.do_round)
                else:
                    root.after(666, app.handle_action)
            else:
                print('no paths grid or egrid, should not be here unless levels altered')
                root.after(666, app.handle_action)
            
            
class App(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        self.pack()
        self.ent_dict = {}
        self.sqr_dict = {}
        self.vis_dict = {}
        self.image_holder = []
        self.global_effects_dict = {}
        self.init_q = []
        self.num_players = 1
        self.moved_right = 0
        self.moved_down = 0
        self.context_buttons = []
        self.help_buttons = []
        self.dethloks = {}
        self.death_count = 0
        self.cycle_q = []
        self.enemy_cycle_q = []
        self.current_ent = ''
        self.active_ent = None
        self.count = 0 # used for uniquely naming Effects with the same prefix/name
        self.p1_witch = ''
        self.p2_witch = ''
        self.two_player_map_num = 0
        self.turn_counter = 0
        
        self.proximity_effects_dict = {}
        self.enemy_color_img = ImageTk.PhotoImage(Image.open('animations/Enemy_Color_Img/0.png'))
        self.bot_minimap_img = ImageTk.PhotoImage(Image.open('animations/Bot_Minimap_Img/0.png').resize((10,10)))
        self.block_minimap_img = ImageTk.PhotoImage(Image.open('minimap_block.png').resize((10,10)))

        
        self.sqr_anims = {}
        anims = [a for r,d,a in walk('animations/move/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/move/' + anim))
            self.sqr_anims[i] = a
        
        self.aura_anims = {}
        anims = [a for r,d,a in walk('animations/Aura/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Aura/' + anim))
            self.aura_anims[i] = a
        
        self.mortar_anims = {}
        anims = [a for r,d,a in walk('animations/Mortar/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Mortar/' + anim))
            self.mortar_anims[i] = a
        
        self.pestilence_anims = {}
        anims = [a for r,d,a in walk('animations/Pestilence/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Pestilence/' + anim))
            self.pestilence_anims[i] = a
            
        self.plague_anims = {}
        anims = [a for r,d,a in walk('animations/Plague/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Plague/' + anim))
            self.plague_anims[i] = a
            
        self.toxic_miasma_anims = {}
        anims = [a for r,d,a in walk('animations/Toxic_Miasma/')][0]
        anims = [a for a in anims[:] if a[0] != '.']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Toxic_Miasma/' + anim))
            self.toxic_miasma_anims[i] = a
            
        self.leap_anims = {}
        anims = [a for r,d,a in walk('./animations/Leap/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Leap/' + anim))
            self.leap_anims[i] = a
            
        self.pounce_anims = {}
        anims = [a for r,d,a in walk('./animations/Pounce/')][0]
        anims = [a for a in anims[:] if a[-3:] == 'png']
        for i, anim in enumerate(anims):
            a = ImageTk.PhotoImage(Image.open('animations/Pounce/' + anim))
            self.pounce_anims[i] = a
            
        self.choose_num_players()
        
        # Luminari 280
        # Herculanum 240
        # Papyrus 240
    def choose_num_players(self):
#         background_music.music.load('Ove Melaa - Dead, Buried and Cold.ogg')
        sound1 = mixer.Sound('Music/Ove Melaa - Dead, Buried and Cold.ogg')
        background_music.play(sound1, -1)
        sound1.set_volume(0.6)
        self.title_screen = ImageTk.PhotoImage(Image.open('titleScreen999.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.game_title = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.game_title.create_image(0,0, image =self.title_screen, anchor = 'nw')
        self.game_title.pack(side = 'top')
        
        self.one_player = tk.Button(root, text = 'Campaign', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda num = 1 : self.num_chose(num))
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-120, anchor='s', window = self.one_player)
        
        self.two_player = tk.Button(root, text = 'Duel', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda num = 2 : self.num_chose(num))
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-70, anchor='s', window = self.two_player)
        
        self.load_button = tk.Button(root, text = 'Load Campaign', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.try_load)
        self.game_title.create_window(root.winfo_screenwidth()/2, root.winfo_screenheight()-20, anchor='s', window = self.load_button)
        
    def try_load(self):
        saves = [s for r,d,s in walk('save_games/')][0]
        saves = [s for s in saves[:] if s[0] != '.']
        # create a button for each save and a cancel button
        self.scroll_frame = VerticalScrolledFrame(root)
        self.game_title.create_window(root.winfo_screenwidth()/2 + root.winfo_screenwidth()/8, root.winfo_screenheight()-220, anchor = 'nw', window = self.scroll_frame)
        self.game_title.saves_buttons = []
        for s in saves:
            # expand filename into readable
            with open('save_games/'+s, 'r') as f:
#                 obj = load(f)
                name = f.readline().strip('\n')
                level = f.readline().strip('\n')
                if name == 'Agnes_Sampson':
                    img = ImageTk.PhotoImage(Image.open('avatars/Agnes_Sampson.png'))
                    obj = Witch(name = 'Agnes_Sampson', img = img, loc = [0,0], owner = 'p1', level = int(level))
                elif name == 'Fakir_Ali':
                    img = ImageTk.PhotoImage(Image.open('avatars/Fakir_Ali.png'))
                    obj = Witch(name = 'Fakir_Ali', img = img, loc = [0,0], owner = 'p1', level = int(level))
#                 cantrips = eval(f.readline().strip('\n'))
                arcane = eval(f.readline().strip('\n'))
                sum_cap = int(f.readline().strip('\n'))
                str = int(f.readline().strip('\n'))
                agl = int(f.readline().strip('\n'))
                end = int(f.readline().strip('\n'))
                mm = int(f.readline().strip('\n'))
                msl = int(f.readline().strip('\n'))
                bls = int(f.readline().strip('\n'))
                dodge = int(f.readline().strip('\n'))
                psyche = int(f.readline().strip('\n'))
                rsn = int(f.readline().strip('\n'))
                wis = int(f.readline().strip('\n'))
                san = int(f.readline().strip('\n'))
                init = int(f.readline().strip('\n'))
                b_acts = int(f.readline().strip('\n'))
                b_mvs = int(f.readline().strip('\n'))
                b_smns = int(f.readline().strip('\n'))
#                 b_can = int(f.readline().strip('\n'))
                b_spirit = int(f.readline().strip('\n'))
#                 b_magick = int(f.readline().strip('\n'))
                move_range = int(f.readline().strip('\n'))
                area = int(f.readline().strip('\n'))
                obj.summon_cap = sum_cap
                obj.str = str
                obj.agl = agl
                obj.end = end
                obj.mm = mm
                obj.msl = msl
                obj.bls = bls
                obj.dodge = dodge
                obj.psyche = psyche
                obj.rsn = rsn
                obj.wis = wis
                obj.san = san
                obj.init = init
                obj.base_acts = b_acts
                obj.base_mvs = b_mvs
                obj.base_smns = b_smns
                obj.smns = b_smns
#                 obj.base_cantrips = b_can
#                 obj.cantrips = b_can
                obj.base_spirit = b_spirit
                obj.spirit = b_spirit
#                 obj.base_magick = b_magick
                obj.magick = 0
                obj.current_area = area
                obj.move_range = move_range
                cmd = lambda obj = obj : self.load_game(obj)
                b = tk.Button(self.scroll_frame.interior, text = s, width = 13, wraplength = 190, fg = 'indianred', highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = cmd)
                b.pack() 
                self.game_title.saves_buttons.append(b)
        cancel_b = tk.Button(self.scroll_frame.interior, text = 'Cancel', bg = 'black', fg = 'black', width = 13, highlightbackground = 'black', font = ('chalkduster', 22), relief = 'raised', command = self.scroll_frame.destroy)
        cancel_b.pack(side = 'bottom')
        self.game_title.saves_buttons.append(cancel_b)
                
    def load_game(self, obj):
        self.game_title.destroy()
        self.load_map_triggers(map_number = obj.current_area, protaganist_object = obj)
        
    def num_chose(self, num):
        self.num_players = num
        self.game_title.destroy()
        self.one_player.destroy()
        self.two_player.destroy()
        del self.title_screen
        del self.game_title
        del self.one_player
        del self.two_player
        if self.num_players == 2:
            self.choose_map()
        else:
        # first choose_witch() here
            self.choose_witch(player_num = 1)
#             self.load_map_triggers(map_number = 0)
            
    # make each branch load the intro scene for level, with 'continue' button when done reading/displaying to call create_map_curs_context
    def load_map_triggers(self, map_number, witch = None, protaganist_object = None):
        background_music.stop()
        if map_number == 0: # FIRST AREA, NO 'CONTINUATION from previous level' BY PASSING PROTAG OBJECT
            self.map_triggers = []
            # CLEANUP FROM CHOOSE_WITCH
            try:
                self.avatar_popup.destroy()
                del self.wrapped_funcs
            except:
                pass
            self.p1_witch = witch
            sound1 = mixer.Sound('Music/heroic_demise.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(.3)
            if protaganist_object:
                self.load_intro_scene(map_number, protaganist_object = protaganist_object)
            else:
                self.load_intro_scene(map_number)# DONT NEED PROTAG OBJECT ON FIRST AREA
    # SECOND LEVEL
        elif map_number == 1:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/Caves of sorrow.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(1.0)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # THRID LEVEL 
        elif map_number == 2:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/arabesque.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(0.3)
            # tag both knights as 'stairway' or 'doorway'
            def tag_knights():
                knights = [v for k,v in app.all_ents().items() if v.name == 'Undead_Knight']
                for v in knights:
                    if v.loc == [19,13]:
                        v.stairway = True
                        v.doorway = False
                    elif v.loc == [28,17]:
                        v.doorway = True
                        v.stairway = False
                self.map_triggers.remove(tag_knights)
            self.map_triggers.append(tag_knights)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # LIBRARY
        elif map_number == 121:
            self.map_triggers = []
            sound1 = mixer.Sound('Music/field_of_dreams.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(1)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
        # LABYRINTH 
        elif map_number == 21:
            sound1 = mixer.Sound('Music/Blackmoor_Colossus.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(0.3)
            self.map_triggers = []
            def ghost_kickoff():
                app.ghost_dead = False
                app.remove(ghost_kickoff)
            self.map_triggers.append(ghost_kickoff)
            self.revenant_rate = 0
            self.top2 = Image.open('1_player_map_fog/map21/2_top.png')
            self.bot2 = Image.open('1_player_map_fog/map21/2.png')
            def area_sixteen():
                if app.ent_dict[app.p1_witch].loc in [[13,16],[13,17],[13,18],[13,19],[13,20]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[14,16],[14,17],[15,16],[15,17],[16, 16], [17, 16], [18, 16], [19, 16], [20, 16], [21, 16], [22, 16], [23, 16], [24, 16], [25, 16], [26, 16], [27, 16],[27,17],[27,18],[27,19],[27,20],[27,21],[26,21],[25,21],[25,20],[25,19],[17, 19], [18, 19], [19, 19], [20, 19], [21, 19], [22, 19], [23, 19], [24, 19],[14, 20], [15, 20], [16, 20], [17, 20], [18, 20], [19, 20]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/16_top.png')
                    bot = Image.open('1_player_map_fog/map21/16.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    app.rebind_all()
                    self.map_triggers.remove(area_sixteen)
            # Ghost place 1, add ghost to coord 35,35
            # when ghost below N hp, move to final spot at 2,2 in area 9 which should only be revealed after area 8
            # add revenants or revenant generation...
            # 29,26 and 31,30 add trig to summon revs on turn 2
            # certain areas, once revealed, generate revenants every N turns, area 1 (start area), area 4 at 30,8, area 15 at 30, 34 and 32, 24, other revs are only placed and not generated/summoned
            def area_fifteen():
                if app.ent_dict[app.p1_witch].loc in [[5,37],[4,37]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[6, 37], [7, 37], [8, 37], [9, 37], [10, 37], [11, 37], [12, 37], [13, 37], [14, 37], [15, 37], [16, 37], [17, 37], [18, 37], [19, 37], [20, 37], [21, 37], [22, 37], [23, 37], [24, 37], [25, 37], [26, 37], [27, 37], [28, 37], [29, 37], [30, 37], [31, 37], [32, 37],[24, 36], [25, 36], [26, 36], [27, 36], [28, 36], [29, 36], [30, 36], [31, 36], [32, 36], [33, 36], [34, 36], [35, 36], [36, 36], [37, 36], [38, 36],[24, 35], [25, 35], [26, 35], [27, 35], [28, 35], [29, 35], [30, 35], [31, 35], [32, 35], [33, 35], [34, 35], [34, 34], [34, 37], [35, 34], [36, 34], [36, 37], [35, 37], [38, 34], [38, 37], [35, 35], [36, 35], [37, 35], [38, 35],[24, 34], [25, 34], [26, 34], [27, 34], [28, 34], [29, 34], [30, 34], [31, 34], [32, 34]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/15_top.png')
                    bot = Image.open('1_player_map_fog/map21/15.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_fifteen)
                    # PLACE GHOST
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Ghost.png'))
                    ent = Ghost(name = 'Ghost', img = img, loc = [35,35], owner = 'p2')
                    app.grid[35][35] = ent.id
                    app.ent_dict[ent.id] = ent
                    app.canvas.create_image(3550-app.moved_right, 3550-app.moved_down, image = ent.img, tags = ent.tags)
                    def ghost_check():
                        if 'Ghost' not in [v.name for k,v in app.all_ents().items()]:
                            app.ghost_dead = True
                            app.map_triggers.remove(ghost_check)
                    app.map_triggers.append(ghost_check)
                    app.rebind_all()
            def area_fourteen():
                if app.ent_dict[app.p1_witch].loc in [[7,24],[6,24]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[7,25],[7, 26], [7, 27], [7, 28], [7, 29], [7, 30], [7, 31],[8, 30], [9, 30], [10, 30], [11, 30], [12, 30], [13, 30], [14, 30], [15, 30], [16, 30], [17, 30], [18, 30], [19, 30], [20, 30], [21, 30], [22, 30], [23, 30], [24, 30],[8, 31], [9, 31], [10, 31], [11, 31], [12, 31], [13, 31], [14, 31], [15, 31], [16, 31], [17, 31], [18, 31], [19, 31], [20, 31], [21, 31], [22, 31], [23, 31], [24, 31],[22,32],[22,33],[7, 34], [8, 34], [9, 34], [10, 34], [11, 34], [12, 34], [13, 34], [14, 34], [15, 34], [16, 34], [17, 34], [18, 34], [19, 34], [20, 34], [21, 34], [22, 34]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/14_top.png')
                    bot = Image.open('1_player_map_fog/map21/14.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    app.rebind_all()
                    self.map_triggers.remove(area_fourteen)
            def area_thirteen():
                if app.ent_dict[app.p1_witch].loc in [[1,24],[1,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_fifteen)
                    coords = [[1,25],[1,26],[1,27],[1,28],[2,27],[2,28],[3,27],[3,28],[4,27],[4,28],[5,27],[5,28],[5, 29], [5, 30], [5, 31], [5, 32], [5, 33], [5, 34], [5, 35], [5, 36], [5, 37],[4, 33], [4, 34], [4, 35], [4, 36], [4, 37],[3, 31], [3, 32], [3, 33], [3, 34], [3, 35], [3, 36], [3, 37],[2, 31], [2, 32], [2, 33], [2, 34], [2, 35], [2, 36], [2, 37],[1, 31], [1, 32], [1, 33], [1, 34], [1, 35], [1, 36], [1, 37]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/13_top.png')
                    bot = Image.open('1_player_map_fog/map21/13.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_thirteen)
                    app.rebind_all()
            self.map_triggers.append(area_thirteen)
            def area_twelve():
                if app.ent_dict[app.p1_witch].loc in [[12,20],[11,20],[4,19],[5,19],[6,19],[5,13],[5,12]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_fourteen)
                    coords = [[4,13],[3,13],[2,13],[1,13],[1, 14], [1, 15], [1, 16], [1, 17], [1, 18], [1, 19], [1, 20], [1, 21], [1, 22], [1, 23], [1, 24],[3, 13], [3, 14], [3, 15], [3, 16], [3, 17], [3, 18], [3, 19], [3, 20], [3, 21], [3, 22], [3, 23], [3, 24],[4,24],[5,24],[5,23],[5,22],[6,22],[6,23],[6,24],[7,22],[7,23],[7,24],[8,23],[8,22],[9,23],[9,22],[10,23],[10,22],[11,23],[11,22],[12,23],[12,22],[11,21],[12,21]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/12_top.png')
                    bot = Image.open('1_player_map_fog/map21/12.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_twelve)
                    # when revealing 12, if 11 not revealed then reveal it
                    if area_eleven in self.map_triggers:
                        area_eleven(alt = True)
                    app.rebind_all()
            self.map_triggers.append(area_twelve)
            def area_eleven(alt = False):
                if app.ent_dict[app.p1_witch].loc in [[14,11],[14,12],[14,13]] or alt == True:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_sixteen)
                    coords = [[13,11],[13,12],[13,13],[12,11],[12,12],[12,13],[11,11],[11,12],[11,13],[11, 14], [11, 15], [11, 16], [11, 17], [11, 18], [11, 19], [11, 20],[12,18],[12,19],[12,20],[13,16],[13,17],[13,18],[13,19],[13,20],[10,15],[9,15],[9,16],[9,17],[9,18],[9,19],[8,19],[7,19],[6,19],[5,19],[10,11],[10,12],[9,11],[9,12],[8,11],[8,12],[7,11],[7,12],[7,13],[7,14],[7,15],[7,16],[6,16],[5,16],[4,19]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/11_top.png')
                    bot = Image.open('1_player_map_fog/map21/11.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_eleven)
                    app.rebind_all()
            self.map_triggers.append(area_eleven)
            def area_ten():
                if app.ent_dict[app.p1_witch].loc in [[16,9],[16,10],[4,13],[3,13]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[5, 8], [6, 8], [7, 8], [8, 8], [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8], [15, 8], [16, 8],[5,9],[5,10],[5,11],[5,12],[5,13]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/10_top.png')
                    bot = Image.open('1_player_map_fog/map21/10.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_ten)
                    app.rebind_all()
            self.map_triggers.append(area_ten)
            def area_nine():
                if app.ent_dict[app.p1_witch].loc in [[3,5],[4,5]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[3,6],[3,7],[3,8],[3,9],[3,10],[2,10],[1,10],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[2,2],[3,2],[4,2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/9_top.png')
                    bot = Image.open('1_player_map_fog/map21/9.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_nine)
                    app.rebind_all()
            def area_eight():
                if app.ent_dict[app.p1_witch].loc in [[24,9],[24,10]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_nine)
                    coords = [[18, 8], [19, 8], [20, 8], [21, 8], [22, 8], [23, 8], [24, 8],[18,7],[18,6],[18,5],[3, 5], [4, 5], [5, 5], [6, 5], [7, 5], [8, 5], [9, 5], [10, 5], [11, 5], [12, 5], [13, 5], [14, 5], [15, 5], [16, 5],[17,5]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/8_top.png')
                    bot = Image.open('1_player_map_fog/map21/8.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_eight)
                    app.rebind_all()
            def area_seven():
                if app.ent_dict[app.p1_witch].loc in [[26,9],[26,10]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[26,8],[26,7],[26,6],[26,5],[25,5],[24,5],[23,5],[22,5],[21,5],[20,5]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/7_top.png')
                    bot = Image.open('1_player_map_fog/map21/7.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_seven)
                    app.rebind_all()
            def area_six():
                if app.ent_dict[app.p1_witch].loc in [[38,2],[37,2]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[7, 2], [8, 2], [9, 2], [10, 2], [11, 2], [12, 2], [13, 2], [14, 2], [15, 2], [16, 2], [17, 2], [18, 2], [19, 2], [20, 2], [21, 2], [22, 2], [23, 2], [24, 2], [25, 2], [26, 2], [27, 2], [28, 2], [29, 2], [30, 2], [31, 2], [32, 2], [33, 2], [34, 2], [35, 2], [36, 2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/6_top.png')
                    bot = Image.open('1_player_map_fog/map21/6.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_six)
                    app.rebind_all()
            def area_five():
                if app.ent_dict[app.p1_witch].loc in [[38,22],[38,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_six)
                    coords = [[38, 2], [38, 3], [38, 4], [38, 5], [38, 6], [38, 7], [38, 8], [38, 9], [38, 10], [38, 11], [38, 12], [38, 13], [38, 14], [38, 15], [38, 16], [38, 17], [38, 18], [38, 19], [38, 20], [38, 21],[37,2]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/5_top.png')
                    bot = Image.open('1_player_map_fog/map21/5.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_five)
                    app.rebind_all()
            self.map_triggers.append(area_five)
            def area_four():
                if app.ent_dict[app.p1_witch].loc in [[35,22],[35,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[35, 7], [35, 8], [35, 9], [35, 10], [35, 11], [35, 12], [35, 13], [35, 14], [35, 15], [35, 16], [35, 17], [35, 18], [35, 19], [35, 20], [35, 21],[29,7],[30,7],[31,7],[32,7],[33,7],[34,7],[29,8],[30,8],[31,8],[32,8],[33,8],[34,8]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/4_top.png')
                    bot = Image.open('1_player_map_fog/map21/4.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_four)
                    app.rebind_all()
            self.map_triggers.append(area_four)
            def area_three():
                if app.ent_dict[app.p1_witch].loc in [[33,22],[33,23]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    coords = [[33,21],[33,20],[33,19],[33,18],[33,17],[33,16],[33,15],[33,14],[33,13],[33,12]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = Image.open('1_player_map_fog/map21/3_top.png')
                    bot = Image.open('1_player_map_fog/map21/3.png')
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_three)
                    app.rebind_all()
            self.map_triggers.append(area_three)
            def area_two():
                if app.ent_dict[app.p1_witch].loc in [[29,22],[30,22],[31,22]]:
                    app.unbind_all()
                    self.revenant_rate += 1
                    self.map_triggers.append(area_seven)
                    self.map_triggers.append(area_eight)
                    coords = [[29,21],[30,21],[31,21],[29,20],[30,20],[31,20],[29,19],[30,19],[31,19],[29,18],[30,18],[31,18],[29,17],[30,17],[31,17],[29,16],[30,16],[31,16],[29,15],[30,15],[31,15],[29,14],[30,14],[31,14],[29,13],[30,13],[31,13],[29,12],[30,12],[31,12],[28,12],[28,13],[27,12],[27,13],[26,12],[26,13],[25,12],[25,13],[24,12],[24,13],[23,12],[23,13],[22,12],[22,13],[21,12],[21,13],[20,12],[20,13],[19,12],[19,13],[18,12],[18,13],[17,12],[17,13],[16,12],[16,13],[15,12],[15,13],[14,12],[14,13],[16,11],[17,11],[18,11],[19,11],[20,11],[21,11],[22,11],[16,10],[16,9],[14,11],[24,11],[24,10],[24,9],[26,11],[26,10],[26,9]]
                    for c in coords:
                        app.grid[c[0]][c[1]] = ''
                    top = self.top2
                    bot = self.bot2
                    newbot = self.map_bottom_image
                    newtop = self.map_top_image
                    newbot = Image.alpha_composite(newbot, bot)
                    newtop = Image.alpha_composite(newtop, top)
                    self.map_bottom_image = newbot
                    self.map_top_image = newtop
                    self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
                    self.map_top = ImageTk.PhotoImage(self.map_top_image)
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_bottom, tags = ('map','mapbottom'))
                    self.canvas.create_image(0-app.moved_right, 0-app.moved_down, anchor = 'nw', image = self.map_top, tags = ('map','maptop'))
                    app.canvas.tag_lower('mapbottom')
                    self.map_triggers.remove(area_two)
                    app.rebind_all()
            self.map_triggers.append(area_two)
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # WHITE DRAGON
        elif map_number == 22:
            sound1 = mixer.Sound('Music/Dark_Amulet.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(0.4)
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # WARLOCK
        elif map_number == 122:
            sound1 = mixer.Sound('Music/Dark_Descent.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(0.3)
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # LEVEL 3 SANCTUM ENTRYWAY
        elif map_number == 3:
            sound1 = mixer.Sound('Music/radakan - old crypt.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(0.8)
            self.map_triggers = []
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # RITUAL CIRCLE
        elif map_number == 4:
            sound1 = mixer.Sound('Music/The Peculiar Habits of the Cave Hermits.ogg')
            background_music.play(sound1, -1)
            sound1.set_volume(1)
            self.map_triggers = []
            app.mages_placed = False
            self.load_intro_scene(map_number, protaganist_object = protaganist_object)
    # END OF GAME
        else:
            print('add gorgon level...map number 5')
        
    def load_intro_scene(self, map_number = None, protaganist_object = None):
        filename = 'intro_scene_texts/intro_scene_text'+str(map_number)+'.txt'
        with open(filename) as f:
            text = f.read()
        self.intro_scene = ImageTk.PhotoImage(Image.open('intro_scenes/intro_scene'+str(map_number)+'.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.intro_canvas = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.intro_canvas.create_image(0,0, image =self.intro_scene, anchor = 'nw')
        self.intro_canvas.pack(side = 'top')

        self.bd_img = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-180, root.winfo_screenheight()//3-11)))
        self.intro_canvas.create_image(root.winfo_screenwidth()//2, root.winfo_screenheight()-192, anchor='s', image =self.bd_img)
        
        self.frame = tk.Frame(root)#, width = root.winfo_screenwidth()-180, height = root.winfo_screenheight()//4)
        self.sb = tk.Scrollbar(self.frame)
        
        self.intro_text = tk.Text(self.frame, height = 7, width = 118, wrap = 'word', bg = 'black', relief = 'raised', highlightthickness = 0, borderwidth = 0, fg = 'indianred', font = ('kokonor', 16))
        self.intro_text.insert('end', text)
        self.intro_text.configure(state = 'disabled')
        
        self.intro_canvas.create_window(root.winfo_screenwidth()//2, root.winfo_screenheight()-320, window = self.frame)
        self.intro_text.pack(side = 'left')
        self.sb.pack(side = 'right', fill = 'y')
        self.intro_text.configure(yscrollcommand = self.sb.set)
        self.sb.config(command = self.intro_text.yview)

# # CONT OR SAVE BUTTONS        
        self.start_area_button = tk.Button(root, text = 'Start Area', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = map_number, po = protaganist_object : self.create_map_curs_context(n,po))
        self.intro_canvas.create_window(root.winfo_screenwidth()//2-100, root.winfo_screenheight()-80, anchor='s', window = self.start_area_button)
        
    # ONLY CALLED IN 2 PLAYER MODE
    def choose_map(self):
        self.choosemap = tk.Label(root, text = 'Choose Map', fg = 'tan3', bg = 'black', font = ('chalkduster', 38))
        self.choosemap.pack()
        # CHOOSE MAPS
        maps = [m for r,d,m in walk('./2_player_map_portraits')][0]
        maps = [m for m in maps[:] if m[0] != '.']
        self.map_button_list = []
        self.tmp_mapimg_dict = {}
        for map in maps:
            b = tk.Button(root)
            map_num = map.rstrip('.png')
            cmd = lambda indx = map_num : self.map_choice_cleanup(indx)
            photo = ImageTk.PhotoImage(Image.open('./2_player_map_portraits/' + map).resize((300,300)))
            self.tmp_mapimg_dict['map'+map_num] = photo
            b.config(image = self.tmp_mapimg_dict['map'+map_num], bg = 'black', highlightbackground = 'tan3', command = cmd)
            # DEBUG packing will have to be fixed here for different screen sizes
            b.pack(side = 'left', padx = 55)
            self.map_button_list.append(b)
        
    def map_choice_cleanup(self, map_number):
        self.two_player_map_num = int(map_number)
        self.choosemap.destroy()
        del self.tmp_mapimg_dict
        for b in self.map_button_list:
            b.destroy()
        del self.map_button_list
        self.choose_witch(player_num = 1)
#         self.create_map_curs_context(map_number)
        
        
        # IF PROTAG, LOAD PROTAG AND DO NOT RE-INIT WITCH
    def create_map_curs_context(self, map_number, protaganist_object = None):
        global curs_pos, grid_pos, map_pos
        for child in root.winfo_children():
            if child._name != '!app':
                child.destroy()
        self.map_number = map_number
        try: self.intro_canvas.destroy()
        except: pass
        # GET MAP DIMENSIONS
        if self.num_players == 1:
            filename = '1_player_map_info/map' + str(map_number) + '.txt'
        else:
            filename = '2_player_map_info/map' + str(map_number) + '.txt'
        with open(filename) as f:
            self.map_info = f.read().splitlines()
        self.map = 'map' + str(map_number)
        self.map_width = int(self.map_info[0])
        self.map_height = int(self.map_info[1])
        # CREATE GRID FROM MAP DIMENSIONS
        col = self.map_width//100
        row = self.map_height//100
        self.grid = [[''] * row for i in range(col)]
        self.coords = [[x,y] for x in range(self.map_width//100) for y in range(self.map_height//100)]
        self.loc_dict = dict([(tuple(c), Loc(c)) for c in app.coords])
        # START LOC
        if self.num_players == 1:
            self.start_loc = eval(self.map_info[2])
        else:
            self.start_loc = eval(self.map_info[2])[0]
            self.p2_start_loc = eval(self.map_info[2])[1]
        # LOAD MAP / GRID INFO / IMPASSABLE TERRAIN
        terrain = eval(self.map_info[3])
        for coord in terrain:
            self.grid[coord[0]][coord[1]] = 'block'
        # CONTEXT MENU
        self.con_bg = ImageTk.PhotoImage(Image.open('texture2.png').resize(( 200, root.winfo_screenheight())))
        self.context_menu = tk.Canvas(root, bg = 'black', bd=0, highlightthickness=0, relief='raised', height = root.winfo_screenheight(), width = 200)
        self.context_menu.pack_propagate(0)
        self.context_menu.pack(side = 'left', fill = 'both', expand = 'false')
        self.context_menu.create_image(0, 0, anchor = 'nw', image = self.con_bg)
        # CANVAS
        width = root.winfo_screenwidth()
        height = root.winfo_screenheight()
        if self.map_width < width:
            width = self.map_width
        if self.map_height < height:
            height = self.map_height
        self.canvas = tk.Canvas(root, width = width, bg = 'black', height = height, bd=4, highlightthickness=0, relief='sunken')
        self.canvas.pack()
        # MAP
        if self.num_players == 1:
            fname = '1_player_maps/'
            topfname = '1_player_map_tops/'
        else:
            fname = '2_player_maps/'
            topfname = '2_player_map_tops/'
        self.map_bottom_image = Image.open(fname + 'map'+str(map_number)+'.png')
        self.map_bottom = ImageTk.PhotoImage(self.map_bottom_image)
#         self.map_bottom = ImageTk.PhotoImage(Image.open(fname + 'map'+str(map_number)+'.png'))
#         self.image_holder.append(map_bottom)
        self.map_top_image = Image.open(topfname + 'map_top'+str(map_number)+'.png')
        self.map_top = ImageTk.PhotoImage(self.map_top_image)
        self.canvas.create_image(0, 0, anchor='nw', image= self.map_bottom, tags=('mapbottom','map'))
        self.canvas.create_image(0, 0, anchor='nw', image= self.map_top, tags = ('maptop','map'))
        # CURSOR
        self.cursor_img = ImageTk.PhotoImage(Image.open("cursor.png").resize((100,100)))
        self.vis_dict['cursor'] = Vis(name = 'cursor', loc = [0,0])
        curs_pos = [0,0]
        grid_pos = [0,0]
        map_pos = [0,0]
        self.canvas.create_image(0, 0, image=self.cursor_img, tags='cursor')
        # MINI MAP
        w = self.map_width//10
        h = self.map_height//10
        self.minimap = ImageTk.PhotoImage(Image.open('minimap.png').resize((w,h)))
        w2 = root.winfo_screenwidth()//10-10
        h2 = root.winfo_screenheight()//10
        self.minimap_screen = ImageTk.PhotoImage(Image.open('minimap_screen.png').resize((w2,h2)))
        # CHOOSE WITCH IF 2 PLAYER OR FIRST LEVEL
        if protaganist_object:
            self.load_witch(witch = protaganist_object.name, player_num = 1, protaganist_object = protaganist_object)
        else:# LOADING FIRST LEVEL, NOT SAVE GAME
            self.load_witch(witch = self.p1_witch, player_num = 1, protaganist_object = None)
#             self.choose_witch()
        
    # Called twice for 2player mode, first call defaults to first player choice, second call passes player_num = 2
    def choose_witch(self, player_num = 1):
        self.avatar_popup = tk.Toplevel(root)
        self.avatar_popup.attributes('-topmost', 'true')
        self.avatar_popup.attributes("-fullscreen", True)
        self.avatar_popup.config(bg = 'black')
#         self.avatar_popup.grab_set()
        label = tk.Label(self.avatar_popup, text = 'Choose Player ' + str(player_num) + ' Witch', font = ('chalkduster', 36), fg = 'indianred', bg = 'black')
        label.pack(side = 'top')
        if player_num == 1:
            witches = [w for r,d,w in walk('./portraits/')][0]
            witches = [w for w in witches[:] if w[0] != '.']
        elif player_num == 2:
            witches = [w for r,d,w in walk('./portraits')][0]
            witches = [w for w in witches[:] if w[0] != '.']
            p1_w_fname = self.p1_witch + '.png'
            witches.remove(p1_w_fname)
        self.avatar_popup.witch_widgets = []
        self.avatar_popup.img_dict = {}
        self.wrapped_funcs = []
        for i,witch in enumerate(witches):
            f = tk.Frame(self.avatar_popup, bg = 'black')
            f.pack(side = 'left')
            self.avatar_popup.witch_widgets.append(f)
            b = tk.Button(f)
            # change below to call load_map_trigger(witchname)
            if player_num == 1 and self.num_players == 2:
                def wrap(somePartial, witch_name):
                    self.p1_witch = witch_name
                    somePartial()
                p1 = partial(self.choose_witch, player_num = 2)
                p = partial(wrap, p1, witch[:-4])
            elif player_num == 2 and self.num_players == 2:
                def wrap(somePartial, witch_name):
                    self.p2_witch = witch_name
                    somePartial()
                p1 = partial(self.create_map_curs_context, map_number = self.two_player_map_num)
                p = partial(wrap, p1, witch[:-4])
            else:
                p = partial(self.load_map_triggers, map_number = 0, witch = witch[:-4])
#             p = partial(self.load_witch, witch[:-4], player_num)
            cmd = lambda win = self.avatar_popup, p = p : self.release_wrapper(win, p)
            self.wrapped_funcs.append(p)
            photo = ImageTk.PhotoImage(Image.open('./portraits/' + witch))
            self.avatar_popup.img_dict[witch] = photo
            # DETERMINE HORIZONTAL PADDING BY SCREENSIZE
            # DEBUG ASSUMES 3 WITCHES, ASSUMES MINIMUM SCREEN WIDTH 900
            width = root.winfo_screenwidth()
            remainder_screen = width - (300 * len(witches))
            horz_pad = (remainder_screen//len(witches))//2
            b.config(image = self.avatar_popup.img_dict[witch],highlightbackground='tan3', font = ('chalkduster', 22), highlightthickness = 1, command = cmd)
            b.pack(side = 'top', padx = horz_pad)
            info = lambda w = witch[:-4] : self.show_avatar_info(w)
            b2 = tk.Button(f)
            whtspc_txt = witch[:-4].replace('_', ' ')
            b2.config(text = whtspc_txt, highlightbackground='tan3', highlightthickness= 1, fg = 'tan3', font = ('chalkduster', 22), command = info)
            b2.pack(side = 'bottom')
            self.avatar_popup.witch_widgets.append(b2)
            self.avatar_popup.witch_widgets.append(b)
        
    def load_witch(self, witch = None, player_num = None, protaganist_object = None):
        if player_num == 1:
            self.p1_witch = witch
            if self.num_players == 2:
                loc = self.start_loc
            else:
                loc = self.start_loc
        elif player_num == 2:
            self.p2_witch = witch
            loc = self.p2_start_loc
        # if protaganist_object, instead load its data, RE-INIT IMAGES THAT CANNOT BE SERIALIZED BY PICKLE DUMP
        # changed from pickle to 'write attrs to encoded text file'... DEBUG
        # works but is ugly esp on load game...
        if protaganist_object:
            protaganist_object.loc = loc[:]
            witch_img = ImageTk.PhotoImage(Image.open('avatars/' + witch +'.png'))
            protaganist_object.img = witch_img
#             protaganist_object.init_normal_anims()
            self.ent_dict[witch] = protaganist_object
        else:
            witch_img = ImageTk.PhotoImage(Image.open('avatars/' + witch +'.png'))
            self.ent_dict[witch] = Witch(name = witch, img = witch_img, loc = loc, owner = 'p' + str(player_num), level = 2)
        self.canvas.create_image(self.ent_dict[witch].loc[0]*100+50-self.moved_right, self.ent_dict[witch].loc[1]*100+50-self.moved_down, image = self.ent_dict[witch].img, tags = self.ent_dict[witch].tags)
        self.grid[self.ent_dict[witch].loc[0]][self.ent_dict[witch].loc[1]] = witch
        # EXIT FOR 1 PLAYER
        if self.num_players == 1:
            # DEBUG LOAD BOT ENEMIES FOR PLAYER 1 HERE
            # LOAD 1 PLAYER MAP BOT UNITS
            lst = self.map_info[4:]
            c1 = 0
            end = len(lst)
            itlst = iter(lst)
            for x in itlst:
                img = eval(x)
                ent = eval(next(itlst))
                self.ent_dict[ent.id] = ent
                self.canvas.create_image(ent.loc[0]*100+50, ent.loc[1]*100+50, image = ent.img, tags = ent.tags)
                self.grid[ent.loc[0]][ent.loc[1]] = ent.id
                c1 += 1
                if c1 == end:
                    break
            self.animate()
            self.start_level_popup()
            self.map_trigger_loop()
        # CHOOSE SECOND PLAYER WITCH
        elif self.num_players == 2 and player_num == 1:# and self.p2_witch == '':
            self.load_witch(witch = self.p2_witch, player_num = 2)
#             self.choose_witch(player_num = 2)
        # EXIT CHOOSING IF BOTH FINISHED AND START TURN
        else: #self.num_players == 2 and self.p2_witch != '':
#             self.start_turn()
            if self.map_number == 0:
                sound1 = mixer.Sound('Music/heroic_demise.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(.3)
            elif self.map_number == 1:
                sound1 = mixer.Sound('Music/Caves of sorrow.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(1.6)
            elif self.map_number == 2:
                sound1 = mixer.Sound('Music/arabesque.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.3)
            elif self.map_number == 121:
                sound1 = mixer.Sound('Music/field_of_dreams.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(1)
            elif self.map_number == 21:
                sound1 = mixer.Sound('Music/Blackmoor_Colossus.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.3)
            elif self.map_number == 22:
                sound1 = mixer.Sound('Music/Dark_Amulet.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.4)
            elif self.map_number == 122:
                sound1 = mixer.Sound('Music/Dark_Descent.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.3)
            elif self.map_number == 3:
                sound1 = mixer.Sound('Music/radakan - old crypt.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.8)
            elif self.map_number == 4:
                sound1 = mixer.Sound('Music/The Peculiar Habits of the Cave Hermits.ogg')
                background_music.play(sound1, -1)
                sound1.set_volume(0.8)
            self.animate()
            self.start_level_popup()
            # change below to use 2-player map triggers (if necessary), will need at least some kind of trigger to detect player death
#             self.map_trigger_loop()
        
    def start_level_popup(self):
        name = 'dethlok'+str(app.death_count)
        app.death_count += 1
#         app.dethloks[name] = tk.IntVar(0)
        def end(window, lockname):
            self.start_turn()
#             app.dethloks[lockname].set(1)
            self.destroy_release(window)
        self.start_popup = tk.Toplevel()
        self.start_popup.grab_set()
        self.start_popup.attributes('-topmost', 'true')
        if app.num_players == 2:
            start_text = '''
            Defeat the opposing Witch...\n
            '''
        elif app.map_number == 2:
            start_text = '''
        Defeat either Undead Knight...\n
        '''
        elif app.map_number == 121:
            start_text = '''
        Defeat the Ghost...
        '''
        elif app.map_number == 122:
            start_text = '''
        Defeat the Warlock...\n
        '''
        elif app.map_number == 21:
            start_text = '''
        Find and Defeat the Ghost...\n
        '''
        elif app.map_number == 22:
            start_text = '''
        Defeat the White Dragon...\n
        '''
        elif app.map_number == 3:
            start_text = '''
        Defeat Kensai, Barbarian, and Sorceress...\n
        '''
        elif app.map_number == 4:
            start_text = '''
        Defeat Earth and Air mages, end the round. Then, defeat Fire and Water mages...\n
        '''
        else:
            start_text = '''
        Defeat all the enemies...\n
        '''
        self.text = tk.Label(self.start_popup, text = start_text, font = ('chalkduster', 22), fg='indianred', bg = 'black')
        self.text.pack()
        self.close = tk.Button(self.start_popup, text = 'OK', font = ('chalkduster', 22), fg='tan3', command = lambda win = self.start_popup, ln = name : end(win, ln))
        self.close.pack()
#         root.wait_variable(app.dethloks[name])
            
    # handle_sot_campaign() for Campaign mode OTHERWISE generate initiative queue (app.generate_init_q)
    def start_turn(self): # AWAIT button press, start level popup
#         if self.num_players == 1:
        self.handle_sot_campaign()
#         else:
#             self.generate_init_q()
    
    # Effects for Campaign mode
    # exit on generate_init_q()
    def handle_sot_campaign(self):
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4-1, app.canvas.winfo_screenheight()-69, text='Start-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'black', tags = 'sot_text')
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4, app.canvas.winfo_screenheight()-70, text='Start-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'indianred', tags = 'sot_text')
        if self.map_number == 21: #LABYRINTH
            self.generate_init_q()
        elif self.map_number == 22: #WHITE DRAGON
            for ent in app.all_ents().values():
                if ent.name == 'White_Dragon':
                    dragon = ent
            # SUMMON KOBOLDS
            if dragon.spirit < 100 and dragon.summoned_kobolds == False:
                empty_locs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c, dragon.loc) >= 14]
                loc1 = choice(empty_locs)
                empty_locs.remove(loc1)
                loc2 = choice(empty_locs)
                empty_locs.remove(loc2)
                loc3 = choice(empty_locs)
                empty_locs.remove(loc3)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Kobold_Shaman.png'))
                ent1 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc1[:], owner = 'p2')
                ent2 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc2[:], owner = 'p2')
                ent3 = Kobold_Shaman(name = 'Kobold_Shaman', img = img, loc = loc3[:], owner = 'p2')
                app.ent_dict[ent1.id] = ent1
                app.ent_dict[ent2.id] = ent2
                app.ent_dict[ent3.id] = ent3
                app.grid[loc1[0]][loc1[1]] = ent1.id
                app.grid[loc2[0]][loc2[1]] = ent2.id
                app.grid[loc3[0]][loc3[1]] = ent3.id
                dragon.summoned_kobolds = True
            # SUMMON ORCS
            elif dragon.spirit < 50 and dragon.summoned_orcs == False:
                empty_locs = [c for c in app.coords if app.grid[c[0]][c[1]] == '' and dist(c, dragon.loc) >= 14]
                loc1 = choice(empty_locs)
                empty_locs.remove(loc1)
                loc2 = choice(empty_locs)
                empty_locs.remove(loc2)
                loc3 = choice(empty_locs)
                empty_locs.remove(loc3)
                img = ImageTk.PhotoImage(Image.open('summon_imgs/Orc_Axeman.png'))
                ent1 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc1[:], owner = 'p2')
                ent2 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc2[:], owner = 'p2')
                ent3 = Orc_Axeman(name = 'Orc_Axeman', img = img, loc = loc3[:], owner = 'p2')
                app.ent_dict[ent1.id] = ent1
                app.ent_dict[ent2.id] = ent2
                app.ent_dict[ent3.id] = ent3
                app.grid[loc1[0]][loc1[1]] = ent1.id
                app.grid[loc2[0]][loc2[1]] = ent2.id
                app.grid[loc3[0]][loc3[1]] = ent3.id
                dragon.summoned_orcs = True
            self.generate_init_q()
        elif self.map_number == 4:
            mages = [v.name for k,v in app.all_ents().items()]
            # earth and air mages have been killed, but fire and water mages have not been created
            if 'Earth_Mage' not in mages and 'Air_Mage' not in mages and 'Water_Mage' not in mages and 'Fire_Mage' not in mages and app.mages_placed == False:
                    # kill earth elementals and air elementals
                    ids = [k for k,v in app.all_ents().items() if v.name == 'Earth_Elemental' or v.name == 'Air_Elemental']
                    def place_fire_water_mages():
                        empty = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
                        loc1 = reduce(lambda a,b : a if dist(a,[22,19])<dist(b,[22,19]) else b,empty)
                        empty.remove(loc1)
                        loc2 = reduce(lambda a,b : a if dist(a,[22,15])<dist(b,[22,15]) else b,empty)
                        img = ImageTk.PhotoImage(Image.open('summon_imgs/Fire_Mage.png'))
                        img2 = ImageTk.PhotoImage(Image.open('summon_imgs/Water_Mage.png'))
                        ent = Fire_Mage(name = 'Fire_Mage', img = img, loc = loc1[:], owner = 'p2')
                        app.ent_dict[ent.id] = ent
                        app.grid[ent.loc[0]][ent.loc[1]] = ent.id
                        ent2 = Water_Mage(name = 'Water_Mage', img = img2, loc = loc2[:], owner = 'p2')
                        app.ent_dict[ent2.id] = ent2
                        app.grid[ent2.loc[0]][ent2.loc[1]] = ent2.id
                        app.mages_placed = True
                        root.after(111, lambda loc1 = loc1 : app.focus_square(loc1))
                        root.after(999, lambda loc2 = loc2 : app.focus_square(loc2))
                        root.after(1888, self.generate_init_q)
                    def kill_loop(ids):
                        if ids == []:
                            place_fire_water_mages()
                        else:
                            id = ids[0]
                            ids = ids[1:]
                            ent = app.ent_dict[id]
                            app.get_focus(ent.id)
                            name = 'dethlok'+str(app.death_count)
                            app.death_count += 1
                            app.dethloks[name] = tk.IntVar(0)
                            root.after(333, lambda id = id, name = name : app.kill(id, name))
                            root.wait_variable(app.dethloks[name])
                            kill_loop(ids)
                    kill_loop(ids)
            else:
                self.generate_init_q()
        else:
            self.generate_init_q()


        
    # Put all game objects to act for the turn in initiative queue (which may be modified later)
    # exit on handle_sot_effects()
    def generate_init_q(self):
        ids = self.ents_to_act()
        q = []
        while ids != []:
            id = ids[0]
            ids = ids[1:]
            if q == []:
                q.append(id)
            else:
                ent = app.ent_dict[id]
                for i,j in enumerate(q[:]):
                    qent = app.ent_dict[j]
                    if ent.get_abl('init') > qent.get_abl('init'):
                        q = q[0:i] + [id] + q[i:]
                        break
                    elif ent.get_abl('init') == qent.get_abl('init'):
                        if ent.get_abl('agl') > qent.get_abl('agl'):
                            q = q[0:i] + [id] + q[i:]
                            break
                        elif ent.get_abl('agl') == qent.get_abl('agl'):
                            if ent.get_abl('dodge') >= qent.get_abl('dodge'):
                                q = q[0:i] + [id] + q[i:]
                                break
                else:
                    q.append(id)
        self.init_q = q[:]
        self.generate_witch_magick()
        
        
    def generate_witch_magick(self):
        # p1
        witch = app.ent_dict[app.p1_witch]
        tombs = len([k for k,v in app.all_ents().items() if v.name == 'Tomb' and v.owner == witch.owner])
        witch.magick += witch.magick_regen
        witch.magick += (tombs*3)
        # p2
        if app.num_players == 2:
            witch = app.ent_dict[app.p2_witch]
            tombs = len([k for k,v in app.all_ents().items() if v.name == 'Tomb' and v.owner == witch.owner])
            witch.magick += witch.magick_regen
            if app.turn_counter == 0:
                witch.magick += 6
            witch.magick += (tombs*3)
        self.handle_sot_effects()
        
    # Resolve start-of-turn effects on each entity AND loc_effects(on map)
    # exit on handle_ent_action()
    def handle_sot_effects(self):
        efs = [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]
        q = []
        while efs != []:
            ef = efs[0]
            efs = efs[1:]
            if q == []:
                q.append(ef)
            else:
                for i,j in enumerate(q[:]):
                    if ef.ts < j.ts:
                        q = q[0:i] + [ef] + q[i:]
                        break
                else:
                    q.append(ef)
        for ef in q:
            if ef.sot_func != None:
                if ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]:
                    lock(ef.sot_func) # RESOLVE / CALL effects
        root.after(1555, lambda t = 'sot_text' : app.canvas.delete(t))
        root.after(1666, self.handle_action)
        
    # Called until no more entities to act in app.init_q
    # COMPUTER entities are handled with Ai_man.handle_ent_action() (or Ai_man.handle_berserk_ent_action on sanity check fail) (whose exits must either lock or not end async expecting their async timeout to be waited for) then exits by calling this function(handle_ent_action)
    # USER controlled entities are EITHER handed the keyboard bindings with app.rebind_all() and always exit by pressing the 'end round' button which calls app.end_round() which calls this function(handle_ent_action) OR (on sanity check fail) handled by Ai_man.handle_berserk_ent_action() in the same manner as a computer controlled entity
    # EXITS on app.handle_eot_effects()
    def handle_action(self):
        app.active_ent = None
        if self.init_q == []:
            app.unbind_all()
            self.active_ent = None
            app.canvas.delete('active_ent')
            self.handle_eot_effects()
        else:
            id = self.init_q[0]
            self.init_q = self.init_q[1:]
            if id not in app.ent_dict.keys():
                app.handle_action()
                return
            ent = app.ent_dict[id]
            ent.acts = ent.get_abl('acts')
            ent.mvs = ent.get_abl('mvs')
            if isinstance(ent, Witch):
                ent.smns = ent.get_abl('smns')
            self.get_focus(id)
            self.active_ent = id
            # SANITY CHECK
            sanity = ent.sanity_check()
            if self.num_players == 1 and ent.owner == 'p2':
                if sanity == 'Pass':
                    ent.do_round()
                else:
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(999, lambda t = 'text' : app.canvas.delete(t))
                    app.get_focus(ent.id)
                    root.after(1333, lambda e = ent : Ai_man.handle_berserk_ent_action(e))
            else:
                if sanity == 'Pass':
                    self.rebind_all()
                else:
                    self.unbind_all()
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+49, ent.loc[1]*100-app.moved_down+84, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'black', tags = 'text')
                    app.canvas.create_text(ent.loc[0]*100-app.moved_right+50, ent.loc[1]*100-app.moved_down+85, text = 'Sanity Fail, Berserk...', justify = 'center', font = ('chalkduster', 13), fill = 'white', tags = 'text')
                    root.after(999, lambda t = 'text' : app.canvas.delete(t))
                    app.get_focus(ent.id)
                    root.after(1333, lambda e = ent : Ai_man.handle_berserk_ent_action(e))
                    
    # End of turn effects for each entity and location
    # exit on app.handle_eot_campaign()
    def handle_eot_effects(self):
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4-1, app.canvas.winfo_screenheight()-69, text='End-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'black', tags = 'eot_text')
        app.canvas.create_text(app.canvas.winfo_screenwidth()//4, app.canvas.winfo_screenheight()-70, text='End-of-Turn Phase', anchor = 'nw', font = ('chalkduster', 24), fill = 'indianred', tags = 'eot_text')
        efs = [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()] + [v for k,v in app.proximity_effects_dict.items()]
        q = []
        while efs != []:
            ef = efs[0]
            efs = efs[1:]
            if q == []:
                q.append(ef)
            else:
                for i,j in enumerate(q[:]):
                    if ef.ts < j.ts: # SORT BY TIMESTAMP
                        q = q[0:i] + [ef] + q[i:]
                        break
                else:
                    q.append(ef)
        for ef in q:
            if ef.eot_func != None:
                if ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()] + [v for k,v in app.proximity_effects_dict.items()]:# CHECKS IF STILL EXISTS THIS LINE
                    lock(ef.eot_func) # RESOLVE / CALL effects
            # decr ef.dur
            if isinstance(ef, Proximity_Effect):
                continue
            else:
                ef.duration -= 1
                if ef.duration <= 0 and ef in [j for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()] + [j for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]: # MUST CHECK IF STILL EXISTS AGAIN, in case eot removed owner
                    lock(ef.undo_func)
                    # delete Effect from source dict
                    for efct,key,ent in [(j,i,v) for k,v in app.ent_dict.items() for i,j in v.effects_dict.items()]:
                        if efct == ef:
                            del ent.effects_dict[key]
                    for efct,key,loc in [(j,i,k) for k,v in app.loc_dict.items() for i,j in v.effects_dict.items()]:
                        if efct == ef:
                            del app.loc_dict[loc].effects_dict[key]
        self.handle_eot_campaign()
        
    # DEBUG debug will not work as is
    # ent generation stuff needs to be changed to use new class init (auto gen ids, no number)
    # Campaign mode stuff that happens end of turn
    # exit on app.end_turn()
    def handle_eot_campaign(self):
        if app.num_players == 1:
            # LABYRINTH
            if self.map_number == 21:
                # generate revenants based on app.revenant_rate, starts at 2
                total_revs = len([v for v in app.all_ents().values() if isinstance(v,Revenant)])
                if total_revs <= 4:
                    for i in range(min(2, app.revenant_rate//3)):
                        img = ImageTk.PhotoImage(Image.open('summon_imgs/Revenant.png'))
                        # get rand empty sqr
                        sqr = choice([s for s in app.coords if app.grid[s[0]][s[1]] == ''])
                        ent = Revenant(name = 'Revenant', img = img, loc = sqr[:], owner = 'p2')
                        app.ent_dict[ent.id] = ent
                        app.grid[sqr[0]][sqr[1]] = ent.id
            # LIBRARY
            elif self.map_number == 121:
                # get potential spawn sqrs
                sqrs = [s for s in [[22,3],[23,3],[24,3],[22,4],[23,4],[24,4],[22,5],[23,5],[24,5]] if app.grid[s[0]][s[1]] == '']
                if sqrs != []:
                    loc = choice(sqrs)
                    img = ImageTk.PhotoImage(Image.open('summon_imgs/Revenant.png'))
                    ent = Revenant(name = 'Revenant', img = img, loc = loc[:], owner = 'p2')
                    app.ent_dict[ent.id] = ent
                    app.grid[loc[0]][loc[1]] = ent.id
                ghost = [v for k,v in app.all_ents().items() if v.name == 'Ghost']
                if ghost:
                    ghost = ghost[0]
                if ghost and ghost.spirit < 50:
                    if app.grid[7][2] != '':
                        empt_coords = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
                        sqr = choice(empt_coords)
                    else:
                        sqr = [7,2]
                    oldloc = ghost.loc[:]
                    app.grid[oldloc[0]][oldloc[1]] = ''
                    ghost.loc = sqr[:]
                    app.grid[sqr[0]][sqr[1]] = ghost.id
                    app.canvas.delete(ghost.tags)
                    app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = ghost.img, tags = ghost.tags)
                elif ghost and ghost.spirit < 30:
                    if app.grid[26][17] != '':
                        empt_coords = [c for c in app.coords if app.grid[c[0]][c[1]] == '']
                        sqr = choice(empt_coords)
                    else:
                        sqr = [26,17]
                    oldloc = ghost.loc[:]
                    app.grid[oldloc[0]][oldloc[1]] = ''
                    ghost.loc = sqr[:]
                    app.grid[sqr[0]][sqr[1]] = ghost.id
                    app.canvas.delete(ghost.tags)
                    app.canvas.create_image(sqr[0]*100+50-app.moved_right, sqr[1]*100+50-app.moved_down, image = ghost.img, tags = ghost.tags)
        root.after(1555, lambda t = 'eot_text' : app.canvas.delete(t))
        root.after(1666, self.check_victory_cond)
        
    # takes the current map number, checks game state if ncsry to see if alt route should be taken,
    # returns int of next level map number
    def get_next_level(self, map):
        # trolls and undead knights level, check which knights are dead
        if map == 2:
            knights = [v for k,v in app.all_ents().items() if v.name == 'Undead_Knight']
            if knights == []:# KILLED BOTH LEVEL WARP to ritual circle
                return 4
            elif [v for v in knights if v.doorway == True]:
                return 21
            elif [v for v in knights if v.stairway == True]:
                return 121
        # warlock and dragon levels both lead to sanctum entryway
        elif map == 22 or map == 122:
            return 3
        else:
            return map + 1
    
    # should return 'victory' or None
    def check_victory_conditions(self, map):
        if map == 0:
            all = [k for k,v in self.ent_dict.items() if v.owner == 'p2']
            if all == []:
                return 'victory'
        elif map == 1:
            all = [k for k,v in self.ent_dict.items() if v.owner == 'p2']
            if all == []:
                return 'victory'
        elif map == 2:
            knights = [k for k,v in self.all_ents().items() if v.name == 'Undead_Knight']
            if len(knights) < 2:
                return 'victory'
        elif map == 21:# minotaur
            if app.ghost_dead == True:
                return 'victory'
        elif map == 22:# dragon
            if 'White_Dragon' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 121:# library
            if 'Ghost' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 122:# warlock
            if 'Warlock' not in [v.name for k,v in self.all_ents().items()]:
                return 'victory'
        elif map == 3:# sanctum entryway
            names = [v.name for k,v in self.all_ents().items()]
            if 'Kensai' not in names and 'Barbarian' not in names and 'Sorceress' not in names:
                return 'victory'
        elif map == 4:# ritual circle
            mages = [v.name for k,v in app.all_ents().items()]
            if 'Earth_Mage' not in mages and 'Air_Mage' not in mages and 'Water_Mage' not in mages and 'Fire_Mage' not in mages and app.mages_placed == True:
                return 'victory'
        
    def check_victory_cond(self):
        if app.num_players == 1:
            if self.check_victory_conditions(self.map_number) == 'victory':
                next_level = self.get_next_level(self.map_number)
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup, lockname, next_level)
        else:
            self.end_turn()
        
    # reset transient vars... these have changed...
    # exit on app.start_turn()
    def end_turn(self):
        ents = [v for k,v in self.all_ents().items()]
        for ent in ents:
            ent.mvs = ent.get_abl('mvs')
            ent.acts = ent.get_abl('acts')
            if isinstance(ent, Witch):
                ent.smns = ent.get_abl('smns')
                ent.entomb_used = False
            if isinstance(ent, Berserker):
                ent.leap_used = False
            if isinstance(ent, Wurdulak):
                ent.shift_form = 1
            if isinstance(ent, Fell_Evolver):
                ent.evolved = False
            if isinstance(ent, Troll):
                ent.regen_this_round = False
            if isinstance(ent, White_Dragon):
                ent.free_fly = False
            if isinstance(ent, Warlock):
                ent.summoned_undead = False
            if isinstance(ent, Sorceress):
                ent.teleport_used = False
            if isinstance(ent, Barbarian):
                ent.leap_used = False
            if isinstance(ent, Water_Mage):
                ent.summoned_elementals = False
                ent.purify_used = False
        app.turn_counter += 1
        self.start_turn()
        # END TURN SEQUENCE
                    
                    
    def get_focus(self, id):
        while grid_pos[0] < self.ent_dict[id].loc[0]:
            self.move_curs(dir = 'Right')
        while grid_pos[0] > self.ent_dict[id].loc[0]:
            self.move_curs(dir = 'Left')
        while grid_pos[1] < self.ent_dict[id].loc[1]:
            self.move_curs(dir = 'Down')
        while grid_pos[1] > self.ent_dict[id].loc[1]:
            self.move_curs(dir = 'Up')
            
    def focus_square(self, s):
        while grid_pos[0] < s[0]:
            self.move_curs(dir = 'Right')
        while grid_pos[0] > s[0]:
            self.move_curs(dir = 'Left')
        while grid_pos[1] < s[1]:
            self.move_curs(dir = 'Down')
        while grid_pos[1] > s[1]:
            self.move_curs(dir = 'Up')
    
    def redraw_colors(self):
        app.canvas.delete('color')
        for ent in app.all_ents().values():
            if ent.owner == 'p1':
                img = app.p1_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
            elif app.num_players == 2:
                img = app.p2_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
            else:
                img = app.enemy_color_img
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = img, tags = 'color')
    
    def redraw_effects_text(self):
        app.canvas.delete('effects_text')
        for ent in self.ent_dict.values():
            efs = [v for v in ent.effects_dict.values()]
            starty = 5
            for ef in efs[0:5]:
                self.canvas.create_text(ent.loc[0]*100+4-self.moved_right, ent.loc[1]*100+starty-1-self.moved_down, text=ef.name.replace('_',' ')[0:9]+'...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'black', tags = 'effects_text')
                self.canvas.create_text(ent.loc[0]*100+5-self.moved_right, ent.loc[1]*100+starty-self.moved_down, text=ef.name.replace('_',' ')[0:9]+'...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'gray66', tags = 'effects_text')
                starty += 10
            if len(efs) > 5:
                self.canvas.create_text(ent.loc[0]*100+4-self.moved_right, ent.loc[1]*100+starty-1-self.moved_down, text='...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'black', tags = 'effects_text')
                self.canvas.create_text(ent.loc[0]*100+5-self.moved_right, ent.loc[1]*100+starty-self.moved_down, text='...', anchor = 'nw', font = ('chalkduster', 10), width = 95, fill = 'gray66', tags = 'effects_text')
        
        
    def animate(self):
        global selected, selected_vis
#         app.canvas.delete('color')
        self.redraw_colors()
        self.redraw_effects_text()
        # ENTS
        for ent in self.ent_dict.values():
            if ent.id not in selected:
                ent.rotate_image()
                self.canvas.delete(ent.id)
                self.canvas.create_image(ent.loc[0]*100+50-self.moved_right, ent.loc[1]*100+50-self.moved_down, image = ent.img, tags = ent.tags)
                app.canvas.tag_lower((ent.tags), 'maptop')
        # SQRS
        for sqr in self.sqr_dict.keys():
            self.sqr_dict[sqr].rotate_image()
            self.canvas.delete(sqr)
            self.canvas.create_image(self.sqr_dict[sqr].loc[0]*100+50-self.moved_right, self.sqr_dict[sqr].loc[1]*100+50-self.moved_down, image = self.sqr_dict[sqr].img, tags = sqr)
        try: app.canvas.tag_raise('large')
        except: pass
#         app.canvas.tag_raise('maptop')
        app.canvas.tag_raise('cursor')
        # VISUALS
        for vis in self.vis_dict.keys():
            if vis not in selected_vis:
                self.vis_dict[vis].rotate_image()
                self.canvas.delete(vis)
                if vis == 'cursor':
                    self.canvas.create_image(self.vis_dict[vis].loc[0]*100+50, self.vis_dict[vis].loc[1]*100+50, image = self.vis_dict[vis].img, tags = vis)
                else:
                    self.canvas.create_image(self.vis_dict[vis].loc[0]*100+50-self.moved_right, self.vis_dict[vis].loc[1]*100+50-self.moved_down, image = self.vis_dict[vis].img, tags = vis)
                app.canvas.tag_raise(vis)
        # PROX
        app.canvas.delete('proximity_effects')
        for k,prx in self.proximity_effects_dict.items():
            if k not in selected_vis:
                prx.rotate_image()
                self.canvas.delete(k)
                for sqr in prx.get_locs():
                    self.canvas.create_image(sqr[0]*100+50-self.moved_right, sqr[1]*100+50-self.moved_down, image = prx.img, tags = (k, 'proximity_effects'))
        try: # LOWER THE CURSOR BELOW MOVING ANIMATIONS (VIS)
            app.canvas.tag_lower(('cursor'), (selected_vis))
        except: pass
        try: app.canvas.tag_raise('text')
        except: pass
        # Show initiative queue
        self.canvas.delete('init_ents')
        if self.init_q != []:
            self.canvas.delete('init_q')
            txt = ''
            for id in self.init_q:
                ent = [v for k,v in app.ent_dict.items() if v.id == id]
                if ent:
                    ent = ent[0]# delist
                    if isinstance(ent, Witch):
                        txt += ent.id.replace('_',' ') + ' '
                    else:
                        txt += ent.name.replace('_',' ') +'-'+ ent.id + ' '
            self.canvas.create_text(14, 14, text='Initiative Queue: ', anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'black', tags = 'init_q')
            self.canvas.create_text(15, 15, text='Initiative Queue: ', anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'indianred', tags = 'init_q')
            self.canvas.create_text(174, 14, text= txt, anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'black', tags = 'init_ents')
            self.canvas.create_text(175, 15, text= txt, anchor = 'nw', font = ('chalkduster', 16), width = 900, fill = 'indianred', tags = 'init_ents')
        # Show Name, Active Ent
        self.redraw_active_ent()
        # MINI MAP
        self.redraw_minimap()
        self.animate_id = root.after(200, self.animate)
        
    def redraw_minimap(self):
        self.canvas.delete('minimap')
        self.canvas.create_image(100,self.canvas.winfo_height()-100, anchor='sw', image =self.minimap, tags = 'minimap')
        col = self.map_width//100
        row = self.map_height//100
        startx = 100
        starty = self.canvas.winfo_height()-self.minimap.height()-90
        ticx = app.map_width//col
        ticy = app.map_height//row
        incrx = 0
        incry = 0
        for x in range(col):
            for y in range(row):
                if app.grid[x][y] in app.all_ents().keys():
                    ent = app.ent_dict[app.grid[x][y]]
                    if ent.owner == 'p1':
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image = app.p1_minimap_img, tags = 'minimap')
                    elif app.num_players == 2:
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image = app.p2_minimap_img, tags = 'minimap')
                    else:
                        self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image =app.bot_minimap_img, tags = 'minimap')
#                 elif app.grid[x][y] == 'block':
#                         self.canvas.create_image(startx+incrx,starty+incry, anchor='sw', image =self.block_minimap_img, tags = 'minimap')
                incry += 10
            incrx += 10
            incry = 0
        # redraw minimap screen
        down = app.moved_down//10
        right = app.moved_right//10
        self.canvas.create_image(100+right-5,self.canvas.winfo_height()-20-self.minimap.height()+down, anchor='sw', image =self.minimap_screen, tags = 'minimap')

    def victory_popup_duel(self, winner, loser, draw = None, lockname = None):
        def end(window):
            self.destroy_release(window)
            app.dethloks[lockname].set(1)
            self.reset()
        self.vic_popup = tk.Toplevel()
        self.vic_popup.grab_set()
        self.vic_popup.attributes('-topmost', 'true')
        if draw == True:
            vic_text = 'Draw'
        else:
            vic_text = winner.replace('_',' ')+' is the victor'
        self.text = tk.Label(self.vic_popup, text = vic_text, font = ('chalkduster', 22), fg='indianred', bg = 'black')
        self.text.pack()
        self.close = tk.Button(self.vic_popup, text = 'OK', font = ('chalkduster', 22), fg='tan3', command = lambda win = self.vic_popup : end(win))
        self.close.pack()
    
    def victory_popup(self, lockname, next_level = None):
        def end(window):
            self.destroy_release(window)
            app.dethloks[lockname].set(1)
            self.end_level(next_level = next_level)
        self.vic_popup = tk.Toplevel()
        self.vic_popup.grab_set()
        self.vic_popup.attributes('-topmost', 'true')
        vic_text = '''
        Victory Achieved, for now...\n
        '''
        self.text = tk.Label(self.vic_popup, text = vic_text, font = ('chalkduster', 22), fg='indianred', bg = 'black')
        self.text.pack()
        self.close = tk.Button(self.vic_popup, text = 'OK', font = ('chalkduster', 22), fg='tan3', command = lambda win = self.vic_popup : end(win))
        self.close.pack()
    
    def map_trigger_loop(self):
        for mt in self.map_triggers:
            result = mt()
        self.map_trigger_id = root.after(1666, self.map_trigger_loop)
        
    def end_level(self, next_level = None):
        global curs_pos, selected, selected_vis, map_pos, grid_pos
#         self.canvas.destroy()
        root.after_cancel(self.animate_id)
        root.after_cancel(self.map_trigger_id)
        # for each effect in witch and global, call its undo
        protaganist_object  = app.ent_dict[self.p1_witch]
        protaganist_object.reset_transient_vars()
        prev_map_num = int(self.map[3:])
        new_map_num = next_level
        for child in root.winfo_children():
            if child._name != '!app':
                child.destroy()
        # THIS WORKS, JUST NEED TO CLEAN ALL VARS LIKE GRID, SELF.STUFF, GLOBALS
        # GLOBALS
        curs_pos = [0, 0]
        selected = []
        selected_vis = []
        map_pos = [0, 0]
        grid_pos = [0,0]
        self.ent_dict = {}
        self.sqr_dict = {}
        self.vis_dict = {}
        self.loc_dict = {}
        self.image_holder = []
        self.map_triggers = []
        self.active_player = 'p1'
        self.moved_right = 0
        self.moved_down = 0
        self.context_buttons = []
        self.help_buttons = []
        self.turn_counter = 0
        self.count = 0 # used for uniquely naming Effects with the same prefix/name
        self.death_count = 0
        self.dethloks = {}
        self.cycle_q = []
        self.enemy_cycle_q = []
        self.current_ent = ''
        self.active_ent = None
        # CALL IN-BETWEEN LEVEL SCREEN / VICTORY SCREEN
        # GIVE ANY STORYLINE RELATED TO FINISHED AND NEXT LEVEL
        # GIVE OPTION TO SAVE PROGRESS
        # WILL NEED, AT SOME POINT, TO SAVE ACTUAL WITCH OBJECT (NOT JUST STRING NAME), TO HOLD PERSISTENT CHANGES
        self.load_cutscene(prev_map_num, new_map_num, protaganist_object)
        
        
    def load_cutscene(self, prev_map_num, new_map_num, protaganist_object):
        # Make cutscene using background pictures and overlay unit models
        self.cut_scene = ImageTk.PhotoImage(Image.open('cut_scenes/cut_scene'+str(prev_map_num)+'.png').resize((root.winfo_screenwidth(),root.winfo_screenheight())))
        self.cut_canvas = tk.Canvas(root, width = root.winfo_screenwidth(), bg = 'black', highlightthickness = 0, height = root.winfo_screenheight())
        self.cut_canvas.create_image(0,0, image =self.cut_scene, anchor = 'nw')
        self.cut_canvas.pack(side = 'top')
        filename = 'cut_scene_texts/cut_scene_text'+str(prev_map_num)+'.txt'
        with open(filename) as f:
            text = f.read()
            
        self.bd_img = ImageTk.PhotoImage(Image.open('border.png').resize((root.winfo_screenwidth()-180, root.winfo_screenheight()//3-11)))
        self.cut_canvas.create_image(root.winfo_screenwidth()//2, root.winfo_screenheight()-192, anchor='s', image =self.bd_img)
        self.frame = tk.Frame(root)#, width = root.winfo_screenwidth()-180, height = root.winfo_screenheight()//4)
        self.sb = tk.Scrollbar(self.frame)
        self.cut_text = tk.Text(self.frame, height = 7, width = 118, wrap = 'word', bg = 'black', relief = 'raised', highlightthickness = 0, borderwidth = 0, fg = 'indianred', font = ('kokonor', 16))
        self.cut_text.insert('end', text)
        self.cut_text.configure(state = 'disabled')
        
        self.cut_canvas.create_window(root.winfo_screenwidth()//2, root.winfo_screenheight()-320, window = self.frame)
        self.cut_text.pack(side = 'left')
        self.sb.pack(side = 'right', fill = 'y')
        self.cut_text.configure(yscrollcommand = self.sb.set)
        self.sb.config(command = self.cut_text.yview)
        # CONT OR SAVE BUTTONS        
        self.next_area_button = tk.Button(root, text = 'Next Area', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = new_map_num, po = protaganist_object : self.next_area(n,po))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2-100, root.winfo_screenheight()-80, anchor='s', window = self.next_area_button)
        self.save_game_button = tk.Button(root, text = 'Save Game', fg = 'tan3', highlightbackground = 'tan3', font = ('chalkduster', 22), command = lambda n = new_map_num, po = protaganist_object : self.save_game(n, po))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-80, anchor='s', window = self.save_game_button)
        
    def next_area(self, new_map_num, protaganist_object):
        self.cut_canvas.destroy()
        # LOAD NEXT MAP
        self.load_map_triggers(new_map_num, protaganist_object = protaganist_object)
        
    def save_game(self, new_map_num, protaganist_object):
        protaganist_object.current_area = new_map_num
        # make text input, put in cut_canvas with create_window
        self.save_game_button.destroy()
        text_var = tk.StringVar()
        text_var.set('filename')
        entry = tk.Entry(root, textvariable = text_var, font = ('chalkduster', 15), highlightbackground = 'black')
        save_b = tk.Button(root, text = 'Save', font = ('chalkduster', 22), fg = 'tan3', highlightbackground = 'black', command = lambda t = text_var, p = protaganist_object : self.do_save(t, p))
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-45, anchor='s', window = save_b)
        self.cut_canvas.create_window(root.winfo_screenwidth()/2+100, root.winfo_screenheight()-80, anchor='s', window = entry)
        
        
        # change from using pickle dump to write to text file, on load decode the written gibberish (make it gibberish in stored form)
    def do_save(self, text_var, protag_obj):
        fname = text_var.get()
        saves = [s for r,d,s in walk('./save_games')][0]
        saves = [s for s in saves[:] if s[0] != '.']
        if fname in saves:
            text_var.set('filename already exists')
            return
        with open('save_games/'+fname, 'w+') as f:
            text_var.set('game saved')
            ####********
            # strip attrs, write all spell names to file
            f.write(str(protag_obj.name)+'\n')
            f.write(str(protag_obj.level)+'\n')
#             f.write(str(list(protag_obj.cantrip_dict.keys()))+'\n')
            f.write(str(list(protag_obj.arcane_dict.keys()))+'\n')
            f.write(str(protag_obj.summon_cap)+'\n')
            f.write(str(protag_obj.str)+'\n')
            f.write(str(protag_obj.agl)+'\n')
            f.write(str(protag_obj.end)+'\n')
            f.write(str(protag_obj.mm)+'\n')
            f.write(str(protag_obj.msl)+'\n')
            f.write(str(protag_obj.bls)+'\n')
            f.write(str(protag_obj.dodge)+'\n')
            f.write(str(protag_obj.psyche)+'\n')
            f.write(str(protag_obj.rsn)+'\n')
            f.write(str(protag_obj.wis)+'\n')
            f.write(str(protag_obj.san)+'\n')
            f.write(str(protag_obj.init)+'\n')
            f.write(str(protag_obj.base_acts)+'\n')
            f.write(str(protag_obj.base_mvs)+'\n')
            f.write(str(protag_obj.base_smns)+'\n')
#             f.write(str(protag_obj.base_cantrips)+'\n')
            f.write(str(protag_obj.base_spirit)+'\n')
#             f.write(str(protag_obj.base_magick)+'\n')
            f.write(str(protag_obj.move_range)+'\n')
            f.write(str(protag_obj.current_area)+'\n')
#             f.write(str(protag_obj.summon_level)+'\n')
            ####********
#             have to strip tkinter objects from protag obj
#             protag_obj.img = None
#             protag_obj.anim_dict = {}
            # below, get all needed attributes of protag_obj, do a rudimentary 'encoding' to disguise
            # on load, ensure values are 'legal'
            # 
#             dump(protag_obj, f)
    
    
    def populate_context(self, event):
        e = self.current_pos()
        if e == '' or e == 'block':
            return
        if e != app.current_ent:
            app.depop_context(event = None)
        elif self.context_buttons != []:
            return
        self.repop_help_buttons()
        expanded_name = self.ent_dict[e].name.replace('_',' ')
        # DEBUG make info button into label that holds the info
        self.cntxt_info_bg = ImageTk.PhotoImage(Image.open('page.png').resize((190,363)))
        bg = tk.Canvas(self.context_menu, width = 190, height = 363, bg = 'burlywood4', bd=0, relief='raised', highlightthickness=0)
        bg.pack(side = 'top')
        bg.create_image(0,0, image = self.cntxt_info_bg, anchor = 'nw')
#         bg.create_text(14, 7, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'ghostwhite')
#         bg.create_text(16, 9, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'ghostwhite')
#         bg.create_text(15, 8, text=expanded_name + '\n', width = 190, anchor = 'nw', font = ('chalkduster', 17), fill = 'gray30')
        text = expanded_name+'\n'
        text +=  self.get_info_text(e)
        bg.create_text(14, 7, text=text, width = 190, anchor = 'nw', font = ('chalkduster', 13), fill = 'ghostwhite')
        bg.create_text(16, 9, text=text, width = 190, anchor = 'nw', font = ('chalkduster', 13), fill = 'ghostwhite')
        bg.create_text(15, 8, text=text, width = 190, anchor = 'nw', font = ('chalkduster', 13), fill = 'gray30')
        # create 'info' button as last element
        if e != self.active_ent:
            txt3 = self.get_more_info(e)
            more_info_button = tk.Button(self.context_menu, text = 'More Info', font = ('chalkduster', 16), fg='indianred', highlightbackground = 'tan3', command = lambda t = txt3 : self.more_info(t))
            more_info_button.pack(side = 'top')
            self.context_buttons.append(more_info_button)
            root.bind('<i>', lambda e, t = txt3 : self.more_info(t))
        self.context_buttons.append(bg)
        if e == self.active_ent:
            tup_list = list(self.ent_dict[e].get_actions().items())
            self.page_actions(tup_list = tup_list, index = 0)
            
    def page_actions(self, event = None, tup_list = None, index = None):
        app.unbind_numerical_hotkeys()
        # destroy old buttons
        for b in self.context_buttons:
            if isinstance(b, tk.Button):
                b.destroy()
        self.repop_help_buttons()
        if index == 0:
            txt3 = self.get_more_info(self.active_ent)
            more_info_button = tk.Button(self.context_menu, text = 'More Info', font = ('chalkduster', 16), fg='indianred', highlightbackground = 'tan3', command = lambda t = txt3 : self.more_info(t))
            more_info_button.pack(side = 'top')
            self.context_buttons.append(more_info_button)
            root.bind('<i>', lambda e, t = txt3 : self.more_info(t))
        for i, name_action in enumerate(tup_list[index:index+5]):
            name = name_action[0].replace('_', ' ')
            action = name_action[1]
            i += 1
            root.bind(str(i), action)
            b1 = tk.Button(app.context_menu, wraplength = 190, text = str(i) +' : '+ name, font = ('chalkduster', 18), fg='tan3', highlightbackground = 'tan3', command = action)
            b1.pack(side = 'top', pady = 2)
            app.context_buttons.append(b1)
            b1.bind('<Button-2>', lambda event, b = b1, n = name : app.action_info(event, name = n, button = b))
        if index > 0:
            b4 = tk.Button(app.context_menu, text = '9 : Prev', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index-5 : self.page_actions(tup_list = t, index = i))
            b4.pack(side = 'top', pady = 2)
            root.bind(str(9), lambda e, t = tup_list, i = index-5 : self.page_actions(tup_list = t, index = i))
            app.context_buttons.append(b4)
        if len(tup_list) > len(tup_list[:index+5]):
            b3 = tk.Button(app.context_menu, text = '8 : Next', font = ('chalkduster', 16), fg='tan3', highlightbackground = 'tan3', command = lambda t = tup_list, i = index+5 : self.page_actions(tup_list = t, index = i))
            b3.pack(side = 'top', pady = 2)
            app.context_buttons.append(b3)
            root.bind(str(8), lambda e, t = tup_list, i = index+5 : self.page_actions(tup_list = t, index = i))
        
    def depop_context(self, event):
        # unbind any potential numeric keys bound to relative actions
        try:
            for x in range(1, 10):
                root.unbind(str(x))
        except: pass
        for b in self.context_buttons:
            b.destroy()
        self.context_buttons = []
    
    
    def move_curs(self, event = None, dir = None):
        global map_pos, grid_pos, curs_pos
        # need to either unbind arrows, or unbind as much as possible during execution without becoming rebound on ai turn
        if event == None:
            event = Dummy()
            event.keysym = None
        frame_width = self.canvas.winfo_width()
        frame_height = self.canvas.winfo_height()
        # map_pos is how much map has moved [x,y]
        # curs_pos is relative to screen (stays within around [0,0] to [9,6] relative to screen size
        # grid_pos is always absolute position of grid where cursor appears (relates to app.grid)
        if event.keysym == 'Left' or dir == 'Left':
            if curs_pos[0] > 1: # leftmost possible cursor position
                curs_pos[0] -= 1
                grid_pos[0] -= 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[0] > 0 : # leftmost possible map position, always zero
                map_pos[0] -= 1
                self.move_map('Left')
                grid_pos[0] -= 1
        elif event.keysym == 'Right' or dir == 'Right':
            if grid_pos[0] == ((self.map_width//100) - 1):
                return
            if curs_pos[0] < ((frame_width//100)-1):
                curs_pos[0] += 1
                grid_pos[0] += 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[0] < ((self.map_width//100)-(frame_width//100)-1):
                self.move_map('Right')
                map_pos[0] += 1
                grid_pos[0] += 1
        elif event.keysym == 'Up' or dir == 'Up':
            if curs_pos[1] > 1: # topmost
                curs_pos[1] -= 1
                grid_pos[1] -= 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[1] > 0: # topmost, always zero
                self.move_map('Down')
                map_pos[1] -= 1
                grid_pos[1] -= 1
        elif event.keysym == 'Down' or dir == 'Down':
            if grid_pos[1] == ((self.map_height//100)-1):
                return
            if curs_pos[1] < ((frame_height//100)-1):
                curs_pos[1] += 1
                grid_pos[1] += 1
                app.vis_dict['cursor'].loc = curs_pos[:]
                app.canvas.delete('cursor')
                app.canvas.create_image(curs_pos[0]*100+50,curs_pos[1]*100+50, image = app.vis_dict['cursor'].img, tags = 'cursor')
            elif map_pos[1] < ((self.map_height//100)-(frame_height//100)-0):
                self.move_map('Up')
                map_pos[1] += 1
                grid_pos[1] += 1

    def redraw_active_ent(self):
        if self.active_ent:
            self.canvas.delete('active_ent')
            loc = app.ent_dict[self.active_ent].loc
            self.canvas.create_text(loc[0]*100+49-self.moved_right, loc[1]*100+99-self.moved_down, text=self.ent_dict[self.active_ent].name.replace('_',' '), font = ('chalkduster', 13), fill = 'black', tags = 'active_ent')
            self.canvas.create_text(loc[0]*100+50-self.moved_right, loc[1]*100+100-self.moved_down, text=self.ent_dict[self.active_ent].name.replace('_',' '), font = ('chalkduster', 13), fill = 'ghostwhite', tags = 'active_ent')
        
        
    def move_map(self, direction):
        tmp = self.ent_dict.keys()
        ents = [x for x in tmp if x not in selected]
        pers_vis = [y for y in self.vis_dict.keys() if y not in selected_vis]
        prxs = [k for k in self.proximity_effects_dict.keys() if k not in selected_vis]
        if direction == 'Left':
            self.canvas.move('map', 100, 0)
            self.moved_right -= 100
            for ent in ents:
                self.canvas.move(ent, 100, 0)
            for vis in pers_vis:
                self.canvas.move(vis, 100, 0)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 100, 0)
            for prx in prxs:
                self.canvas.move(prx, 100, 0)
        elif direction == 'Right':
            self.canvas.move('map', -100, 0)
            self.moved_right += 100
            for ent in ents:
                self.canvas.move(ent, -100, 0)
            for vis in pers_vis:
                self.canvas.move(vis, -100, 0)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, -100, 0)
            for prx in prxs:
                self.canvas.move(prx, -100, 0)
        elif direction == 'Up':
            self.canvas.move('map', 0, -100)
            self.moved_down += 100
            for ent in ents:
                self.canvas.move(ent, 0, -100)
            for vis in pers_vis:
                self.canvas.move(vis, 0,-100)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 0, -100)
            for prx in prxs:
                self.canvas.move(prx, 0, -100)
        elif direction == 'Down':
            self.canvas.move('map', 0, 100)
            self.moved_down -= 100
            for ent in ents:
                self.canvas.move(ent, 0, 100)
            for vis in pers_vis:
                self.canvas.move(vis, 0, 100)
            for sqr in self.sqr_dict.keys():
                self.canvas.move(sqr, 0, 100)
            for prx in prxs:
                self.canvas.move(prx, 0, 100)
        self.redraw_active_ent()
        self.redraw_colors()
        self.redraw_effects_text()
        
    # Helper functions
    def help(self):
        self.help_popup = tk.Toplevel(bg = 'black')
        sb = tk.Scrollbar(self.help_popup)
        self.help_popup.grab_set()
        self.help_popup.attributes('-topmost', 'true')
#         self.help_popup.config(resize = False)
#         self.help_popup.geometry(root.winfo_screenwidth(), root.winfo_screenheight())
        def on_close():
            pass
        self.help_popup.protocol('WM_DELETE_WINDOW', on_close)
        help_text = '''
        R-click on spell or action buttons to see descriptions. 
        L-click on map to move cursor. 
        Arrow keys move cursor around map. 
        Press 'a' when cursor is over a unit to populate the context menu (left side of screen) with information. If you own the unit and it has available actions, then those will be in the context menu when you have selected the unit with 'a'. 
        To cancel an action after you have chosen it, press 'q'. 
        'i' is the hotkey for the 'more info' button.
        'e' is the hotkey for 'end round. (press 'e' again to confirm 'end round')
        ',' and 'l' cycle cursor over friendly units. 
        '.' and ';' cycle cursor over enemy units. 
        Your witch (main protagonist) may cast as many arcane spells that can be afforded with magick and move a number of times equal to move ability. Witch can cast Entomb once per turn to place tomb at current location. Magick is generated for your witch every turn equal to 3 times the number of tombs you have placed plus your magick regeneration rate. Your witch can place one summon per turn.
        Summons may move and act according to the number of moves and actions they have (calculated at the begin its round).
        A turn consists of a start-of-turn phase, the round for each unit in the initiative queue, and an end-of-turn phase.
        Effects placed by spells/actions may happen during the start/end-of-turn phase.
        The order of rounds is determined by the initiative-queue, which is displayed at the top of the screen, showing the order of units to act in this turn. The ordering happens before applying start-of-turn effects and is determined by 'initiative' ability (ties broken with 'agility', those ties broken with 'dodge', those ties randomly ordered).
        Actions/arcane spells EITHER target as ACTIONS (and cannot target units with INVISIBILITY) OR as SPELLS (and cannot target units with PSYSHIELD).
        Some actions/spells do not target at all.
        Every unit makes a 'sanity check' before its round. A fail makes it move randomly and attempt melee attacks (using agility vs agility to-hit, and strength vs endurance damage) using the number of moves and actions available to it. A sanity check generates a random number between 0-100. If this value is higher than the unit's sanity times ten, it fails. So once sanity abilities start falling below 10, units will randomly go berserk.
        Ability Scores:
        *NOTE* The use of abilities is determined by the specific action/spell being used, which will always declare (in its right-click description) WHICH specific abilities are used in any to-hit, damage, save, dispel checks, etc. Abilities do have a tendency to be used by certain kinds of actions. For example, ranged attacks will often compare marksmanship vs dodge to-hit, missle vs endurance for damage, and ballistics for range/distance. In contrast, a spell-action (costing magick points) that causes damage will often use wisdom vs wisdom to-hit, psyche vs psyche for damage, reason for range. A spell/action that grants an effect often uses reason for determining the duration of the effect and wisdom for the 'level' (affects dispel/removal attempts).***
        Strength: used mostly for damage from melee actions
        Agility: mostly to-hit/miss melee actions
        Endurance: mostly used for resisting damage from physical(slashing, crushing, piercing) actions
        Marksmanship: to-hit chance, ranged, physical actions
        Missle: damage from physical(mostly piercing type) ranged actions
        Ballistics: range from physical actions
        Dodge: avoid ranged physical actions
        Psyche: damage dealt/resisted from non-phys actions/spells (usually magick type)
        Wisdom: to-hit/miss for mostly spell-based actions, also used for determining the 'level' of an effect granted
        Reason: range and duration for many spells/effects.
        Sanity: mostly just for sanity checks
        Initiative: mostly order of round performance
        The 'to hit' (chance to affect with an action/spell) formula compares one ability to another (noted by the specific action/ability). Percentage chance to hit = ((attacker ability minus defender ability) times ten) plus 50. For example, an attacker's agility score of 5 compared to a defender's agility 5 is a fifty percent chance to hit.
        Effects can be dispelled with some modifier (usually provided by some ability score of the dispelling unit). A dispel is an attempt to remove the effect, the success of which depends on the level of the effect, usually the caster's wisdom score (higher level effects are harder to dispel). The dispel formula is random-value-between-neg1-and-101 compared to spell-level minus modifier times 10. 
        Save-checks are implemented similarly except they only use one ability score times 10 (plus 50).
        Damage happens to the units 'spirit' ability and function like hit-points/health.
        The damage formula (similar to to-hit) compares some ability score against another (usually a value of the attacker compared to a value of the defender). The BASE VALUE for damage when ability scores are equal is FOUR. For example, if the strength value 6 of the attacker is compared to the endurance value 6 of the defender, the damage is 4.
        Multiple effects can be applied to abilities like strength, agility, etc and also move range. Multiple changes of abilities caused by effects are resolved in the order in which they were applied (the most recently added effect is resolved last).
        '''
#         self.text = tk.List(self.help_popup, yscrollcommand = sb.set, text = help_text, wraplength = 750, font = ('chalkduster', 20), fg='indianred', bg = 'black')
        self.text = tk.Text(self.help_popup, yscrollcommand = sb.set, wrap = 'word', bg = 'black', fg = 'tan3', font = ('chalkduster', 20))
        self.text.insert('end', help_text)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(self.help_popup, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.help_popup : self.destroy_release(win))
        self.close.pack()
        self.text.pack()
        sb.pack(side = 'right', fill = 'y')
        sb.config(command = self.text.yview)
        
    def map_effect_info(self, event = None):
        # get location from cursor loc
        loc = grid_pos[:]
        # get effects from app.loc_dict
        efs = app.loc_dict[tuple(loc)].effects_dict.items()
        txt = ''
        txt += 'Location: '+str(loc)+'\n'
        txt += 'Effects:' +'\n'
        for k,ef in efs:
            txt += '  '+ef.name.replace('_',' ')+': '+loc_effect_description(ef)+'\n'
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', wrap = 'word', relief = 'sunken', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))

    def more_info(self, txt):
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', highlightthickness = 0, relief = 'sunken', wrap = 'word', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))
        
        
    def get_info_text(self, ent):
        ent = app.ent_dict[ent]
        txt = ''
        txt += 'Strength: ' + str(ent.get_abl('str')) +'/'+str(ent.str)+ '\n'
        txt += 'Agility: ' + str(ent.get_abl('agl'))  +'/'+str(ent.agl)+ '\n'
        txt += 'Endurance: ' + str(ent.get_abl('end'))  +'/'+str(ent.end)+ '\n'
        txt += 'Marksmanship: ' + str(ent.get_abl('mm'))  +'/'+str(ent.mm)+ '\n'
        txt += 'Missle: ' + str(ent.get_abl('msl'))  +'/'+str(ent.msl)+ '\n'
        txt += 'Ballistics: ' + str(ent.get_abl('bls'))  +'/'+str(ent.bls)+ '\n'
        txt += 'Dodge: ' + str(ent.get_abl('dodge'))  +'/'+str(ent.dodge)+ '\n'
        txt += 'Psyche: ' + str(ent.get_abl('psyche'))  +'/'+str(ent.psyche)+ '\n'
        txt += 'Wisdom: ' + str(ent.get_abl('wis'))  +'/'+str(ent.wis)+ '\n'
        txt += 'Reason: ' + str(ent.get_abl('rsn'))  +'/'+str(ent.rsn)+ '\n'
        txt += 'Sanity: ' + str(ent.get_abl('san'))  +'/'+str(ent.san)+ '\n'
        txt += 'Initiative: ' + str(ent.get_abl('init'))  +'/'+str(ent.init)+ '\n'
        txt += 'Move Range: ' + str(ent.get_abl('move_range'))  +'/'+str(ent.move_range)+ '\n'
        txt += 'Moves: ' + str(max(0,ent.mvs))+'/'+str(ent.get_abl('mvs'))  + '\n'
        txt += 'Actions: ' + str(max(0,ent.acts))+'/'+str(ent.get_abl('acts'))  + '\n'
        if isinstance(ent, Witch):
#             txt += 'Cantrips: ' + str(max(0,ent.cantrips))+'/'+str(ent.get_abl('cantrips')) + '\n'
            txt += 'Summon Cap: ' + str(ent.summon_count) + '/' + str(ent.summon_cap) + '\n'
            txt += 'Magick: ' + str(ent.magick) + '\n'
        else:
            txt += 'Magick: ' + str(ent.magick) + '/' + str(ent.base_magick) + '\n'
        txt += 'Spirit: ' + str(ent.spirit) + '/' + str(ent.base_spirit)
        return txt
        
    def get_more_info(self, ent):
        txt = ''
        ent = app.ent_dict[ent]
        if isinstance(ent, Witch):
            txt += 'Name: '+ent.id.replace('_',' ') + '\n'
            txt += 'Magick Regen: '+str(ent.magick_regen)+'\n' 
        else:
            txt += 'Name: '+ent.name.replace('_',' ') + '\n'
            txt += 'ID: ' +ent.id.replace('_',' ') + '\n'
        if isinstance(ent, Witch):
            txt += 'Summon Cap: ' + str(ent.summon_cap) + '\n'
        if isinstance(ent, Warlock):
            txt += 'Warlock is immune to all effects that alter abilities, including acts and moves.' + '\n'
        if isinstance(ent, Earth_Mage):
            txt += 'Earth Mage gets +1 to abls, besides acts and moves, for each Earth Elemental that exists.' + '\n'
        txt += 'Move type: ' + ent.get_move_type() + '\n'
        # actions/atks
        txt += 'Actions:'+'\n'
        for a in ent.get_actions().keys():
            txt += '  '+a +': '+ action_description(a) +'\n'
        # types
        txt += 'Types:'+'\n'
        tmp = []
        for t in ent.get_types():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        # resist, wkns
        txt += 'Resist:'+'\n'
        tmp = []
        for t in ent.get_resist():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        txt += 'Weak:'+'\n'
        tmp = []
        for t in ent.get_weak():
            if t not in tmp:
                txt += '  '+t + '\n'
                tmp.append(t)
        # effects
        txt += 'Effects:'+'\n'
        for ef,v in ent.effects_dict.items():
            txt += '  '+v.name.replace('_',' ') +': '+effect_description(v) +'\n'
        # death triggers...
        txt += 'Death Triggers:'+'\n'
        for dt in ent.death_triggers:
            txt += '  '+ dt.name.replace('_',' ') +': '+death_trigger_description(dt.name)+'\n'
        return txt

                 
    def confirm_end(self, event = None):
        self.unbind_all()
        self.depop_context(event = None)
        l = tk.Label(self.context_menu, text = 'End Round?', fg = 'indianred', bg = 'black', wraplength = 190, relief = 'raised', font = ('chalkduster', 22))
        self.context_buttons.append(l)
        root.bind('<e>', self.end_round)
        b1 = tk.Button(self.context_menu, text = 'END', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.end_round)
        b1.pack(side = 'bottom')
        self.context_buttons.append(b1)
        b2 = tk.Button(self.context_menu, text = 'Cancel', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.cancel_end_round)
        b2.pack(side = 'bottom')
        self.context_buttons.append(b2)
        l.pack(side = 'bottom')
        root.bind('<q>', lambda e : self.cancel_end_round())
        
    def end_round(self, event = None):
        app.unbind_all()
        self.depop_context(event = None)
        app.handle_action()
        
        
    def cancel_end_round(self):
        self.rebind_all()
        self.depop_context(event = None)
        
        
        # kokonor
    def show_avatar_info(self, witch):
        self.info_popup = tk.Toplevel()
        self.info_popup.grab_set()
        self.info_popup.attributes('-topmost', 'true')
        self.info_popup.title(witch)
        text = open('avatar_info/' + witch + '.txt', 'r').read()
        f = tk.Frame(self.info_popup, bg = 'black')
        f.pack()
        l = tk.Label(f, text = text, wraplength = root.winfo_screenwidth()-90, bg = 'black', fg = 'indianred', font = ('kokonor', 18))
        l.pack()
        close = tk.Button(f, text = 'close', font = ('chalkduster', 22), highlightbackground = 'black', command = lambda win = self.info_popup : self.destroy_release(win))
        close.pack()
    
    def animate_squares(self, sqrs):
        sqrs = [s for s in sqrs if app.grid[s[0]][s[1]] != 'block']
        for i, sqr in enumerate(sqrs):
            img = ImageTk.PhotoImage(Image.open('animations/move/0.png'))
            self.sqr_dict['sqr'+str(i)] = Sqr(img, sqr)
            self.canvas.create_image(sqr[0]*100+50-self.moved_right, sqr[1]*100+50-self.moved_down, image = self.sqr_dict['sqr'+str(i)].img, tags = 'sqr'+str(i))
            
    def cleanup_squares(self):
        for s in app.sqr_dict.keys():
            app.canvas.delete(s)
        app.sqr_dict = {}
    
    def current_pos(self):
        return self.grid[grid_pos[0]][grid_pos[1]]
        
    def exit_fullscreen(self, event):
        root.attributes("-fullscreen", False)
        
    def destroy_release(self, popup):
        popup.grab_release()
        popup.destroy()
        
    def release_wrapper(self, window, partial):
        window.grab_release()
        window.destroy()
        partial()
        
    def kill(self, id, lockname):
        def trigger_loop(triggers):
            if triggers == []:
                root.after(666, lambda id = id, ln = lockname : self.finish_kill(id, ln))
            else:
                t = triggers[0]
                triggers = triggers[1:]
                name = 'dethlok'+str(app.death_count)
                app.death_count += 1
                app.dethloks[name] = tk.IntVar(0)
                t.dt(lockname = name)
                root.wait_variable(app.dethloks[name])
#                 root.after(222, lambda name = name : root.wait_variable(app.dethloks[name]))
                trigger_loop(triggers)
#                 root.after(333, lambda ts = triggers : trigger_loop(ts))
        trigger_loop(app.ent_dict[id].death_triggers[:])

    def finish_kill(self, id, lockname):
        self.canvas.delete(id)
        # destroy related 'top' image of large Ents
        if app.ent_dict[id].type == 'large_bottom':
            app.ent_dict[id].large_undo()
        self.grid[self.ent_dict[id].loc[0]][self.ent_dict[id].loc[1]] = ''
        if id in app.init_q:
            app.init_q.remove(id)
        if app.active_ent == id:
            app.active_ent = None
        del self.ent_dict[id]
        ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        app.cycle_q = ents[:]
        app.enemy_cycle_q = en_ents[:]
        # DEBUG handle if killing witch
        # If witch is dead, show popup with victory/defeat
        if app.num_players == 1:
            witch = app.p1_witch
            if witch not in app.all_ents().keys():
                self.reset()
        elif app.num_players == 2:# 2 PLAYER DUEL
            witch1 = app.p1_witch
            witch2 = app.p2_witch
            ids = app.all_ents().keys()
            if witch1 in ids and witch2 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch1, witch2)
            elif witch2 in ids and witch1 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch2, witch1)
            elif witch1 not in ids and witch2 not in ids:
                lockname = 'victory_lock'+str(app.death_count)
                app.death_count += 1
                lock(self.victory_popup_duel, witch1, witch2, draw = True)
        app.dethloks[lockname].set(1)

    def unbind_arrows(self):
        root.unbind('<Right>')
        root.unbind('<Left>')
        root.unbind('<Up>')
        root.unbind('<Down>')
        
    def rebind_arrows(self):
        root.bind('<Right>', app.move_curs)
        root.bind('<Left>', app.move_curs)
        root.bind('<Up>', app.move_curs)
        root.bind('<Down>', app.move_curs)
        app.canvas.bind('<Button-1>', app.jump_to_square)
        
    def unbind_nonarrows(self):
        root.unbind('<a>')
        root.unbind('<q>')
        root.unbind('<i>')
        root.unbind('<e>')
        app.canvas.unbind('<Button-2>')
#         root.unbind('<,>')
#         root.unbind('<.>')
        for x in range(10):
            root.unbind(str(x))
            
    def unbind_numerical_hotkeys(self):
        for x in range(10):
            root.unbind(str(x))
            
    def unbind_all(self):
        for x in range(10):
            root.unbind(str(x))
        root.unbind('<Right>')
        root.unbind('<Left>')
        root.unbind('<Up>')
        root.unbind('<Down>')
        root.unbind('<a>')
        root.unbind('<q>')
        root.unbind('<,>')
        root.unbind('<.>')
        root.unbind('<l>')
        root.unbind('<;>')
        root.unbind('<e>')
        root.unbind('<i>')
        root.unbind('<m>')
        root.unbind('<h>')
        try: app.canvas.unbind('<Button-1>')
        except: pass
        try: app.canvas.unbind('<Button-2>')
        except: pass
#         root.unbind('<Escape>')

    def rebind_all(self):
        root.bind('<Right>', app.move_curs)
        root.bind('<Left>', app.move_curs)
        root.bind('<Up>', app.move_curs)
        root.bind('<Down>', app.move_curs)
        root.bind('<a>', app.populate_context)
        app.canvas.bind('<Button-2>', app.rclick_pop_context)
        root.bind('<q>', app.depop_context)
        root.bind('<,>', app.cycle_friendly_units)
        root.bind('<l>', app.de_cycle_friendly_units)
        root.bind('<.>', app.cycle_enemy_units)
        root.bind('<;>', app.de_cycle_enemy_units)
        root.bind('<m>', app.map_effect_info)
        root.bind('<h>', app.highlight_active)
        app.canvas.bind('<Button-1>', app.jump_to_square)
#         root.bind('<Escape>', app.exit_fullscreen)
        # DEBUG ####
#         root.bind('<d>', app.debugger)

    def rclick_pop_context(self, event = None):
        app.jump_to_square(event)
        app.populate_context(event = None)

    def confirm_quit(self):
        self.depop_context(event = None)
        self.unbind_all()
    # Instead of label just paste a bunch of intrusive text across the main canvas
    # centered around the grid_pos
        l = tk.Label(self.context_menu, text = 'Confirm Quit', relief = 'raised', fg = 'indianred', bg = 'black', font = ('chalkduster', 22))
        self.context_buttons.append(l)
        b1 = tk.Button(self.context_menu, text = 'QUIT', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = root.destroy)
        self.context_buttons.append(b1)
        b2 = tk.Button(self.context_menu, text = 'Cancel', fg = 'indianred', highlightbackground = 'tan3', font = ('chalkduster', 22), command = self.cancel_quit)
        b2.pack(side = 'bottom')
        b1.pack(side = 'bottom')
        self.context_buttons.append(b2)
        l.pack(side = 'bottom')

    def cancel_quit(self):
        self.depop_context(event = None)
#         for b in self.context_buttons:
#             b.destroy()
#         self.repop_help_buttons()
        self.rebind_all()
        
    def repop_help_buttons(self):
        menu_button = tk.Button(self.context_menu, text="Menu", font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=self.open_menu)
        menu_button.pack(side = 'bottom')
        self.context_buttons.append(menu_button)
        root.bind('<e>', self.confirm_end)
        end_turn_button = tk.Button(self.context_menu, text = 'End Round', font = ('chalkduster', 22), highlightbackground = 'tan3', command = self.confirm_end)
        end_turn_button.pack(side = 'bottom')
        self.context_buttons.append(end_turn_button)
        
    def open_menu(self):
        self.depop_context(event = None)
        self.unbind_all()
        quit_button = tk.Button(self.context_menu, text="QUIT", font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command=self.confirm_quit)
        quit_button.pack(side = 'bottom')
        self.context_buttons.append(quit_button)
        help_button = tk.Button(self.context_menu, text = 'Help', font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command = self.help)
        help_button.pack(side = 'bottom')
        self.context_buttons.append(help_button)
        close_button = tk.Button(self.context_menu, text = 'Close Menu', font = ('chalkduster', 22), fg='indianred', highlightbackground = 'tan3', command = self.cancel_quit)
        close_button.pack(side = 'bottom')
        self.context_buttons.append(close_button)
        
    # called when you die in 1player mode
    def reset(self):
        from sys import executable, argv
        from os import execl
        python = executable
        execl(python, python, * argv)
        
    def highlight_active(self, event = None):
        if app.active_ent:
            app.get_focus(app.active_ent)
        
    # cycle through units on your turn with SpaceBar
    def cycle_friendly_units(self, event = None):
        my_ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        for id in my_ents: # if ents has changed, reset the cycle order
            if id not in app.cycle_q:
                app.cycle_q = my_ents[:]
                break
        id = app.cycle_q[0] # after possible reset, grab first in line to focus
        app.cycle_q = app.cycle_q[1:]+[app.cycle_q[0]] # move to back of q
        app.focus_square(app.ent_dict[id].loc)

    def de_cycle_friendly_units(self, event = None):
        my_ents = [k for k,v in app.ent_dict.items() if v.owner == 'p1']
        for id in my_ents: # if ents has changed, reset the cycle order
            if id not in app.cycle_q:
                app.cycle_q = my_ents[:]
                break
        app.cycle_q = [app.cycle_q[-1]] + app.cycle_q[:-1] # put it back in front
        id = app.cycle_q[-1] # after possible reset, grab last in line to focus
        app.focus_square(app.ent_dict[id].loc)
        
    def cycle_enemy_units(self, event = None):
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        for id in en_ents: # if ents has changed, reset the cycle order
            if id not in app.enemy_cycle_q:
                app.enemy_cycle_q = en_ents[:]
                break
        id = app.enemy_cycle_q[0] # after possible reset, grab first in line to focus
        app.enemy_cycle_q = app.enemy_cycle_q[1:]+[app.enemy_cycle_q[0]] # move to back of q
        app.focus_square(app.ent_dict[id].loc)
        
    def de_cycle_enemy_units(self, event = None):
        en_ents = [k for k,v in app.ent_dict.items() if v.owner != 'p1']
        for id in en_ents: # if ents has changed, reset the cycle order
            if id not in app.enemy_cycle_q:
                app.enemy_cycle_q = en_ents[:]
                break
        app.enemy_cycle_q = [app.enemy_cycle_q[-1]] + app.enemy_cycle_q[:-1] # put it back in front
        id = app.enemy_cycle_q[-1]
        app.focus_square(app.ent_dict[id].loc)
        
        
    def jump_to_square(self, event = None):
        x = (event.x + app.moved_right)//100
        y = (event.y + app.moved_down)//100
        if (app.map_width//100)-1 <= x or (app.map_height//100)-1 <= y:
            return
        if x < 1 or y < 1:
            return
        app.focus_square([x,y])
        
    def all_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large'}
        
    def ents_to_act(self):
        ids = [k for k,v in self.ent_dict.items() if v.type != 'large']
        shuffle(ids)
        return ids
        
    def spell_target_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large' and 'psyshield' not in v.get_types()}
        
    def action_target_ents(self):
        return {k:v for k,v in self.ent_dict.items() if v.type != 'large' and 'invisibility' not in v.get_types()}
        
    # create popup with description of action name
    # ADD manually lookup name for all actions and spells
#     def action_info(self, event = None, name = None, button = None):
#         def end(window):
#             self.destroy_release(window)
#         self.info_popup = tk.Toplevel()
#         self.info_popup.grab_set()
#         self.info_popup.attributes('-topmost', 'true')
#         def on_close():
#             pass
#         self.info_popup.protocol('WM_DELETE_WINDOW', on_close)
#         info_text = name + '\n' + action_description(name)
#         self.text = tk.Label(self.info_popup, text = info_text, wraplength = 400, font = ('chalkduster', 22), fg='indianred', bg = 'black')
#         self.text.pack()
#         self.close = tk.Button(self.info_popup, text = 'OK', font = ('chalkduster', 22), fg='tan3', command = lambda win = self.info_popup : end(win))
#         self.close.pack()

    def action_info(self, event = None, name = None, button = None):
        txt = name+'\n'
        txt += action_description(name)
        self.mi_popup = tk.Toplevel(bg = 'black')
        self.img = ImageTk.PhotoImage(Image.open('paper.png').resize((self.mi_popup.winfo_screenwidth(),self.mi_popup.winfo_screenheight())))
        bg = tk.Canvas(self.mi_popup, bg = 'burlywood4', bd=3, relief='raised', highlightthickness=0)
        bg.pack()
        bg.create_image(0,0, image = self.img, anchor = 'nw')
        sb = tk.Scrollbar(bg)
        self.mi_popup.grab_set()
        self.mi_popup.attributes('-topmost', 'true')
        self.mi_popup.resizable(width = 0, height = 0)
        self.mi_popup.title('~WITCH~')
        self.mi_popup.geometry((str(root.winfo_screenwidth()//2)+'x'+str(root.winfo_screenheight()//3)))
        def on_close():
            pass
        self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
        self.text = tk.Text(bg, yscrollcommand = sb.set, bg = 'black', highlightthickness = 0, relief = 'sunken', wrap = 'word', borderwidth = 0, fg = 'tan3', font = ('baskerville', 20))
        self.text.insert('end', txt)
        self.text.configure(state = 'disabled')
        self.close = tk.Button(bg, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
        self.close.pack()
        sb.pack(side = 'right', fill = 'y')
        self.text.pack()
        sb.config(command = self.text.yview)
        self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))
#         self.mi_popup = tk.Toplevel(bg = 'black')
#         sb = tk.Scrollbar(self.mi_popup)
#         self.mi_popup.grab_set()
#         self.mi_popup.attributes('-topmost', 'true')
#         def on_close():
#             pass
#         self.mi_popup.protocol('WM_DELETE_WINDOW', on_close)
#         self.text = tk.Text(self.mi_popup, yscrollcommand = sb.set, bg = 'black', fg = 'tan3', font = ('chalkduster', 20))
#         self.text.insert('end', txt)
#         self.text.configure(state = 'disabled')
#         self.close = tk.Button(self.mi_popup, text = 'Close', font = ('chalkduster', 22), fg='tan3', highlightbackground = 'tan3', command = lambda win = self.mi_popup : self.destroy_release(win))
#         self.close.pack()
#         self.text.pack()
#         sb.pack(side = 'right', fill = 'y')
#         sb.config(command = self.text.yview)
#         self.mi_popup.bind('<q>', lambda e, win = self.mi_popup : self.destroy_release(win))


    def generic_cancel(self, event = None):
        app.depop_context(event = None)
        app.cleanup_squares()
        app.unbind_all()
        app.rebind_all()
        
    def debugger(self, event):
        for child in root.winfo_children():
            print(child)
        print(self.canvas.winfo_width())
        print(self.canvas.winfo_height())

root = tk.Tk()
app = App(master=root)

root.bind('<Right>', app.move_curs)
root.bind('<Left>', app.move_curs)
root.bind('<Up>', app.move_curs)
root.bind('<Down>', app.move_curs)
root.bind('<a>', app.populate_context)
root.bind('<q>', app.depop_context)
root.bind('<l>', app.de_cycle_friendly_units)
root.bind('<,>', app.cycle_friendly_units)
root.bind('<;>', app.de_cycle_enemy_units)
root.bind('<.>', app.cycle_enemy_units)
app.unbind_all()
# root.bind('<Escape>', app.exit_fullscreen)
#### DEBUG ####
# root.bind('<d>', app.debugger)


root.configure(background = 'black')

root.attributes('-transparent', True)
root.attributes("-fullscreen", True)

width = root.winfo_screenwidth()
height = root.winfo_screenheight()
root.geometry('%sx%s' % (width, height))

app.mainloop()